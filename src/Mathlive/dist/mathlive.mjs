// src/common/types.ts
function isArray(x3) {
  return Array.isArray(x3);
}

// src/core/color.ts
var MATHEMATICA_COLORS = {
  m0: "#3F3D99",
  m1: "#993D71",
  m2: "#998B3D",
  m3: "#3D9956",
  m4: "#3D5A99",
  m5: "#993D90",
  m6: "#996D3D",
  m7: "#43993D",
  m8: "#3D7999",
  m9: "#843D99"
};
var MATLAB_COLORS = {
  blue: "#0072BD",
  orange: "#D95319",
  yellow: "#EDB120",
  purple: "#7E2F8E",
  green: "#77AC30",
  cyan: "#4DBEEE",
  red: "#A2142F"
};
var BACKGROUND_COLORS = {
  "red": "#fbbbb6",
  "orange": "#ffe0c2",
  "yellow": "#fff1c2",
  "lime": "#d0e8b9",
  "green": "#bceac4",
  "teal": "#b9f1f1",
  "blue": "#b6d9fb",
  "indigo": "#d1c2f0",
  "purple": "#e3baf8",
  "magenta": "#f9c8e0",
  "black": "#353535",
  "dark-grey": "#8C8C8C",
  "grey": "#D0D0D0",
  "light-grey": "#F0F0F0",
  "white": "#ffffff"
};
var FOREGROUND_COLORS = {
  "red": "#d7170b",
  "orange": "#fe8a2b",
  "yellow": "#ffc02b",
  "lime": "#63b215",
  "green": "#21ba3a",
  "teal": "#17cfcf",
  "blue": "#0d80f2",
  "indigo": "#63c",
  "purple": "#a219e6",
  "magenta": "#eb4799",
  "black": "#000",
  "dark-grey": "#666",
  "grey": "#A6A6A6",
  "light-grey": "#d4d5d2",
  "white": "#ffffff"
};
var DVIPS_TO_CHROMATIC = {
  Red: "red",
  Orange: "orange",
  Yellow: "yellow",
  LimeGreen: "lime",
  Green: "green",
  TealBlue: "teal",
  Blue: "blue",
  Violet: "indigo",
  Purple: "purple",
  Magenta: "magenta",
  Black: "black",
  Gray: "grey",
  White: "white"
};
var DVIPS_COLORS = {
  Apricot: "#FBB982",
  Aquamarine: "#00B5BE",
  Bittersweet: "#C04F17",
  Black: "#221E1F",
  Blue: "#2D2F92",
  BlueGreen: "#00B3B8",
  BlueViolet: "#473992",
  BrickRed: "#B6321C",
  Brown: "#792500",
  BurntOrange: "#F7921D",
  CadetBlue: "#74729A",
  CarnationPink: "#F282B4",
  Cerulean: "#00A2E3",
  CornflowerBlue: "#41B0E4",
  Cyan: "#00AEEF",
  Dandelion: "#FDBC42",
  DarkOrchid: "#A4538A",
  Emerald: "#00A99D",
  ForestGreen: "#009B55",
  Fuchsia: "#8C368C",
  Goldenrod: "#FFDF42",
  Gray: "#949698",
  Green: "#00A64F",
  GreenYellow: "#DFE674",
  JungleGreen: "#00A99A",
  Lavender: "#F49EC4",
  Limegreen: "#8DC73E",
  Magenta: "#EC008C",
  Mahogany: "#A9341F",
  Maroon: "#AF3235",
  Melon: "#F89E7B",
  MidnightBlue: "#006795",
  Mulberry: "#A93C93",
  NavyBlue: "#006EB8",
  OliveGreen: "#3C8031",
  Orange: "#F58137",
  OrangeRed: "#ED135A",
  Orchid: "#AF72B0",
  Peach: "#F7965A",
  Periwinkle: "#7977B8",
  PineGreen: "#008B72",
  Plum: "#92268F",
  ProcessBlue: "#00B0F0",
  Purple: "#99479B",
  RawSienna: "#974006",
  Red: "#ED1B23",
  RedOrange: "#F26035",
  RedViolet: "#A1246B",
  Rhodamine: "#EF559F",
  RoyalBlue: "#0071BC",
  RoyalPurple: "#613F99",
  RubineRed: "#ED017D",
  Salmon: "#F69289",
  SeaGreen: "#3FBC9D",
  Sepia: "#671800",
  SkyBlue: "#46C5DD",
  SpringGreen: "#C6DC67",
  Tan: "#DA9D76",
  TealBlue: "#00AEB3",
  Thistle: "#D883B7",
  Turquoise: "#00B4CE",
  Violet: "#58429B",
  VioletRed: "#EF58A0",
  White: "#FFFFFF",
  WildStrawberry: "#EE2967",
  Yellow: "#FFF200",
  YellowGreen: "#98CC70",
  YellowOrange: "#FAA21A"
};
function defaultColorMap(s3) {
  const colorSpec = s3.split("!");
  let baseRed;
  let baseGreen;
  let baseBlue;
  let red = 255;
  let green = 255;
  let blue = 255;
  let mix = -1;
  const complementary = colorSpec.length > 0 && colorSpec[0].startsWith("-");
  if (complementary)
    colorSpec[0] = colorSpec[0].slice(1);
  for (let i3 = 0; i3 < colorSpec.length; i3++) {
    baseRed = red;
    baseGreen = green;
    baseBlue = blue;
    const colorName = colorSpec[i3].trim().match(/^([A-Za-z\d]+)/)?.[1];
    const lcColorName = colorName?.toLowerCase();
    const color = !colorName ? colorSpec[i3].trim() : FOREGROUND_COLORS[lcColorName] ?? FOREGROUND_COLORS[DVIPS_TO_CHROMATIC[colorName]] ?? MATLAB_COLORS[colorName] ?? DVIPS_COLORS[colorName] ?? MATHEMATICA_COLORS[colorName] ?? colorSpec[i3].trim();
    let m3 = color.match(/^#([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i);
    if (m3?.[1] && m3[2] && m3[3]) {
      red = Math.max(0, Math.min(255, Number.parseInt(m3[1], 16)));
      green = Math.max(0, Math.min(255, Number.parseInt(m3[2], 16)));
      blue = Math.max(0, Math.min(255, Number.parseInt(m3[3], 16)));
    } else {
      m3 = color.match(/^#([\da-f]{3})$/i);
      if (m3?.[1]) {
        const r1 = Number.parseInt(m3[1][0], 16);
        const g1 = Number.parseInt(m3[1][1], 16);
        const b1 = Number.parseInt(m3[1][2], 16);
        red = Math.max(0, Math.min(255, r1 * 16 + r1));
        green = Math.max(0, Math.min(255, g1 * 16 + g1));
        blue = Math.max(0, Math.min(255, b1 * 16 + b1));
      } else {
        m3 = color.match(/^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i);
        if (m3?.[1] && m3[2] && m3[3]) {
          red = Math.max(0, Math.min(255, Number.parseInt(m3[1])));
          green = Math.max(0, Math.min(255, Number.parseInt(m3[2])));
          blue = Math.max(0, Math.min(255, Number.parseInt(m3[3])));
        } else {
          return void 0;
        }
      }
    }
    if (mix >= 0) {
      red = (1 - mix) * red + mix * baseRed;
      green = (1 - mix) * green + mix * baseGreen;
      blue = (1 - mix) * blue + mix * baseBlue;
      mix = -1;
    }
    if (i3 + 1 < colorSpec.length) {
      mix = Math.max(0, Math.min(100, Number.parseInt(colorSpec[++i3]))) / 100;
    }
  }
  if (mix >= 0) {
    red = mix * red + (1 - mix) * baseRed;
    green = mix * green + (1 - mix) * baseGreen;
    blue = mix * blue + (1 - mix) * baseBlue;
  }
  if (complementary) {
    red = 255 - red;
    green = 255 - green;
    blue = 255 - blue;
  }
  return "#" + ("00" + Math.round(red).toString(16)).slice(-2) + ("00" + Math.round(green).toString(16)).slice(-2) + ("00" + Math.round(blue).toString(16)).slice(-2);
}
function defaultBackgroundColorMap(s3) {
  s3 = s3.trim();
  return BACKGROUND_COLORS[s3.toLowerCase()] ?? BACKGROUND_COLORS[DVIPS_TO_CHROMATIC[s3]] ?? defaultColorMap(s3);
}
function parseHex(hex) {
  if (!hex)
    return void 0;
  if (hex[0] !== "#")
    return void 0;
  hex = hex.slice(1);
  let result;
  if (hex.length <= 4) {
    result = {
      r: parseInt(hex[0] + hex[0], 16),
      g: parseInt(hex[1] + hex[1], 16),
      b: parseInt(hex[2] + hex[2], 16)
    };
    if (hex.length === 4) {
      result.a = parseInt(hex[3] + hex[3], 16) / 255;
    }
  } else {
    result = {
      r: parseInt(hex[0] + hex[1], 16),
      g: parseInt(hex[2] + hex[3], 16),
      b: parseInt(hex[4] + hex[5], 16)
    };
    if (hex.length === 8) {
      result.a = parseInt(hex[6] + hex[7], 16) / 255;
    }
  }
  if (result && result.a === void 0)
    result.a = 1;
  return result;
}
function hueToRgbChannel(t1, t22, hue) {
  if (hue < 0)
    hue += 6;
  if (hue >= 6)
    hue -= 6;
  if (hue < 1)
    return (t22 - t1) * hue + t1;
  else if (hue < 3)
    return t22;
  else if (hue < 4)
    return (t22 - t1) * (4 - hue) + t1;
  return t1;
}
function hslToRgb(hsl) {
  let [hue, sat, light] = [hsl.h, hsl.s, hsl.l];
  hue = (hue + 360) % 360 / 60;
  light = Math.max(0, Math.min(light, 1));
  sat = Math.max(0, Math.min(sat, 1));
  const t22 = light <= 0.5 ? light * (sat + 1) : light + sat - light * sat;
  const t1 = light * 2 - t22;
  return {
    r: Math.round(255 * hueToRgbChannel(t1, t22, hue + 2)),
    g: Math.round(255 * hueToRgbChannel(t1, t22, hue)),
    b: Math.round(255 * hueToRgbChannel(t1, t22, hue - 2))
  };
}
function clampByte(v3) {
  if (v3 < 0)
    return 0;
  if (v3 > 255)
    return 255;
  return Math.round(v3);
}
function rgbToHexstring(rgb) {
  const {r: r3, g: g3, b: b3} = rgb;
  let hexString = ((1 << 24) + (clampByte(r3) << 16) + (clampByte(g3) << 8) + clampByte(b3)).toString(16).slice(1);
  if (hexString[0] === hexString[1] && hexString[2] === hexString[3] && hexString[4] === hexString[5] && hexString[6] === hexString[7]) {
    hexString = hexString[0] + hexString[2] + hexString[4];
  }
  return "#" + hexString;
}
function rgbToHsl(rgb) {
  let {r: r3, g: g3, b: b3} = rgb;
  r3 = r3 / 255;
  g3 = g3 / 255;
  b3 = b3 / 255;
  const min = Math.min(r3, g3, b3);
  const max = Math.max(r3, g3, b3);
  const delta = max - min;
  let h3;
  let s3;
  if (max === min) {
    h3 = 0;
  } else if (r3 === max) {
    h3 = (g3 - b3) / delta;
  } else if (g3 === max) {
    h3 = 2 + (b3 - r3) / delta;
  } else if (b3 === max) {
    h3 = 4 + (r3 - g3) / delta;
  }
  h3 = Math.min(h3 * 60, 360);
  if (h3 < 0) {
    h3 += 360;
  }
  const l3 = (min + max) / 2;
  if (max === min) {
    s3 = 0;
  } else if (l3 <= 0.5) {
    s3 = delta / (max + min);
  } else {
    s3 = delta / (2 - max - min);
  }
  return {h: h3, s: s3, l: l3};
}
function highlight(color) {
  let rgb = parseHex(color);
  if (!rgb)
    return color;
  let {h: h3, s: s3, l: l3} = rgbToHsl(rgb);
  s3 += 0.1;
  l3 -= 0.1;
  return rgbToHexstring(hslToRgb({h: h3, s: s3, l: l3}));
}

// src/core/font-metrics-data.ts
var M6 = [0, 0.69444, 0, 0];
var M11 = [0, 0.61111, 0, 0];
var M15 = [0.25, 0.75, 0, 0];
var M7 = [0, 0.44444, 0, 0];
var M4 = [0, 0.68611, 0, 0];
var M16 = [0.19444, 0.69444, 0, 0];
var M9 = [0, 0.68333, 0, 0];
var M1 = [0, 0.68889, 0, 0];
var M21 = [0, 0.69141, 0, 0];
var M0 = [0, 0, 0, 0];
var M5 = [0, 0.64444, 0, 0];
var M3 = [0, 0.69224, 0, 0];
var M8 = [0.19444, 0.44444, 0, 0];
var M19 = [0.65002, 1.15, 0, 0];
var M20 = [0, 0.55556, 0, 0];
var M10 = [0.35001, 0.85, 0, 0];
var M12 = [1.25003, 1.75, 0, 0];
var M13 = [0.95003, 1.45, 0, 0];
var M14 = [0, 0.75, 0, 0];
var M22 = [0, 0.47534, 0, 0];
var M17 = [0.25001, 0.75, 0, 0];
var M18 = [0.55001, 1.05, 0, 0];
var M2 = [0.16667, 0.68889, 0, 0];
var M23 = [0.08167, 0.58167, 0, 0];
var font_metrics_data_default = {
  "AMS-Regular": {
    "32": M0,
    "65": M1,
    "66": M1,
    "67": M1,
    "68": M1,
    "69": M1,
    "70": M1,
    "71": M1,
    "72": M1,
    "73": M1,
    "74": M2,
    "75": M1,
    "76": M1,
    "77": M1,
    "78": M1,
    "79": M2,
    "80": M1,
    "81": M2,
    "82": M1,
    "83": M1,
    "84": M1,
    "85": M1,
    "86": M1,
    "87": M1,
    "88": M1,
    "89": M1,
    "90": M1,
    "107": M1,
    "160": M0,
    "165": [0, 0.675, 0.025, 0],
    "174": [0.15559, 0.69224, 0, 0],
    "240": M1,
    "295": M1,
    "710": [0, 0.825, 0, 0],
    "732": [0, 0.9, 0, 0],
    "770": [0, 0.825, 0, 0],
    "771": [0, 0.9, 0, 0],
    "989": M23,
    "1008": [0, 0.43056, 0.04028, 0],
    "8245": [0, 0.54986, 0, 0],
    "8463": M1,
    "8487": M1,
    "8498": M1,
    "8502": M1,
    "8503": M1,
    "8504": M1,
    "8513": M1,
    "8592": [-0.03598, 0.46402, 0, 0],
    "8594": [-0.03598, 0.46402, 0, 0],
    "8602": [-0.13313, 0.36687, 0, 0],
    "8603": [-0.13313, 0.36687, 0, 0],
    "8606": [0.01354, 0.52239, 0, 0],
    "8608": [0.01354, 0.52239, 0, 0],
    "8610": [0.01354, 0.52239, 0, 0],
    "8611": [0.01354, 0.52239, 0, 0],
    "8619": [0, 0.54986, 0, 0],
    "8620": [0, 0.54986, 0, 0],
    "8621": [-0.13313, 0.37788, 0, 0],
    "8622": [-0.13313, 0.36687, 0, 0],
    "8624": M3,
    "8625": M3,
    "8630": [0, 0.43056, 0, 0],
    "8631": [0, 0.43056, 0, 0],
    "8634": [0.08198, 0.58198, 0, 0],
    "8635": [0.08198, 0.58198, 0, 0],
    "8638": [0.19444, 0.69224, 0, 0],
    "8639": [0.19444, 0.69224, 0, 0],
    "8642": [0.19444, 0.69224, 0, 0],
    "8643": [0.19444, 0.69224, 0, 0],
    "8644": [0.1808, 0.675, 0, 0],
    "8646": [0.1808, 0.675, 0, 0],
    "8647": [0.1808, 0.675, 0, 0],
    "8648": [0.19444, 0.69224, 0, 0],
    "8649": [0.1808, 0.675, 0, 0],
    "8650": [0.19444, 0.69224, 0, 0],
    "8651": [0.01354, 0.52239, 0, 0],
    "8652": [0.01354, 0.52239, 0, 0],
    "8653": [-0.13313, 0.36687, 0, 0],
    "8654": [-0.13313, 0.36687, 0, 0],
    "8655": [-0.13313, 0.36687, 0, 0],
    "8666": [0.13667, 0.63667, 0, 0],
    "8667": [0.13667, 0.63667, 0, 0],
    "8669": [-0.13313, 0.37788, 0, 0],
    "8672": [-0.064, 0.437, 0, 0],
    "8674": [-0.064, 0.437, 0, 0],
    "8705": [0, 0.825, 0, 0],
    "8708": M1,
    "8709": M23,
    "8717": [0, 0.43056, 0, 0],
    "8722": [-0.03598, 0.46402, 0, 0],
    "8724": [0.08198, 0.69224, 0, 0],
    "8726": M23,
    "8733": M3,
    "8736": M3,
    "8737": M3,
    "8738": [0.03517, 0.52239, 0, 0],
    "8739": M23,
    "8740": [0.25142, 0.74111, 0, 0],
    "8741": M23,
    "8742": [0.25142, 0.74111, 0, 0],
    "8756": M3,
    "8757": M3,
    "8764": [-0.13313, 0.36687, 0, 0],
    "8765": [-0.13313, 0.37788, 0, 0],
    "8769": [-0.13313, 0.36687, 0, 0],
    "8770": [-0.03625, 0.46375, 0, 0],
    "8774": [0.30274, 0.79383, 0, 0],
    "8776": [-0.01688, 0.48312, 0, 0],
    "8778": M23,
    "8782": [0.06062, 0.54986, 0, 0],
    "8783": [0.06062, 0.54986, 0, 0],
    "8785": [0.08198, 0.58198, 0, 0],
    "8786": [0.08198, 0.58198, 0, 0],
    "8787": [0.08198, 0.58198, 0, 0],
    "8790": M3,
    "8791": [0.22958, 0.72958, 0, 0],
    "8796": [0.08198, 0.91667, 0, 0],
    "8806": [0.25583, 0.75583, 0, 0],
    "8807": [0.25583, 0.75583, 0, 0],
    "8808": [0.25142, 0.75726, 0, 0],
    "8809": [0.25142, 0.75726, 0, 0],
    "8812": [0.25583, 0.75583, 0, 0],
    "8814": [0.20576, 0.70576, 0, 0],
    "8815": [0.20576, 0.70576, 0, 0],
    "8816": [0.30274, 0.79383, 0, 0],
    "8817": [0.30274, 0.79383, 0, 0],
    "8818": [0.22958, 0.72958, 0, 0],
    "8819": [0.22958, 0.72958, 0, 0],
    "8822": [0.1808, 0.675, 0, 0],
    "8823": [0.1808, 0.675, 0, 0],
    "8828": [0.13667, 0.63667, 0, 0],
    "8829": [0.13667, 0.63667, 0, 0],
    "8830": [0.22958, 0.72958, 0, 0],
    "8831": [0.22958, 0.72958, 0, 0],
    "8832": [0.20576, 0.70576, 0, 0],
    "8833": [0.20576, 0.70576, 0, 0],
    "8840": [0.30274, 0.79383, 0, 0],
    "8841": [0.30274, 0.79383, 0, 0],
    "8842": [0.13597, 0.63597, 0, 0],
    "8843": [0.13597, 0.63597, 0, 0],
    "8847": [0.03517, 0.54986, 0, 0],
    "8848": [0.03517, 0.54986, 0, 0],
    "8858": [0.08198, 0.58198, 0, 0],
    "8859": [0.08198, 0.58198, 0, 0],
    "8861": [0.08198, 0.58198, 0, 0],
    "8862": [0, 0.675, 0, 0],
    "8863": [0, 0.675, 0, 0],
    "8864": [0, 0.675, 0, 0],
    "8865": [0, 0.675, 0, 0],
    "8872": M3,
    "8873": M3,
    "8874": M3,
    "8876": M1,
    "8877": M1,
    "8878": M1,
    "8879": M1,
    "8882": [0.03517, 0.54986, 0, 0],
    "8883": [0.03517, 0.54986, 0, 0],
    "8884": [0.13667, 0.63667, 0, 0],
    "8885": [0.13667, 0.63667, 0, 0],
    "8888": [0, 0.54986, 0, 0],
    "8890": [0.19444, 0.43056, 0, 0],
    "8891": [0.19444, 0.69224, 0, 0],
    "8892": [0.19444, 0.69224, 0, 0],
    "8901": [0, 0.54986, 0, 0],
    "8903": M23,
    "8905": M23,
    "8906": M23,
    "8907": M3,
    "8908": M3,
    "8909": [-0.03598, 0.46402, 0, 0],
    "8910": [0, 0.54986, 0, 0],
    "8911": [0, 0.54986, 0, 0],
    "8912": [0.03517, 0.54986, 0, 0],
    "8913": [0.03517, 0.54986, 0, 0],
    "8914": [0, 0.54986, 0, 0],
    "8915": [0, 0.54986, 0, 0],
    "8916": M3,
    "8918": [0.0391, 0.5391, 0, 0],
    "8919": [0.0391, 0.5391, 0, 0],
    "8920": [0.03517, 0.54986, 0, 0],
    "8921": [0.03517, 0.54986, 0, 0],
    "8922": [0.38569, 0.88569, 0, 0],
    "8923": [0.38569, 0.88569, 0, 0],
    "8926": [0.13667, 0.63667, 0, 0],
    "8927": [0.13667, 0.63667, 0, 0],
    "8928": [0.30274, 0.79383, 0, 0],
    "8929": [0.30274, 0.79383, 0, 0],
    "8934": [0.23222, 0.74111, 0, 0],
    "8935": [0.23222, 0.74111, 0, 0],
    "8936": [0.23222, 0.74111, 0, 0],
    "8937": [0.23222, 0.74111, 0, 0],
    "8938": [0.20576, 0.70576, 0, 0],
    "8939": [0.20576, 0.70576, 0, 0],
    "8940": [0.30274, 0.79383, 0, 0],
    "8941": [0.30274, 0.79383, 0, 0],
    "8994": [0.19444, 0.69224, 0, 0],
    "8995": [0.19444, 0.69224, 0, 0],
    "9416": [0.15559, 0.69224, 0, 0],
    "9484": M3,
    "9488": M3,
    "9492": [0, 0.37788, 0, 0],
    "9496": [0, 0.37788, 0, 0],
    "9585": [0.19444, 0.68889, 0, 0],
    "9586": [0.19444, 0.74111, 0, 0],
    "9632": [0, 0.675, 0, 0],
    "9633": [0, 0.675, 0, 0],
    "9650": [0, 0.54986, 0, 0],
    "9651": [0, 0.54986, 0, 0],
    "9654": [0.03517, 0.54986, 0, 0],
    "9660": [0, 0.54986, 0, 0],
    "9661": [0, 0.54986, 0, 0],
    "9664": [0.03517, 0.54986, 0, 0],
    "9674": [0.11111, 0.69224, 0, 0],
    "9733": [0.19444, 0.69224, 0, 0],
    "10003": M3,
    "10016": M3,
    "10731": [0.11111, 0.69224, 0, 0],
    "10846": [0.19444, 0.75583, 0, 0],
    "10877": [0.13667, 0.63667, 0, 0],
    "10878": [0.13667, 0.63667, 0, 0],
    "10885": [0.25583, 0.75583, 0, 0],
    "10886": [0.25583, 0.75583, 0, 0],
    "10887": [0.13597, 0.63597, 0, 0],
    "10888": [0.13597, 0.63597, 0, 0],
    "10889": [0.26167, 0.75726, 0, 0],
    "10890": [0.26167, 0.75726, 0, 0],
    "10891": [0.48256, 0.98256, 0, 0],
    "10892": [0.48256, 0.98256, 0, 0],
    "10901": [0.13667, 0.63667, 0, 0],
    "10902": [0.13667, 0.63667, 0, 0],
    "10933": [0.25142, 0.75726, 0, 0],
    "10934": [0.25142, 0.75726, 0, 0],
    "10935": [0.26167, 0.75726, 0, 0],
    "10936": [0.26167, 0.75726, 0, 0],
    "10937": [0.26167, 0.75726, 0, 0],
    "10938": [0.26167, 0.75726, 0, 0],
    "10949": [0.25583, 0.75583, 0, 0],
    "10950": [0.25583, 0.75583, 0, 0],
    "10955": [0.28481, 0.79383, 0, 0],
    "10956": [0.28481, 0.79383, 0, 0],
    "57350": M23,
    "57351": M23,
    "57352": M23,
    "57353": [0, 0.43056, 0.04028, 0],
    "57356": [0.25142, 0.75726, 0, 0],
    "57357": [0.25142, 0.75726, 0, 0],
    "57358": [0.41951, 0.91951, 0, 0],
    "57359": [0.30274, 0.79383, 0, 0],
    "57360": [0.30274, 0.79383, 0, 0],
    "57361": [0.41951, 0.91951, 0, 0],
    "57366": [0.25142, 0.75726, 0, 0],
    "57367": [0.25142, 0.75726, 0, 0],
    "57368": [0.25142, 0.75726, 0, 0],
    "57369": [0.25142, 0.75726, 0, 0],
    "57370": [0.13597, 0.63597, 0, 0],
    "57371": [0.13597, 0.63597, 0, 0]
  },
  "Caligraphic-Regular": {
    "32": M0,
    "65": [0, 0.68333, 0, 0.19445],
    "66": [0, 0.68333, 0.03041, 0.13889],
    "67": [0, 0.68333, 0.05834, 0.13889],
    "68": [0, 0.68333, 0.02778, 0.08334],
    "69": [0, 0.68333, 0.08944, 0.11111],
    "70": [0, 0.68333, 0.09931, 0.11111],
    "71": [0.09722, 0.68333, 0.0593, 0.11111],
    "72": [0, 0.68333, 965e-5, 0.11111],
    "73": [0, 0.68333, 0.07382, 0],
    "74": [0.09722, 0.68333, 0.18472, 0.16667],
    "75": [0, 0.68333, 0.01445, 0.05556],
    "76": [0, 0.68333, 0, 0.13889],
    "77": [0, 0.68333, 0, 0.13889],
    "78": [0, 0.68333, 0.14736, 0.08334],
    "79": [0, 0.68333, 0.02778, 0.11111],
    "80": [0, 0.68333, 0.08222, 0.08334],
    "81": [0.09722, 0.68333, 0, 0.11111],
    "82": [0, 0.68333, 0, 0.08334],
    "83": [0, 0.68333, 0.075, 0.13889],
    "84": [0, 0.68333, 0.25417, 0],
    "85": [0, 0.68333, 0.09931, 0.08334],
    "86": [0, 0.68333, 0.08222, 0],
    "87": [0, 0.68333, 0.08222, 0.08334],
    "88": [0, 0.68333, 0.14643, 0.13889],
    "89": [0.09722, 0.68333, 0.08222, 0.08334],
    "90": [0, 0.68333, 0.07944, 0.13889],
    "160": M0
  },
  "Fraktur-Regular": {
    "32": M0,
    "33": M21,
    "34": M21,
    "38": M21,
    "39": M21,
    "40": [0.24982, 0.74947, 0, 0],
    "41": [0.24982, 0.74947, 0, 0],
    "42": [0, 0.62119, 0, 0],
    "43": [0.08319, 0.58283, 0, 0],
    "44": [0, 0.10803, 0, 0],
    "45": [0.08319, 0.58283, 0, 0],
    "46": [0, 0.10803, 0, 0],
    "47": [0.24982, 0.74947, 0, 0],
    "48": M22,
    "49": M22,
    "50": M22,
    "51": [0.18906, 0.47534, 0, 0],
    "52": [0.18906, 0.47534, 0, 0],
    "53": [0.18906, 0.47534, 0, 0],
    "54": M21,
    "55": [0.18906, 0.47534, 0, 0],
    "56": M21,
    "57": [0.18906, 0.47534, 0, 0],
    "58": M22,
    "59": [0.12604, 0.47534, 0, 0],
    "61": [-0.13099, 0.36866, 0, 0],
    "63": M21,
    "65": M21,
    "66": M21,
    "67": M21,
    "68": M21,
    "69": M21,
    "70": [0.12604, 0.69141, 0, 0],
    "71": M21,
    "72": [0.06302, 0.69141, 0, 0],
    "73": M21,
    "74": [0.12604, 0.69141, 0, 0],
    "75": M21,
    "76": M21,
    "77": M21,
    "78": M21,
    "79": M21,
    "80": [0.18906, 0.69141, 0, 0],
    "81": [0.03781, 0.69141, 0, 0],
    "82": M21,
    "83": M21,
    "84": M21,
    "85": M21,
    "86": M21,
    "87": M21,
    "88": M21,
    "89": [0.18906, 0.69141, 0, 0],
    "90": [0.12604, 0.69141, 0, 0],
    "91": [0.24982, 0.74947, 0, 0],
    "93": [0.24982, 0.74947, 0, 0],
    "94": M21,
    "97": M22,
    "98": M21,
    "99": M22,
    "100": [0, 0.62119, 0, 0],
    "101": M22,
    "102": [0.18906, 0.69141, 0, 0],
    "103": [0.18906, 0.47534, 0, 0],
    "104": [0.18906, 0.69141, 0, 0],
    "105": M21,
    "106": M21,
    "107": M21,
    "108": M21,
    "109": M22,
    "110": M22,
    "111": M22,
    "112": [0.18906, 0.52396, 0, 0],
    "113": [0.18906, 0.47534, 0, 0],
    "114": M22,
    "115": M22,
    "116": [0, 0.62119, 0, 0],
    "117": M22,
    "118": [0, 0.52396, 0, 0],
    "119": [0, 0.52396, 0, 0],
    "120": [0.18906, 0.47534, 0, 0],
    "121": [0.18906, 0.47534, 0, 0],
    "122": [0.18906, 0.47534, 0, 0],
    "160": M0,
    "8216": M21,
    "8217": M21,
    "58112": [0, 0.62119, 0, 0],
    "58113": [0, 0.62119, 0, 0],
    "58114": [0.18906, 0.69141, 0, 0],
    "58115": [0.18906, 0.69141, 0, 0],
    "58116": [0.18906, 0.47534, 0, 0],
    "58117": M21,
    "58118": [0, 0.62119, 0, 0],
    "58119": M22
  },
  "Main-Bold": {
    "32": M0,
    "33": M6,
    "34": M6,
    "35": M16,
    "36": [0.05556, 0.75, 0, 0],
    "37": [0.05556, 0.75, 0, 0],
    "38": M6,
    "39": M6,
    "40": M15,
    "41": M15,
    "42": M14,
    "43": [0.13333, 0.63333, 0, 0],
    "44": [0.19444, 0.15556, 0, 0],
    "45": M7,
    "46": [0, 0.15556, 0, 0],
    "47": M15,
    "48": M5,
    "49": M5,
    "50": M5,
    "51": M5,
    "52": M5,
    "53": M5,
    "54": M5,
    "55": M5,
    "56": M5,
    "57": M5,
    "58": M7,
    "59": M8,
    "60": [0.08556, 0.58556, 0, 0],
    "61": [-0.10889, 0.39111, 0, 0],
    "62": [0.08556, 0.58556, 0, 0],
    "63": M6,
    "64": M6,
    "65": M4,
    "66": M4,
    "67": M4,
    "68": M4,
    "69": M4,
    "70": M4,
    "71": M4,
    "72": M4,
    "73": M4,
    "74": M4,
    "75": M4,
    "76": M4,
    "77": M4,
    "78": M4,
    "79": M4,
    "80": M4,
    "81": [0.19444, 0.68611, 0, 0],
    "82": M4,
    "83": M4,
    "84": M4,
    "85": M4,
    "86": [0, 0.68611, 0.01597, 0],
    "87": [0, 0.68611, 0.01597, 0],
    "88": M4,
    "89": [0, 0.68611, 0.02875, 0],
    "90": M4,
    "91": M15,
    "92": M15,
    "93": M15,
    "94": M6,
    "95": [0.31, 0.13444, 0.03194, 0],
    "97": M7,
    "98": M6,
    "99": M7,
    "100": M6,
    "101": M7,
    "102": [0, 0.69444, 0.10903, 0],
    "103": [0.19444, 0.44444, 0.01597, 0],
    "104": M6,
    "105": M6,
    "106": M16,
    "107": M6,
    "108": M6,
    "109": M7,
    "110": M7,
    "111": M7,
    "112": M8,
    "113": M8,
    "114": M7,
    "115": M7,
    "116": [0, 0.63492, 0, 0],
    "117": M7,
    "118": [0, 0.44444, 0.01597, 0],
    "119": [0, 0.44444, 0.01597, 0],
    "120": M7,
    "121": [0.19444, 0.44444, 0.01597, 0],
    "122": M7,
    "123": M15,
    "124": M15,
    "125": M15,
    "126": [0.35, 0.34444, 0, 0],
    "160": M0,
    "163": M6,
    "168": M6,
    "172": M7,
    "176": M6,
    "177": [0.13333, 0.63333, 0, 0],
    "184": [0.17014, 0, 0, 0],
    "198": M4,
    "215": [0.13333, 0.63333, 0, 0],
    "216": [0.04861, 0.73472, 0, 0],
    "223": M6,
    "230": M7,
    "247": [0.13333, 0.63333, 0, 0],
    "248": [0.09722, 0.54167, 0, 0],
    "305": M7,
    "338": M4,
    "339": M7,
    "567": M8,
    "710": M6,
    "711": [0, 0.63194, 0, 0],
    "713": [0, 0.59611, 0, 0],
    "714": M6,
    "715": M6,
    "728": M6,
    "729": M6,
    "730": M6,
    "732": M6,
    "733": M6,
    "915": M4,
    "916": M4,
    "920": M4,
    "923": M4,
    "926": M4,
    "928": M4,
    "931": M4,
    "933": M4,
    "934": M4,
    "936": M4,
    "937": M4,
    "8211": [0, 0.44444, 0.03194, 0],
    "8212": [0, 0.44444, 0.03194, 0],
    "8216": M6,
    "8217": M6,
    "8220": M6,
    "8221": M6,
    "8224": M16,
    "8225": M16,
    "8242": M20,
    "8407": [0, 0.72444, 0.15486, 0],
    "8463": M6,
    "8465": M6,
    "8467": M6,
    "8472": M8,
    "8476": M6,
    "8501": M6,
    "8592": [-0.10889, 0.39111, 0, 0],
    "8593": M16,
    "8594": [-0.10889, 0.39111, 0, 0],
    "8595": M16,
    "8596": [-0.10889, 0.39111, 0, 0],
    "8597": M15,
    "8598": M16,
    "8599": M16,
    "8600": M16,
    "8601": M16,
    "8636": [-0.10889, 0.39111, 0, 0],
    "8637": [-0.10889, 0.39111, 0, 0],
    "8640": [-0.10889, 0.39111, 0, 0],
    "8641": [-0.10889, 0.39111, 0, 0],
    "8656": [-0.10889, 0.39111, 0, 0],
    "8657": M16,
    "8658": [-0.10889, 0.39111, 0, 0],
    "8659": M16,
    "8660": [-0.10889, 0.39111, 0, 0],
    "8661": M15,
    "8704": M6,
    "8706": [0, 0.69444, 0.06389, 0],
    "8707": M6,
    "8709": [0.05556, 0.75, 0, 0],
    "8711": M4,
    "8712": [0.08556, 0.58556, 0, 0],
    "8715": [0.08556, 0.58556, 0, 0],
    "8722": [0.13333, 0.63333, 0, 0],
    "8723": [0.13333, 0.63333, 0, 0],
    "8725": M15,
    "8726": M15,
    "8727": [-0.02778, 0.47222, 0, 0],
    "8728": [-0.02639, 0.47361, 0, 0],
    "8729": [-0.02639, 0.47361, 0, 0],
    "8730": [0.18, 0.82, 0, 0],
    "8733": M7,
    "8734": M7,
    "8736": M3,
    "8739": M15,
    "8741": M15,
    "8743": M20,
    "8744": M20,
    "8745": M20,
    "8746": M20,
    "8747": [0.19444, 0.69444, 0.12778, 0],
    "8764": [-0.10889, 0.39111, 0, 0],
    "8768": M16,
    "8771": [222e-5, 0.50222, 0, 0],
    "8776": [0.02444, 0.52444, 0, 0],
    "8781": [222e-5, 0.50222, 0, 0],
    "8801": [222e-5, 0.50222, 0, 0],
    "8804": [0.19667, 0.69667, 0, 0],
    "8805": [0.19667, 0.69667, 0, 0],
    "8810": [0.08556, 0.58556, 0, 0],
    "8811": [0.08556, 0.58556, 0, 0],
    "8826": [0.08556, 0.58556, 0, 0],
    "8827": [0.08556, 0.58556, 0, 0],
    "8834": [0.08556, 0.58556, 0, 0],
    "8835": [0.08556, 0.58556, 0, 0],
    "8838": [0.19667, 0.69667, 0, 0],
    "8839": [0.19667, 0.69667, 0, 0],
    "8846": M20,
    "8849": [0.19667, 0.69667, 0, 0],
    "8850": [0.19667, 0.69667, 0, 0],
    "8851": M20,
    "8852": M20,
    "8853": [0.13333, 0.63333, 0, 0],
    "8854": [0.13333, 0.63333, 0, 0],
    "8855": [0.13333, 0.63333, 0, 0],
    "8856": [0.13333, 0.63333, 0, 0],
    "8857": [0.13333, 0.63333, 0, 0],
    "8866": M6,
    "8867": M6,
    "8868": M6,
    "8869": M6,
    "8900": [-0.02639, 0.47361, 0, 0],
    "8901": [-0.02639, 0.47361, 0, 0],
    "8902": [-0.02778, 0.47222, 0, 0],
    "8968": M15,
    "8969": M15,
    "8970": M15,
    "8971": M15,
    "8994": [-0.13889, 0.36111, 0, 0],
    "8995": [-0.13889, 0.36111, 0, 0],
    "9651": M16,
    "9657": [-0.02778, 0.47222, 0, 0],
    "9661": M16,
    "9667": [-0.02778, 0.47222, 0, 0],
    "9711": M16,
    "9824": [0.12963, 0.69444, 0, 0],
    "9825": [0.12963, 0.69444, 0, 0],
    "9826": [0.12963, 0.69444, 0, 0],
    "9827": [0.12963, 0.69444, 0, 0],
    "9837": M14,
    "9838": M16,
    "9839": M16,
    "10216": M15,
    "10217": M15,
    "10815": M4,
    "10927": [0.19667, 0.69667, 0, 0],
    "10928": [0.19667, 0.69667, 0, 0],
    "57376": M16
  },
  "Main-BoldItalic": {
    "32": M0,
    "33": [0, 0.69444, 0.11417, 0],
    "34": [0, 0.69444, 0.07939, 0],
    "35": [0.19444, 0.69444, 0.06833, 0],
    "37": [0.05556, 0.75, 0.12861, 0],
    "38": [0, 0.69444, 0.08528, 0],
    "39": [0, 0.69444, 0.12945, 0],
    "40": [0.25, 0.75, 0.15806, 0],
    "41": [0.25, 0.75, 0.03306, 0],
    "42": [0, 0.75, 0.14333, 0],
    "43": [0.10333, 0.60333, 0.03306, 0],
    "44": [0.19444, 0.14722, 0, 0],
    "45": [0, 0.44444, 0.02611, 0],
    "46": [0, 0.14722, 0, 0],
    "47": [0.25, 0.75, 0.15806, 0],
    "48": [0, 0.64444, 0.13167, 0],
    "49": [0, 0.64444, 0.13167, 0],
    "50": [0, 0.64444, 0.13167, 0],
    "51": [0, 0.64444, 0.13167, 0],
    "52": [0.19444, 0.64444, 0.13167, 0],
    "53": [0, 0.64444, 0.13167, 0],
    "54": [0, 0.64444, 0.13167, 0],
    "55": [0.19444, 0.64444, 0.13167, 0],
    "56": [0, 0.64444, 0.13167, 0],
    "57": [0, 0.64444, 0.13167, 0],
    "58": [0, 0.44444, 0.06695, 0],
    "59": [0.19444, 0.44444, 0.06695, 0],
    "61": [-0.10889, 0.39111, 0.06833, 0],
    "63": [0, 0.69444, 0.11472, 0],
    "64": [0, 0.69444, 0.09208, 0],
    "65": M4,
    "66": [0, 0.68611, 0.0992, 0],
    "67": [0, 0.68611, 0.14208, 0],
    "68": [0, 0.68611, 0.09062, 0],
    "69": [0, 0.68611, 0.11431, 0],
    "70": [0, 0.68611, 0.12903, 0],
    "71": [0, 0.68611, 0.07347, 0],
    "72": [0, 0.68611, 0.17208, 0],
    "73": [0, 0.68611, 0.15681, 0],
    "74": [0, 0.68611, 0.145, 0],
    "75": [0, 0.68611, 0.14208, 0],
    "76": M4,
    "77": [0, 0.68611, 0.17208, 0],
    "78": [0, 0.68611, 0.17208, 0],
    "79": [0, 0.68611, 0.09062, 0],
    "80": [0, 0.68611, 0.0992, 0],
    "81": [0.19444, 0.68611, 0.09062, 0],
    "82": [0, 0.68611, 0.02559, 0],
    "83": [0, 0.68611, 0.11264, 0],
    "84": [0, 0.68611, 0.12903, 0],
    "85": [0, 0.68611, 0.17208, 0],
    "86": [0, 0.68611, 0.18625, 0],
    "87": [0, 0.68611, 0.18625, 0],
    "88": [0, 0.68611, 0.15681, 0],
    "89": [0, 0.68611, 0.19803, 0],
    "90": [0, 0.68611, 0.14208, 0],
    "91": [0.25, 0.75, 0.1875, 0],
    "93": [0.25, 0.75, 0.09972, 0],
    "94": [0, 0.69444, 0.06709, 0],
    "95": [0.31, 0.13444, 0.09811, 0],
    "97": [0, 0.44444, 0.09426, 0],
    "98": [0, 0.69444, 0.07861, 0],
    "99": [0, 0.44444, 0.05222, 0],
    "100": [0, 0.69444, 0.10861, 0],
    "101": [0, 0.44444, 0.085, 0],
    "102": [0.19444, 0.69444, 0.21778, 0],
    "103": [0.19444, 0.44444, 0.105, 0],
    "104": [0, 0.69444, 0.09426, 0],
    "105": [0, 0.69326, 0.11387, 0],
    "106": [0.19444, 0.69326, 0.1672, 0],
    "107": [0, 0.69444, 0.11111, 0],
    "108": [0, 0.69444, 0.10861, 0],
    "109": [0, 0.44444, 0.09426, 0],
    "110": [0, 0.44444, 0.09426, 0],
    "111": [0, 0.44444, 0.07861, 0],
    "112": [0.19444, 0.44444, 0.07861, 0],
    "113": [0.19444, 0.44444, 0.105, 0],
    "114": [0, 0.44444, 0.11111, 0],
    "115": [0, 0.44444, 0.08167, 0],
    "116": [0, 0.63492, 0.09639, 0],
    "117": [0, 0.44444, 0.09426, 0],
    "118": [0, 0.44444, 0.11111, 0],
    "119": [0, 0.44444, 0.11111, 0],
    "120": [0, 0.44444, 0.12583, 0],
    "121": [0.19444, 0.44444, 0.105, 0],
    "122": [0, 0.44444, 0.13889, 0],
    "126": [0.35, 0.34444, 0.11472, 0],
    "160": M0,
    "168": [0, 0.69444, 0.11473, 0],
    "176": M6,
    "184": [0.17014, 0, 0, 0],
    "198": [0, 0.68611, 0.11431, 0],
    "216": [0.04861, 0.73472, 0.09062, 0],
    "223": [0.19444, 0.69444, 0.09736, 0],
    "230": [0, 0.44444, 0.085, 0],
    "248": [0.09722, 0.54167, 0.09458, 0],
    "305": [0, 0.44444, 0.09426, 0],
    "338": [0, 0.68611, 0.11431, 0],
    "339": [0, 0.44444, 0.085, 0],
    "567": [0.19444, 0.44444, 0.04611, 0],
    "710": [0, 0.69444, 0.06709, 0],
    "711": [0, 0.63194, 0.08271, 0],
    "713": [0, 0.59444, 0.10444, 0],
    "714": [0, 0.69444, 0.08528, 0],
    "715": M6,
    "728": [0, 0.69444, 0.10333, 0],
    "729": [0, 0.69444, 0.12945, 0],
    "730": M6,
    "732": [0, 0.69444, 0.11472, 0],
    "733": [0, 0.69444, 0.11472, 0],
    "915": [0, 0.68611, 0.12903, 0],
    "916": M4,
    "920": [0, 0.68611, 0.09062, 0],
    "923": M4,
    "926": [0, 0.68611, 0.15092, 0],
    "928": [0, 0.68611, 0.17208, 0],
    "931": [0, 0.68611, 0.11431, 0],
    "933": [0, 0.68611, 0.10778, 0],
    "934": [0, 0.68611, 0.05632, 0],
    "936": [0, 0.68611, 0.10778, 0],
    "937": [0, 0.68611, 0.0992, 0],
    "8211": [0, 0.44444, 0.09811, 0],
    "8212": [0, 0.44444, 0.09811, 0],
    "8216": [0, 0.69444, 0.12945, 0],
    "8217": [0, 0.69444, 0.12945, 0],
    "8220": [0, 0.69444, 0.16772, 0],
    "8221": [0, 0.69444, 0.07939, 0]
  },
  "Main-Italic": {
    "32": M0,
    "33": [0, 0.69444, 0.12417, 0],
    "34": [0, 0.69444, 0.06961, 0],
    "35": [0.19444, 0.69444, 0.06616, 0],
    "37": [0.05556, 0.75, 0.13639, 0],
    "38": [0, 0.69444, 0.09694, 0],
    "39": [0, 0.69444, 0.12417, 0],
    "40": [0.25, 0.75, 0.16194, 0],
    "41": [0.25, 0.75, 0.03694, 0],
    "42": [0, 0.75, 0.14917, 0],
    "43": [0.05667, 0.56167, 0.03694, 0],
    "44": [0.19444, 0.10556, 0, 0],
    "45": [0, 0.43056, 0.02826, 0],
    "46": [0, 0.10556, 0, 0],
    "47": [0.25, 0.75, 0.16194, 0],
    "48": [0, 0.64444, 0.13556, 0],
    "49": [0, 0.64444, 0.13556, 0],
    "50": [0, 0.64444, 0.13556, 0],
    "51": [0, 0.64444, 0.13556, 0],
    "52": [0.19444, 0.64444, 0.13556, 0],
    "53": [0, 0.64444, 0.13556, 0],
    "54": [0, 0.64444, 0.13556, 0],
    "55": [0.19444, 0.64444, 0.13556, 0],
    "56": [0, 0.64444, 0.13556, 0],
    "57": [0, 0.64444, 0.13556, 0],
    "58": [0, 0.43056, 0.0582, 0],
    "59": [0.19444, 0.43056, 0.0582, 0],
    "61": [-0.13313, 0.36687, 0.06616, 0],
    "63": [0, 0.69444, 0.1225, 0],
    "64": [0, 0.69444, 0.09597, 0],
    "65": M9,
    "66": [0, 0.68333, 0.10257, 0],
    "67": [0, 0.68333, 0.14528, 0],
    "68": [0, 0.68333, 0.09403, 0],
    "69": [0, 0.68333, 0.12028, 0],
    "70": [0, 0.68333, 0.13305, 0],
    "71": [0, 0.68333, 0.08722, 0],
    "72": [0, 0.68333, 0.16389, 0],
    "73": [0, 0.68333, 0.15806, 0],
    "74": [0, 0.68333, 0.14028, 0],
    "75": [0, 0.68333, 0.14528, 0],
    "76": M9,
    "77": [0, 0.68333, 0.16389, 0],
    "78": [0, 0.68333, 0.16389, 0],
    "79": [0, 0.68333, 0.09403, 0],
    "80": [0, 0.68333, 0.10257, 0],
    "81": [0.19444, 0.68333, 0.09403, 0],
    "82": [0, 0.68333, 0.03868, 0],
    "83": [0, 0.68333, 0.11972, 0],
    "84": [0, 0.68333, 0.13305, 0],
    "85": [0, 0.68333, 0.16389, 0],
    "86": [0, 0.68333, 0.18361, 0],
    "87": [0, 0.68333, 0.18361, 0],
    "88": [0, 0.68333, 0.15806, 0],
    "89": [0, 0.68333, 0.19383, 0],
    "90": [0, 0.68333, 0.14528, 0],
    "91": [0.25, 0.75, 0.1875, 0],
    "93": [0.25, 0.75, 0.10528, 0],
    "94": [0, 0.69444, 0.06646, 0],
    "95": [0.31, 0.12056, 0.09208, 0],
    "97": [0, 0.43056, 0.07671, 0],
    "98": [0, 0.69444, 0.06312, 0],
    "99": [0, 0.43056, 0.05653, 0],
    "100": [0, 0.69444, 0.10333, 0],
    "101": [0, 0.43056, 0.07514, 0],
    "102": [0.19444, 0.69444, 0.21194, 0],
    "103": [0.19444, 0.43056, 0.08847, 0],
    "104": [0, 0.69444, 0.07671, 0],
    "105": [0, 0.65536, 0.1019, 0],
    "106": [0.19444, 0.65536, 0.14467, 0],
    "107": [0, 0.69444, 0.10764, 0],
    "108": [0, 0.69444, 0.10333, 0],
    "109": [0, 0.43056, 0.07671, 0],
    "110": [0, 0.43056, 0.07671, 0],
    "111": [0, 0.43056, 0.06312, 0],
    "112": [0.19444, 0.43056, 0.06312, 0],
    "113": [0.19444, 0.43056, 0.08847, 0],
    "114": [0, 0.43056, 0.10764, 0],
    "115": [0, 0.43056, 0.08208, 0],
    "116": [0, 0.61508, 0.09486, 0],
    "117": [0, 0.43056, 0.07671, 0],
    "118": [0, 0.43056, 0.10764, 0],
    "119": [0, 0.43056, 0.10764, 0],
    "120": [0, 0.43056, 0.12042, 0],
    "121": [0.19444, 0.43056, 0.08847, 0],
    "122": [0, 0.43056, 0.12292, 0],
    "126": [0.35, 0.31786, 0.11585, 0],
    "160": M0,
    "168": [0, 0.66786, 0.10474, 0],
    "176": M6,
    "184": [0.17014, 0, 0, 0],
    "198": [0, 0.68333, 0.12028, 0],
    "216": [0.04861, 0.73194, 0.09403, 0],
    "223": [0.19444, 0.69444, 0.10514, 0],
    "230": [0, 0.43056, 0.07514, 0],
    "248": [0.09722, 0.52778, 0.09194, 0],
    "338": [0, 0.68333, 0.12028, 0],
    "339": [0, 0.43056, 0.07514, 0],
    "710": [0, 0.69444, 0.06646, 0],
    "711": [0, 0.62847, 0.08295, 0],
    "713": [0, 0.56167, 0.10333, 0],
    "714": [0, 0.69444, 0.09694, 0],
    "715": M6,
    "728": [0, 0.69444, 0.10806, 0],
    "729": [0, 0.66786, 0.11752, 0],
    "730": M6,
    "732": [0, 0.66786, 0.11585, 0],
    "733": [0, 0.69444, 0.1225, 0],
    "915": [0, 0.68333, 0.13305, 0],
    "916": M9,
    "920": [0, 0.68333, 0.09403, 0],
    "923": M9,
    "926": [0, 0.68333, 0.15294, 0],
    "928": [0, 0.68333, 0.16389, 0],
    "931": [0, 0.68333, 0.12028, 0],
    "933": [0, 0.68333, 0.11111, 0],
    "934": [0, 0.68333, 0.05986, 0],
    "936": [0, 0.68333, 0.11111, 0],
    "937": [0, 0.68333, 0.10257, 0],
    "8211": [0, 0.43056, 0.09208, 0],
    "8212": [0, 0.43056, 0.09208, 0],
    "8216": [0, 0.69444, 0.12417, 0],
    "8217": [0, 0.69444, 0.12417, 0],
    "8220": [0, 0.69444, 0.1685, 0],
    "8221": [0, 0.69444, 0.06961, 0],
    "8463": M1
  },
  "Main-Regular": {
    "32": M0,
    "33": M6,
    "34": M6,
    "35": M16,
    "36": [0.05556, 0.75, 0, 0],
    "37": [0.05556, 0.75, 0, 0],
    "38": M6,
    "39": M6,
    "40": M15,
    "41": M15,
    "42": M14,
    "43": [0.08333, 0.58333, 0, 0],
    "44": [0.19444, 0.10556, 0, 0],
    "45": [0, 0.43056, 0, 0],
    "46": [0, 0.10556, 0, 0],
    "47": M15,
    "48": M5,
    "49": M5,
    "50": M5,
    "51": M5,
    "52": M5,
    "53": M5,
    "54": M5,
    "55": M5,
    "56": M5,
    "57": M5,
    "58": [0, 0.43056, 0, 0],
    "59": [0.19444, 0.43056, 0, 0],
    "60": [0.0391, 0.5391, 0, 0],
    "61": [-0.13313, 0.36687, 0, 0],
    "62": [0.0391, 0.5391, 0, 0],
    "63": M6,
    "64": M6,
    "65": M9,
    "66": M9,
    "67": M9,
    "68": M9,
    "69": M9,
    "70": M9,
    "71": M9,
    "72": M9,
    "73": M9,
    "74": M9,
    "75": M9,
    "76": M9,
    "77": M9,
    "78": M9,
    "79": M9,
    "80": M9,
    "81": [0.19444, 0.68333, 0, 0],
    "82": M9,
    "83": M9,
    "84": M9,
    "85": M9,
    "86": [0, 0.68333, 0.01389, 0],
    "87": [0, 0.68333, 0.01389, 0],
    "88": M9,
    "89": [0, 0.68333, 0.025, 0],
    "90": M9,
    "91": M15,
    "92": M15,
    "93": M15,
    "94": M6,
    "95": [0.31, 0.12056, 0.02778, 0],
    "97": [0, 0.43056, 0, 0],
    "98": M6,
    "99": [0, 0.43056, 0, 0],
    "100": M6,
    "101": [0, 0.43056, 0, 0],
    "102": [0, 0.69444, 0.07778, 0],
    "103": [0.19444, 0.43056, 0.01389, 0],
    "104": M6,
    "105": [0, 0.66786, 0, 0],
    "106": [0.19444, 0.66786, 0, 0],
    "107": M6,
    "108": M6,
    "109": [0, 0.43056, 0, 0],
    "110": [0, 0.43056, 0, 0],
    "111": [0, 0.43056, 0, 0],
    "112": [0.19444, 0.43056, 0, 0],
    "113": [0.19444, 0.43056, 0, 0],
    "114": [0, 0.43056, 0, 0],
    "115": [0, 0.43056, 0, 0],
    "116": [0, 0.61508, 0, 0],
    "117": [0, 0.43056, 0, 0],
    "118": [0, 0.43056, 0.01389, 0],
    "119": [0, 0.43056, 0.01389, 0],
    "120": [0, 0.43056, 0, 0],
    "121": [0.19444, 0.43056, 0.01389, 0],
    "122": [0, 0.43056, 0, 0],
    "123": M15,
    "124": M15,
    "125": M15,
    "126": [0.35, 0.31786, 0, 0],
    "160": M0,
    "163": M6,
    "167": M16,
    "168": [0, 0.66786, 0, 0],
    "172": [0, 0.43056, 0, 0],
    "176": M6,
    "177": [0.08333, 0.58333, 0, 0],
    "182": M16,
    "184": [0.17014, 0, 0, 0],
    "198": M9,
    "215": [0.08333, 0.58333, 0, 0],
    "216": [0.04861, 0.73194, 0, 0],
    "223": M6,
    "230": [0, 0.43056, 0, 0],
    "247": [0.08333, 0.58333, 0, 0],
    "248": [0.09722, 0.52778, 0, 0],
    "305": [0, 0.43056, 0, 0],
    "338": M9,
    "339": [0, 0.43056, 0, 0],
    "567": [0.19444, 0.43056, 0, 0],
    "710": M6,
    "711": [0, 0.62847, 0, 0],
    "713": [0, 0.56778, 0, 0],
    "714": M6,
    "715": M6,
    "728": M6,
    "729": [0, 0.66786, 0, 0],
    "730": M6,
    "732": [0, 0.66786, 0, 0],
    "733": M6,
    "915": M9,
    "916": M9,
    "920": M9,
    "923": M9,
    "926": M9,
    "928": M9,
    "931": M9,
    "933": M9,
    "934": M9,
    "936": M9,
    "937": M9,
    "8211": [0, 0.43056, 0.02778, 0],
    "8212": [0, 0.43056, 0.02778, 0],
    "8216": M6,
    "8217": M6,
    "8220": M6,
    "8221": M6,
    "8224": M16,
    "8225": M16,
    "8230": [0, 0.12, 0, 0],
    "8242": M20,
    "8407": [0, 0.71444, 0.15382, 0],
    "8463": M1,
    "8465": M6,
    "8467": [0, 0.69444, 0, 0.11111],
    "8472": [0.19444, 0.43056, 0, 0.11111],
    "8476": M6,
    "8501": M6,
    "8592": [-0.13313, 0.36687, 0, 0],
    "8593": M16,
    "8594": [-0.13313, 0.36687, 0, 0],
    "8595": M16,
    "8596": [-0.13313, 0.36687, 0, 0],
    "8597": M15,
    "8598": M16,
    "8599": M16,
    "8600": M16,
    "8601": M16,
    "8614": [0.011, 0.511, 0, 0],
    "8617": [0.011, 0.511, 0, 0],
    "8618": [0.011, 0.511, 0, 0],
    "8636": [-0.13313, 0.36687, 0, 0],
    "8637": [-0.13313, 0.36687, 0, 0],
    "8640": [-0.13313, 0.36687, 0, 0],
    "8641": [-0.13313, 0.36687, 0, 0],
    "8652": [0.011, 0.671, 0, 0],
    "8656": [-0.13313, 0.36687, 0, 0],
    "8657": M16,
    "8658": [-0.13313, 0.36687, 0, 0],
    "8659": M16,
    "8660": [-0.13313, 0.36687, 0, 0],
    "8661": M15,
    "8704": M6,
    "8706": [0, 0.69444, 0.05556, 0.08334],
    "8707": M6,
    "8709": [0.05556, 0.75, 0, 0],
    "8711": M9,
    "8712": [0.0391, 0.5391, 0, 0],
    "8715": [0.0391, 0.5391, 0, 0],
    "8722": [0.08333, 0.58333, 0, 0],
    "8723": [0.08333, 0.58333, 0, 0],
    "8725": M15,
    "8726": M15,
    "8727": [-0.03472, 0.46528, 0, 0],
    "8728": [-0.05555, 0.44445, 0, 0],
    "8729": [-0.05555, 0.44445, 0, 0],
    "8730": [0.2, 0.8, 0, 0],
    "8733": [0, 0.43056, 0, 0],
    "8734": [0, 0.43056, 0, 0],
    "8736": M3,
    "8739": M15,
    "8741": M15,
    "8743": M20,
    "8744": M20,
    "8745": M20,
    "8746": M20,
    "8747": [0.19444, 0.69444, 0.11111, 0],
    "8764": [-0.13313, 0.36687, 0, 0],
    "8768": M16,
    "8771": [-0.03625, 0.46375, 0, 0],
    "8773": [-0.022, 0.589, 0, 0],
    "8776": [-0.01688, 0.48312, 0, 0],
    "8781": [-0.03625, 0.46375, 0, 0],
    "8784": [-0.133, 0.67, 0, 0],
    "8801": [-0.03625, 0.46375, 0, 0],
    "8804": [0.13597, 0.63597, 0, 0],
    "8805": [0.13597, 0.63597, 0, 0],
    "8810": [0.0391, 0.5391, 0, 0],
    "8811": [0.0391, 0.5391, 0, 0],
    "8826": [0.0391, 0.5391, 0, 0],
    "8827": [0.0391, 0.5391, 0, 0],
    "8834": [0.0391, 0.5391, 0, 0],
    "8835": [0.0391, 0.5391, 0, 0],
    "8838": [0.13597, 0.63597, 0, 0],
    "8839": [0.13597, 0.63597, 0, 0],
    "8846": M20,
    "8849": [0.13597, 0.63597, 0, 0],
    "8850": [0.13597, 0.63597, 0, 0],
    "8851": M20,
    "8852": M20,
    "8853": [0.08333, 0.58333, 0, 0],
    "8854": [0.08333, 0.58333, 0, 0],
    "8855": [0.08333, 0.58333, 0, 0],
    "8856": [0.08333, 0.58333, 0, 0],
    "8857": [0.08333, 0.58333, 0, 0],
    "8866": M6,
    "8867": M6,
    "8868": M6,
    "8869": M6,
    "8872": [0.249, 0.75, 0, 0],
    "8900": [-0.05555, 0.44445, 0, 0],
    "8901": [-0.05555, 0.44445, 0, 0],
    "8902": [-0.03472, 0.46528, 0, 0],
    "8904": [5e-3, 0.505, 0, 0],
    "8942": [0.03, 0.9, 0, 0],
    "8943": [-0.19, 0.31, 0, 0],
    "8945": [-0.1, 0.82, 0, 0],
    "8968": M15,
    "8969": M15,
    "8970": M15,
    "8971": M15,
    "8994": [-0.14236, 0.35764, 0, 0],
    "8995": [-0.14236, 0.35764, 0, 0],
    "9136": [0.244, 0.744, 0, 0],
    "9137": [0.244, 0.744, 0, 0],
    "9651": M16,
    "9657": [-0.03472, 0.46528, 0, 0],
    "9661": M16,
    "9667": [-0.03472, 0.46528, 0, 0],
    "9711": M16,
    "9824": [0.12963, 0.69444, 0, 0],
    "9825": [0.12963, 0.69444, 0, 0],
    "9826": [0.12963, 0.69444, 0, 0],
    "9827": [0.12963, 0.69444, 0, 0],
    "9837": M14,
    "9838": M16,
    "9839": M16,
    "10216": M15,
    "10217": M15,
    "10222": [0.244, 0.744, 0, 0],
    "10223": [0.244, 0.744, 0, 0],
    "10229": [0.011, 0.511, 0, 0],
    "10230": [0.011, 0.511, 0, 0],
    "10231": [0.011, 0.511, 0, 0],
    "10232": [0.024, 0.525, 0, 0],
    "10233": [0.024, 0.525, 0, 0],
    "10234": [0.024, 0.525, 0, 0],
    "10236": [0.011, 0.511, 0, 0],
    "10815": M9,
    "10927": [0.13597, 0.63597, 0, 0],
    "10928": [0.13597, 0.63597, 0, 0],
    "57376": M16
  },
  "Math-BoldItalic": {
    "32": M0,
    "48": M7,
    "49": M7,
    "50": M7,
    "51": M8,
    "52": M8,
    "53": M8,
    "54": M5,
    "55": M8,
    "56": M5,
    "57": M8,
    "65": M4,
    "66": [0, 0.68611, 0.04835, 0],
    "67": [0, 0.68611, 0.06979, 0],
    "68": [0, 0.68611, 0.03194, 0],
    "69": [0, 0.68611, 0.05451, 0],
    "70": [0, 0.68611, 0.15972, 0],
    "71": M4,
    "72": [0, 0.68611, 0.08229, 0],
    "73": [0, 0.68611, 0.07778, 0],
    "74": [0, 0.68611, 0.10069, 0],
    "75": [0, 0.68611, 0.06979, 0],
    "76": M4,
    "77": [0, 0.68611, 0.11424, 0],
    "78": [0, 0.68611, 0.11424, 0],
    "79": [0, 0.68611, 0.03194, 0],
    "80": [0, 0.68611, 0.15972, 0],
    "81": [0.19444, 0.68611, 0, 0],
    "82": [0, 0.68611, 421e-5, 0],
    "83": [0, 0.68611, 0.05382, 0],
    "84": [0, 0.68611, 0.15972, 0],
    "85": [0, 0.68611, 0.11424, 0],
    "86": [0, 0.68611, 0.25555, 0],
    "87": [0, 0.68611, 0.15972, 0],
    "88": [0, 0.68611, 0.07778, 0],
    "89": [0, 0.68611, 0.25555, 0],
    "90": [0, 0.68611, 0.06979, 0],
    "97": M7,
    "98": M6,
    "99": M7,
    "100": M6,
    "101": M7,
    "102": [0.19444, 0.69444, 0.11042, 0],
    "103": [0.19444, 0.44444, 0.03704, 0],
    "104": M6,
    "105": [0, 0.69326, 0, 0],
    "106": [0.19444, 0.69326, 0.0622, 0],
    "107": [0, 0.69444, 0.01852, 0],
    "108": [0, 0.69444, 88e-4, 0],
    "109": M7,
    "110": M7,
    "111": M7,
    "112": M8,
    "113": [0.19444, 0.44444, 0.03704, 0],
    "114": [0, 0.44444, 0.03194, 0],
    "115": M7,
    "116": [0, 0.63492, 0, 0],
    "117": M7,
    "118": [0, 0.44444, 0.03704, 0],
    "119": [0, 0.44444, 0.02778, 0],
    "120": M7,
    "121": [0.19444, 0.44444, 0.03704, 0],
    "122": [0, 0.44444, 0.04213, 0],
    "160": M0,
    "915": [0, 0.68611, 0.15972, 0],
    "916": M4,
    "920": [0, 0.68611, 0.03194, 0],
    "923": M4,
    "926": [0, 0.68611, 0.07458, 0],
    "928": [0, 0.68611, 0.08229, 0],
    "931": [0, 0.68611, 0.05451, 0],
    "933": [0, 0.68611, 0.15972, 0],
    "934": M4,
    "936": [0, 0.68611, 0.11653, 0],
    "937": [0, 0.68611, 0.04835, 0],
    "945": M7,
    "946": [0.19444, 0.69444, 0.03403, 0],
    "947": [0.19444, 0.44444, 0.06389, 0],
    "948": [0, 0.69444, 0.03819, 0],
    "949": M7,
    "950": [0.19444, 0.69444, 0.06215, 0],
    "951": [0.19444, 0.44444, 0.03704, 0],
    "952": [0, 0.69444, 0.03194, 0],
    "953": M7,
    "954": M7,
    "955": M6,
    "956": M8,
    "957": [0, 0.44444, 0.06898, 0],
    "958": [0.19444, 0.69444, 0.03021, 0],
    "959": M7,
    "960": [0, 0.44444, 0.03704, 0],
    "961": M8,
    "962": [0.09722, 0.44444, 0.07917, 0],
    "963": [0, 0.44444, 0.03704, 0],
    "964": [0, 0.44444, 0.13472, 0],
    "965": [0, 0.44444, 0.03704, 0],
    "966": M8,
    "967": M8,
    "968": [0.19444, 0.69444, 0.03704, 0],
    "969": [0, 0.44444, 0.03704, 0],
    "977": M6,
    "981": M16,
    "982": [0, 0.44444, 0.03194, 0],
    "1009": M8,
    "1013": M7,
    "57649": M7,
    "57911": M8
  },
  "Math-Italic": {
    "32": M0,
    "48": [0, 0.43056, 0, 0],
    "49": [0, 0.43056, 0, 0],
    "50": [0, 0.43056, 0, 0],
    "51": [0.19444, 0.43056, 0, 0],
    "52": [0.19444, 0.43056, 0, 0],
    "53": [0.19444, 0.43056, 0, 0],
    "54": M5,
    "55": [0.19444, 0.43056, 0, 0],
    "56": M5,
    "57": [0.19444, 0.43056, 0, 0],
    "65": [0, 0.68333, 0, 0.13889],
    "66": [0, 0.68333, 0.05017, 0.08334],
    "67": [0, 0.68333, 0.07153, 0.08334],
    "68": [0, 0.68333, 0.02778, 0.05556],
    "69": [0, 0.68333, 0.05764, 0.08334],
    "70": [0, 0.68333, 0.13889, 0.08334],
    "71": [0, 0.68333, 0, 0.08334],
    "72": [0, 0.68333, 0.08125, 0.05556],
    "73": [0, 0.68333, 0.07847, 0.11111],
    "74": [0, 0.68333, 0.09618, 0.16667],
    "75": [0, 0.68333, 0.07153, 0.05556],
    "76": [0, 0.68333, 0, 0.02778],
    "77": [0, 0.68333, 0.10903, 0.08334],
    "78": [0, 0.68333, 0.10903, 0.08334],
    "79": [0, 0.68333, 0.02778, 0.08334],
    "80": [0, 0.68333, 0.13889, 0.08334],
    "81": [0.19444, 0.68333, 0, 0.08334],
    "82": [0, 0.68333, 773e-5, 0.08334],
    "83": [0, 0.68333, 0.05764, 0.08334],
    "84": [0, 0.68333, 0.13889, 0.08334],
    "85": [0, 0.68333, 0.10903, 0.02778],
    "86": [0, 0.68333, 0.22222, 0],
    "87": [0, 0.68333, 0.13889, 0],
    "88": [0, 0.68333, 0.07847, 0.08334],
    "89": [0, 0.68333, 0.22222, 0],
    "90": [0, 0.68333, 0.07153, 0.08334],
    "97": [0, 0.43056, 0, 0],
    "98": M6,
    "99": [0, 0.43056, 0, 0.05556],
    "100": [0, 0.69444, 0, 0.16667],
    "101": [0, 0.43056, 0, 0.05556],
    "102": [0.19444, 0.69444, 0.10764, 0.16667],
    "103": [0.19444, 0.43056, 0.03588, 0.02778],
    "104": M6,
    "105": [0, 0.65952, 0, 0],
    "106": [0.19444, 0.65952, 0.05724, 0],
    "107": [0, 0.69444, 0.03148, 0],
    "108": [0, 0.69444, 0.01968, 0.08334],
    "109": [0, 0.43056, 0, 0],
    "110": [0, 0.43056, 0, 0],
    "111": [0, 0.43056, 0, 0.05556],
    "112": [0.19444, 0.43056, 0, 0.08334],
    "113": [0.19444, 0.43056, 0.03588, 0.08334],
    "114": [0, 0.43056, 0.02778, 0.05556],
    "115": [0, 0.43056, 0, 0.05556],
    "116": [0, 0.61508, 0, 0.08334],
    "117": [0, 0.43056, 0, 0.02778],
    "118": [0, 0.43056, 0.03588, 0.02778],
    "119": [0, 0.43056, 0.02691, 0.08334],
    "120": [0, 0.43056, 0, 0.02778],
    "121": [0.19444, 0.43056, 0.03588, 0.05556],
    "122": [0, 0.43056, 0.04398, 0.05556],
    "160": M0,
    "915": [0, 0.68333, 0.13889, 0.08334],
    "916": [0, 0.68333, 0, 0.16667],
    "920": [0, 0.68333, 0.02778, 0.08334],
    "923": [0, 0.68333, 0, 0.16667],
    "926": [0, 0.68333, 0.07569, 0.08334],
    "928": [0, 0.68333, 0.08125, 0.05556],
    "931": [0, 0.68333, 0.05764, 0.08334],
    "933": [0, 0.68333, 0.13889, 0.05556],
    "934": [0, 0.68333, 0, 0.08334],
    "936": [0, 0.68333, 0.11, 0.05556],
    "937": [0, 0.68333, 0.05017, 0.08334],
    "945": [0, 0.43056, 37e-4, 0.02778],
    "946": [0.19444, 0.69444, 0.05278, 0.08334],
    "947": [0.19444, 0.43056, 0.05556, 0],
    "948": [0, 0.69444, 0.03785, 0.05556],
    "949": [0, 0.43056, 0, 0.08334],
    "950": [0.19444, 0.69444, 0.07378, 0.08334],
    "951": [0.19444, 0.43056, 0.03588, 0.05556],
    "952": [0, 0.69444, 0.02778, 0.08334],
    "953": [0, 0.43056, 0, 0.05556],
    "954": [0, 0.43056, 0, 0],
    "955": M6,
    "956": [0.19444, 0.43056, 0, 0.02778],
    "957": [0, 0.43056, 0.06366, 0.02778],
    "958": [0.19444, 0.69444, 0.04601, 0.11111],
    "959": [0, 0.43056, 0, 0.05556],
    "960": [0, 0.43056, 0.03588, 0],
    "961": [0.19444, 0.43056, 0, 0.08334],
    "962": [0.09722, 0.43056, 0.07986, 0.08334],
    "963": [0, 0.43056, 0.03588, 0],
    "964": [0, 0.43056, 0.1132, 0.02778],
    "965": [0, 0.43056, 0.03588, 0.02778],
    "966": [0.19444, 0.43056, 0, 0.08334],
    "967": [0.19444, 0.43056, 0, 0.05556],
    "968": [0.19444, 0.69444, 0.03588, 0.11111],
    "969": [0, 0.43056, 0.03588, 0],
    "977": [0, 0.69444, 0, 0.08334],
    "981": [0.19444, 0.69444, 0, 0.08334],
    "982": [0, 0.43056, 0.02778, 0],
    "1009": [0.19444, 0.43056, 0, 0.08334],
    "1013": [0, 0.43056, 0, 0.05556],
    "57649": [0, 0.43056, 0, 0.02778],
    "57911": [0.19444, 0.43056, 0, 0.08334]
  },
  "SansSerif-Bold": {
    "32": M0,
    "33": M6,
    "34": M6,
    "35": M16,
    "36": [0.05556, 0.75, 0, 0],
    "37": [0.05556, 0.75, 0, 0],
    "38": M6,
    "39": M6,
    "40": M15,
    "41": M15,
    "42": M14,
    "43": [0.11667, 0.61667, 0, 0],
    "44": [0.10556, 0.13056, 0, 0],
    "45": [0, 0.45833, 0, 0],
    "46": [0, 0.13056, 0, 0],
    "47": M15,
    "48": M6,
    "49": M6,
    "50": M6,
    "51": M6,
    "52": M6,
    "53": M6,
    "54": M6,
    "55": M6,
    "56": M6,
    "57": M6,
    "58": [0, 0.45833, 0, 0],
    "59": [0.10556, 0.45833, 0, 0],
    "61": [-0.09375, 0.40625, 0, 0],
    "63": M6,
    "64": M6,
    "65": M6,
    "66": M6,
    "67": M6,
    "68": M6,
    "69": M6,
    "70": M6,
    "71": M6,
    "72": M6,
    "73": M6,
    "74": M6,
    "75": M6,
    "76": M6,
    "77": M6,
    "78": M6,
    "79": M6,
    "80": M6,
    "81": [0.10556, 0.69444, 0, 0],
    "82": M6,
    "83": M6,
    "84": M6,
    "85": M6,
    "86": [0, 0.69444, 0.01528, 0],
    "87": [0, 0.69444, 0.01528, 0],
    "88": M6,
    "89": [0, 0.69444, 0.0275, 0],
    "90": M6,
    "91": M15,
    "93": M15,
    "94": M6,
    "95": [0.35, 0.10833, 0.03056, 0],
    "97": [0, 0.45833, 0, 0],
    "98": M6,
    "99": [0, 0.45833, 0, 0],
    "100": M6,
    "101": [0, 0.45833, 0, 0],
    "102": [0, 0.69444, 0.07639, 0],
    "103": [0.19444, 0.45833, 0.01528, 0],
    "104": M6,
    "105": M6,
    "106": M16,
    "107": M6,
    "108": M6,
    "109": [0, 0.45833, 0, 0],
    "110": [0, 0.45833, 0, 0],
    "111": [0, 0.45833, 0, 0],
    "112": [0.19444, 0.45833, 0, 0],
    "113": [0.19444, 0.45833, 0, 0],
    "114": [0, 0.45833, 0.01528, 0],
    "115": [0, 0.45833, 0, 0],
    "116": [0, 0.58929, 0, 0],
    "117": [0, 0.45833, 0, 0],
    "118": [0, 0.45833, 0.01528, 0],
    "119": [0, 0.45833, 0.01528, 0],
    "120": [0, 0.45833, 0, 0],
    "121": [0.19444, 0.45833, 0.01528, 0],
    "122": [0, 0.45833, 0, 0],
    "126": [0.35, 0.34444, 0, 0],
    "160": M0,
    "168": M6,
    "176": M6,
    "180": M6,
    "184": [0.17014, 0, 0, 0],
    "305": [0, 0.45833, 0, 0],
    "567": [0.19444, 0.45833, 0, 0],
    "710": M6,
    "711": [0, 0.63542, 0, 0],
    "713": [0, 0.63778, 0, 0],
    "728": M6,
    "729": M6,
    "730": M6,
    "732": M6,
    "733": M6,
    "915": M6,
    "916": M6,
    "920": M6,
    "923": M6,
    "926": M6,
    "928": M6,
    "931": M6,
    "933": M6,
    "934": M6,
    "936": M6,
    "937": M6,
    "8211": [0, 0.45833, 0.03056, 0],
    "8212": [0, 0.45833, 0.03056, 0],
    "8216": M6,
    "8217": M6,
    "8220": M6,
    "8221": M6
  },
  "SansSerif-Italic": {
    "32": M0,
    "33": [0, 0.69444, 0.05733, 0],
    "34": [0, 0.69444, 316e-5, 0],
    "35": [0.19444, 0.69444, 0.05087, 0],
    "36": [0.05556, 0.75, 0.11156, 0],
    "37": [0.05556, 0.75, 0.03126, 0],
    "38": [0, 0.69444, 0.03058, 0],
    "39": [0, 0.69444, 0.07816, 0],
    "40": [0.25, 0.75, 0.13164, 0],
    "41": [0.25, 0.75, 0.02536, 0],
    "42": [0, 0.75, 0.11775, 0],
    "43": [0.08333, 0.58333, 0.02536, 0],
    "44": [0.125, 0.08333, 0, 0],
    "45": [0, 0.44444, 0.01946, 0],
    "46": [0, 0.08333, 0, 0],
    "47": [0.25, 0.75, 0.13164, 0],
    "48": [0, 0.65556, 0.11156, 0],
    "49": [0, 0.65556, 0.11156, 0],
    "50": [0, 0.65556, 0.11156, 0],
    "51": [0, 0.65556, 0.11156, 0],
    "52": [0, 0.65556, 0.11156, 0],
    "53": [0, 0.65556, 0.11156, 0],
    "54": [0, 0.65556, 0.11156, 0],
    "55": [0, 0.65556, 0.11156, 0],
    "56": [0, 0.65556, 0.11156, 0],
    "57": [0, 0.65556, 0.11156, 0],
    "58": [0, 0.44444, 0.02502, 0],
    "59": [0.125, 0.44444, 0.02502, 0],
    "61": [-0.13, 0.37, 0.05087, 0],
    "63": [0, 0.69444, 0.11809, 0],
    "64": [0, 0.69444, 0.07555, 0],
    "65": M6,
    "66": [0, 0.69444, 0.08293, 0],
    "67": [0, 0.69444, 0.11983, 0],
    "68": [0, 0.69444, 0.07555, 0],
    "69": [0, 0.69444, 0.11983, 0],
    "70": [0, 0.69444, 0.13372, 0],
    "71": [0, 0.69444, 0.11983, 0],
    "72": [0, 0.69444, 0.08094, 0],
    "73": [0, 0.69444, 0.13372, 0],
    "74": [0, 0.69444, 0.08094, 0],
    "75": [0, 0.69444, 0.11983, 0],
    "76": M6,
    "77": [0, 0.69444, 0.08094, 0],
    "78": [0, 0.69444, 0.08094, 0],
    "79": [0, 0.69444, 0.07555, 0],
    "80": [0, 0.69444, 0.08293, 0],
    "81": [0.125, 0.69444, 0.07555, 0],
    "82": [0, 0.69444, 0.08293, 0],
    "83": [0, 0.69444, 0.09205, 0],
    "84": [0, 0.69444, 0.13372, 0],
    "85": [0, 0.69444, 0.08094, 0],
    "86": [0, 0.69444, 0.1615, 0],
    "87": [0, 0.69444, 0.1615, 0],
    "88": [0, 0.69444, 0.13372, 0],
    "89": [0, 0.69444, 0.17261, 0],
    "90": [0, 0.69444, 0.11983, 0],
    "91": [0.25, 0.75, 0.15942, 0],
    "93": [0.25, 0.75, 0.08719, 0],
    "94": [0, 0.69444, 0.0799, 0],
    "95": [0.35, 0.09444, 0.08616, 0],
    "97": [0, 0.44444, 981e-5, 0],
    "98": [0, 0.69444, 0.03057, 0],
    "99": [0, 0.44444, 0.08336, 0],
    "100": [0, 0.69444, 0.09483, 0],
    "101": [0, 0.44444, 0.06778, 0],
    "102": [0, 0.69444, 0.21705, 0],
    "103": [0.19444, 0.44444, 0.10836, 0],
    "104": [0, 0.69444, 0.01778, 0],
    "105": [0, 0.67937, 0.09718, 0],
    "106": [0.19444, 0.67937, 0.09162, 0],
    "107": [0, 0.69444, 0.08336, 0],
    "108": [0, 0.69444, 0.09483, 0],
    "109": [0, 0.44444, 0.01778, 0],
    "110": [0, 0.44444, 0.01778, 0],
    "111": [0, 0.44444, 0.06613, 0],
    "112": [0.19444, 0.44444, 0.0389, 0],
    "113": [0.19444, 0.44444, 0.04169, 0],
    "114": [0, 0.44444, 0.10836, 0],
    "115": [0, 0.44444, 0.0778, 0],
    "116": [0, 0.57143, 0.07225, 0],
    "117": [0, 0.44444, 0.04169, 0],
    "118": [0, 0.44444, 0.10836, 0],
    "119": [0, 0.44444, 0.10836, 0],
    "120": [0, 0.44444, 0.09169, 0],
    "121": [0.19444, 0.44444, 0.10836, 0],
    "122": [0, 0.44444, 0.08752, 0],
    "126": [0.35, 0.32659, 0.08826, 0],
    "160": M0,
    "168": [0, 0.67937, 0.06385, 0],
    "176": M6,
    "184": [0.17014, 0, 0, 0],
    "305": [0, 0.44444, 0.04169, 0],
    "567": [0.19444, 0.44444, 0.04169, 0],
    "710": [0, 0.69444, 0.0799, 0],
    "711": [0, 0.63194, 0.08432, 0],
    "713": [0, 0.60889, 0.08776, 0],
    "714": [0, 0.69444, 0.09205, 0],
    "715": M6,
    "728": [0, 0.69444, 0.09483, 0],
    "729": [0, 0.67937, 0.07774, 0],
    "730": M6,
    "732": [0, 0.67659, 0.08826, 0],
    "733": [0, 0.69444, 0.09205, 0],
    "915": [0, 0.69444, 0.13372, 0],
    "916": M6,
    "920": [0, 0.69444, 0.07555, 0],
    "923": M6,
    "926": [0, 0.69444, 0.12816, 0],
    "928": [0, 0.69444, 0.08094, 0],
    "931": [0, 0.69444, 0.11983, 0],
    "933": [0, 0.69444, 0.09031, 0],
    "934": [0, 0.69444, 0.04603, 0],
    "936": [0, 0.69444, 0.09031, 0],
    "937": [0, 0.69444, 0.08293, 0],
    "8211": [0, 0.44444, 0.08616, 0],
    "8212": [0, 0.44444, 0.08616, 0],
    "8216": [0, 0.69444, 0.07816, 0],
    "8217": [0, 0.69444, 0.07816, 0],
    "8220": [0, 0.69444, 0.14205, 0],
    "8221": [0, 0.69444, 316e-5, 0]
  },
  "SansSerif-Regular": {
    "32": M0,
    "33": M6,
    "34": M6,
    "35": M16,
    "36": [0.05556, 0.75, 0, 0],
    "37": [0.05556, 0.75, 0, 0],
    "38": M6,
    "39": M6,
    "40": M15,
    "41": M15,
    "42": M14,
    "43": [0.08333, 0.58333, 0, 0],
    "44": [0.125, 0.08333, 0, 0],
    "45": M7,
    "46": [0, 0.08333, 0, 0],
    "47": M15,
    "48": [0, 0.65556, 0, 0],
    "49": [0, 0.65556, 0, 0],
    "50": [0, 0.65556, 0, 0],
    "51": [0, 0.65556, 0, 0],
    "52": [0, 0.65556, 0, 0],
    "53": [0, 0.65556, 0, 0],
    "54": [0, 0.65556, 0, 0],
    "55": [0, 0.65556, 0, 0],
    "56": [0, 0.65556, 0, 0],
    "57": [0, 0.65556, 0, 0],
    "58": M7,
    "59": [0.125, 0.44444, 0, 0],
    "61": [-0.13, 0.37, 0, 0],
    "63": M6,
    "64": M6,
    "65": M6,
    "66": M6,
    "67": M6,
    "68": M6,
    "69": M6,
    "70": M6,
    "71": M6,
    "72": M6,
    "73": M6,
    "74": M6,
    "75": M6,
    "76": M6,
    "77": M6,
    "78": M6,
    "79": M6,
    "80": M6,
    "81": [0.125, 0.69444, 0, 0],
    "82": M6,
    "83": M6,
    "84": M6,
    "85": M6,
    "86": [0, 0.69444, 0.01389, 0],
    "87": [0, 0.69444, 0.01389, 0],
    "88": M6,
    "89": [0, 0.69444, 0.025, 0],
    "90": M6,
    "91": M15,
    "93": M15,
    "94": M6,
    "95": [0.35, 0.09444, 0.02778, 0],
    "97": M7,
    "98": M6,
    "99": M7,
    "100": M6,
    "101": M7,
    "102": [0, 0.69444, 0.06944, 0],
    "103": [0.19444, 0.44444, 0.01389, 0],
    "104": M6,
    "105": [0, 0.67937, 0, 0],
    "106": [0.19444, 0.67937, 0, 0],
    "107": M6,
    "108": M6,
    "109": M7,
    "110": M7,
    "111": M7,
    "112": M8,
    "113": M8,
    "114": [0, 0.44444, 0.01389, 0],
    "115": M7,
    "116": [0, 0.57143, 0, 0],
    "117": M7,
    "118": [0, 0.44444, 0.01389, 0],
    "119": [0, 0.44444, 0.01389, 0],
    "120": M7,
    "121": [0.19444, 0.44444, 0.01389, 0],
    "122": M7,
    "126": [0.35, 0.32659, 0, 0],
    "160": M0,
    "168": [0, 0.67937, 0, 0],
    "176": M6,
    "184": [0.17014, 0, 0, 0],
    "305": M7,
    "567": M8,
    "710": M6,
    "711": [0, 0.63194, 0, 0],
    "713": [0, 0.60889, 0, 0],
    "714": M6,
    "715": M6,
    "728": M6,
    "729": [0, 0.67937, 0, 0],
    "730": M6,
    "732": [0, 0.67659, 0, 0],
    "733": M6,
    "915": M6,
    "916": M6,
    "920": M6,
    "923": M6,
    "926": M6,
    "928": M6,
    "931": M6,
    "933": M6,
    "934": M6,
    "936": M6,
    "937": M6,
    "8211": [0, 0.44444, 0.02778, 0],
    "8212": [0, 0.44444, 0.02778, 0],
    "8216": M6,
    "8217": M6,
    "8220": M6,
    "8221": M6
  },
  "Script-Regular": {
    "32": M0,
    "65": [0, 0.7, 0.22925, 0],
    "66": [0, 0.7, 0.04087, 0],
    "67": [0, 0.7, 0.1689, 0],
    "68": [0, 0.7, 0.09371, 0],
    "69": [0, 0.7, 0.18583, 0],
    "70": [0, 0.7, 0.13634, 0],
    "71": [0, 0.7, 0.17322, 0],
    "72": [0, 0.7, 0.29694, 0],
    "73": [0, 0.7, 0.19189, 0],
    "74": [0.27778, 0.7, 0.19189, 0],
    "75": [0, 0.7, 0.31259, 0],
    "76": [0, 0.7, 0.19189, 0],
    "77": [0, 0.7, 0.15981, 0],
    "78": [0, 0.7, 0.3525, 0],
    "79": [0, 0.7, 0.08078, 0],
    "80": [0, 0.7, 0.08078, 0],
    "81": [0, 0.7, 0.03305, 0],
    "82": [0, 0.7, 0.06259, 0],
    "83": [0, 0.7, 0.19189, 0],
    "84": [0, 0.7, 0.29087, 0],
    "85": [0, 0.7, 0.25815, 0],
    "86": [0, 0.7, 0.27523, 0],
    "87": [0, 0.7, 0.27523, 0],
    "88": [0, 0.7, 0.26006, 0],
    "89": [0, 0.7, 0.2939, 0],
    "90": [0, 0.7, 0.24037, 0],
    "160": M0
  },
  "Size1-Regular": {
    "32": M0,
    "40": M10,
    "41": M10,
    "47": M10,
    "91": M10,
    "92": M10,
    "93": M10,
    "123": M10,
    "125": M10,
    "160": M0,
    "710": [0, 0.72222, 0, 0],
    "732": [0, 0.72222, 0, 0],
    "770": [0, 0.72222, 0, 0],
    "771": [0, 0.72222, 0, 0],
    "8214": [-99e-5, 0.601, 0, 0],
    "8593": [1e-5, 0.6, 0, 0],
    "8595": [1e-5, 0.6, 0, 0],
    "8657": [1e-5, 0.6, 0, 0],
    "8659": [1e-5, 0.6, 0, 0],
    "8719": M17,
    "8720": M17,
    "8721": M17,
    "8730": M10,
    "8739": [-599e-5, 0.606, 0, 0],
    "8741": [-599e-5, 0.606, 0, 0],
    "8747": [0.30612, 0.805, 0.19445, 0],
    "8748": [0.306, 0.805, 0.19445, 0],
    "8749": [0.306, 0.805, 0.19445, 0],
    "8750": [0.30612, 0.805, 0.19445, 0],
    "8896": M17,
    "8897": M17,
    "8898": M17,
    "8899": M17,
    "8968": M10,
    "8969": M10,
    "8970": M10,
    "8971": M10,
    "9168": [-99e-5, 0.601, 0, 0],
    "10216": M10,
    "10217": M10,
    "10752": M17,
    "10753": M17,
    "10754": M17,
    "10756": M17,
    "10758": M17
  },
  "Size2-Regular": {
    "32": M0,
    "40": M19,
    "41": M19,
    "47": M19,
    "91": M19,
    "92": M19,
    "93": M19,
    "123": M19,
    "125": M19,
    "160": M0,
    "710": M14,
    "732": M14,
    "770": M14,
    "771": M14,
    "8719": M18,
    "8720": M18,
    "8721": M18,
    "8730": M19,
    "8747": [0.86225, 1.36, 0.44445, 0],
    "8748": [0.862, 1.36, 0.44445, 0],
    "8749": [0.862, 1.36, 0.44445, 0],
    "8750": [0.86225, 1.36, 0.44445, 0],
    "8896": M18,
    "8897": M18,
    "8898": M18,
    "8899": M18,
    "8968": M19,
    "8969": M19,
    "8970": M19,
    "8971": M19,
    "10216": M19,
    "10217": M19,
    "10752": M18,
    "10753": M18,
    "10754": M18,
    "10756": M18,
    "10758": M18
  },
  "Size3-Regular": {
    "32": M0,
    "40": M13,
    "41": M13,
    "47": M13,
    "91": M13,
    "92": M13,
    "93": M13,
    "123": M13,
    "125": M13,
    "160": M0,
    "710": M14,
    "732": M14,
    "770": M14,
    "771": M14,
    "8730": M13,
    "8968": M13,
    "8969": M13,
    "8970": M13,
    "8971": M13,
    "10216": M13,
    "10217": M13
  },
  "Size4-Regular": {
    "32": M0,
    "40": M12,
    "41": M12,
    "47": M12,
    "91": M12,
    "92": M12,
    "93": M12,
    "123": M12,
    "125": M12,
    "160": M0,
    "710": [0, 0.825, 0, 0],
    "732": [0, 0.825, 0, 0],
    "770": [0, 0.825, 0, 0],
    "771": [0, 0.825, 0, 0],
    "8730": M12,
    "8968": M12,
    "8969": M12,
    "8970": M12,
    "8971": M12,
    "9115": [0.64502, 1.155, 0, 0],
    "9116": [1e-5, 0.6, 0, 0],
    "9117": [0.64502, 1.155, 0, 0],
    "9118": [0.64502, 1.155, 0, 0],
    "9119": [1e-5, 0.6, 0, 0],
    "9120": [0.64502, 1.155, 0, 0],
    "9121": [0.64502, 1.155, 0, 0],
    "9122": [-99e-5, 0.601, 0, 0],
    "9123": [0.64502, 1.155, 0, 0],
    "9124": [0.64502, 1.155, 0, 0],
    "9125": [-99e-5, 0.601, 0, 0],
    "9126": [0.64502, 1.155, 0, 0],
    "9127": [1e-5, 0.9, 0, 0],
    "9128": M19,
    "9129": [0.90001, 0, 0, 0],
    "9130": [0, 0.3, 0, 0],
    "9131": [1e-5, 0.9, 0, 0],
    "9132": M19,
    "9133": [0.90001, 0, 0, 0],
    "9143": [0.88502, 0.915, 0, 0],
    "10216": M12,
    "10217": M12,
    "57344": [-499e-5, 0.605, 0, 0],
    "57345": [-499e-5, 0.605, 0, 0],
    "57680": [0, 0.12, 0, 0],
    "57681": [0, 0.12, 0, 0],
    "57682": [0, 0.12, 0, 0],
    "57683": [0, 0.12, 0, 0]
  },
  "Typewriter-Regular": {
    "32": M0,
    "33": M11,
    "34": M11,
    "35": M11,
    "36": [0.08333, 0.69444, 0, 0],
    "37": [0.08333, 0.69444, 0, 0],
    "38": M11,
    "39": M11,
    "40": [0.08333, 0.69444, 0, 0],
    "41": [0.08333, 0.69444, 0, 0],
    "42": [0, 0.52083, 0, 0],
    "43": [-0.08056, 0.53055, 0, 0],
    "44": [0.13889, 0.125, 0, 0],
    "45": [-0.08056, 0.53055, 0, 0],
    "46": [0, 0.125, 0, 0],
    "47": [0.08333, 0.69444, 0, 0],
    "48": M11,
    "49": M11,
    "50": M11,
    "51": M11,
    "52": M11,
    "53": M11,
    "54": M11,
    "55": M11,
    "56": M11,
    "57": M11,
    "58": [0, 0.43056, 0, 0],
    "59": [0.13889, 0.43056, 0, 0],
    "60": [-0.05556, 0.55556, 0, 0],
    "61": [-0.19549, 0.41562, 0, 0],
    "62": [-0.05556, 0.55556, 0, 0],
    "63": M11,
    "64": M11,
    "65": M11,
    "66": M11,
    "67": M11,
    "68": M11,
    "69": M11,
    "70": M11,
    "71": M11,
    "72": M11,
    "73": M11,
    "74": M11,
    "75": M11,
    "76": M11,
    "77": M11,
    "78": M11,
    "79": M11,
    "80": M11,
    "81": [0.13889, 0.61111, 0, 0],
    "82": M11,
    "83": M11,
    "84": M11,
    "85": M11,
    "86": M11,
    "87": M11,
    "88": M11,
    "89": M11,
    "90": M11,
    "91": [0.08333, 0.69444, 0, 0],
    "92": [0.08333, 0.69444, 0, 0],
    "93": [0.08333, 0.69444, 0, 0],
    "94": M11,
    "95": [0.09514, 0, 0, 0],
    "96": M11,
    "97": [0, 0.43056, 0, 0],
    "98": M11,
    "99": [0, 0.43056, 0, 0],
    "100": M11,
    "101": [0, 0.43056, 0, 0],
    "102": M11,
    "103": [0.22222, 0.43056, 0, 0],
    "104": M11,
    "105": M11,
    "106": [0.22222, 0.61111, 0, 0],
    "107": M11,
    "108": M11,
    "109": [0, 0.43056, 0, 0],
    "110": [0, 0.43056, 0, 0],
    "111": [0, 0.43056, 0, 0],
    "112": [0.22222, 0.43056, 0, 0],
    "113": [0.22222, 0.43056, 0, 0],
    "114": [0, 0.43056, 0, 0],
    "115": [0, 0.43056, 0, 0],
    "116": [0, 0.55358, 0, 0],
    "117": [0, 0.43056, 0, 0],
    "118": [0, 0.43056, 0, 0],
    "119": [0, 0.43056, 0, 0],
    "120": [0, 0.43056, 0, 0],
    "121": [0.22222, 0.43056, 0, 0],
    "122": [0, 0.43056, 0, 0],
    "123": [0.08333, 0.69444, 0, 0],
    "124": [0.08333, 0.69444, 0, 0],
    "125": [0.08333, 0.69444, 0, 0],
    "126": M11,
    "127": M11,
    "160": M0,
    "176": M11,
    "184": [0.19445, 0, 0, 0],
    "305": [0, 0.43056, 0, 0],
    "567": [0.22222, 0.43056, 0, 0],
    "711": [0, 0.56597, 0, 0],
    "713": [0, 0.56555, 0, 0],
    "714": M11,
    "715": M11,
    "728": M11,
    "730": M11,
    "770": M11,
    "771": M11,
    "776": M11,
    "915": M11,
    "916": M11,
    "920": M11,
    "923": M11,
    "926": M11,
    "928": M11,
    "931": M11,
    "933": M11,
    "934": M11,
    "936": M11,
    "937": M11,
    "8216": M11,
    "8217": M11,
    "8242": M11,
    "9251": [0.11111, 0.21944, 0, 0]
  }
};

// src/core/font-metrics.ts
var CJK_REGEX = /[\u3040-\u309F]|[\u30A0-\u30FF]|[\u4E00-\u9FAF]|[\uAC00-\uD7AF]/;
var PT_PER_EM = 10;
var AXIS_HEIGHT = 0.25;
var BASELINE_SKIP = 1.2;
var X_HEIGHT = 0.431;
var FONT_METRICS = {
  slant: [0.25, 0.25, 0.25],
  space: [0, 0, 0],
  stretch: [0, 0, 0],
  shrink: [0, 0, 0],
  xHeight: [X_HEIGHT, X_HEIGHT, X_HEIGHT],
  quad: [1, 1.171, 1.472],
  extraSpace: [0, 0, 0],
  num1: [0.677, 0.732, 0.925],
  num2: [0.394, 0.384, 0.387],
  num3: [0.444, 0.471, 0.504],
  denom1: [0.686, 0.752, 1.025],
  denom2: [0.345, 0.344, 0.532],
  sup1: [0.413, 0.503, 0.504],
  sup2: [0.363, 0.431, 0.404],
  sup3: [0.289, 0.286, 0.294],
  sub1: [0.15, 0.143, 0.2],
  sub2: [0.247, 0.286, 0.4],
  supDrop: [0.386, 0.353, 0.494],
  subDrop: [0.05, 0.071, 0.1],
  delim1: [2.39, 1.7, 1.98],
  delim2: [1.01, 1.157, 1.42],
  axisHeight: [AXIS_HEIGHT, AXIS_HEIGHT, AXIS_HEIGHT],
  defaultRuleThickness: [0.04, 0.049, 0.049],
  bigOpSpacing1: [0.111, 0.111, 0.111],
  bigOpSpacing2: [0.166, 0.166, 0.166],
  bigOpSpacing3: [0.2, 0.2, 0.2],
  bigOpSpacing4: [0.6, 0.611, 0.611],
  bigOpSpacing5: [0.1, 0.143, 0.143],
  sqrtRuleThickness: [0.04, 0.04, 0.04]
};
var FONT_SCALE = [
  0,
  0.5,
  0.7,
  0.8,
  0.9,
  1,
  1.2,
  1.44,
  1.728,
  2.074,
  2.488
];
var DEFAULT_FONT_SIZE = 5;
var extraCharacterMap = {
  "\xA0": " ",
  "\u200B": " ",
  "\xC5": "A",
  "\xC7": "C",
  "\xD0": "D",
  "\xDE": "o",
  "\xE5": "a",
  "\xE7": "c",
  "\xF0": "d",
  "\xFE": "o",
  "\u0410": "A",
  "\u0411": "B",
  "\u0412": "B",
  "\u0413": "F",
  "\u0414": "A",
  "\u0415": "E",
  "\u0416": "K",
  "\u0417": "3",
  "\u0418": "N",
  "\u0419": "N",
  "\u041A": "K",
  "\u041B": "N",
  "\u041C": "M",
  "\u041D": "H",
  "\u041E": "O",
  "\u041F": "N",
  "\u0420": "P",
  "\u0421": "C",
  "\u0422": "T",
  "\u0423": "y",
  "\u0424": "O",
  "\u0425": "X",
  "\u0426": "U",
  "\u0427": "h",
  "\u0428": "W",
  "\u0429": "W",
  "\u042A": "B",
  "\u042B": "X",
  "\u042C": "B",
  "\u042D": "3",
  "\u042E": "X",
  "\u042F": "R",
  "\u0430": "a",
  "\u0431": "b",
  "\u0432": "a",
  "\u0433": "r",
  "\u0434": "y",
  "\u0435": "e",
  "\u0436": "m",
  "\u0437": "e",
  "\u0438": "n",
  "\u0439": "n",
  "\u043A": "n",
  "\u043B": "n",
  "\u043C": "m",
  "\u043D": "n",
  "\u043E": "o",
  "\u043F": "n",
  "\u0440": "p",
  "\u0441": "c",
  "\u0442": "o",
  "\u0443": "y",
  "\u0444": "b",
  "\u0445": "x",
  "\u0446": "n",
  "\u0447": "n",
  "\u0448": "w",
  "\u0449": "w",
  "\u044A": "a",
  "\u044B": "m",
  "\u044C": "a",
  "\u044D": "e",
  "\u044E": "m",
  "\u044F": "r"
};
function getCharacterMetrics(codepoint, fontName) {
  if (codepoint === void 0)
    codepoint = 77;
  const metrics = font_metrics_data_default[fontName][codepoint];
  if (metrics) {
    return {
      defaultMetrics: false,
      depth: metrics[0],
      height: metrics[1],
      italic: metrics[2],
      skew: metrics[3]
    };
  }
  if (codepoint === 11034) {
    return {
      defaultMetrics: true,
      depth: 0.2,
      height: 0.8,
      italic: 0,
      skew: 0
    };
  }
  const char = String.fromCodePoint(codepoint);
  if (char in extraCharacterMap) {
    codepoint = extraCharacterMap[char].codePointAt(0);
  } else if (CJK_REGEX.test(char)) {
    codepoint = 77;
    return {
      defaultMetrics: true,
      depth: 0.2,
      height: 0.9,
      italic: 0,
      skew: 0
    };
  }
  return {
    defaultMetrics: true,
    depth: 0.2,
    height: 0.7,
    italic: 0,
    skew: 0
  };
}

// src/core/mathstyle.ts
var D = 7;
var Dc = 6;
var T = 5;
var Tc = 4;
var S = 3;
var Sc = 2;
var SS = 1;
var SSc = 0;
var Mathstyle = class {
  constructor(id, sizeDelta, cramped) {
    this.id = id;
    this.sizeDelta = sizeDelta;
    this.cramped = cramped;
    const metricsIndex = {"-4": 2, "-3": 1, 0: 0}[sizeDelta];
    this.metrics = Object.keys(FONT_METRICS).reduce((acc, x3) => {
      return {...acc, [x3]: FONT_METRICS[x3][metricsIndex]};
    }, {});
  }
  getFontSize(size) {
    return Math.max(1, size + this.sizeDelta);
  }
  get sup() {
    return MATHSTYLES[[SSc, SS, SSc, SS, Sc, S, Sc, S][this.id]];
  }
  get sub() {
    return MATHSTYLES[[SSc, SSc, SSc, SSc, Sc, Sc, Sc, Sc][this.id]];
  }
  get fracNum() {
    return MATHSTYLES[[SSc, SS, SSc, SS, Sc, S, Tc, T][this.id]];
  }
  get fracDen() {
    return MATHSTYLES[[SSc, SSc, SSc, SSc, Sc, Sc, Tc, Tc][this.id]];
  }
  get cramp() {
    return MATHSTYLES[[SSc, SSc, Sc, Sc, Tc, Tc, Dc, Dc][this.id]];
  }
  get isTight() {
    return this.sizeDelta < 0;
  }
};
var MATHSTYLES = {
  7: new Mathstyle(D, 0, false),
  6: new Mathstyle(Dc, 0, true),
  5: new Mathstyle(T, 0, false),
  4: new Mathstyle(Tc, 0, true),
  3: new Mathstyle(S, -3, false),
  2: new Mathstyle(Sc, -3, true),
  1: new Mathstyle(SS, -4, false),
  0: new Mathstyle(SSc, -4, true)
};
MATHSTYLES.displaystyle = MATHSTYLES[D];
MATHSTYLES.textstyle = MATHSTYLES[T];
MATHSTYLES.scriptstyle = MATHSTYLES[S];
MATHSTYLES.scriptscriptstyle = MATHSTYLES[SS];

// src/core/registers-utils.ts
function convertDimensionToPt(value, precision) {
  if (!value)
    return 0;
  const f3 = {
    pt: 1,
    mm: 7227 / 2540,
    cm: 7227 / 254,
    ex: 35271 / 8192,
    px: 3 / 4,
    em: PT_PER_EM,
    bp: 803 / 800,
    dd: 1238 / 1157,
    pc: 12,
    in: 72.27,
    mu: 10 / 18
  }[value.unit ?? "pt"];
  if (Number.isFinite(precision)) {
    const factor = 10 ** precision;
    return Math.round(value.dimension / PT_PER_EM * f3 * factor) / factor;
  }
  return value.dimension * f3;
}
function convertDimensionToEm(value, precision) {
  if (value === null)
    return 0;
  return convertDimensionToPt(value, precision) / PT_PER_EM;
}
function convertGlueToEm(value) {
  return convertDimensionToEm(value.glue);
}
function serializeDimension(value) {
  return `${value.dimension}${value.unit ?? "pt"}`;
}

// src/core/context.ts
var Context = class {
  constructor(parent, style, inMathstyle) {
    console.assert(parent instanceof Context || style?.fontSize !== void 0);
    console.assert(parent instanceof Context || inMathstyle !== void 0);
    if (parent instanceof Context)
      this.parent = parent;
    if (!(parent instanceof Context))
      this.registers = parent.registers ?? {};
    this.isSelected = style?.isSelected ?? parent?.isSelected ?? false;
    this.isPhantom = style?.isPhantom ?? this.parent?.isPhantom ?? false;
    const from = {
      ...parent
    };
    if (style) {
      let size = void 0;
      if (style.fontSize && style.fontSize !== "auto" && style.fontSize !== this.parent?._size) {
        size = style.fontSize;
      }
      if (style.letterShapeStyle && style.letterShapeStyle !== "auto") {
        from.letterShapeStyle = style.letterShapeStyle;
      }
      if (style.color && style.color !== "none")
        from.color = style.color;
      if (style.backgroundColor && style.backgroundColor !== "none") {
        from.backgroundColor = this.isSelected ? highlight(style.backgroundColor) : style.backgroundColor;
      }
      this._size = size;
    }
    this.letterShapeStyle = from.letterShapeStyle ?? "tex";
    this.color = from.color;
    this.backgroundColor = from.backgroundColor;
    let mathstyle;
    if (typeof inMathstyle === "string") {
      if (parent instanceof Context) {
        switch (inMathstyle) {
          case "cramp":
            mathstyle = parent.mathstyle.cramp;
            break;
          case "superscript":
            mathstyle = parent.mathstyle.sup;
            break;
          case "subscript":
            mathstyle = parent.mathstyle.sub;
            break;
          case "numerator":
            mathstyle = parent.mathstyle.fracNum;
            break;
          case "denominator":
            mathstyle = parent.mathstyle.fracDen;
            break;
        }
      }
      switch (inMathstyle) {
        case "textstyle":
          mathstyle = MATHSTYLES.textstyle;
          break;
        case "displaystyle":
          mathstyle = MATHSTYLES.displaystyle;
          break;
        case "scriptstyle":
          mathstyle = MATHSTYLES.scriptstyle;
          break;
        case "scriptscriptstyle":
          mathstyle = MATHSTYLES.scriptscriptstyle;
          break;
        case "":
        case "auto":
          break;
      }
    }
    this._mathstyle = mathstyle;
    this.atomIdsSettings = parent.atomIdsSettings;
    this.macros = from.macros ?? {};
    this.smartFence = from.smartFence ?? false;
    this.renderPlaceholder = from.renderPlaceholder;
    console.assert(!(parent instanceof Context) || this.atomIdsSettings === parent.atomIdsSettings);
  }
  get mathstyle() {
    let result = this._mathstyle;
    let parent = this.parent;
    while (!result) {
      result = parent._mathstyle;
      parent = parent.parent;
    }
    return result;
  }
  getRegister(name) {
    if (this.registers?.[name])
      return this.registers[name];
    if (this.parent)
      return this.parent.getRegister(name);
    return void 0;
  }
  getRegisterAsGlue(name) {
    if (this.registers?.[name]) {
      const value = this.registers[name];
      if (typeof value === "object" && "glue" in value) {
        return value;
      } else if (typeof value === "object" && "dimension" in value) {
        return {glue: {dimension: value.dimension}};
      } else if (typeof value === "number") {
        return {glue: {dimension: value}};
      }
      return void 0;
    }
    if (this.parent)
      return this.parent.getRegisterAsGlue(name);
    return void 0;
  }
  getRegisterAsEm(name) {
    return convertDimensionToEm(this.getRegisterAsDimension(name));
  }
  getRegisterAsDimension(name) {
    if (this.registers?.[name]) {
      const value = this.registers[name];
      if (typeof value === "object" && "glue" in value) {
        return value.glue;
      } else if (typeof value === "object" && "dimension" in value) {
        return value;
      } else if (typeof value === "number") {
        return {dimension: value};
      }
      return void 0;
    }
    if (this.parent)
      return this.parent.getRegisterAsDimension(name);
    return void 0;
  }
  setRegister(name, value) {
    if (value === void 0) {
      delete this.registers[name];
      return;
    }
    this.registers[name] = value;
  }
  setGlobalRegister(name, value) {
    let root = this;
    while (root.parent) {
      root.setRegister(name, void 0);
      root = root.parent;
    }
    root.setRegister(name, value);
  }
  get size() {
    let result = this._size;
    let parent = this.parent;
    while (!result) {
      result = parent._size;
      parent = parent.parent;
    }
    return result;
  }
  makeID() {
    if (!this.atomIdsSettings)
      return void 0;
    if (typeof this.atomIdsSettings.seed !== "number") {
      return Date.now().toString(36).slice(-2) + Math.floor(Math.random() * 1e5).toString(36);
    }
    const result = this.atomIdsSettings.overrideID ? this.atomIdsSettings.overrideID : this.atomIdsSettings.seed.toString(36);
    this.atomIdsSettings.seed += 1;
    return result;
  }
  scale(value) {
    return value * this.effectiveFontSize;
  }
  get scalingFactor() {
    if (!this.parent)
      return 1;
    return this.effectiveFontSize / this.parent.effectiveFontSize;
  }
  get isDisplayStyle() {
    return this.mathstyle.id === D || this.mathstyle.id === Dc;
  }
  get isCramped() {
    return this.mathstyle.cramped;
  }
  get isTight() {
    return this.mathstyle.isTight;
  }
  get effectiveFontSize() {
    return FONT_SCALE[Math.max(1, this.size + this.mathstyle.sizeDelta)];
  }
  get computedColor() {
    let result = this.color;
    let parent = this.parent;
    if (!result && parent) {
      result = parent.color;
      parent = parent.parent;
    }
    return result ?? "";
  }
  get computedBackgroundColor() {
    let result = this.backgroundColor;
    let parent = this.parent;
    if (!result && parent) {
      result = parent.backgroundColor;
      parent = parent.parent;
    }
    return result ?? "";
  }
  get metrics() {
    return this.mathstyle.metrics;
  }
};

// src/core/svg-box.ts
var SVG_BODY = {
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [
    ["leftbraceunder", "midbraceunder", "rightbraceunder"],
    1.6,
    548
  ],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [
    ["baraboveshortleftharpoon", "rightharpoonaboveshortbar"],
    1.75,
    716
  ],
  xleftequilibrium: [
    ["shortbaraboveleftharpoon", "shortrightharpoonabovebar"],
    1.75,
    716
  ]
};
var SVG_ACCENTS = {
  widehat1: [1062, 239, 0.24],
  widehat2: [2364, 300, 0.3],
  widehat3: [2364, 360, 0.36],
  widehat4: [2364, 420, 0.42],
  widecheck1: [1062, 239, 0.24],
  widecheck2: [2364, 300, 0.3],
  widecheck3: [2364, 360, 0.36],
  widecheck4: [2364, 420, 0.42],
  widetilde1: [600, 260, 0.26],
  widetilde2: [1033, 286, 0.286],
  widetilde3: [2339, 306, 0.306],
  widetilde4: [2340, 312, 0.34],
  overarc: [1061, 159, 0.3],
  underarc: [1061, 159, 0.3]
};
var PATHS = {
  doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
  doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
  leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
  leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
  leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
  overarc: `M529 0c179 0 524 115 524 115 5 1 9 5 9 10 0 1-1 2-1 3l-4 22c-1 5-5 9-11 9h-2s-338-93-512-92c-174 0-513 92-513 92h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13 0 0 342-115 520-115z`,
  underarc: `m 529 160
  c -179 0 -524 -115 -524 -115
  c -5 -1 -9 -5 -9 -10
  c 0 -1 1 -2 1 -3
  l 4 -22
  c 1 -5 5 -9 11 -9
  h 2
  s 338 93 512 92
  c 174 0 513 -92 513 -92
  h 2
  c 5 0 9 4 11 9
  l 5 22
  c 1 6 -2 12 -8 13
  c 0 0 -342 115 -520 115
  z
  `,
  leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
  leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
  leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
  leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
  leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
  leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
  lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
  leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
  leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
  leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
  longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
  midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
  midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
  oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
  oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
  oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
  oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
  rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
  rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
  rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
  rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
  rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
  rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
  rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
  rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
  rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
  righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
  rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
  rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
  twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
  twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
  widetilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
  widetilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
  widetilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
  widetilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
  vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
  widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
  widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
  widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
  rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
  baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
  rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
  shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
  shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
};
function svgBodyToMarkup(svgBodyName) {
  if (SVG_ACCENTS[svgBodyName]) {
    const [vbWidth, vbHeight, height2] = SVG_ACCENTS[svgBodyName];
    const result = `<span class="stretchy" style="height:${height2}em"><svg width="100%" height="${height2}em" viewBox="0 0 ${vbWidth} ${vbHeight}" preserveAspectRatio="none" ><path d="${PATHS[svgBodyName]}"></path></svg></span>`;
    return `<span style="display:inline-block;height:${height2 / 2}em;min-width:0">${result}</span>`;
  }
  const [paths, minWidth, viewBoxHeight, align] = SVG_BODY[svgBodyName];
  let widthClasses;
  let aligns;
  const height = viewBoxHeight / 1e3;
  if (paths.length === 3) {
    widthClasses = ["slice-1-of-3", "slice-2-of-3", "slice-3-of-3"];
    aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
  } else if (paths.length === 2) {
    widthClasses = ["slice-1-of-2", "slice-2-of-2"];
    aligns = ["xMinYMin", "xMaxYMin"];
  } else {
    widthClasses = ["slice-1-of-1"];
    aligns = [align];
  }
  const body = paths.map((path, i3) => `<span class="${widthClasses[i3]}" style=height:${height}em><svg width=400em height=${height}em viewBox="0 0 400000 ${viewBoxHeight}" preserveAspectRatio="${aligns[i3]} slice"><path d="${PATHS[path]}"></path></svg></span>`).join("");
  return `<span style="display:inline-block;height:${height}em;min-width:${minWidth}em;">${body}</span>`;
}
function svgBodyHeight(svgBodyName) {
  if (SVG_BODY[svgBodyName]) {
    return SVG_BODY[svgBodyName][2] / 1e3;
  }
  return SVG_ACCENTS[svgBodyName][2];
}

// src/core/modes-utils.ts
var _Mode = class {
  constructor(name) {
    _Mode._registry[name] = this;
  }
  static createAtom(mode, command, style) {
    return _Mode._registry[mode].createAtom(command, style);
  }
  static parseTokens(mode, tokens, onError, options) {
    return _Mode._registry[mode].parseTokens(tokens, onError, options);
  }
  static serialize(run, options) {
    console.assert(run.length > 0);
    const mode = _Mode._registry[run[0].mode];
    return mode.serialize(run, options);
  }
  static applyStyle(mode, box, style) {
    return _Mode._registry[mode].applyStyle(box, style);
  }
  createAtom(_command, _style) {
    return null;
  }
  parseTokens(_tokens, _onError, _options) {
    return null;
  }
  serialize(_run, _options) {
    return "";
  }
  applyStyle(_box, _style) {
    return "";
  }
};
var Mode = _Mode;
Mode._registry = {};
function getModeRuns(atoms) {
  const result = [];
  let run = [];
  let currentMode = "NONE";
  for (const atom of atoms) {
    if (atom.type !== "first") {
      if (atom.mode !== currentMode) {
        if (run.length > 0)
          result.push(run);
        run = [atom];
        currentMode = atom.mode;
      } else {
        run.push(atom);
      }
    }
  }
  if (run.length > 0)
    result.push(run);
  return result;
}
function getPropertyRuns(atoms, property) {
  const result = [];
  let run = [];
  let currentValue = void 0;
  for (const atom of atoms) {
    if (atom.type !== "first") {
      let value;
      if (property === "variant") {
        value = atom.style.variant;
        if (atom.style.variantStyle && atom.style.variantStyle !== "up") {
          value += "-" + atom.style.variantStyle;
        }
      } else if (property === "cssClass") {
        if (atom.type === "group") {
          value = atom.customClass;
        }
      } else {
        value = atom.style[property];
      }
      if (value === currentValue) {
        run.push(atom);
      } else {
        if (run.length > 0)
          result.push(run);
        run = [atom];
        currentValue = value;
      }
    }
  }
  if (run.length > 0)
    result.push(run);
  return result;
}

// src/core/box.ts
var BOX_TYPE = [
  "",
  "chem",
  "mord",
  "mbin",
  "mop",
  "mrel",
  "mopen",
  "mclose",
  "mpunct",
  "minner",
  "spacing",
  "first",
  "latex",
  "composition",
  "error",
  "placeholder",
  "supsub",
  "none",
  "mathfield"
];
function isBoxType(type) {
  return BOX_TYPE.includes(type);
}
var INTER_ATOM_SPACING = {
  mord: {mop: 3, mbin: 4, mrel: 5, minner: 3},
  mop: {mord: 3, mop: 3, rel: 5, minner: 3},
  mbin: {mord: 4, mop: 4, mopen: 4, minner: 4},
  mrel: {mord: 5, mop: 5, mopen: 5, minner: 5},
  mclose: {mop: 3, mbin: 4, mrel: 5, minner: 3},
  mpunct: {mord: 3, mop: 3, mrel: 3, mopen: 3, mpunct: 3, minner: 3},
  minner: {mord: 3, mop: 3, mbin: 4, mrel: 5, mopen: 3, mpunct: 3, minner: 3}
};
var INTER_ATOM_TIGHT_SPACING = {
  mord: {mop: 3},
  mop: {mord: 3, mop: 3},
  mclose: {mop: 3},
  minner: {mop: 3}
};
function toString(arg1, arg2) {
  if (typeof arg1 === "string") {
    return arg1;
  }
  if (typeof arg1 === "number") {
    console.assert(Number.isFinite(arg1));
    const numValue = Math.ceil(100 * arg1) / 100;
    if (numValue === 0)
      return "0";
    return numValue.toString() + (arg2 ?? "");
  }
  return "";
}
var Box = class {
  constructor(content, options) {
    if (typeof content === "number") {
      this.value = String.fromCodePoint(content);
    } else if (typeof content === "string") {
      this.value = content;
    } else if (isArray(content)) {
      this.children = content.filter((x3) => x3 !== null);
    } else if (content && content instanceof Box) {
      this.children = [content];
    }
    this.type = options?.type ?? "";
    this.isSelected = false;
    this.isTight = options?.isTight ?? false;
    this.newList = options?.newList ?? false;
    if (options?.properties) {
      for (const prop of Object.keys(options.properties)) {
        this.setStyle(prop, options.properties[prop]);
      }
    }
    if (options?.attributes)
      this.attributes = options.attributes;
    this.classes = options?.classes ?? "";
    let fontName = options?.fontFamily ?? "Main-Regular";
    if (options?.style && this.value) {
      fontName = Mode.applyStyle(options.mode ?? "math", this, options.style) ?? "Main-Regular";
    }
    this.height = 0;
    this.depth = 0;
    this.skew = 0;
    this.italic = 0;
    this.maxFontSize = 0;
    if (typeof content === "number") {
      const metrics = getCharacterMetrics(content, fontName);
      this.height = metrics.height;
      this.depth = metrics.depth;
      this.skew = metrics.skew;
      this.italic = metrics.italic;
      this.right = metrics.italic;
    } else if (this.value) {
      this.height = -Infinity;
      this.depth = -Infinity;
      this.skew = -Infinity;
      this.italic = -Infinity;
      for (let i3 = 0; i3 < this.value.length; i3++) {
        const metrics = getCharacterMetrics(this.value.codePointAt(i3), fontName ?? "Main-Regular");
        this.height = Math.max(this.height, metrics.height);
        this.depth = Math.max(this.depth, metrics.depth);
        this.skew = metrics.skew;
        this.italic = metrics.italic;
      }
      this.right = this.italic;
    } else if (this.type === "latex") {
      this.height = 0.8;
      this.depth = 0.2;
    } else if (this.children && this.children.length > 0) {
      if (this.children.length === 1) {
        const child = this.children[0];
        this.height = child.height;
        this.depth = child.depth;
        this.maxFontSize = child.maxFontSize;
        this.skew = child.skew;
        this.italic = child.italic;
      } else {
        let height = -Infinity;
        let depth = -Infinity;
        let maxFontSize = 0;
        for (const child of this.children) {
          if (child.height > height)
            height = child.height;
          if (child.depth > depth)
            depth = child.depth;
          maxFontSize = Math.max(maxFontSize, child.maxFontSize ?? 0);
        }
        this.height = height;
        this.depth = depth;
        this.maxFontSize = maxFontSize;
      }
    }
    if (options?.height !== void 0)
      this.height = options.height;
    if (options?.depth !== void 0)
      this.depth = options.depth;
    if (options?.maxFontSize !== void 0) {
      this.maxFontSize = options.maxFontSize;
    }
  }
  set atomID(id) {
    if (id === void 0)
      return;
    if (!this.attributes)
      this.attributes = {};
    this.attributes["data-atom-id"] = id;
  }
  selected(isSelected) {
    this.isSelected = isSelected;
    if (this.children) {
      for (const child of this.children) {
        child.selected(isSelected);
      }
    }
  }
  setStyle(prop, value, unit) {
    const v3 = toString(value, unit);
    if (v3.length > 0) {
      if (!this.cssProperties)
        this.cssProperties = {};
      this.cssProperties[prop] = v3;
    }
  }
  setTop(top) {
    if (Number.isFinite(top) && Math.abs(top) > 0.01) {
      if (!this.cssProperties)
        this.cssProperties = {};
      this.cssProperties.top = toString(top, "em");
      this.height -= top;
      this.depth += top;
    }
  }
  get left() {
    if (this.cssProperties?.["margin-left"]) {
      return Number.parseFloat(this.cssProperties["margin-left"]);
    }
    return 0;
  }
  set left(value) {
    if (!Number.isFinite(value))
      return;
    if (!this.cssProperties)
      this.cssProperties = {};
    if (value === 0) {
      delete this.cssProperties["margin-left"];
    } else {
      this.cssProperties["margin-left"] = toString(value, "em");
    }
  }
  set right(value) {
    if (!Number.isFinite(value))
      return;
    if (!this.cssProperties)
      this.cssProperties = {};
    if (value === 0) {
      delete this.cssProperties["margin-right"];
    } else {
      this.cssProperties["margin-right"] = toString(value, "em");
    }
  }
  set width(value) {
    if (!this.cssProperties)
      this.cssProperties = {};
    this.cssProperties.width = toString(value, "em");
  }
  wrap(context, options) {
    const parent = context.parent;
    if (!parent)
      return this;
    if (context.isPhantom) {
      this.setStyle("opacity", 0);
    }
    const newColor = context.computedColor === parent.computedColor ? void 0 : context.color;
    this.setStyle("color", newColor);
    const newSize = context.effectiveFontSize === parent.effectiveFontSize ? void 0 : context.effectiveFontSize;
    const newBackgroundColor = context.computedBackgroundColor === parent.computedBackgroundColor ? void 0 : context.backgroundColor;
    if (!newSize && !newBackgroundColor && !(options && (options.classes || options.type))) {
      return this;
    }
    let result;
    if (newBackgroundColor) {
      result = makeStruts(this, options);
      result.selected(this.isSelected);
      result.setStyle("background-color", newBackgroundColor);
      result.setStyle("display", "inline-block");
    } else {
      result = new Box(this, options);
    }
    const factor = context.scalingFactor;
    if (factor !== 1) {
      result.setStyle("font-size", factor * 100, "%");
      result.height *= factor;
      result.depth *= factor;
      result.italic *= factor;
      result.skew *= factor;
    }
    return result;
  }
  toMarkup() {
    let body = this.value ?? "";
    if (this.children) {
      for (const box of this.children) {
        body += box.toMarkup();
      }
    }
    const classes = this.classes.split(" ");
    classes.push({
      latex: "ML__latex",
      placeholder: "ML__placeholder",
      error: "ML__error"
    }[this.type] ?? "");
    if (this.caret === "latex") {
      classes.push("ML__latex-caret");
    }
    const classList = classes.length === 1 ? classes[0] : classes.filter((x3, e3, a3) => x3.length > 0 && a3.indexOf(x3) === e3).join(" ");
    let result = "";
    if (body.length > 0 && body !== "\u200B" || classList.length > 0 || this.cssId || this.htmlData || this.htmlStyle || this.attributes || this.cssProperties || this.svgBody || this.svgOverlay) {
      let props = "";
      if (this.cssId) {
        props += ` id=${this.cssId.replace(/ /g, "-")} `;
      }
      if (this.htmlData) {
        const entries = this.htmlData.split(",");
        for (const entry of entries) {
          const matched = entry.match(/([^=]+)=(.+$)/);
          if (matched) {
            const key = matched[1].trim().replace(/ /g, "-");
            if (key) {
              props += ` data-${key}=${matched[2]} `;
            }
          } else {
            const key = entry.trim().replace(/ /g, "-");
            if (key) {
              props += ` data-${key} `;
            }
          }
        }
      }
      if (this.htmlStyle) {
        const entries = this.htmlStyle.split(";");
        let styleString = "";
        for (const entry of entries) {
          const matched = entry.match(/([^=]+):(.+$)/);
          if (matched) {
            const key = matched[1].trim().replace(/ /g, "-");
            if (key) {
              styleString += `${key}:${matched[2]};`;
            }
          }
        }
        if (styleString) {
          props += ` style="${styleString}"`;
        }
      }
      if (this.attributes) {
        props += " " + Object.keys(this.attributes).map((x3) => `${x3}="${this.attributes[x3]}"`).join(" ");
      }
      if (classList.length > 0) {
        props += ` class="${classList}"`;
      }
      if (this.cssProperties) {
        const styleString = Object.keys(this.cssProperties).map((x3) => `${x3}:${this.cssProperties[x3]}`).join(";");
        if (styleString.length > 0) {
          props += ` style="${styleString}"`;
        }
      }
      let svgMarkup = "";
      if (this.svgBody) {
        svgMarkup = svgBodyToMarkup(this.svgBody);
      } else if (this.svgOverlay) {
        svgMarkup = '<span style="';
        svgMarkup += "display: inline-block;";
        svgMarkup += `height:${this.height + this.depth}em;`;
        svgMarkup += `vertical-align:${this.depth}em;`;
        svgMarkup += '">';
        svgMarkup += body;
        svgMarkup += "</span>";
        svgMarkup += '<svg style="position:absolute;overflow:overlay;';
        svgMarkup += `height:${this.height + this.depth}em;`;
        if (this.cssProperties?.padding) {
          svgMarkup += `top:${this.cssProperties.padding}em;`;
          svgMarkup += `left:${this.cssProperties.padding}em;`;
          svgMarkup += `width:calc(100% - 2 * ${this.cssProperties.padding}em );`;
        } else {
          svgMarkup += "top:0;left:0;width:100%;";
        }
        svgMarkup += "z-index:2;";
        svgMarkup += '"';
        if (this.svgStyle) {
          svgMarkup += ` style="${this.svgStyle}"`;
        }
        svgMarkup += `>${this.svgOverlay}</svg>`;
      }
      result = `<span${props}>${body}${svgMarkup}</span>`;
    }
    if (this.caret === "text") {
      result += '<span class="ML__text-caret"></span>';
    } else if (this.caret === "math") {
      result += '<span class="ML__caret"></span>';
    }
    return result;
  }
  tryCoalesceWith(box) {
    if (this.type !== box.type)
      return false;
    if (!/ML__text/.test(this.classes) && !["mord", "mbin", "mrel"].includes(this.type)) {
      return false;
    }
    if (this.svgBody || !this.value)
      return false;
    if (box.svgBody || !box.value)
      return false;
    const hasChildren = this.children && this.children.length > 0;
    const boxHasChildren = box.children && box.children.length > 0;
    if (hasChildren || boxHasChildren)
      return false;
    const thisStyleCount = this.cssProperties ? Object.keys(this.cssProperties).length : 0;
    const boxStyleCount = box.cssProperties ? Object.keys(box.cssProperties).length : 0;
    if (thisStyleCount !== boxStyleCount)
      return false;
    if (thisStyleCount > 0) {
      for (const prop of Object.keys(this.cssProperties)) {
        if (this.cssProperties[prop] !== box.cssProperties[prop]) {
          return false;
        }
      }
    }
    const classes = this.classes.trim().replace(/\s+/g, " ").split(" ");
    const boxClasses = box.classes.trim().replace(/\s+/g, " ").split(" ");
    if (classes.length !== boxClasses.length)
      return false;
    classes.sort();
    boxClasses.sort();
    for (const [i3, class_] of classes.entries()) {
      if (class_ === "vertical-separator")
        return false;
      if (class_ !== boxClasses[i3])
        return false;
    }
    this.value += box.value;
    this.height = Math.max(this.height, box.height);
    this.depth = Math.max(this.depth, box.depth);
    this.maxFontSize = Math.max(this.maxFontSize, box.maxFontSize);
    this.italic = box.italic;
    return true;
  }
};
function coalesceRecursive(boxes) {
  if (!boxes || boxes.length === 0)
    return [];
  boxes[0].children = coalesceRecursive(boxes[0].children);
  const result = [boxes[0]];
  for (let i3 = 1; i3 < boxes.length; i3++) {
    if (!result[result.length - 1].tryCoalesceWith(boxes[i3])) {
      boxes[i3].children = coalesceRecursive(boxes[i3].children);
      result.push(boxes[i3]);
    }
  }
  return result;
}
function coalesce(box) {
  if (box.children)
    box.children = coalesceRecursive(box.children);
  return box;
}
function adjustType(root) {
  forEachBox(root, (prevBox, box) => {
    if (box.type === "mbin" && (!prevBox || /first|none|mbin|mop|mrel|mopen|mpunct/.test(prevBox.type))) {
      box.type = "mord";
    }
    if (prevBox && prevBox.type === "mbin" && /mrel|mclose|mpunct|placeholder/.test(box.type)) {
      prevBox.type = "mord";
    }
  });
}
function applyInterAtomSpacing(root, scale) {
  forEachBox(root, (prevBox, box) => {
    const prevType = prevBox?.type ?? "none";
    const table = box.isTight ? INTER_ATOM_TIGHT_SPACING[prevType] ?? null : INTER_ATOM_SPACING[prevType] ?? null;
    const hskip = table ? table[box.type] ?? 0 : 0;
    if (hskip)
      box.left += scale * (hskip / 18);
  });
}
function forEachBoxRecursive(prevBox, box, f3) {
  if (box.newList)
    prevBox = null;
  const type = box.type;
  if (type === "first") {
    console.assert(box.newList === true);
    return null;
  }
  if (type === "spacing") {
    return prevBox;
  }
  f3(prevBox, box);
  if (box.children) {
    let childPrev = null;
    if (type === void 0 || type.length === 0) {
      childPrev = prevBox;
    }
    for (const child of box.children) {
      childPrev = forEachBoxRecursive(childPrev, child, f3);
    }
    if (type === void 0 || type.length === 0) {
      prevBox = childPrev;
    }
  }
  if (type !== "supsub" && type !== void 0 && type.length > 0) {
    prevBox = box;
  }
  return prevBox;
}
function forEachBox(box, f3) {
  if (!box)
    return;
  forEachBoxRecursive(null, box, f3);
}
function adjustInterAtomSpacing(root, scale = 1) {
  adjustType(root);
  applyInterAtomSpacing(root, scale);
  return root;
}
function makeStruts(content, options) {
  if (!content)
    return new Box(null, options);
  const topStrut = new Box(null, {classes: "ML__strut"});
  topStrut.setStyle("height", Math.max(0, content.height), "em");
  const struts = [topStrut];
  if (content.depth !== 0) {
    const bottomStrut = new Box(null, {classes: "ML__strut--bottom"});
    bottomStrut.setStyle("height", content.height + content.depth, "em");
    bottomStrut.setStyle("vertical-align", -content.depth, "em");
    struts.push(bottomStrut);
  }
  struts.push(content);
  return new Box(struts, options);
}
function addSVGOverlay(body, svgMarkup, svgStyle) {
  body.svgOverlay = svgMarkup;
  body.svgStyle = svgStyle;
  return body;
}
function makeSVGBox(svgBodyName) {
  const height = svgBodyHeight(svgBodyName) / 2;
  const box = new Box(null, {
    height: height + 0.166,
    depth: height - 0.166,
    maxFontSize: 0
  });
  box.svgBody = svgBodyName;
  return box;
}

// src/core/v-box.ts
function getVListChildrenAndDepth(params) {
  if ("individualShift" in params) {
    const oldChildren = params.individualShift;
    let prevChild = oldChildren[0];
    const children = [prevChild];
    const depth = -prevChild.shift - prevChild.box.depth;
    let currPos = depth;
    for (let i3 = 1; i3 < oldChildren.length; i3++) {
      const child = oldChildren[i3];
      const diff = -child.shift - currPos - child.box.depth;
      const size = diff - (prevChild.box.height + prevChild.box.depth);
      currPos = currPos + diff;
      children.push(size);
      children.push(child);
      prevChild = child;
    }
    return [children, depth];
  }
  if ("top" in params) {
    let bottom = params.top;
    for (const child of params.children) {
      bottom -= typeof child === "number" ? child : child.box.height + child.box.depth;
    }
    return [params.children, bottom];
  } else if ("bottom" in params) {
    return [params.children, -params.bottom];
  } else if ("firstBaseline" in params) {
    const firstChild = params.firstBaseline[0];
    if (typeof firstChild === "number") {
      throw new Error("First child must be an element.");
    }
    return [params.firstBaseline, -firstChild.box.depth];
  } else if ("shift" in params) {
    const firstChild = params.children[0];
    if (typeof firstChild === "number") {
      throw new Error("First child must be an element.");
    }
    return [params.children, -firstChild.box.depth - params.shift];
  }
  return [null, 0];
}
function makeRows(params) {
  const [children, depth] = getVListChildrenAndDepth(params);
  if (!children)
    return [[], 0, 0];
  let pstrutSize = 0;
  for (const child of children) {
    if (typeof child !== "number") {
      const box = child.box;
      pstrutSize = Math.max(pstrutSize, box.maxFontSize, box.height);
    }
  }
  pstrutSize += 2;
  const pstrut = new Box(null, {classes: "pstrut"});
  pstrut.setStyle("height", pstrutSize, "em");
  const realChildren = [];
  let minPos = depth;
  let maxPos = depth;
  let currPos = depth;
  for (const child of children) {
    if (typeof child === "number") {
      currPos += child;
    } else {
      const box = child.box;
      const classes = child.classes ?? [];
      const childWrap = new Box([pstrut, box], {
        classes: classes.join(" "),
        style: child.style
      });
      childWrap.setStyle("top", -pstrutSize - currPos - box.depth, "em");
      if (child.marginLeft) {
        childWrap.setStyle("margin-left", child.marginLeft, "em");
      }
      if (child.marginRight) {
        childWrap.setStyle("margin-right", child.marginRight, "em");
      }
      realChildren.push(childWrap);
      currPos += box.height + box.depth;
    }
    minPos = Math.min(minPos, currPos);
    maxPos = Math.max(maxPos, currPos);
  }
  const vlist = new Box(realChildren, {classes: "vlist"});
  vlist.setStyle("height", maxPos, "em");
  let rows;
  if (minPos < 0) {
    const depthStrut = new Box(new Box(null), {classes: "vlist"});
    depthStrut.setStyle("height", -minPos, "em");
    const topStrut = new Box(8203, {
      classes: "vlist-s",
      maxFontSize: 0,
      height: 0,
      depth: 0
    });
    rows = [
      new Box([vlist, topStrut], {classes: "vlist-r"}),
      new Box(depthStrut, {classes: "vlist-r"})
    ];
  } else {
    rows = [new Box(vlist, {classes: "vlist-r"})];
  }
  return [rows, maxPos, -minPos];
}
var VBox = class extends Box {
  constructor(content, options) {
    const [rows, height, depth] = makeRows(content);
    super(rows.length === 1 ? rows[0] : rows, {
      classes: (options?.classes ?? "") + " vlist-t" + (rows.length === 2 ? " vlist-t2" : ""),
      height,
      depth,
      type: options?.type
    });
  }
};
function makeLimitsStack(context, options) {
  const metrics = context.metrics;
  const base = new Box(options.base);
  const baseShift = options.baseShift ?? 0;
  const slant = options.slant ?? 0;
  let aboveShift = 0;
  let belowShift = 0;
  if (options.above) {
    aboveShift = options.aboveShift ?? Math.max(metrics.bigOpSpacing1, metrics.bigOpSpacing3 - options.above.depth);
  }
  if (options.below) {
    belowShift = options.belowShift ?? Math.max(metrics.bigOpSpacing2, metrics.bigOpSpacing4 - options.below.height);
  }
  let result = null;
  if (options.below && options.above) {
    const bottom = metrics.bigOpSpacing5 + options.below.height + options.below.depth + belowShift + base.depth + baseShift;
    result = new VBox({
      bottom,
      children: [
        metrics.bigOpSpacing5,
        {
          box: options.below,
          marginLeft: -slant,
          classes: ["ML__center"]
        },
        belowShift,
        {box: base, classes: ["ML__center"]},
        aboveShift,
        {
          box: options.above,
          marginLeft: slant,
          classes: ["ML__center"]
        },
        metrics.bigOpSpacing5
      ]
    }).wrap(context);
  } else if (options.below && !options.above) {
    result = new VBox({
      top: base.height - baseShift,
      children: [
        metrics.bigOpSpacing5,
        {
          box: options.below,
          marginLeft: -slant,
          classes: ["ML__center"]
        },
        belowShift,
        {box: base, classes: ["ML__center"]}
      ]
    }).wrap(context);
  } else if (!options.below && options.above) {
    const bottom = base.depth + baseShift;
    result = new VBox({
      bottom,
      children: [
        {box: base, classes: ["ML__center"]},
        aboveShift,
        {
          box: options.above,
          marginLeft: slant,
          classes: ["ML__center"]
        },
        metrics.bigOpSpacing5
      ]
    }).wrap(context);
  } else {
    const bottom = base.depth + baseShift;
    result = new VBox({
      bottom,
      children: [{box: base}, metrics.bigOpSpacing5]
    }).wrap(context);
  }
  console.assert(options.type !== void 0);
  return new Box(result, {type: options.type ?? "mop"});
}

// src/core/grapheme-splitter.ts
function stringToCodepoints(string) {
  const result = [];
  for (let i3 = 0; i3 < string.length; i3++) {
    let code = string.charCodeAt(i3);
    if (code === 13 && string.charCodeAt(i3 + 1) === 10) {
      code = 10;
      i3++;
    }
    if (code === 13 || code === 12)
      code = 10;
    if (code === 0)
      code = 65533;
    if (code >= 55296 && code <= 56319) {
      const nextCode = string.charCodeAt(i3 + 1);
      if (nextCode >= 56320 && nextCode <= 57343) {
        const lead = code - 55296;
        const trail = nextCode - 56320;
        code = 2 ** 16 + lead * 2 ** 10 + trail;
        i3++;
      }
    }
    result.push(code);
  }
  return result;
}
var ZWJ = 8205;
var EMOJI_COMBINATOR = [
  [ZWJ, 1],
  [65038, 2],
  [127995, 5],
  [129456, 4],
  [917536, 96]
];
var emojiCombinator;
var REGIONAL_INDICATOR = [127462, 127487];
function isEmojiCombinator(code) {
  if (emojiCombinator === void 0) {
    emojiCombinator = {};
    for (const x3 of EMOJI_COMBINATOR) {
      for (let i3 = x3[0]; i3 <= x3[0] + x3[1] - 1; i3++) {
        emojiCombinator[i3] = true;
      }
    }
  }
  return emojiCombinator[code] ?? false;
}
function isRegionalIndicator(code) {
  return code >= REGIONAL_INDICATOR[0] && code <= REGIONAL_INDICATOR[1];
}
function splitGraphemes(string) {
  if (/^[\u0020-\u00FF]*$/.test(string))
    return string;
  const result = [];
  const codePoints = stringToCodepoints(string);
  let index = 0;
  while (index < codePoints.length) {
    const code = codePoints[index++];
    const next = codePoints[index];
    if (next === ZWJ) {
      const baseIndex = index - 1;
      index += 2;
      while (codePoints[index] === ZWJ) {
        index += 2;
      }
      result.push(String.fromCodePoint(...codePoints.slice(baseIndex, index - baseIndex + 1)));
    } else if (isEmojiCombinator(next)) {
      const baseIndex = index - 1;
      while (isEmojiCombinator(codePoints[index])) {
        index += codePoints[index] === ZWJ ? 2 : 1;
      }
      result.push(String.fromCodePoint(...codePoints.slice(baseIndex, 2 * index - baseIndex - 1)));
    } else if (isRegionalIndicator(code)) {
      index += 1;
      result.push(String.fromCodePoint(...codePoints.slice(index - 2, 2)));
    } else {
      result.push(String.fromCodePoint(code));
    }
  }
  return result;
}

// src/core/tokenizer.ts
var Tokenizer = class {
  constructor(s3) {
    this.s = splitGraphemes(s3);
    this.pos = 0;
    this.obeyspaces = false;
  }
  end() {
    return this.pos >= this.s.length;
  }
  get() {
    return this.pos < this.s.length ? this.s[this.pos++] : "";
  }
  peek() {
    return this.s[this.pos];
  }
  match(regEx) {
    const execResult = typeof this.s === "string" ? regEx.exec(this.s.slice(this.pos)) : regEx.exec(this.s.slice(this.pos).join(""));
    if (execResult?.[0]) {
      this.pos += execResult[0].length;
      return execResult[0];
    }
    return "";
  }
  next() {
    if (this.end())
      return null;
    if (!this.obeyspaces && this.match(/^[ \f\n\r\t\v\u00A0\u2028\u2029]+/)) {
      return "<space>";
    }
    if (this.obeyspaces && this.match(/^[ \f\n\r\t\v\u00A0\u2028\u2029]/)) {
      return "<space>";
    }
    const next = this.get();
    if (next === "\\") {
      if (!this.end()) {
        let command = this.match(/^[a-zA-Z*]+/);
        if (command) {
          this.match(/^[ \f\n\r\t\v\u00A0\u2028\u2029]*/);
        } else {
          command = this.get();
          if (command === " ") {
            return "<space>";
          }
        }
        return "\\" + command;
      }
    } else if (next === "{") {
      return "<{>";
    } else if (next === "}") {
      return "<}>";
    } else if (next === "^") {
      if (this.peek() === "^") {
        this.get();
        const hex = this.match(/^(\^(\^(\^(\^[\da-f])?[\da-f])?[\da-f])?[\da-f])?[\da-f]{2}/);
        if (hex) {
          return String.fromCodePoint(Number.parseInt(hex.slice(hex.lastIndexOf("^") + 1), 16));
        }
      }
      return next;
    } else if (next === "#") {
      if (!this.end()) {
        let isParameter = false;
        if (/[\d?@]/.test(this.peek())) {
          isParameter = true;
          if (this.pos + 1 < this.s.length) {
            const after = this.s[this.pos + 1];
            isParameter = /[^\dA-Za-z]/.test(after);
          }
        }
        if (isParameter) {
          return "#" + this.get();
        }
        return "#";
      }
    } else if (next === "$") {
      if (this.peek() === "$") {
        this.get();
        return "<$$>";
      }
      return "<$>";
    }
    return next;
  }
};
function expand(lex, args) {
  let result = [];
  let token = lex.next();
  if (token) {
    if (token === "\\relax") {
    } else if (token === "\\noexpand") {
      token = lex.next();
      if (token) {
        result.push(token);
      }
    } else if (token === "\\obeyspaces") {
      lex.obeyspaces = true;
    } else if (token === "\\space" || token === "~") {
      result.push("<space>");
    } else if (token === "\\bgroup") {
      result.push("<{>");
    } else if (token === "\\egroup") {
      result.push("<}>");
    } else if (token === "\\string") {
      token = lex.next();
      if (token) {
        if (token.startsWith("\\")) {
          for (const x3 of token) {
            result.push(x3 === "\\" ? "\\backslash" : x3);
          }
        } else if (token === "<{>") {
          result.push("\\{");
        } else if (token === "<space>") {
          result.push("~");
        } else if (token === "<}>") {
          result.push("\\}");
        }
      }
    } else if (token === "\\csname") {
      while (lex.peek() === "<space>") {
        lex.next();
      }
      let command = "";
      let done = false;
      let tokens = [];
      do {
        if (tokens.length === 0) {
          if (/^#[\d?@]$/.test(lex.peek())) {
            const parameter = lex.get().slice(1);
            tokens = tokenize(args?.(parameter) ?? args?.("?") ?? "\\placeholder{}", args);
            token = tokens[0];
          } else {
            token = lex.next();
            tokens = token ? [token] : [];
          }
        }
        done = tokens.length === 0;
        if (!done && token === "\\endcsname") {
          done = true;
          tokens.shift();
        }
        if (!done) {
          done = token === "<$>" || token === "<$$>" || token === "<{>" || token === "<}>" || typeof token === "string" && token.length > 1 && token.startsWith("\\");
        }
        if (!done) {
          command += tokens.shift();
        }
      } while (!done);
      if (command) {
        result.push("\\" + command);
      }
      result = result.concat(tokens);
    } else if (token === "\\endcsname") {
    } else if (token.length > 1 && token.startsWith("#")) {
      const parameter = token.slice(1);
      result = result.concat(tokenize(args?.(parameter) ?? args?.("?") ?? "\\placeholder{}", args));
    } else {
      result.push(token);
    }
  }
  return result;
}
function tokenize(s3, args = null) {
  const lines = s3.toString().split(/\r?\n/);
  let stream = "";
  let sep = "";
  for (const line of lines) {
    stream += sep;
    sep = " ";
    const m3 = line.match(/((?:\\%)|[^%])*/);
    if (m3 !== null)
      stream += m3[0];
  }
  const tokenizer = new Tokenizer(stream);
  let result = [];
  do {
    result = result.concat(expand(tokenizer, args));
  } while (!tokenizer.end());
  return result;
}
function joinLatex(segments) {
  let sep = "";
  let result = "";
  for (const segment of segments) {
    if (segment) {
      if (/[a-zA-Z*]/.test(segment[0])) {
        result += sep;
      }
      sep = /\\[a-zA-Z]+\*?$/.test(segment) ? " " : "";
      result += segment;
    }
  }
  return result;
}
function tokensToString(tokens) {
  const result = joinLatex(tokens.map((token) => {
    return {
      "<space>": " ",
      "<$$>": "$$",
      "<$>": "$",
      "<{>": "{",
      "<}>": "}"
    }[token] ?? token;
  }));
  return result;
}

// src/common/capabilities.ts
function isBrowser() {
  return "window" in globalThis && "document" in globalThis;
}
function throwIfNotInBrowser() {
  if (!isBrowser()) {
    throw new Error("<math-field> is an interactive component that needs to run in a browser environment\nIf you are using nextjs, see https://nextjs.org/docs/advanced-features/dynamic-import#with-no-ssr");
  }
}
function isTouchCapable() {
  return (isBrowser() && window.matchMedia?.("(any-pointer: coarse)").matches) ?? false;
}
function canVibrate() {
  return isBrowser() && typeof navigator.vibrate === "function";
}
function osPlatform() {
  if (!isBrowser()) {
    return "other";
  }
  const platform2 = navigator.platform;
  if (/^(mac)/i.test(platform2)) {
    if (navigator.maxTouchPoints === 5)
      return "ios";
    return "macos";
  }
  if (/^(win)/i.test(platform2))
    return "windows";
  if (/(android)/i.test(navigator.userAgent))
    return "android";
  if (/(iphone|ipod|ipad)/i.test(navigator.userAgent))
    return "ios";
  if (/\bcros\b/i.test(navigator.userAgent))
    return "chromeos";
  return "other";
}
function supportRegexPropertyEscape() {
  if (!isBrowser())
    return true;
  if (/firefox/i.test(navigator.userAgent)) {
    const m3 = navigator.userAgent.match(/firefox\/(\d+)/i);
    if (!m3)
      return false;
    const version2 = parseInt(m3[1]);
    return version2 >= 78;
  }
  if (/trident/i.test(navigator.userAgent))
    return false;
  if (/edge/i.test(navigator.userAgent)) {
    const m3 = navigator.userAgent.match(/edg\/(\d+)/i);
    if (!m3)
      return false;
    const version2 = parseInt(m3[1]);
    return version2 >= 79;
  }
  return true;
}
function supportLocalFontEnumeration() {
  return isBrowser() && !/firefox|safari/i.test(navigator.userAgent);
}

// src/core-definitions/definitions-utils.ts
var MATH_SYMBOLS = {};
var REVERSE_MATH_SYMBOLS = {
  60: "<",
  62: ">",
  111: "o",
  38: "\\&",
  123: "\\lbrace",
  125: "\\rbrace",
  91: "\\lbrack",
  93: "\\rbrack",
  58: "\\colon",
  160: "~",
  172: "\\neg",
  183: "\\cdot",
  188: "\\frac{1}{4}",
  189: "\\frac{1}{2}",
  190: "\\frac{3}{4}",
  8304: "^{0}",
  8305: "^{i}",
  185: "^{1}",
  178: "^{2}",
  179: "^{3}",
  8224: "\\dagger",
  8225: "\\ddagger",
  8230: "\\ldots",
  8308: "^{4}",
  8309: "^{5}",
  8310: "^{6}",
  8311: "^{7}",
  8312: "^{8}",
  8313: "^{9}",
  8314: "^{+}",
  8315: "^{-}",
  8316: "^{=}",
  8319: "^{n}",
  8320: "_{0}",
  8321: "_{1}",
  8322: "_{2}",
  8323: "_{3}",
  8324: "_{4}",
  8325: "_{5}",
  8326: "_{6}",
  8327: "_{7}",
  8328: "_{8}",
  8329: "_{9}",
  8330: "_{+}",
  8331: "_{-}",
  8332: "_{=}",
  8336: "_{a}",
  8337: "_{e}",
  8338: "_{o}",
  8339: "_{x}",
  8242: "\\prime",
  39: "\\prime",
  8592: "\\gets",
  8594: "\\to",
  9651: "\\triangle",
  9661: "\\triangledown",
  8715: "\\owns",
  8727: "\\ast",
  8739: "\\vert",
  8741: "\\Vert",
  8743: "\\land",
  8744: "\\lor",
  8901: "\\cdot",
  8904: "\\bowtie",
  8800: "\\ne",
  8804: "\\le",
  8805: "\\ge",
  8869: "\\bot",
  10231: "\\biconditional",
  10232: "\\impliedby",
  10233: "\\implies",
  10234: "\\iff",
  8450: "\\C",
  8469: "\\N",
  8473: "\\P",
  8474: "\\Q",
  8477: "\\R",
  8484: "\\Z"
};
var LEGACY_COMMANDS = {};
var ENVIRONMENTS = {};
var TEXVC_MACROS = {
  darr: "\\downarrow",
  dArr: "\\Downarrow",
  Darr: "\\Downarrow",
  lang: "\\langle",
  rang: "\\rangle",
  uarr: "\\uparrow",
  uArr: "\\Uparrow",
  Uarr: "\\Uparrow",
  N: "\\mathbb{N}",
  R: "\\mathbb{R}",
  Z: "\\mathbb{Z}",
  alef: "\\aleph",
  alefsym: "\\aleph",
  Alpha: "\\mathrm{A}",
  Beta: "\\mathrm{B}",
  bull: "\\bullet",
  Chi: "\\mathrm{X}",
  clubs: "\\clubsuit",
  cnums: "\\mathbb{C}",
  Complex: "\\mathbb{C}",
  Dagger: "\\ddagger",
  diamonds: "\\diamondsuit",
  empty: "\\emptyset",
  Epsilon: "\\mathrm{E}",
  Eta: "\\mathrm{H}",
  exist: "\\exists",
  harr: "\\leftrightarrow",
  hArr: "\\Leftrightarrow",
  Harr: "\\Leftrightarrow",
  hearts: "\\heartsuit",
  image: "\\Im",
  infin: "\\infty",
  Iota: "\\mathrm{I}",
  isin: "\\in",
  Kappa: "\\mathrm{K}",
  larr: "\\leftarrow",
  lArr: "\\Leftarrow",
  Larr: "\\Leftarrow",
  lrarr: "\\leftrightarrow",
  lrArr: "\\Leftrightarrow",
  Lrarr: "\\Leftrightarrow",
  Mu: "\\mathrm{M}",
  natnums: "\\mathbb{N}",
  Nu: "\\mathrm{N}",
  Omicron: "\\mathrm{O}",
  plusmn: "\\pm",
  rarr: "\\rightarrow",
  rArr: "\\Rightarrow",
  Rarr: "\\Rightarrow",
  real: "\\Re",
  reals: "\\mathbb{R}",
  Reals: "\\mathbb{R}",
  Rho: "\\mathrm{P}",
  sdot: "\\cdot",
  sect: "\\S",
  spades: "\\spadesuit",
  sub: "\\subset",
  sube: "\\subseteq",
  supe: "\\supseteq",
  Tau: "\\mathrm{T}",
  thetasym: "\\vartheta",
  weierp: "\\wp",
  Zeta: "\\mathrm{Z}"
};
var AMSMATH_MACROS = {
  varGamma: "\\mathit{\\Gamma}",
  varDelta: "\\mathit{\\Delta}",
  varTheta: "\\mathit{\\Theta}",
  varLambda: "\\mathit{\\Lambda}",
  varXi: "\\mathit{\\Xi}",
  varPi: "\\mathit{\\Pi}",
  varSigma: "\\mathit{\\Sigma}",
  varUpsilon: "\\mathit{\\Upsilon}",
  varPhi: "\\mathit{\\Phi}",
  varPsi: "\\mathit{\\Psi}",
  varOmega: "\\mathit{\\Omega}",
  pmod: {
    def: "\\quad(\\operatorname{mod}\\ #1)",
    args: 1,
    expand: false,
    captureSelection: false
  },
  mod: {
    def: "\\quad\\operatorname{mod}\\,\\,#1",
    args: 1,
    expand: false,
    captureSelection: false
  },
  bmod: {
    def: "\\;\\mathbin{\\operatorname{mod }}",
    expand: false
  }
};
var BRAKET_MACROS = {
  bra: "\\mathinner{\\langle{#1}|}",
  ket: "\\mathinner{|{#1}\\rangle}",
  braket: "\\mathinner{\\langle{#1}\\rangle}",
  set: "\\mathinner{\\lbrace #1 \\rbrace}",
  Bra: "\\left\\langle #1\\right|",
  Ket: "\\left|#1\\right\\rangle",
  Braket: "\\left\\langle{#1}\\right\\rangle",
  Set: "\\left\\lbrace #1 \\right\\rbrace"
};
var DEFAULT_MACROS = {
  "iff": "\\;\u27FA\\;",
  "nicefrac": "^{#1}\\!\\!/\\!_{#2}",
  "rd": "\\mathrm{d}",
  "rD": "\\mathrm{D}",
  "doubleStruckCapitalN": "\\mathbb{N}",
  "doubleStruckCapitalR": "\\mathbb{R}",
  "doubleStruckCapitalQ": "\\mathbb{Q}",
  "doubleStruckCapitalZ": "\\mathbb{Z}",
  "doubleStruckCapitalP": "\\mathbb{P}",
  "scriptCapitalE": "\\mathscr{E}",
  "scriptCapitalH": "\\mathscr{H}",
  "scriptCapitalL": "\\mathscr{L}",
  "gothicCapitalC": "\\mathfrak{C}",
  "gothicCapitalH": "\\mathfrak{H}",
  "gothicCapitalI": "\\mathfrak{I}",
  "gothicCapitalR": "\\mathfrak{R}",
  "imaginaryI": "\\mathrm{i}",
  "imaginaryJ": "\\mathrm{j}",
  "exponentialE": "\\mathrm{e}",
  "differentialD": "\\mathrm{d}",
  "capitalDifferentialD": "\\mathrm{D}",
  "braket.sty": {package: BRAKET_MACROS},
  "amsmath.sty": {
    package: AMSMATH_MACROS,
    expand: false
  },
  "texvc.sty": {
    package: TEXVC_MACROS,
    expand: false
  }
};
var TEXT_SYMBOLS = {
  " ": 32,
  "\\#": 35,
  "\\&": 38,
  "\\$": 36,
  "\\%": 37,
  "\\_": 95,
  "\\euro": 8364,
  "\\maltese": 10016,
  "\\{": 123,
  "\\}": 125,
  "\\nobreakspace": 160,
  "\\ldots": 8230,
  "\\textellipsis": 8230,
  "\\backslash": 92,
  "`": 8216,
  "'": 8217,
  "``": 8220,
  "''": 8221,
  "\\degree": 176,
  "\\textasciicircum": 94,
  "\\textasciitilde": 126,
  "\\textasteriskcentered": 42,
  "\\textbackslash": 92,
  "\\textbraceleft": 123,
  "\\textbraceright": 125,
  "\\textbullet": 8226,
  "\\textdollar": 36,
  "\\textsterling": 163,
  "\\textdagger": 8224,
  "\\textdaggerdbl": 8225,
  "\u2013": 8211,
  "\u2014": 8212,
  "\u2018": 8216,
  "\u2019": 8217,
  "\u201C": 8220,
  "\u201D": 8221,
  '"': 8221,
  "\\ss": 223,
  "\\ae": 230,
  "\\oe": 339,
  "\\AE": 198,
  "\\OE": 338,
  "\\O": 216,
  "\\i": 305,
  "\\j": 567,
  "\\aa": 229,
  "\\AA": 197
};
var COMMAND_MODE_CHARACTERS = /[\w!@*()-=+{}[\]\\';:?/.,~<>`|$%#&^" ]/;
var LETTER = supportRegexPropertyEscape() ? new RegExp("\\p{Letter}", "u") : /[a-zA-Z]/;
var LETTER_AND_DIGITS = supportRegexPropertyEscape() ? new RegExp("[0-9\\p{Letter}]", "u") : /[\da-zA-Z]/;
function newSymbol(symbol, value, type = "mord", variant) {
  if (value === void 0)
    return;
  MATH_SYMBOLS[symbol] = {
    type,
    variant,
    codepoint: value
  };
  if (!REVERSE_MATH_SYMBOLS[value] && !variant) {
    REVERSE_MATH_SYMBOLS[value] = symbol;
  }
  if (!TEXT_SYMBOLS[symbol]) {
    TEXT_SYMBOLS[symbol] = value;
  }
}
function newSymbols(value, inType, inVariant) {
  if (typeof value === "string") {
    for (let i3 = 0; i3 < value.length; i3++) {
      const ch = value.charAt(i3);
      newSymbol(ch, ch.codePointAt(0));
    }
    return;
  }
  for (const [symbol, val, type, variant] of value) {
    newSymbol(symbol, val, type ?? inType, variant ?? inVariant);
  }
}
function newSymbolRange(from, to) {
  for (let i3 = from; i3 <= to; i3++) {
    newSymbol(String.fromCodePoint(i3), i3);
  }
}
function charToLatex(parseMode, codepoint) {
  if (codepoint === void 0)
    return "";
  if (parseMode === "math" && REVERSE_MATH_SYMBOLS[codepoint]) {
    return REVERSE_MATH_SYMBOLS[codepoint];
  }
  if (parseMode === "text") {
    let textSymbol = Object.keys(TEXT_SYMBOLS).find((x3) => TEXT_SYMBOLS[x3] === codepoint);
    if (!textSymbol) {
      const hex = codepoint.toString(16);
      textSymbol = "^".repeat(hex.length) + hex;
    }
    return textSymbol;
  }
  return String.fromCodePoint(codepoint);
}
var MATH_LETTER_EXCEPTIONS = {
  119893: 8462,
  119965: 8492,
  119968: 8496,
  119969: 8497,
  119971: 8459,
  119972: 8464,
  119975: 8466,
  119976: 8499,
  119981: 8475,
  119994: 8495,
  119996: 8458,
  120004: 8500,
  120070: 8493,
  120075: 8460,
  120076: 8465,
  120085: 8476,
  120093: 8488,
  120122: 8450,
  120127: 8461,
  120133: 8469,
  120135: 8473,
  120136: 8474,
  120137: 8477,
  120145: 8484
};
var MATH_UNICODE_BLOCKS = [
  {start: 119808, len: 26, offset: 65, style: "bold"},
  {start: 119834, len: 26, offset: 97, style: "bold"},
  {start: 119860, len: 26, offset: 65, style: "italic"},
  {start: 119886, len: 26, offset: 97, style: "italic"},
  {start: 119912, len: 26, offset: 65, style: "bolditalic"},
  {start: 119938, len: 26, offset: 97, style: "bolditalic"},
  {start: 119964, len: 26, offset: 65, variant: "script"},
  {start: 119990, len: 26, offset: 97, variant: "script"},
  {start: 120016, len: 26, offset: 65, variant: "script", style: "bold"},
  {start: 120042, len: 26, offset: 97, variant: "script", style: "bold"},
  {start: 120068, len: 26, offset: 65, variant: "fraktur"},
  {start: 120094, len: 26, offset: 97, variant: "fraktur"},
  {start: 120172, len: 26, offset: 65, variant: "fraktur", style: "bold"},
  {start: 120198, len: 26, offset: 97, variant: "fraktur", style: "bold"},
  {start: 120120, len: 26, offset: 65, variant: "double-struck"},
  {start: 120146, len: 26, offset: 97, variant: "double-struck"},
  {start: 120224, len: 26, offset: 65, variant: "sans-serif"},
  {start: 120250, len: 26, offset: 97, variant: "sans-serif"},
  {
    start: 120276,
    len: 26,
    offset: 65,
    variant: "sans-serif",
    style: "bold"
  },
  {
    start: 120302,
    len: 26,
    offset: 97,
    variant: "sans-serif",
    style: "bold"
  },
  {
    start: 120328,
    len: 26,
    offset: 65,
    variant: "sans-serif",
    style: "italic"
  },
  {
    start: 120354,
    len: 26,
    offset: 97,
    variant: "sans-serif",
    style: "italic"
  },
  {
    start: 120380,
    len: 26,
    offset: 65,
    variant: "sans-serif",
    style: "bolditalic"
  },
  {
    start: 120406,
    len: 26,
    offset: 97,
    variant: "sans-serif",
    style: "bolditalic"
  },
  {start: 120432, len: 26, offset: 65, variant: "monospace"},
  {start: 120458, len: 26, offset: 97, variant: "monospace"},
  {start: 120488, len: 25, offset: 913, style: "bold"},
  {start: 120514, len: 25, offset: 945, style: "bold"},
  {start: 120546, len: 25, offset: 913, style: "italic"},
  {start: 120572, len: 25, offset: 945, style: "italic"},
  {start: 120604, len: 25, offset: 913, style: "bolditalic"},
  {start: 120630, len: 25, offset: 945, style: "bolditalic"},
  {
    start: 120662,
    len: 25,
    offset: 913,
    variant: "sans-serif",
    style: "bold"
  },
  {
    start: 120688,
    len: 25,
    offset: 945,
    variant: "sans-serif",
    style: "bold"
  },
  {
    start: 120720,
    len: 25,
    offset: 913,
    variant: "sans-serif",
    style: "bolditalic"
  },
  {
    start: 120746,
    len: 25,
    offset: 945,
    variant: "sans-serif",
    style: "bolditalic"
  },
  {start: 120782, len: 10, offset: 48, variant: "main", style: "bold"},
  {start: 120792, len: 10, offset: 48, variant: "double-struck"},
  {start: 120803, len: 10, offset: 48, variant: "sans-serif"},
  {
    start: 120812,
    len: 10,
    offset: 48,
    variant: "sans-serif",
    style: "bold"
  },
  {start: 120822, len: 10, offset: 48, variant: "monospace"}
];
function unicodeToMathVariant(codepoint) {
  if ((codepoint < 119808 || codepoint > 120831) && (codepoint < 8448 || codepoint > 8527)) {
    return {char: String.fromCodePoint(codepoint)};
  }
  for (const c3 in MATH_LETTER_EXCEPTIONS) {
    if (MATH_LETTER_EXCEPTIONS[c3] === codepoint) {
      codepoint = c3.codePointAt(0) ?? 0;
      break;
    }
  }
  for (const MATH_UNICODE_BLOCK of MATH_UNICODE_BLOCKS) {
    if (codepoint >= MATH_UNICODE_BLOCK.start && codepoint < MATH_UNICODE_BLOCK.start + MATH_UNICODE_BLOCK.len) {
      return {
        char: String.fromCodePoint(codepoint - MATH_UNICODE_BLOCK.start + MATH_UNICODE_BLOCK.offset),
        variant: MATH_UNICODE_BLOCK.variant,
        style: MATH_UNICODE_BLOCK.style
      };
    }
  }
  return {char: String.fromCodePoint(codepoint)};
}
function mathVariantToUnicode(char, variant, style) {
  if (!/[A-Za-z\d]/.test(char))
    return char;
  if (!variant && !style)
    return char;
  const codepoint = char.codePointAt(0);
  if (codepoint === void 0)
    return char;
  for (const MATH_UNICODE_BLOCK of MATH_UNICODE_BLOCKS) {
    if (!variant || MATH_UNICODE_BLOCK.variant === variant) {
      if (!style || MATH_UNICODE_BLOCK.style === style) {
        if (codepoint >= MATH_UNICODE_BLOCK.offset && codepoint < MATH_UNICODE_BLOCK.offset + MATH_UNICODE_BLOCK.len) {
          const result = MATH_UNICODE_BLOCK.start + codepoint - MATH_UNICODE_BLOCK.offset;
          return String.fromCodePoint(MATH_LETTER_EXCEPTIONS[result] || result);
        }
      }
    }
  }
  return char;
}
function unicodeCharToLatex(parseMode, char) {
  if (parseMode === "text") {
    return charToLatex(parseMode, char.codePointAt(0)) ?? char;
  }
  let result;
  result = charToLatex(parseMode, char.codePointAt(0));
  if (result)
    return result;
  const cp = char.codePointAt(0);
  const v3 = unicodeToMathVariant(cp);
  if (!v3.style && !v3.variant)
    return "";
  result = v3.char;
  if (v3.variant) {
    result = "\\" + v3.variant + "{" + result + "}";
  }
  if (v3.style === "bold") {
    result = "\\mathbf{" + result + "}";
  } else if (v3.style === "italic") {
    result = "\\mathit{" + result + "}";
  } else if (v3.style === "bolditalic") {
    result = "\\mathbfit{" + result + "}";
  }
  return "\\mathord{" + result + "}";
}
function getEnvironmentDefinition(name) {
  return ENVIRONMENTS[name] ?? null;
}
function getInfo(symbol, parseMode, macros) {
  if (!symbol || symbol.length === 0)
    return null;
  let info = null;
  if (symbol.startsWith("\\")) {
    info = LEGACY_COMMANDS[symbol] ?? null;
    if (info) {
      return info;
    }
    if (parseMode === "math") {
      info = MATH_SYMBOLS[symbol];
    } else if (TEXT_SYMBOLS[symbol]) {
      info = {type: "mord", codepoint: TEXT_SYMBOLS[symbol]};
    }
    if (!info) {
      const command = symbol.slice(1);
      if (macros?.[command]) {
        let argCount = macros[command].args ?? 0;
        info = {
          type: "group",
          params: [],
          infix: false
        };
        while (argCount >= 1) {
          info.params.push({
            isOptional: false,
            type: "math"
          });
          argCount -= 1;
        }
      }
    }
  } else if (parseMode === "math") {
    info = MATH_SYMBOLS[symbol];
  } else if (TEXT_SYMBOLS[symbol]) {
    info = {codepoint: TEXT_SYMBOLS[symbol], type: "mord"};
  } else if (parseMode === "text") {
    info = {codepoint: symbol.codePointAt(0), type: "mord"};
  }
  if (info && info.type === "mord" && (info.codepoint === 102 || info.codepoint === 103 || info.codepoint === 104)) {
    info.isFunction = true;
  }
  return info;
}
function suggest(s3) {
  if (s3 === "\\")
    return [];
  const result = [];
  for (const p3 in LEGACY_COMMANDS) {
    if (p3.startsWith(s3) && !LEGACY_COMMANDS[p3].infix) {
      result.push({match: p3, frequency: LEGACY_COMMANDS[p3].frequency ?? 0});
    }
  }
  for (const p3 in MATH_SYMBOLS) {
    if (p3.startsWith(s3)) {
      result.push({match: p3, frequency: MATH_SYMBOLS[p3].frequency ?? 0});
    }
  }
  result.sort((a3, b3) => {
    if (a3.frequency === b3.frequency) {
      if (a3.match.length === b3.match.length) {
        return a3.match.localeCompare(b3.match);
      }
      return a3.match.length - b3.match.length;
    }
    return (b3.frequency ?? 0) - (a3.frequency ?? 0);
  });
  return result;
}
function parseParameterTemplateArgument(argTemplate) {
  let type = "auto";
  const r3 = argTemplate.match(/:([^=]+)/);
  if (r3)
    type = r3[1].trim();
  return type;
}
function parseParameterTemplate(parameterTemplate) {
  if (!parameterTemplate)
    return [];
  let result = [];
  let parameters = parameterTemplate.split("]");
  if (parameters[0].startsWith("[")) {
    result.push({
      isOptional: true,
      type: parseParameterTemplateArgument(parameters[0].slice(1))
    });
    for (let i3 = 1; i3 <= parameters.length; i3++) {
      result = result.concat(parseParameterTemplate(parameters[i3]));
    }
  } else {
    parameters = parameterTemplate.split("}");
    if (parameters[0].startsWith("{")) {
      result.push({
        isOptional: false,
        type: parseParameterTemplateArgument(parameters[0].slice(1))
      });
      for (let i3 = 1; i3 <= parameters.length; i3++) {
        result = result.concat(parseParameterTemplate(parameters[i3]));
      }
    }
  }
  return result;
}
function parseArgAsString(atoms) {
  if (!atoms)
    return "";
  let result = "";
  let success = true;
  for (const atom of atoms) {
    if (typeof atom.value === "string") {
      result += atom.value;
    } else {
      success = false;
    }
  }
  return success ? result : "";
}
function defineEnvironment(names, parameters, parser, isTabular = false) {
  if (typeof names === "string") {
    names = [names];
  }
  const parsedParameters = parseParameterTemplate(parameters);
  const data = {
    tabular: isTabular,
    params: parsedParameters,
    createAtom: parser
  };
  for (const name of names) {
    ENVIRONMENTS[name] = data;
  }
}
function defineTabularEnvironment(names, parameters, parser) {
  defineEnvironment(names, parameters, parser, true);
}
function defineFunction(names, parameters, options) {
  if (!options)
    options = {};
  const data = {
    params: parseParameterTemplate(parameters),
    ifMode: options.ifMode,
    isFunction: options.isFunction ?? false,
    applyMode: options.applyMode,
    infix: options.infix ?? false,
    createAtom: options.createAtom,
    applyStyle: options.applyStyle
  };
  if (typeof names === "string") {
    LEGACY_COMMANDS["\\" + names] = data;
  } else {
    for (const name of names)
      LEGACY_COMMANDS["\\" + name] = data;
  }
}
var _DEFAULT_MACROS;
function getMacros(otherMacros) {
  if (!_DEFAULT_MACROS) {
    _DEFAULT_MACROS = normalizeMacroDictionary(DEFAULT_MACROS);
  }
  if (!otherMacros)
    return _DEFAULT_MACROS;
  return {..._DEFAULT_MACROS, ...normalizeMacroDictionary(otherMacros)};
}
function normalizeMacroDefinition(def, options) {
  if (typeof def === "string") {
    let argCount = 0;
    const defString = def;
    if (/(^|[^\\])#1/.test(defString))
      argCount = 1;
    if (/(^|[^\\])#2/.test(defString))
      argCount = 2;
    if (/(^|[^\\])#3/.test(defString))
      argCount = 3;
    if (/(^|[^\\])#4/.test(defString))
      argCount = 4;
    if (/(^|[^\\])#5/.test(defString))
      argCount = 5;
    if (/(^|[^\\])#6/.test(defString))
      argCount = 6;
    if (/(^|[^\\])#7/.test(defString))
      argCount = 7;
    if (/(^|[^\\])#8/.test(defString))
      argCount = 8;
    if (/(^|[^\\])#9/.test(defString))
      argCount = 9;
    return {
      expand: options?.expand ?? true,
      captureSelection: options?.captureSelection ?? true,
      args: argCount,
      def: defString
    };
  }
  return {
    expand: options?.expand ?? true,
    captureSelection: options?.captureSelection ?? true,
    args: 0,
    ...def
  };
}
function normalizeMacroDictionary(macros) {
  if (!macros)
    return {};
  const result = {};
  for (const macro of Object.keys(macros)) {
    const macroDef = macros[macro];
    if (macroDef === void 0 || macroDef === null) {
      delete result[macro];
    } else if (typeof macroDef === "object" && "package" in macroDef) {
      for (const packageMacro of Object.keys(macroDef.package)) {
        result[packageMacro] = normalizeMacroDefinition(macroDef.package[packageMacro], {
          expand: macroDef.expand,
          captureSelection: macroDef.captureSelection
        });
      }
    } else {
      result[macro] = normalizeMacroDefinition(macroDef);
    }
  }
  return result;
}

// src/core/mathfield-box.ts
var MathfieldBox = class extends Box {
  constructor(placeholderId, element, options) {
    super(null, options);
    this.placeholderId = placeholderId;
    this.element = element;
    this.htmlData = `placeholder-id=${placeholderId}`;
    this.height = element.style.fontSize === "" ? 1 : element.clientHeight / parseInt(element.style.fontSize) * 0.6;
  }
  toMarkup() {
    let props = "";
    const classes = this.classes.split(" ");
    const classList = classes.length === 1 ? classes[0] : classes.filter((x3, e3, a3) => x3.length > 0 && a3.indexOf(x3) === e3).join(" ");
    if (this.cssId) {
      props += ` id=${this.cssId.replace(/ /g, "-")} `;
    }
    if (this.htmlData) {
      const entries = this.htmlData.split(",");
      for (const entry of entries) {
        const matched = entry.match(/([^=]+)=(.+$)/);
        if (matched) {
          const key = matched[1].trim().replace(/ /g, "-");
          if (key) {
            props += ` data-${key}=${matched[2]} `;
          }
        } else {
          const key = entry.trim().replace(/ /g, "-");
          if (key) {
            props += ` data-${key} `;
          }
        }
      }
    }
    if (this.htmlStyle) {
      const entries = this.htmlStyle.split(";");
      let styleString = "";
      for (const entry of entries) {
        const matched = entry.match(/([^=]+):(.+$)/);
        if (matched) {
          const key = matched[1].trim().replace(/ /g, "-");
          if (key) {
            styleString += `${key}:${matched[2]};`;
          }
        }
      }
      if (styleString) {
        props += ` style="${styleString}"`;
      }
    }
    if (this.attributes) {
      props += " " + Object.keys(this.attributes).map((x3) => `${x3}="${this.attributes[x3]}"`).join(" ");
    }
    if (classList.length > 0) {
      props += ` class="${classList}"`;
    }
    props += ` style="display: inline-block; width:${this.element.clientWidth}px; height:${this.element.clientHeight}px; "`;
    return `<span ${props}></span>`;
  }
};

// src/core/atom-class.ts
var NAMED_BRANCHES = [
  "above",
  "body",
  "below",
  "superscript",
  "subscript"
];
function isNamedBranch(branch) {
  return typeof branch === "string" && NAMED_BRANCHES.includes(branch);
}
function isColRowBranch(branch) {
  return branch !== void 0 && Array.isArray(branch) && branch.length === 2;
}
var Atom = class {
  constructor(type, options) {
    this.command = options?.command;
    this.type = type;
    if (typeof options?.value === "string") {
      this.value = options.value;
    }
    this._isDirty = false;
    this._changeCounter = 0;
    this.mode = options?.mode ?? "math";
    this.isFunction = options?.isFunction ?? false;
    this.subsupPlacement = options?.limits;
    this.style = options?.style ?? {};
    this.serializeOverride = options?.serialize;
    this.displayContainsHighlight = options?.displayContainsHighlight ?? false;
  }
  get changeCounter() {
    return this._changeCounter;
  }
  get isDirty() {
    return this._isDirty;
  }
  set isDirty(dirty) {
    this._isDirty = dirty;
    if (dirty) {
      this._changeCounter++;
      this.verbatimLatex = void 0;
      this._children = void 0;
      let {parent} = this;
      while (parent) {
        parent._isDirty = true;
        parent._changeCounter++;
        parent.verbatimLatex = void 0;
        parent._children = void 0;
        parent = parent.parent;
      }
    }
  }
  static createBox(parentContext, atoms, options) {
    if (!atoms)
      return null;
    const runs = getStyleRuns(atoms);
    if (runs.length === 1) {
      const run = runs[0];
      if (run[0].style) {
        return renderStyleRun(parentContext, run, {
          ...options,
          style: {
            color: run[0].style.color,
            backgroundColor: run[0].style.backgroundColor,
            fontSize: run[0].style.fontSize
          }
        });
      }
      return renderStyleRun(parentContext, run, options);
    }
    const boxes = [];
    let newList = options?.newList;
    for (const run of runs) {
      const context = new Context(parentContext, {
        color: run[0].style?.color,
        backgroundColor: run[0].style?.backgroundColor,
        fontSize: run[0].style?.fontSize,
        isSelected: run[0].isSelected
      });
      const box = renderStyleRun(context, run, {newList});
      if (box) {
        newList = false;
        boxes.push(box);
      }
    }
    if (boxes.length === 0)
      return null;
    if (boxes.length === 1 && !options?.classes && !options?.type) {
      return boxes[0].wrap(parentContext);
    }
    return new Box(boxes, {
      classes: options?.classes,
      type: options?.type,
      newList: options?.newList
    }).wrap(parentContext);
  }
  static serialize(value, options) {
    let result = "";
    if (isArray(value)) {
      result = atomsToLatex(value, options);
    } else if (typeof value === "number" || typeof value === "boolean") {
      result = value.toString();
    } else if (typeof value === "string") {
      result = value.replace(/\s/g, "~");
    } else if (value !== void 0) {
      if (!options.expandMacro && typeof value.verbatimLatex === "string") {
        return value.verbatimLatex;
      }
      if (value.serializeOverride) {
        return value.serializeOverride(value, options);
      }
      result = value.serialize(options);
    }
    return result;
  }
  static commonAncestor(a3, b3) {
    if (a3 === b3)
      return a3.parent;
    if (a3.parent === b3.parent)
      return a3.parent;
    const parents = new WeakSet();
    let {parent} = a3;
    while (parent) {
      parents.add(parent);
      parent = parent.parent;
    }
    parent = b3.parent;
    while (parent) {
      if (parents.has(parent))
        return parent;
      parent = parent.parent;
    }
    console.assert(Boolean(parent));
    return void 0;
  }
  serialize(options) {
    if (this.body && this.command) {
      return joinLatex([
        this.command,
        "{",
        this.bodyToLatex(options),
        "}",
        this.supsubToLatex(options)
      ]);
    }
    if (this.body) {
      return joinLatex([
        this.bodyToLatex(options),
        this.supsubToLatex(options)
      ]);
    }
    if (this.value && this.value !== "\u200B") {
      return this.command ?? unicodeCharToLatex(this.mode, this.value);
    }
    return "";
  }
  bodyToLatex(options) {
    return atomsToLatex(this.body, options);
  }
  aboveToLatex(options) {
    return atomsToLatex(this.above, options);
  }
  belowToLatex(options) {
    return atomsToLatex(this.below, options);
  }
  supsubToLatex(options) {
    let result = "";
    if (this.branch("subscript") !== void 0) {
      const sub = atomsToLatex(this.subscript, options);
      if (sub.length === 0) {
        result += "_";
      } else if (sub.length === 1) {
        result += "_" + sub;
      } else {
        result += `_{${sub}}`;
      }
    }
    if (this.branch("superscript") !== void 0) {
      const sup = atomsToLatex(this.superscript, options);
      if (sup.length === 0) {
        result += "^";
      } else if (sup.length === 1) {
        if (sup === "\u2032") {
          result += "^\\prime ";
        } else if (sup === "\u2033") {
          result += "^\\doubleprime ";
        } else {
          result += "^" + sup;
        }
      } else {
        result += `^{${sup}}`;
      }
    }
    return result;
  }
  get treeDepth() {
    let result = 1;
    let atom = this.parent;
    while (atom) {
      atom = atom.parent;
      result += 1;
    }
    return result;
  }
  get inCaptureSelection() {
    let result = false;
    let atom = this;
    while (atom) {
      if (atom.captureSelection) {
        result = true;
        break;
      }
      atom = atom.parent;
    }
    return result;
  }
  branch(name) {
    if (!isNamedBranch(name))
      return void 0;
    if (!this._branches)
      return void 0;
    return this._branches[name];
  }
  get branches() {
    if (!this._branches)
      return [];
    const result = [];
    for (const branch of NAMED_BRANCHES) {
      if (this._branches[branch]) {
        result.push(branch);
      }
    }
    return result;
  }
  createBranch(name) {
    console.assert(isNamedBranch(name));
    if (!isNamedBranch(name))
      return [];
    if (!this._branches) {
      this._branches = {
        [name]: [this.makeFirstAtom(name)]
      };
    } else if (!this._branches[name]) {
      this._branches[name] = [this.makeFirstAtom(name)];
    }
    this.isDirty = true;
    return this._branches[name];
  }
  get row() {
    if (!isColRowBranch(this.treeBranch))
      return -1;
    return this.treeBranch[0];
  }
  get col() {
    if (!isColRowBranch(this.treeBranch))
      return -1;
    return this.treeBranch[1];
  }
  get body() {
    return this._branches?.body;
  }
  set body(atoms) {
    this.setChildren(atoms, "body");
  }
  get superscript() {
    return this._branches?.superscript;
  }
  set superscript(atoms) {
    this.setChildren(atoms, "superscript");
  }
  get subscript() {
    return this._branches?.subscript;
  }
  set subscript(atoms) {
    this.setChildren(atoms, "subscript");
  }
  get above() {
    return this._branches?.above;
  }
  set above(atoms) {
    this.setChildren(atoms, "above");
  }
  get below() {
    return this._branches?.below;
  }
  set below(atoms) {
    this.setChildren(atoms, "below");
  }
  get computedStyle() {
    const style = {...this.style};
    const hadVerbatimColor = this.style.verbatimColor !== void 0;
    const hadVerbatimBackgroundColor = this.style.verbatimBackgroundColor !== void 0;
    if (style) {
      delete style.variant;
      delete style.variantStyle;
    }
    if (!this.parent)
      return style ?? {};
    const result = {...this.parent.computedStyle, ...style};
    if (!hadVerbatimBackgroundColor)
      delete result.verbatimBackgroundColor;
    if (!hadVerbatimColor)
      delete result.verbatimColor;
    return result;
  }
  applyStyle(style) {
    this.isDirty = true;
    this.style = {...this.style, ...style};
    if (this.style.fontFamily === "none") {
      delete this.style.fontFamily;
    }
    if (this.style.fontShape === "auto") {
      delete this.style.fontShape;
    }
    if (this.style.fontSeries === "auto") {
      delete this.style.fontSeries;
    }
    if (this.style.color === "none") {
      delete this.style.color;
      delete this.style.verbatimColor;
    }
    if (this.style.backgroundColor === "none") {
      delete this.style.backgroundColor;
      delete this.style.verbatimBackgroundColor;
    }
    if (this.style.fontSize === "auto") {
      delete this.style.fontSize;
    }
  }
  getInitialBaseElement() {
    let result = void 0;
    if (!this.hasEmptyBranch("body")) {
      console.assert(this.body?.[0].type === "first");
      result = this.body[1].getInitialBaseElement();
    }
    return result ?? this;
  }
  getFinalBaseElement() {
    if (!this.hasEmptyBranch("body")) {
      return this.body[this.body.length - 1].getFinalBaseElement();
    }
    return this;
  }
  isCharacterBox() {
    const base = this.getInitialBaseElement();
    return /mord/.test(base.type);
  }
  hasEmptyBranch(branch) {
    const atoms = this.branch(branch);
    if (!atoms)
      return true;
    console.assert(atoms.length > 0);
    console.assert(atoms[0].type === "first");
    return atoms.length === 1;
  }
  setChildren(children, branch) {
    if (!children)
      return;
    console.assert(isNamedBranch(branch));
    if (!isNamedBranch(branch))
      return;
    console.assert(children[0]?.type !== "first");
    if (this._branches) {
      this._branches[branch] = [this.makeFirstAtom(branch), ...children];
    } else {
      this._branches = {
        [branch]: [this.makeFirstAtom(branch), ...children]
      };
    }
    this.isDirty = true;
    for (const child of children) {
      child.parent = this;
      child.treeBranch = branch;
    }
  }
  makeFirstAtom(branch) {
    const result = new Atom("first", {mode: this.mode});
    result.parent = this;
    result.treeBranch = branch;
    return result;
  }
  addChild(child, branch) {
    console.assert(child.type !== "first");
    this.createBranch(branch).push(child);
    this.isDirty = true;
    child.parent = this;
    child.treeBranch = branch;
  }
  addChildBefore(child, before) {
    console.assert(before.treeBranch !== void 0);
    const branch = this.createBranch(before.treeBranch);
    branch.splice(branch.indexOf(before), 0, child);
    this.isDirty = true;
    child.parent = this;
    child.treeBranch = before.treeBranch;
  }
  addChildAfter(child, after) {
    console.assert(after.treeBranch !== void 0);
    const branch = this.createBranch(after.treeBranch);
    branch.splice(branch.indexOf(after) + 1, 0, child);
    this.isDirty = true;
    child.parent = this;
    child.treeBranch = after.treeBranch;
  }
  addChildren(children, branch) {
    for (const child of children)
      this.addChild(child, branch);
  }
  addChildrenAfter(children, after) {
    console.assert(children.length === 0 || children[0].type !== "first");
    console.assert(after.treeBranch !== void 0);
    const branch = this.createBranch(after.treeBranch);
    branch.splice(branch.indexOf(after) + 1, 0, ...children);
    this.isDirty = true;
    for (const child of children) {
      child.parent = this;
      child.treeBranch = after.treeBranch;
    }
    return children[children.length - 1];
  }
  removeBranch(name) {
    const children = this.branch(name);
    if (isNamedBranch(name)) {
      this._branches[name] = void 0;
    }
    if (!children)
      return [];
    for (const child of children) {
      child.parent = void 0;
      child.treeBranch = void 0;
    }
    console.assert(children[0].type === "first");
    children.shift();
    this.isDirty = true;
    return children;
  }
  removeChild(child) {
    console.assert(child.parent === this);
    if (child.type === "first")
      return;
    const branch = this.branch(child.treeBranch);
    const index = branch.indexOf(child);
    console.assert(index >= 0);
    branch.splice(index, 1);
    this.isDirty = true;
    child.parent = void 0;
    child.treeBranch = void 0;
  }
  get siblings() {
    if (this.type === "root")
      return [];
    return this.parent.branch(this.treeBranch);
  }
  get firstSibling() {
    return this.siblings[0];
  }
  get lastSibling() {
    const {siblings} = this;
    return siblings[siblings.length - 1];
  }
  get isFirstSibling() {
    return this === this.firstSibling;
  }
  get isLastSibling() {
    return this === this.lastSibling;
  }
  get hasNoSiblings() {
    return this.siblings.length === 1;
  }
  get leftSibling() {
    console.assert(this.parent !== void 0);
    const siblings = this.parent.branch(this.treeBranch);
    return siblings[siblings.indexOf(this) - 1];
  }
  get rightSibling() {
    console.assert(this.parent !== void 0);
    const siblings = this.parent.branch(this.treeBranch);
    return siblings[siblings.indexOf(this) + 1];
  }
  get hasChildren() {
    return this._branches && this.children.length > 0;
  }
  get firstChild() {
    console.assert(this.hasChildren);
    return this.children[0];
  }
  get lastChild() {
    console.assert(this.hasChildren);
    const {children} = this;
    return children[children.length - 1];
  }
  get children() {
    if (this._children)
      return this._children;
    if (!this._branches)
      return [];
    const result = [];
    for (const branchName of NAMED_BRANCHES) {
      if (this._branches[branchName]) {
        for (const x3 of this._branches[branchName]) {
          result.push(...x3.children);
          result.push(x3);
        }
      }
    }
    this._children = result;
    return result;
  }
  render(parentContext, options) {
    if (this.type === "first" && !parentContext.atomIdsSettings)
      return null;
    const context = new Context(parentContext, this.style);
    let result = this.createBox(context, {
      classes: this.type === "root" ? " ML__base" : "",
      newList: options?.newList === true || this.type === "first"
    });
    if (!result)
      return null;
    if (!this.subsupPlacement && (this.superscript || this.subscript)) {
      result = this.attachSupsub(context, {base: result});
    }
    return result.wrap(context);
  }
  attachSupsub(parentContext, options) {
    const base = options.base;
    const superscript = this.superscript;
    const subscript = this.subscript;
    if (!superscript && !subscript) {
      return base;
    }
    let supBox = null;
    let subBox = null;
    const isCharacterBox = options.isCharacterBox ?? this.isCharacterBox();
    let supShift = 0;
    if (superscript) {
      const context = new Context(parentContext, void 0, "superscript");
      supBox = Atom.createBox(context, superscript, {newList: true});
      if (!isCharacterBox) {
        supShift = base.height - parentContext.metrics.supDrop * context.scalingFactor;
      }
    }
    let subShift = 0;
    if (subscript) {
      const context = new Context(parentContext, void 0, "subscript");
      subBox = Atom.createBox(context, subscript, {newList: true});
      if (!isCharacterBox) {
        subShift = base.depth + parentContext.metrics.subDrop * context.scalingFactor;
      }
    }
    let minSupShift;
    if (parentContext.isDisplayStyle) {
      minSupShift = parentContext.metrics.sup1;
    } else if (parentContext.isCramped) {
      minSupShift = parentContext.metrics.sup3;
    } else {
      minSupShift = parentContext.metrics.sup2;
    }
    const scriptspace = 0.5 / PT_PER_EM / parentContext.scalingFactor;
    let supsub = null;
    if (subBox && supBox) {
      supShift = Math.max(supShift, minSupShift, supBox.depth + 0.25 * parentContext.metrics.xHeight);
      subShift = Math.max(subShift, parentContext.metrics.sub2);
      const ruleWidth = parentContext.metrics.defaultRuleThickness;
      if (supShift - supBox.depth - (subBox.height - subShift) < 4 * ruleWidth) {
        subShift = 4 * ruleWidth - (supShift - supBox.depth) + subBox.height;
        const psi = 0.8 * parentContext.metrics.xHeight - (supShift - supBox.depth);
        if (psi > 0) {
          supShift += psi;
          subShift -= psi;
        }
      }
      const slant = this.isExtensibleSymbol && base.italic ? -base.italic : 0;
      supsub = new VBox({
        individualShift: [
          {box: subBox, shift: subShift, marginLeft: slant},
          {box: supBox, shift: -supShift}
        ]
      }).wrap(parentContext);
    } else if (subBox && !supBox) {
      subShift = Math.max(subShift, parentContext.metrics.sub1, subBox.height - 0.8 * X_HEIGHT);
      supsub = new VBox({
        shift: subShift,
        children: [
          {
            box: subBox,
            marginRight: scriptspace,
            marginLeft: this.isCharacterBox() ? -(base.italic ?? 0) : 0
          }
        ]
      });
    } else if (!subBox && supBox) {
      supShift = Math.max(supShift, minSupShift, supBox.depth + 0.25 * X_HEIGHT);
      supsub = new VBox({
        shift: -supShift,
        children: [{box: supBox, marginRight: scriptspace}]
      });
      supsub.wrap(parentContext);
    }
    const supsubContainer = new Box(supsub, {classes: "msubsup"});
    if (this.caret) {
      supsubContainer.caret = this.caret;
    }
    return new Box([base, supsubContainer], {type: options.type});
  }
  attachLimits(parentContext, options) {
    const above = this.superscript ? Atom.createBox(new Context(parentContext, this.style, "superscript"), this.superscript, {newList: true}) : null;
    const below = this.subscript ? Atom.createBox(new Context(parentContext, this.style, "subscript"), this.subscript, {newList: true}) : null;
    if (!above && !below)
      return options.base.wrap(parentContext);
    return makeLimitsStack(parentContext, {
      ...options,
      above,
      below,
      type: options?.type ?? "mop"
    });
  }
  bind(context, box) {
    if (!box)
      return null;
    if (context.isPhantom)
      return box;
    if (!box || this.value === "\u200B")
      return box;
    if (!this.id)
      this.id = context.makeID();
    box.atomID = this.id;
    return box;
  }
  createMathfieldBox(context, options) {
    const type = "mathfield";
    const classes = options?.classes ?? "";
    const result = new MathfieldBox(options.placeholderId, options.element, {
      type,
      mode: this.mode,
      maxFontSize: context.scalingFactor,
      style: {
        variant: "normal",
        ...this.style,
        letterShapeStyle: context.letterShapeStyle,
        fontSize: Math.max(1, context.size + context.mathstyle.sizeDelta)
      },
      classes,
      newList: options?.newList
    });
    if (context.isTight)
      result.isTight = true;
    if (this.mode !== "math")
      result.italic = 0;
    result.right = result.italic;
    this.bind(context, result);
    return result;
  }
  createBox(context, options) {
    const value = this.value ?? this.body;
    const type = isBoxType(this.type) ? this.type : void 0;
    let classes = options?.classes ?? "";
    if (this.mode === "text")
      classes += " ML__text";
    const result = typeof value === "string" || value === void 0 ? new Box(value ?? null, {
      type,
      mode: this.mode,
      maxFontSize: context.scalingFactor,
      style: {
        variant: "normal",
        ...this.style,
        letterShapeStyle: context.letterShapeStyle,
        fontSize: Math.max(1, context.size + context.mathstyle.sizeDelta)
      },
      classes,
      newList: options?.newList
    }) : Atom.createBox(context, value, {
      type,
      mode: this.mode,
      style: this.style,
      classes,
      newList: options?.newList
    }) ?? new Box(null);
    if (context.isTight)
      result.isTight = true;
    if (this.mode !== "math")
      result.italic = 0;
    result.right = result.italic;
    this.bind(context, result);
    if (this.caret) {
      if (!this.superscript && !this.subscript) {
        result.caret = this.caret;
      }
    }
    return result;
  }
};
function atomsToLatex(atoms, options) {
  if (!atoms || atoms.length === 0)
    return "";
  if (atoms[0].type === "first") {
    if (atoms.length === 1)
      return "";
    atoms = atoms.slice(1);
  }
  if (atoms.length === 0)
    return "";
  return joinLatex(getPropertyRuns(atoms, "cssClass").map((x3) => joinLatex(getPropertyRuns(x3, "color").map((x4) => joinLatex(getModeRuns(x4).map((x5) => Mode.serialize(x5, options)))))));
}
function getStyleRuns(atoms) {
  let style = void 0;
  let selected;
  const runs = [];
  let run = [];
  for (const atom of atoms) {
    const atomStyle = atom.computedStyle;
    if (!style && !atom.style) {
      run.push(atom);
    } else if (style && selected === atom.isSelected && atomStyle.color === style.color && atomStyle.backgroundColor === style.backgroundColor && atomStyle.fontSize === style.fontSize) {
      run.push(atom);
    } else {
      if (run.length > 0)
        runs.push(run);
      run = [atom];
      style = atom.computedStyle;
      selected = atom.isSelected;
    }
  }
  if (run.length > 0)
    runs.push(run);
  return runs;
}
function renderStyleRun(parentContext, atoms, options) {
  function isDigit(atom) {
    return atom.type === "mord" && Boolean(atom.value) && /^[\d,.]$/.test(atom.value);
  }
  function isText(atom) {
    return atom.mode === "text";
  }
  if (!atoms || atoms.length === 0)
    return null;
  const context = new Context(parentContext, options?.style);
  const displaySelection = !context.atomIdsSettings || !context.atomIdsSettings.groupNumbers;
  let boxes = [];
  if (atoms.length === 1) {
    const box = atoms[0].render(context, {
      newList: options?.newList ?? false
    });
    if (box && displaySelection && atoms[0].isSelected) {
      box.selected(true);
    }
    if (box)
      boxes = [box];
  } else {
    let selection = [];
    let digitOrTextStringID = "";
    let lastWasDigit = true;
    let isNewList = options?.newList ?? false;
    for (const atom of atoms) {
      if (context.atomIdsSettings?.groupNumbers && digitOrTextStringID && (lastWasDigit && isDigit(atom) || !lastWasDigit && isText(atom))) {
        context.atomIdsSettings.overrideID = digitOrTextStringID;
      }
      const box = atom.render(context, {newList: isNewList});
      if (context.atomIdsSettings) {
        context.atomIdsSettings.overrideID = void 0;
      }
      if (box) {
        isNewList = false;
        if (context.atomIdsSettings?.groupNumbers) {
          if (isDigit(atom) || isText(atom)) {
            if (!digitOrTextStringID || lastWasDigit !== isDigit(atom)) {
              lastWasDigit = isDigit(atom);
              digitOrTextStringID = atom.id ?? "";
            }
          }
          if ((!(isDigit(atom) || isText(atom)) || !atom.hasEmptyBranch("superscript") || !atom.hasEmptyBranch("subscript")) && digitOrTextStringID) {
            digitOrTextStringID = "";
          }
        }
        if (displaySelection && atom.isSelected) {
          selection.push(box);
          for (const box2 of selection)
            box2.selected(true);
        } else {
          if (selection.length > 0) {
            boxes = [...boxes, ...selection];
            selection = [];
          }
          boxes.push(box);
        }
      }
    }
    if (selection.length > 0) {
      boxes = [...boxes, ...selection];
      selection = [];
    }
  }
  if (!boxes || boxes.length === 0)
    return null;
  let result = boxes[0];
  if (options || boxes.length > 1) {
    result = new Box(boxes, {
      isTight: context.isTight,
      ...options
    });
    result.selected(boxes[0].isSelected);
  }
  return result.wrap(context).wrap(parentContext);
}

// src/core-atoms/group.ts
var GroupAtom = class extends Atom {
  constructor(arg, options) {
    super("group", {
      mode: options?.mode ?? "math",
      serialize: options?.serialize,
      style: options?.style,
      displayContainsHighlight: true
    });
    this.body = arg;
    this.mathstyleName = options?.mathstyleName;
    this.latexOpen = options?.latexOpen;
    this.latexClose = options?.latexClose;
    this.cssId = options?.cssId;
    this.htmlData = options?.htmlData;
    this.htmlStyle = options?.htmlStyle;
    this.customClass = options?.customClass;
    this.boxType = options?.boxType;
    this.skipBoundary = true;
    this.captureSelection = options?.captureSelection;
    this.changeMode = options?.changeMode ?? false;
    this.displayContainsHighlight = false;
  }
  render(context) {
    const localContext = new Context(context, this.style, this.mathstyleName);
    const box = Atom.createBox(localContext, this.body, {
      type: this.boxType,
      classes: this.customClass,
      mode: this.mode,
      style: {
        backgroundColor: this.style.backgroundColor
      }
    });
    if (!box)
      return box;
    if (this.cssId)
      box.cssId = this.cssId;
    if (this.htmlData)
      box.htmlData = this.htmlData;
    if (this.htmlStyle)
      box.htmlStyle = this.htmlStyle;
    if (this.caret)
      box.caret = this.caret;
    return this.bind(context, box);
  }
  serialize(options) {
    let result = this.bodyToLatex(options);
    if (typeof this.latexOpen === "string") {
      result = this.latexOpen + result + this.latexClose;
    }
    if (this.htmlData) {
      result = `\\htmlData{${this.htmlData}}{${result}}`;
    }
    if (this.htmlStyle) {
      result = `\\htmlStyle{${this.htmlStyle}}{${result}}`;
    }
    if (this.customClass) {
      result = `\\class{${this.customClass}}{${result}}`;
    }
    if (this.cssId) {
      result = `\\cssId{${this.cssId}}{${result}}`;
    }
    return result;
  }
};

// src/core-atoms/spacing.ts
var SpacingAtom = class extends Atom {
  constructor(command, style, width) {
    super("spacing", {command, style});
    this.width = width;
  }
  render(_context) {
    let result;
    if (this.width) {
      result = new Box(null, {classes: "mspace"});
      result.left = convertGlueToEm(this.width);
    } else {
      const spacingCls = {
        "\\qquad": "qquad",
        "\\quad": "quad",
        "\\enspace": "enspace",
        "\\;": "thickspace",
        "\\:": "mediumspace",
        "\\,": "thinspace",
        "\\!": "negativethinspace"
      }[this.command] ?? "mediumspace";
      result = new Box(null, {classes: spacingCls});
    }
    if (this.caret)
      result.caret = this.caret;
    return result;
  }
  serialize(_options) {
    let result = this.command ?? "";
    if (this.command === "\\hspace" || this.command === "\\hspace*") {
      if (Number.isFinite(this.width)) {
        result += `{${this.width}em'}`;
      } else {
        result += `{0pt}`;
      }
    } else {
      if (Number.isFinite(this.width)) {
        result += ` ${this.width}em`;
      }
    }
    return result;
  }
};

// src/core/delimiters.ts
var RIGHT_DELIM = {
  "(": ")",
  "{": "}",
  "[": "]",
  "|": "|",
  "\\lbrace": "\\rbrace",
  "\\lparen": "\\rparen",
  "\\{": "\\}",
  "\\langle": "\\rangle",
  "\\lfloor": "\\rfloor",
  "\\lceil": "\\rceil",
  "\\vert": "\\vert",
  "\\lvert": "\\rvert",
  "\\Vert": "\\Vert",
  "\\lVert": "\\rVert",
  "\\lbrack": "\\rbrack",
  "\\ulcorner": "\\urcorner",
  "\\llcorner": "\\lrcorner",
  "\\lgroup": "\\rgroup",
  "\\lmoustache": "\\rmoustache"
};
function getSymbolValue(symbol) {
  return {
    "[": 91,
    "]": 93,
    "(": 40,
    ")": 41,
    "\\mid": 8739,
    "|": 8739,
    "\u2223": 8739,
    "\u2225": 8741,
    "\\|": 8739,
    "\\{": 123,
    "\\}": 125,
    "\\lbrace": 123,
    "\\rbrace": 125,
    "\\lparen": 40,
    "\\rparen": 41,
    "\\lbrack": 91,
    "\\rbrack": 93,
    "\\vert": 8739,
    "\\lvert": 8739,
    "\\mvert": 8739,
    "\\rvert": 8739,
    "\\Vert": 8741,
    "\\lVert": 8741,
    "\\mVert": 8741,
    "\\rVert": 8741,
    "\\parallel": 8741,
    "\\shortparallel": 8741,
    "\\langle": 10216,
    "\\rangle": 10217,
    "\\lfloor": 8970,
    "\\rfloor": 8971,
    "\\lceil": 8968,
    "\\rceil": 8969,
    "\\ulcorner": 9484,
    "\\urcorner": 9488,
    "\\llcorner": 9492,
    "\\lrcorner": 9496,
    "\\lgroup": 10222,
    "\\rgroup": 10223,
    "\\lmoustache": 9136,
    "\\rmoustache": 9137,
    "\\surd": 8730
  }[symbol] ?? symbol.codePointAt(0);
}
function makeSmallDelim(delim, context, center, options) {
  const text = new Box(getSymbolValue(delim), {fontFamily: "Main-Regular"});
  const box = text.wrap(context, options);
  if (center) {
    box.setTop((1 - context.scalingFactor) * AXIS_HEIGHT);
  }
  return box;
}
function makeLargeDelim(delim, size, center, parentContext, options) {
  const context = new Context(parentContext, options?.style, "textstyle");
  const result = new Box(getSymbolValue(delim), {
    fontFamily: "Size" + size + "-Regular",
    classes: "ML__delim-size" + size
  }).wrap(context);
  if (center) {
    result.setTop((1 - context.scalingFactor) * AXIS_HEIGHT);
  }
  return result;
}
function makeStackedDelim(delim, heightTotal, center, context, options) {
  let top;
  let middle;
  let repeat;
  let bottom;
  top = repeat = bottom = getSymbolValue(delim);
  middle = null;
  let fontFamily = "Size1-Regular";
  if (delim === "\\vert" || delim === "\\lvert" || delim === "\\rvert" || delim === "\\mvert" || delim === "\\mid") {
    repeat = top = bottom = 8739;
  } else if (delim === "\\Vert" || delim === "\\lVert" || delim === "\\rVert" || delim === "\\mVert" || delim === "\\|") {
    repeat = top = bottom = 8741;
  } else if (delim === "\\uparrow") {
    repeat = bottom = 9168;
  } else if (delim === "\\Uparrow") {
    repeat = bottom = 8214;
  } else if (delim === "\\downarrow") {
    top = repeat = 9168;
  } else if (delim === "\\Downarrow") {
    top = repeat = 8214;
  } else if (delim === "\\updownarrow") {
    top = 8593;
    repeat = 9168;
    bottom = 8595;
  } else if (delim === "\\Updownarrow") {
    top = 8657;
    repeat = 8214;
    bottom = 8659;
  } else if (delim === "[" || delim === "\\lbrack") {
    top = 9121;
    repeat = 9122;
    bottom = 9123;
    fontFamily = "Size4-Regular";
  } else if (delim === "]" || delim === "\\rbrack") {
    top = 9124;
    repeat = 9125;
    bottom = 9126;
    fontFamily = "Size4-Regular";
  } else if (delim === "\\lfloor" || delim === "\u230A") {
    repeat = top = 9122;
    bottom = 9123;
    fontFamily = "Size4-Regular";
  } else if (delim === "\\lceil" || delim === "\u2308") {
    top = 9121;
    repeat = bottom = 9122;
    fontFamily = "Size4-Regular";
  } else if (delim === "\\rfloor" || delim === "\u230B") {
    repeat = top = 9125;
    bottom = 9126;
    fontFamily = "Size4-Regular";
  } else if (delim === "\\rceil" || delim === "\u2309") {
    top = 9124;
    repeat = bottom = 9125;
    fontFamily = "Size4-Regular";
  } else if (delim === "(" || delim === "\\lparen") {
    top = 9115;
    repeat = 9116;
    bottom = 9117;
    fontFamily = "Size4-Regular";
  } else if (delim === ")" || delim === "\\rparen") {
    top = 9118;
    repeat = 9119;
    bottom = 9120;
    fontFamily = "Size4-Regular";
  } else if (delim === "\\{" || delim === "\\lbrace") {
    top = 9127;
    middle = 9128;
    bottom = 9129;
    repeat = 9130;
    fontFamily = "Size4-Regular";
  } else if (delim === "\\}" || delim === "\\rbrace") {
    top = 9131;
    middle = 9132;
    bottom = 9133;
    repeat = 9130;
    fontFamily = "Size4-Regular";
  } else if (delim === "\\lgroup" || delim === "\u27EE") {
    top = 9127;
    bottom = 9129;
    repeat = 9130;
    fontFamily = "Size4-Regular";
  } else if (delim === "\\rgroup" || delim === "\u27EF") {
    top = 9131;
    bottom = 9133;
    repeat = 9130;
    fontFamily = "Size4-Regular";
  } else if (delim === "\\lmoustache" || delim === "\u23B0") {
    top = 9127;
    bottom = 9133;
    repeat = 9130;
    fontFamily = "Size4-Regular";
  } else if (delim === "\\rmoustache" || delim === "\u23B1") {
    top = 9131;
    bottom = 9129;
    repeat = 9130;
    fontFamily = "Size4-Regular";
  } else if (delim === "\\surd") {
    top = 57345;
    bottom = 9143;
    repeat = 57344;
    fontFamily = "Size4-Regular";
  } else if (delim === "\\ulcorner") {
    top = 9484;
    repeat = bottom = 32;
  } else if (delim === "\\urcorner") {
    top = 9488;
    repeat = bottom = 32;
  } else if (delim === "\\llcorner") {
    bottom = 9492;
    repeat = top = 32;
  } else if (delim === "\\lrcorner") {
    top = 9496;
    repeat = top = 32;
  }
  const topMetrics = getCharacterMetrics(top, fontFamily);
  const topHeightTotal = topMetrics.height + topMetrics.depth;
  const repeatMetrics = getCharacterMetrics(repeat, fontFamily);
  const repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
  const bottomMetrics = getCharacterMetrics(bottom, fontFamily);
  const bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
  let middleHeightTotal = 0;
  let middleFactor = 1;
  if (middle !== null) {
    const middleMetrics = getCharacterMetrics(middle, fontFamily);
    middleHeightTotal = middleMetrics.height + middleMetrics.depth;
    middleFactor = 2;
  }
  const minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
  const repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
  const realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
  let axisHeight = AXIS_HEIGHT;
  if (center) {
    axisHeight = axisHeight * context.scalingFactor;
  }
  const depth = realHeightTotal / 2 - axisHeight;
  const OVERLAP = 8e-3;
  const stack = [];
  stack.push({box: new Box(bottom, {fontFamily})});
  stack.push(-OVERLAP);
  const repeatBox = new Box(repeat, {fontFamily});
  if (middle === null) {
    for (let i3 = 0; i3 < repeatCount; i3++) {
      stack.push({box: repeatBox});
    }
  } else {
    for (let i3 = 0; i3 < repeatCount; i3++) {
      stack.push({box: repeatBox});
    }
    stack.push(-OVERLAP);
    stack.push({box: new Box(middle, {fontFamily})});
    stack.push(-OVERLAP);
    for (let i3 = 0; i3 < repeatCount; i3++) {
      stack.push({box: repeatBox});
    }
  }
  stack.push(-OVERLAP);
  stack.push({box: new Box(top, {fontFamily})});
  let sizeClass = "";
  if (fontFamily === "Size1-Regular") {
    sizeClass = " delim-size1";
  } else if (fontFamily === "Size4-Regular") {
    sizeClass = " delim-size4";
  }
  const inner = new VBox({
    bottom: depth,
    children: stack
  }, {classes: sizeClass});
  const result = new Box(inner, {
    ...options ?? {},
    classes: (options?.classes ?? "") + " ML__delim-mult"
  });
  return result;
}
var stackLargeDelimiters = new Set([
  "(",
  ")",
  "\\lparen",
  "\\rparen",
  "[",
  "]",
  "\\lbrack",
  "\\rbrack",
  "\\{",
  "\\}",
  "\\lbrace",
  "\\rbrace",
  "\\lfloor",
  "\\rfloor",
  "\\lceil",
  "\\rceil",
  "\\surd",
  "\u230A",
  "\u230B",
  "\u2308",
  "\u2309"
]);
var stackAlwaysDelimiters = new Set([
  "\\uparrow",
  "\\downarrow",
  "\\updownarrow",
  "\\Uparrow",
  "\\Downarrow",
  "\\Updownarrow",
  "|",
  "\\|",
  "\\vert",
  "\\Vert",
  "\\lvert",
  "\\rvert",
  "\\lVert",
  "\\rVert",
  "\\mvert",
  "\\mid",
  "\\lgroup",
  "\\rgroup",
  "\\lmoustache",
  "\\rmoustache",
  "\u27EE",
  "\u27EF",
  "\u23B0",
  "\u23B1"
]);
var stackNeverDelimiters = new Set([
  "<",
  ">",
  "\\langle",
  "\\rangle",
  "/",
  "\\backslash",
  "\\lt",
  "\\gt"
]);
var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
function makeSizedDelim(delim, size, context, options) {
  if (delim === void 0 || delim === ".") {
    return makeNullDelimiter(context, options.type ?? "minner", options.classes);
  }
  if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
    delim = "\\langle";
  } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
    delim = "\\rangle";
  }
  if (stackLargeDelimiters.has(delim) || stackNeverDelimiters.has(delim)) {
    return makeLargeDelim(delim, size, false, context, options);
  }
  if (stackAlwaysDelimiters.has(delim)) {
    return makeStackedDelim(delim, sizeToMaxHeight[size], false, context, options);
  }
  console.assert(false, "Unknown delimiter '" + delim + "'");
  return null;
}
var stackNeverDelimiterSequence = [
  {type: "small", mathstyle: "scriptscriptstyle"},
  {type: "small", mathstyle: "scriptstyle"},
  {type: "small", mathstyle: "textstyle"},
  {type: "large", size: 1},
  {type: "large", size: 2},
  {type: "large", size: 3},
  {type: "large", size: 4}
];
var stackAlwaysDelimiterSequence = [
  {type: "small", mathstyle: "scriptscriptstyle"},
  {type: "small", mathstyle: "scriptscriptstyle"},
  {type: "small", mathstyle: "textstyle"},
  {type: "stack"}
];
var stackLargeDelimiterSequence = [
  {type: "small", mathstyle: "scriptscriptstyle"},
  {type: "small", mathstyle: "scriptstyle"},
  {type: "small", mathstyle: "textstyle"},
  {type: "large", size: 1},
  {type: "large", size: 2},
  {type: "large", size: 3},
  {type: "large", size: 4},
  {type: "stack"}
];
function delimTypeToFont(info) {
  if (info.type === "small") {
    return "Main-Regular";
  }
  if (info.type === "large") {
    return "Size" + info.size + "-Regular";
  }
  console.assert(info.type === "stack");
  return "Size4-Regular";
}
function traverseSequence(delim, height, sequence, context) {
  const start = {"-4": 0, "-3": 1, "0": 2}[context.mathstyle.sizeDelta];
  for (let i3 = start; i3 < sequence.length; i3++) {
    if (sequence[i3].type === "stack") {
      break;
    }
    const metrics = getCharacterMetrics(delim, delimTypeToFont(sequence[i3]));
    if (metrics.defaultMetrics) {
      return {type: "small", mathstyle: "scriptstyle"};
    }
    let heightDepth = metrics.height + metrics.depth;
    if (sequence[i3].type === "small") {
      if (sequence[i3].mathstyle === "scriptscriptstyle") {
        heightDepth *= FONT_SCALE[Math.max(1, context.size - 2)];
      } else if (sequence[i3].mathstyle === "scriptstyle") {
        heightDepth *= FONT_SCALE[Math.max(1, context.size - 1)];
      }
    }
    if (heightDepth > height) {
      return sequence[i3];
    }
  }
  return sequence[sequence.length - 1];
}
function makeCustomSizedDelim(type, delim, height, center, context, options) {
  if (!delim || delim.length === 0 || delim === ".") {
    return makeNullDelimiter(context, type, type);
  }
  if (delim === "<" || delim === "\\lt") {
    delim = "\\langle";
  } else if (delim === ">" || delim === "\\gt") {
    delim = "\\rangle";
  }
  let sequence;
  if (stackNeverDelimiters.has(delim)) {
    sequence = stackNeverDelimiterSequence;
  } else if (stackLargeDelimiters.has(delim)) {
    sequence = stackLargeDelimiterSequence;
  } else {
    sequence = stackAlwaysDelimiterSequence;
  }
  const delimType = traverseSequence(getSymbolValue(delim), height, sequence, context);
  const delimContext = new Context(context, options?.style, delimType.mathstyle);
  if (delimType.type === "small") {
    return makeSmallDelim(delim, delimContext, center, {
      type,
      classes: "ML__small-delim " + (options?.classes ?? "")
    });
  }
  if (delimType.type === "large") {
    return makeLargeDelim(delim, delimType.size, center, delimContext, {
      ...options,
      type
    });
  }
  console.assert(delimType.type === "stack");
  return makeStackedDelim(delim, height, center, delimContext, {
    ...options,
    type
  });
}
function makeLeftRightDelim(type, delim, height, depth, context, options) {
  if (delim === ".") {
    return makeNullDelimiter(context, type, options?.classes);
  }
  const axisHeight = AXIS_HEIGHT * context.scalingFactor;
  const delimiterFactor = 901;
  const delimiterExtend = 5 / PT_PER_EM;
  const maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
  const totalHeight = Math.max(maxDistFromAxis / 500 * delimiterFactor, 2 * maxDistFromAxis - delimiterExtend);
  return makeCustomSizedDelim(type, delim, totalHeight, true, context, options);
}
function makeNullDelimiter(parentContext, type, classes) {
  const context = new Context(parentContext, void 0, "textstyle");
  return new Box(null, {
    classes: " nulldelimiter " + (classes ?? ""),
    type
  }).wrap(context);
}

// src/core-atoms/leftright.ts
var LeftRightAtom = class extends Atom {
  constructor(body, options) {
    super("leftright", {
      style: options.style,
      displayContainsHighlight: true
    });
    this.body = body;
    this.inner = options.inner ?? false;
    this.leftDelim = options.leftDelim;
    this.rightDelim = options.rightDelim;
  }
  serialize(options) {
    let segments = [];
    if (this.inner) {
      segments = [
        "\\left" + (this.leftDelim ?? "."),
        this.bodyToLatex(options),
        "\\right" + (this.rightDelim ?? ".")
      ];
    } else if (options.expandMacro) {
      segments = [
        !this.leftDelim || this.leftDelim === "." ? "" : this.leftDelim,
        this.bodyToLatex(options),
        !this.rightDelim || this.rightDelim === "." ? "" : this.rightDelim
      ];
    } else {
      segments = [
        "\\mleft" + (this.leftDelim ?? "."),
        this.bodyToLatex(options),
        "\\mright" + (this.rightDelim ?? ".")
      ];
    }
    return joinLatex(segments);
  }
  render(parentContext) {
    const context = new Context(parentContext, this.style);
    if (!this.body) {
      const boxes2 = [];
      if (this.leftDelim) {
        boxes2.push(new Atom("mopen", {value: this.leftDelim}).render(context));
      }
      if (this.rightDelim) {
        boxes2.push(new Atom("mclose", {value: this.rightDelim}).render(context));
      }
      if (boxes2.length === 0)
        return null;
      return new Box(boxes2, {type: "minner"});
    }
    const delimContext = new Context(parentContext, this.style, "textstyle");
    const inner = Atom.createBox(context, this.body, {newList: true}) ?? new Box(null, {newList: true});
    const innerHeight = inner.height / delimContext.scalingFactor;
    const innerDepth = inner.depth / delimContext.scalingFactor;
    const boxes = [];
    if (this.leftDelim) {
      boxes.push(this.bind(delimContext, makeLeftRightDelim("mopen", this.leftDelim, innerHeight, innerDepth, delimContext, {
        classes: "ML__open" + (this.containsCaret ? " ML__contains-caret" : ""),
        mode: this.mode,
        style: this.style
      })));
    }
    if (inner) {
      if (inner.children) {
        for (let i3 = 0; i3 < inner.children.length; i3++) {
          const child = inner.children[i3];
          if (child.delim) {
            const savedCaret = child.caret;
            inner.children[i3] = this.bind(context, makeLeftRightDelim("minner", child.delim, innerHeight, innerDepth, context));
            inner.children[i3].caret = savedCaret;
          }
        }
      }
      boxes.push(inner);
    }
    if (this.rightDelim) {
      let delim = this.rightDelim;
      let classes = this.containsCaret ? " ML__contains-caret" : "";
      if (delim === "?") {
        if (context.smartFence) {
          delim = {
            "(": ")",
            "[": "\\rbrack",
            "\\{": "\\}",
            "\\lbrace": "\\rbrace",
            "\\lparen": "\\rparen",
            "\\langle": "\\rangle",
            "\\lfloor": "\\rfloor",
            "\\lceil": "\\rceil",
            "\\vert": "\\vert",
            "\\lvert": "\\rvert",
            "\\Vert": "\\Vert",
            "\\lVert": "\\rVert",
            "\\lbrack": "\\rbrack",
            "\\ulcorner": "\\urcorner",
            "\\llcorner": "\\lrcorner",
            "\\lgroup": "\\rgroup",
            "\\lmoustache": "\\rmoustache"
          }[this.leftDelim ?? "."] ?? this.leftDelim ?? ".";
          classes += " ML__smart-fence__close";
        } else {
          delim = ".";
        }
      }
      boxes.push(this.bind(delimContext, makeLeftRightDelim("mclose", delim, innerHeight, innerDepth, delimContext, {
        classes: classes + " ML__close",
        mode: this.mode,
        style: this.style
      })));
    }
    const result = new Box(boxes, {
      type: this.inner ? "minner" : "mclose",
      classes: "left-right"
    });
    if (this.caret)
      result.caret = this.caret;
    return this.bind(context, result.wrap(context));
  }
};

// src/core-atoms/subsup.ts
var SubsupAtom = class extends Atom {
  constructor(options) {
    super("msubsup", {style: options?.style});
  }
  render(context) {
    console.assert(!this.subsupPlacement);
    const phantomContex = new Context(context, {isPhantom: true});
    const base = this.leftSibling.render(phantomContex) ?? new Box(null);
    const phantom = new Box(null, {height: base.height, depth: base.depth});
    return this.attachSupsub(context, {
      base: phantom,
      isCharacterBox: this.leftSibling.isCharacterBox(),
      type: "supsub"
    });
  }
  serialize(options) {
    return this.supsubToLatex(options);
  }
};

// src/core-atoms/placeholder.ts
var PlaceholderAtom = class extends Atom {
  constructor(options) {
    super("placeholder", {
      mode: options?.mode,
      style: options?.style,
      value: options?.value
    });
    this.captureSelection = true;
    this.value = "\u2B1A";
    this.placeholderId = options?.placeholderId;
    this.defaultValue = options?.default;
  }
  render(context) {
    if (typeof context.renderPlaceholder === "function") {
      return context.renderPlaceholder(context, this);
    }
    return this.createBox(context, {
      classes: this.caret ? "ML__placeholder-selected" : ""
    });
  }
  serialize(_options) {
    const id = this.placeholderId ? `[${this.placeholderId}]` : "";
    const defaultValue = this.defaultValue ? `[${Atom.serialize(this.defaultValue, _options)}]` : "";
    return `\\placeholder${id}${defaultValue}{${this.value ?? ""}}`;
  }
};

// src/core-atoms/error.ts
var ErrorAtom = class extends Atom {
  constructor(value) {
    super("error", {value, command: value, mode: "math"});
    this.verbatimLatex = value;
  }
  render(context) {
    const result = this.createBox(context, {classes: "ML__error"});
    if (this.caret)
      result.caret = this.caret;
    return result;
  }
};

// src/core-atoms/macro.ts
var MacroAtom = class extends Atom {
  constructor(macro, options) {
    super("macro", {command: macro});
    this.body = options.body;
    this.captureSelection = options.captureSelection ?? true;
    this.macroLatex = macro + options.args;
    this.expand = options.expand ?? false;
  }
  serialize(options) {
    return options.expandMacro && this.expand ? this.bodyToLatex(options) : this.macroLatex;
  }
  render(context) {
    const result = Atom.createBox(context, this.body);
    if (!result)
      return null;
    if (this.caret)
      result.caret = this.caret;
    return this.bind(context, result);
  }
};

// src/core-atoms/text.ts
var TextAtom = class extends Atom {
  constructor(command, value, style) {
    super("text", {command, mode: "text", displayContainsHighlight: true});
    this.value = value;
    this.verbatimLatex = value;
    this.applyStyle(style);
  }
  render(context) {
    const result = this.createBox(context);
    if (this.caret)
      result.caret = this.caret;
    return result;
  }
  serialize(_options) {
    return this.verbatimLatex ?? charToLatex("text", this.value.codePointAt(0));
  }
};

// src/core/parser.ts
function isLiteral(token) {
  return !/^<({|}|\$|\$\$|space)>$/.test(token);
}
var Parser = class {
  constructor(tokens, options) {
    this.index = 0;
    this.smartFence = false;
    this.endCount = 0;
    this.tokens = tokens;
    this.args = options.args ?? null;
    this.macros = options.macros;
    this.colorMap = options.colorMap;
    this.backgroundColorMap = options.backgroundColorMap ?? this.colorMap;
    this.smartFence = options.smartFence ?? false;
    this.onError = options.onError ? (err) => options.onError({
      before: tokensToString(this.tokens.slice(this.index, this.index + 10)),
      after: tokensToString(this.tokens.slice(Math.max(0, this.index - 10), this.index)),
      ...err
    }) : () => {
    };
    this._parsingContexts = [
      {
        parseMode: options.parseMode ?? "math",
        mathstyle: options.mathstyle ?? "displaystyle",
        registers: options.registers,
        tabular: false,
        style: options.style ?? {},
        mathlist: []
      }
    ];
  }
  get currentContext() {
    return this._parsingContexts[this._parsingContexts.length - 1];
  }
  beginContext(options) {
    this._parsingContexts.push({
      parseMode: options?.mode ?? this.currentContext.parseMode,
      mathstyle: options?.mathstyle ?? this.currentContext.mathstyle,
      registers: null,
      style: {...this.currentContext.style},
      tabular: options?.tabular ?? false,
      mathlist: []
    });
  }
  endContext() {
    this._parsingContexts.pop();
  }
  get mathlist() {
    return this._parsingContexts[this._parsingContexts.length - 1].mathlist;
  }
  set mathlist(value) {
    this._parsingContexts[this._parsingContexts.length - 1].mathlist = value;
  }
  get parseMode() {
    return this._parsingContexts[this._parsingContexts.length - 1].parseMode;
  }
  set parseMode(value) {
    this._parsingContexts[this._parsingContexts.length - 1].parseMode = value;
  }
  get tabularMode() {
    return this._parsingContexts[this._parsingContexts.length - 1].tabular;
  }
  get style() {
    let i3 = this._parsingContexts.length - 1;
    let result = this._parsingContexts[i3].style;
    while (result === void 0 && i3 > 0) {
      i3 -= 1;
      result = this._parsingContexts[i3].style;
    }
    return result ?? {};
  }
  set style(value) {
    this._parsingContexts[this._parsingContexts.length - 1].style = value;
  }
  getRegister(name) {
    console.assert(name[0] !== "\\");
    if (name.startsWith("global ")) {
      return this._parsingContexts[0].registers?.[name.slice(7)] ?? 0;
    }
    let i3 = this._parsingContexts.length - 1;
    let registers = this._parsingContexts[i3].registers;
    while (i3 >= 0 && registers && registers[name] === void 0) {
      i3 -= 1;
      registers = this._parsingContexts[i3]?.registers;
    }
    return registers?.[name] ?? 0;
  }
  setRegister(name, value) {
    if (name.startsWith("global ")) {
      name = name.slice(7);
      let i3 = this._parsingContexts.length - 1;
      while (i3 > 0) {
        if (this._parsingContexts[i3].registers) {
          delete this._parsingContexts[i3].registers[name];
        }
        i3 -= 1;
      }
      this._parsingContexts[0].registers[name] = value;
      return;
    }
    if (!this._parsingContexts[this._parsingContexts.length - 1].registers) {
      this._parsingContexts[this._parsingContexts.length - 1].registers = {};
    }
    this._parsingContexts[this._parsingContexts.length - 1].registers[name] = value;
  }
  end() {
    this.endCount++;
    return this.index >= this.tokens.length || this.endCount > 1e3;
  }
  get() {
    this.endCount = 0;
    return this.index < this.tokens.length ? this.tokens[this.index++] : "";
  }
  peek() {
    return this.tokens[this.index];
  }
  match(input) {
    if (this.tokens[this.index] === input) {
      this.index++;
      return true;
    }
    return false;
  }
  lastSubsupAtom() {
    let atom;
    if (this.mathlist.length > 0) {
      atom = this.mathlist[this.mathlist.length - 1];
      if (atom.type === "msubsup")
        return atom;
      if (atom.subsupPlacement !== void 0)
        return atom;
    }
    atom = new SubsupAtom({style: this.style});
    this.mathlist.push(atom);
    return atom;
  }
  hasPattern(pattern) {
    return pattern.test(this.tokens[this.index]);
  }
  hasInfixCommand() {
    const {index} = this;
    if (index < this.tokens.length && this.tokens[index].startsWith("\\")) {
      const info = getInfo(this.tokens[index], this.parseMode, this.macros);
      if (!info)
        return false;
      if (info.ifMode && !info.ifMode.includes(this.parseMode)) {
        return false;
      }
      return info.infix ?? false;
    }
    return false;
  }
  matchColumnSeparator() {
    const {index} = this;
    if (this.tabularMode && this.tokens[index] === "&") {
      this.index++;
      return true;
    }
    return false;
  }
  matchRowSeparator() {
    const {index} = this;
    if (this.tabularMode && (this.tokens[index] === "\\\\" || this.tokens[index] === "\\cr")) {
      this.index++;
      return true;
    }
    return false;
  }
  placeholder() {
    const placeHolderArg = this.args?.("?");
    if (!placeHolderArg) {
      return [
        new PlaceholderAtom({
          mode: this.parseMode,
          style: this.style
        })
      ];
    }
    return parseLatex(placeHolderArg, {
      parseMode: this.parseMode,
      onError: this.onError,
      registers: this.currentContext.registers,
      mathstyle: "textstyle",
      colorMap: this.colorMap,
      backgroundColorMap: this.backgroundColorMap
    });
  }
  matchWhitespace() {
    let found = false;
    while (this.match("<space>")) {
      found = true;
    }
    return found;
  }
  skipUntilToken(input) {
    let token = this.tokens[this.index];
    while (token && token !== input) {
      token = this.tokens[++this.index];
    }
    if (token === input) {
      this.index++;
    }
  }
  skipFiller() {
    let done = false;
    do {
      const skippedSpace = this.matchWhitespace();
      const skippedRelax = this.match("\\relax");
      done = !skippedSpace && !skippedRelax;
    } while (!done);
  }
  matchKeyword(keyword) {
    const savedIndex = this.index;
    let done = this.end();
    let value = "";
    while (!done) {
      const token = this.get();
      if (isLiteral(token)) {
        value += token;
        done = this.end() || value.length >= keyword.length;
      } else {
        done = true;
      }
    }
    const hasKeyword = keyword.toUpperCase() === value.toUpperCase();
    if (!hasKeyword) {
      this.index = savedIndex;
    }
    return hasKeyword;
  }
  scanString() {
    let result = "";
    while (!this.end()) {
      if (this.match("<space>")) {
        result += " ";
      } else {
        const token = this.peek();
        if (token === "]")
          break;
        if (isLiteral(token)) {
          result += this.get();
        } else if (token.startsWith("\\")) {
          this.onError({code: "unbalanced-braces"});
          result += this.get();
        } else {
          break;
        }
      }
    }
    return result;
  }
  scanBalancedString() {
    let result = "";
    let done = this.end();
    let level = 1;
    while (!done) {
      if (this.match("<space>")) {
        result += " ";
      } else {
        const token = this.get();
        if (token === "<{>") {
          result += "{";
          level += 1;
        } else if (token === "<}>") {
          level -= 1;
          if (level > 0) {
            result += "}";
          } else {
            this.index -= 1;
          }
        } else if (token === "<$>") {
          result += "$";
        } else if (token === "<$$>") {
          result += "$$";
        } else {
          result += token;
        }
      }
      done = level === 0 || this.end();
    }
    return result;
  }
  matchLiteralArg() {
    let result = "";
    if (this.match("<{>")) {
      let depth = 1;
      while (depth > 0 && !this.end()) {
        const token = this.get();
        if (token === "<}>") {
          depth -= 1;
          if (depth > 0) {
            result += "}";
          }
        } else if (token === "<{>") {
          depth += 1;
          result += "{";
        } else {
          result += {
            "<space>": " ",
            "<$$>": "$$",
            "<$>": "$"
          }[token] ?? token;
        }
      }
    }
    return result;
  }
  scanNumber(isInteger = true) {
    let negative = false;
    let token = this.peek();
    while (token === "<space>" || token === "+" || token === "-") {
      this.get();
      if (token === "-")
        negative = !negative;
      token = this.peek();
    }
    isInteger = Boolean(isInteger);
    let radix = 10;
    let digits = /\d/;
    if (this.match("'")) {
      radix = 8;
      digits = /[0-7]/;
      isInteger = true;
    } else if (this.match('"') || this.match("x")) {
      radix = 16;
      digits = /[\dA-F]/;
      isInteger = true;
    } else if (this.match("`")) {
      token = this.get();
      if (token) {
        if (token.startsWith("\\") && token.length === 2) {
          return (negative ? -1 : 1) * (token.codePointAt(1) ?? 0);
        }
        return (negative ? -1 : 1) * (token.codePointAt(0) ?? 0);
      }
      return null;
    }
    let value = "";
    while (this.hasPattern(digits)) {
      value += this.get();
    }
    if (!isInteger && (this.match(".") || this.match(","))) {
      value += ".";
      while (this.hasPattern(digits)) {
        value += this.get();
      }
    }
    const result = isInteger ? Number.parseInt(value, radix) : Number.parseFloat(value);
    if (Number.isNaN(result))
      return null;
    return negative ? -result : result;
  }
  scanDimen() {
    let value = this.scanNumber(false);
    if (value === null) {
      if (this.peek()?.startsWith("\\")) {
        value = 1;
      } else {
        return null;
      }
    }
    this.matchWhitespace();
    let result;
    if (this.matchKeyword("pt")) {
      result = {dimension: value, unit: "pt"};
    } else if (this.matchKeyword("mm")) {
      result = {dimension: value, unit: "mm"};
    } else if (this.matchKeyword("cm")) {
      result = {dimension: value, unit: "cm"};
    } else if (this.matchKeyword("ex")) {
      result = {dimension: value, unit: "ex"};
    } else if (this.matchKeyword("px")) {
      result = {dimension: value, unit: "px"};
    } else if (this.matchKeyword("em")) {
      result = {dimension: value, unit: "em"};
    } else if (this.matchKeyword("bp")) {
      result = {dimension: value, unit: "bp"};
    } else if (this.matchKeyword("dd")) {
      result = {dimension: value, unit: "dd"};
    } else if (this.matchKeyword("pc")) {
      result = {dimension: value, unit: "pc"};
    } else if (this.matchKeyword("in")) {
      result = {dimension: value, unit: "in"};
    } else if (this.matchKeyword("mu")) {
      result = {dimension: value, unit: "mu"};
    } else {
      if (this.peek()?.startsWith("\\")) {
        result = convertToDimension(this.getRegister(this.get().slice(1)), this.currentContext.registers) ?? {dimension: 0};
        result.dimension *= value;
      } else {
        if (!this.match("\\relax")) {
          this.onError({code: "missing-unit"});
        }
        result = {dimension: value, unit: "pt"};
      }
    }
    return result;
  }
  scanGlue() {
    const dimen = this.scanDimen();
    if (dimen === null)
      return null;
    const result = {glue: dimen};
    this.matchWhitespace();
    if (this.match("\\relax"))
      return result;
    if (this.matchKeyword("plus")) {
      this.scanDimen();
    }
    this.matchWhitespace();
    if (this.match("\\relax"))
      return result;
    this.matchWhitespace();
    if (this.matchKeyword("minus")) {
      this.scanDimen();
    }
    return result;
  }
  scanColspec() {
    this.matchWhitespace();
    const result = [];
    while (!this.end() && !(this.peek() === "<}>" || this.peek() === "]")) {
      const literal = this.get();
      if (literal === "c" || literal === "r" || literal === "l") {
        result.push({align: literal});
      } else if (literal === "|") {
        result.push({separator: "solid"});
      } else if (literal === ":") {
        result.push({separator: "dashed"});
      } else if (literal === "@") {
        if (this.match("<{>")) {
          this.beginContext({mode: "math"});
          result.push({
            gap: this.parse((token) => token === "<}>")
          });
          this.endContext();
        }
        if (!this.match("<}>")) {
          this.onError({code: "unbalanced-braces"});
        }
      }
    }
    return result;
  }
  parseModeSet() {
    let final = "";
    if (this.match("\\("))
      final = "\\)";
    if (!final && this.match("\\["))
      final = "\\]";
    if (!final)
      return null;
    this.beginContext({
      mode: "math",
      mathstyle: final === "\\)" ? "textstyle" : "displaystyle"
    });
    const result = new GroupAtom(this.parse((token) => token === final), {
      mathstyleName: final === "\\)" ? "textstyle" : "displaystyle",
      latexOpen: final === "\\]" ? "\\[" : "\\(",
      latexClose: final,
      boxType: "mord"
    });
    if (!this.match(final)) {
      this.onError({code: "unbalanced-mode-shift"});
    }
    this.endContext();
    if (result.hasEmptyBranch("body"))
      return null;
    return result;
  }
  parseModeShift() {
    let final = "";
    if (this.match("<$>"))
      final = "<$>";
    if (!final && this.match("<$$>"))
      final = "<$$>";
    if (!final)
      return null;
    this.beginContext({
      mode: "math",
      mathstyle: "<$>" ? "textstyle" : "displaystyle"
    });
    const result = new GroupAtom(this.parse((token) => token === final), {
      mathstyleName: final === "<$>" ? "textstyle" : "displaystyle",
      latexOpen: final === "<$>" ? "$ " : "$$ ",
      latexClose: final === "<$>" ? " $" : " $$"
    });
    if (!this.match(final)) {
      this.onError({code: "unbalanced-mode-shift"});
    }
    this.endContext();
    if (result.hasEmptyBranch("body"))
      return null;
    return result;
  }
  parseEnvironment() {
    if (!this.match("\\begin"))
      return null;
    const envName = this.parseArgument("string");
    if (!envName)
      return null;
    const def = getEnvironmentDefinition(envName);
    if (!def) {
      this.onError({
        code: "unknown-environment",
        arg: envName
      });
      return null;
    }
    const args = [];
    if (def.params) {
      for (const parameter of def.params) {
        if (parameter.isOptional) {
          args.push(this.parseOptionalArgument(parameter.type));
        } else {
          const arg = this.parseArgument(parameter.type);
          if (!arg) {
            this.onError({
              code: "missing-argument",
              arg: envName
            });
          }
          args.push(arg);
        }
      }
    }
    this.beginContext({tabular: def.tabular});
    const array = [];
    const rowGaps = [];
    let row = [];
    let done = false;
    do {
      if (this.end()) {
        this.onError({code: "unbalanced-environment", arg: envName});
        done = true;
      }
      if (!done && this.match("\\end")) {
        if (this.parseArgument("string") !== envName) {
          this.onError({
            code: "unbalanced-environment",
            arg: envName
          });
        }
        done = true;
      }
      if (!done) {
        if (this.matchColumnSeparator()) {
          row.push(this.mathlist);
          this.mathlist = [];
        } else if (this.matchRowSeparator()) {
          row.push(this.mathlist);
          this.mathlist = [];
          let gap = null;
          this.matchWhitespace();
          if (this.match("[")) {
            gap = this.scanDimen();
            this.matchWhitespace();
            this.match("]");
          }
          rowGaps.push(gap ?? {dimension: 0});
          array.push(row);
          row = [];
        } else {
          this.mathlist = this.mathlist.concat(this.parse((token) => token === "<}>" || token === "&" || token === "\\end" || token === "\\cr" || token === "\\\\"));
        }
      }
    } while (!done);
    row.push(this.mathlist);
    if (row.length > 0)
      array.push(row);
    this.endContext();
    return def.createAtom(envName, array, rowGaps, args);
  }
  parse(done) {
    this.beginContext();
    if (!done) {
      done = (token) => token === "<}>";
    }
    let infix = "";
    let infixInfo = null;
    let infixArgs = [];
    let prefix = null;
    const saveAtoms = this.mathlist;
    this.mathlist = [];
    while (!this.end() && !done(this.peek())) {
      if (this.hasInfixCommand() && !infix) {
        infix = this.get();
        infixInfo = getInfo(infix, "math", this.macros);
        if (infixInfo) {
          infixArgs = this.parseArguments(infixInfo)[1];
        }
        prefix = this.mathlist;
        this.mathlist = [];
      } else {
        this.parseToken();
      }
    }
    let result;
    if (infix) {
      console.assert(Boolean(infixInfo));
      infixArgs.unshift(this.mathlist);
      this.mathlist = saveAtoms;
      if (prefix)
        infixArgs.unshift(prefix);
      result = [
        infixInfo.createAtom(infix, infixArgs, this.style, {
          colorMap: this.colorMap,
          backgroundColorMap: this.backgroundColorMap
        })
      ];
    } else {
      result = this.mathlist;
      this.mathlist = saveAtoms;
    }
    this.endContext();
    return result;
  }
  parseGroup() {
    if (!this.match("<{>"))
      return null;
    const result = new GroupAtom(this.parse((token) => token === "<}>"), {
      mode: this.parseMode,
      latexOpen: "{",
      latexClose: "}"
    });
    if (!this.match("<}>")) {
      this.onError({code: "unbalanced-braces"});
    }
    return result;
  }
  scanSmartFence() {
    this.matchWhitespace();
    if (!this.match("("))
      return null;
    this.beginContext();
    let nestLevel = 1;
    while (!this.end() && nestLevel !== 0) {
      if (this.match("("))
        nestLevel += 1;
      if (this.match(")"))
        nestLevel -= 1;
      if (nestLevel !== 0)
        this.parseToken();
    }
    if (nestLevel === 0)
      this.match(")");
    const result = new LeftRightAtom(this.mathlist, {
      inner: false,
      leftDelim: "(",
      rightDelim: nestLevel === 0 ? ")" : "?"
    });
    this.endContext();
    return result;
  }
  scanDelim() {
    this.matchWhitespace();
    const token = this.get();
    if (!token) {
      this.onError({code: "unexpected-end-of-string"});
      return null;
    }
    let delim = ".";
    if (token.startsWith("\\") || isLiteral(token)) {
      delim = token;
    }
    const info = getInfo(delim, "math", this.macros);
    if (!info) {
      this.onError({code: "unknown-command", arg: delim});
      return null;
    }
    if (info.ifMode && !info.ifMode.includes(this.parseMode)) {
      this.onError({code: "unexpected-delimiter", arg: delim});
      return null;
    }
    if (info.type === "mopen" || info.type === "mclose") {
      return delim;
    }
    if (/^(\.|\?|\||<|>|\\vert|\\Vert|\\\||\\surd|\\uparrow|\\downarrow|\\Uparrow|\\Downarrow|\\updownarrow|\\Updownarrow|\\mid|\\mvert|\\mVert)$/.test(delim)) {
      return delim;
    }
    this.onError({code: "unexpected-delimiter", arg: delim});
    return null;
  }
  parseLeftRight() {
    if (this.match("\\right") || this.match("\\mright")) {
      this.onError({code: "unbalanced-braces"});
      return null;
    }
    let close = "\\right";
    if (!this.match("\\left")) {
      if (!this.match("\\mleft"))
        return null;
      close = "\\mright";
    }
    const leftDelim = this.scanDelim();
    if (!leftDelim)
      return null;
    this.beginContext();
    while (!this.end() && !this.match(close)) {
      this.parseToken();
    }
    const body = this.mathlist;
    this.endContext();
    const rightDelim = this.scanDelim() ?? ".";
    return new LeftRightAtom(body, {
      leftDelim,
      rightDelim,
      inner: close === "\\right",
      style: this.style
    });
  }
  parseSupSub() {
    if (this.parseMode !== "math")
      return false;
    let token = this.peek();
    if (token !== "^" && token !== "_" && token !== "'")
      return false;
    while (token === "^" || token === "_" || token === "'") {
      if (this.match("'")) {
        if (this.match("'")) {
          this.lastSubsupAtom().addChild(new Atom("mord", {
            command: "\\doubleprime",
            mode: "math",
            value: "\u2032\u2032"
          }), "superscript");
        } else {
          this.lastSubsupAtom().addChild(new Atom("mord", {
            command: "\\prime",
            mode: "math",
            value: "\u2032"
          }), "superscript");
        }
      } else if (this.match("^") || this.match("_")) {
        const arg = this.parseArgument("math");
        if (arg) {
          this.lastSubsupAtom().addChildren(arg, token === "_" ? "subscript" : "superscript");
        } else {
          this.lastSubsupAtom().createBranch(token === "_" ? "subscript" : "superscript");
        }
      }
      token = this.peek();
    }
    return true;
  }
  parseLimits() {
    const isLimits = this.match("\\limits");
    const isNoLimits = !isLimits && this.match("\\nolimits");
    const isDisplayLimits = !isNoLimits && !isLimits && this.match("\\displaylimits");
    if (!isLimits && !isNoLimits && !isDisplayLimits)
      return false;
    const opAtom = this.mathlist.length > 0 ? this.mathlist[this.mathlist.length - 1] : null;
    if (opAtom === null || opAtom.type !== "mop")
      return false;
    if (isLimits) {
      opAtom.subsupPlacement = "over-under";
      opAtom.explicitSubsupPlacement = true;
      return true;
    }
    if (isNoLimits) {
      opAtom.subsupPlacement = "adjacent";
      opAtom.explicitSubsupPlacement = true;
      return true;
    }
    if (isDisplayLimits) {
      opAtom.subsupPlacement = "auto";
      opAtom.explicitSubsupPlacement = true;
      return true;
    }
    return false;
  }
  parseArguments(info) {
    if (!info || !info.params)
      return [void 0, []];
    let explicitGroup = void 0;
    const args = [];
    let i3 = info.infix ? 2 : 0;
    while (i3 < info.params.length) {
      const parameter = info.params[i3];
      if (parameter.type === "rest") {
        args.push(this.parse((token) => token === "<}>" || token === "&" || token === "\\end" || token === "\\cr" || token === "\\\\"));
      } else if (parameter.isOptional) {
        args.push(this.parseOptionalArgument(parameter.type));
      } else if (parameter.type.endsWith("*")) {
        explicitGroup = parameter.type.slice(0, -1);
      } else {
        const arg = this.parseArgument(parameter.type);
        if (arg !== null) {
          args.push(arg);
        } else {
          this.onError({code: "missing-argument"});
          switch (parameter.type) {
            case "number":
              args.push(0);
              break;
            case "dimen":
              args.push({dimension: 0, unit: "pt"});
              break;
            case "glue":
              args.push({glue: {dimension: 0, unit: "pt"}});
              break;
            case "string":
            case "balanced-string":
              args.push("");
              break;
            case "delim":
              args.push(".");
              break;
            case "colspec":
              args.push("llllllllll");
              break;
            case "auto":
            default:
              args.push(this.placeholder());
              break;
          }
        }
      }
      i3 += 1;
    }
    return [explicitGroup, args];
  }
  parseArgument(argType) {
    this.skipFiller();
    argType = argType === "auto" ? this.parseMode : argType;
    let result = null;
    if (!this.match("<{>")) {
      if (argType === "delim") {
        return this.scanDelim() ?? ".";
      }
      if (argType === "text" || argType === "math") {
        this.beginContext();
        const atom = this.parseSimpleToken();
        this.endContext();
        return atom;
      }
    }
    if (argType === "text" || argType === "math") {
      this.beginContext({mode: argType});
      const initialIndex = this.index;
      let depth = 1;
      do {
        const token = this.get();
        if (token === "<}>")
          depth -= 1;
        if (token === "<{>")
          depth += 1;
      } while (depth > 0 && !this.end());
      result = Mode.parseTokens(argType, this.tokens.slice(initialIndex, this.index - 1), this.onError, {
        args: this.args ?? (() => ""),
        macros: this.macros ?? {},
        smartFence: this.smartFence,
        style: this.style,
        parse: (mode, tokens, options) => {
          const parser = new Parser(tokens, {
            args: options.args,
            parseMode: mode,
            smartFence: this.smartFence,
            macros: options.macros,
            registers: this.currentContext.registers,
            mathstyle: this.currentContext.mathstyle,
            colorMap: this.colorMap,
            backgroundColorMap: this.backgroundColorMap,
            style: options.style,
            onError: this.onError
          });
          result = parser.parse();
          return [result, tokens.slice(parser.index)];
        }
      });
      if (!result) {
        this.index = initialIndex;
        do {
          this.mathlist = this.mathlist.concat(this.parse());
        } while (!this.match("<}>") && !this.end());
      }
    } else {
      this.beginContext();
      if (argType === "string") {
        result = this.scanString();
      } else if (argType === "balanced-string") {
        result = this.scanBalancedString();
      } else if (argType === "number") {
        result = this.scanNumber();
      } else if (argType === "colspec") {
        result = this.scanColspec();
      } else if (argType === "dimen") {
        result = this.scanDimen();
      } else if (argType === "glue") {
        result = this.scanGlue();
      } else if (argType === "delim") {
        result = this.scanDelim() ?? ".";
      }
      if (result === null) {
        this.endContext();
        return null;
      }
      this.skipUntilToken("<}>");
    }
    const atoms = this.mathlist;
    this.endContext();
    return result ?? atoms;
  }
  parseOptionalArgument(argType) {
    argType = argType === "auto" ? this.parseMode : argType;
    this.matchWhitespace();
    if (!this.match("["))
      return null;
    let result = null;
    while (!this.end() && !this.match("]")) {
      if (argType === "string") {
        result = this.scanString();
      } else if (argType === "number") {
        result = this.scanNumber();
      } else if (argType === "dimen") {
        result = this.scanDimen();
      } else if (argType === "glue") {
        result = this.scanGlue();
      } else if (argType === "colspec") {
        result = this.scanColspec();
      } else if (argType === "bbox") {
        const list = this.scanString().toLowerCase().trim().split(/,(?![^(]*\)(?:(?:[^(]*\)){2})*[^"]*$)/);
        const bboxParameter = {};
        for (const element of list) {
          const color = this.backgroundColorMap?.(element);
          if (color) {
            bboxParameter.backgroundcolor = color;
          } else {
            const m3 = element.match(/^\s*([\d.]+)\s*([a-z]{2})/);
            if (m3) {
              bboxParameter.padding = m3[0];
            } else {
              const m4 = element.match(/^\s*border\s*:\s*(.*)/);
              if (m4) {
                bboxParameter.border = m4[1];
              }
            }
          }
        }
        result = bboxParameter;
      } else if (argType === "math") {
        this.beginContext({mode: "math"});
        result = this.mathlist.concat(this.parse((token) => token === "]"));
        this.endContext();
      }
    }
    return result;
  }
  parseCommand(command) {
    let result = null;
    if (command === "\\placeholder") {
      const placeholder = new PlaceholderAtom({
        mode: this.parseMode,
        placeholderId: this.parseOptionalArgument("string"),
        default: this.parseOptionalArgument("math"),
        value: this.parseArgument("string") ?? void 0,
        style: this.style
      });
      return [placeholder];
    }
    if (command === "\\char") {
      const initialIndex2 = this.index;
      let codepoint = Math.floor(this.scanNumber(true) ?? Number.NaN);
      if (!Number.isFinite(codepoint) || codepoint < 0 || codepoint > 1114111) {
        codepoint = 10067;
      }
      const verbatimLatex = "\\char" + tokensToString(this.tokens.slice(initialIndex2, this.index));
      result = new Atom(this.parseMode === "math" ? "mord" : "text", {
        command: "\\char",
        mode: this.parseMode,
        value: String.fromCodePoint(codepoint),
        serialize: () => verbatimLatex
      });
      result.verbatimLatex = verbatimLatex;
      return [result];
    }
    if (command === "\\hskip" || command === "\\kern") {
      const width = this.scanGlue();
      if (!width)
        return null;
      return [new SpacingAtom(command, this.style, width)];
    }
    result = this.scanMacro(command);
    if (result)
      return [result];
    const info = getInfo(command, this.parseMode, {});
    if (!info) {
      this.onError({
        code: "unknown-command",
        arg: command
      });
      return [new ErrorAtom(command)];
    }
    if (info.ifMode && !info.ifMode.includes(this.parseMode)) {
      return [];
    }
    const savedMode = this.parseMode;
    if (info.applyMode) {
      this.parseMode = info.applyMode;
    }
    const initialIndex = this.index;
    const [deferredArg, args] = this.parseArguments(info);
    this.parseMode = savedMode;
    if (!args)
      return null;
    if (info.applyMode && !info.applyStyle && !info.createAtom) {
      return args[0];
    }
    if (info.infix) {
      this.onError({
        code: "too-many-infix-commands",
        arg: command
      });
      return null;
    }
    if (typeof info.createAtom === "function") {
      result = info.createAtom(command, args, this.style, {
        colorMap: this.colorMap,
        backgroundColorMap: this.backgroundColorMap
      });
      if (deferredArg) {
        result.body = this.parseArgument(deferredArg) ?? void 0;
      }
    } else if (typeof info.applyStyle === "function") {
      const style = info.applyStyle(command, args, {
        colorMap: this.colorMap,
        backgroundColorMap: this.backgroundColorMap
      });
      const savedMode2 = this.parseMode;
      if (info.applyMode) {
        this.parseMode = info.applyMode;
      }
      if (deferredArg) {
        const saveStyle = this.style;
        this.style = {...this.style, ...style};
        const atoms = this.parseArgument(deferredArg);
        this.style = saveStyle;
        this.parseMode = savedMode2;
        return atoms;
      }
      this.style = {...this.style, ...style};
      this.parseMode = savedMode2;
    } else {
      const style = {...this.style};
      if (info.variant) {
        style.variant = info.variant;
      }
      result = new Atom(info.type ?? "mop", {
        command,
        style,
        value: info.codepoint ? String.fromCodePoint(info.codepoint) : command,
        mode: info.applyMode ?? this.parseMode
      });
    }
    if (result instanceof Atom && !result.verbatimLatex && !/^\\(llap|rlap|class|cssId|htmlData)$/.test(command)) {
      result.verbatimLatex = (result.command ?? "") + tokensToString(this.tokens.slice(initialIndex, this.index));
      if (result.isFunction && this.smartFence) {
        const smartFence = this.scanSmartFence();
        if (smartFence)
          return [result, smartFence];
      }
    }
    if (!result)
      return null;
    return [result];
  }
  parseLiteral(literal) {
    const result = Mode.createAtom(this.parseMode, literal, {
      ...this.style
    });
    if (!result)
      return null;
    if (result.isFunction && this.smartFence) {
      const smartFence = this.scanSmartFence();
      if (smartFence)
        return [result, smartFence];
    }
    return [result];
  }
  parseSimpleToken() {
    const token = this.get();
    if (!token)
      return null;
    if (token === "<space>") {
      if (this.parseMode === "text") {
        return [new TextAtom(" ", " ", this.style)];
      }
      return null;
    }
    if (token.startsWith("\\"))
      return this.parseCommand(token);
    if (isLiteral(token))
      return this.parseLiteral(token);
    if (token === "<}>") {
      this.onError({latex: "", code: "unbalanced-braces"});
    } else {
      this.onError({
        latex: "",
        code: "unexpected-token",
        arg: token
      });
    }
    return null;
  }
  scanMacro(macro) {
    const macroName = macro.slice(1);
    if (!this.macros || !this.macros[macroName])
      return null;
    const initialIndex = this.index;
    const def = this.macros[macroName].def;
    const argCount = this.macros[macroName].args;
    const args = {};
    for (let i3 = 1; i3 <= argCount; i3++) {
      args[i3] = this.matchLiteralArg();
    }
    args["?"] = this.args?.("?");
    return new MacroAtom(macro, {
      expand: this.macros[macroName].expand,
      captureSelection: this.macros[macroName].captureSelection,
      args: tokensToString(this.tokens.slice(initialIndex, this.index)),
      body: parseLatex(def, {
        parseMode: this.parseMode,
        args: (arg) => args[arg],
        macros: this.macros,
        registers: this.currentContext.registers ?? null,
        mathstyle: this.currentContext.mathstyle,
        colorMap: this.colorMap,
        backgroundColorMap: this.backgroundColorMap,
        onError: this.onError
      })
    });
  }
  parseToken() {
    let result = this.parseEnvironment() ?? this.parseModeShift() ?? this.parseModeSet() ?? this.parseGroup() ?? this.parseLeftRight();
    if (result === null) {
      if (this.parseSupSub())
        return true;
      if (this.parseLimits())
        return true;
      result = this.parseSimpleToken();
    }
    if (isArray(result)) {
      this.mathlist = this.mathlist.concat(result);
    } else if (result) {
      this.mathlist.push(result);
    }
    return result !== null;
  }
};
function parseLatex(s3, options) {
  const parser = new Parser(tokenize(s3, options?.args ?? null), {
    args: options?.args ?? null,
    macros: getMacros(options?.macros),
    registers: options?.registers ?? null,
    mathstyle: options?.mathstyle ?? "displaystyle",
    colorMap: options?.colorMap ?? defaultColorMap,
    parseMode: options?.parseMode ?? "math",
    smartFence: options?.smartFence,
    backgroundColorMap: options?.backgroundColorMap ?? options?.colorMap ?? defaultBackgroundColorMap,
    onError: (err) => {
      if (typeof options?.onError === "function") {
        options.onError({...err, latex: s3});
      } else {
      }
    }
  });
  let atoms = [];
  while (!parser.end()) {
    const more = parser.parse();
    if (!more)
      break;
    atoms = atoms.concat(more);
  }
  return atoms;
}
function convertToGlue(value, registers) {
  if (typeof value === "object" && "glue" in value)
    return value;
  if (typeof value === "object" && "dimension" in value) {
    return {glue: value};
  }
  if (typeof value === "number")
    return {glue: {dimension: value}};
  const parser = new Parser(tokenize(value), {registers});
  return parser.scanGlue();
}
function convertToDimension(value, registers) {
  if (typeof value === "number")
    return {dimension: value, unit: "pt"};
  if (typeof value === "object" && "glue" in value) {
    value = value.glue;
  }
  if (typeof value === "object" && "dimension" in value) {
    return value;
  }
  const parser = new Parser(tokenize(value), {registers});
  return parser.scanDimen();
}

// src/core-atoms/accent.ts
var AccentAtom = class extends Atom {
  constructor(command, body, options) {
    super("accent", {command, style: options.style});
    if (options.accentChar) {
      this.accent = options.accentChar;
    } else {
      this.svgAccent = options?.svgAccent;
    }
    this.body = body;
    this.skipBoundary = true;
  }
  render(parentContext) {
    const context = new Context(parentContext, this.style, "cramp");
    const base = Atom.createBox(context, this.body) ?? new Box(null);
    let skew = 0;
    if (!this.hasEmptyBranch("body") && this.body.length === 2 && this.body[1].isCharacterBox()) {
      skew = base.skew;
    }
    let clearance = Math.min(base.height, X_HEIGHT);
    let accentBox;
    if (this.svgAccent) {
      accentBox = makeSVGBox(this.svgAccent);
      clearance = context.metrics.bigOpSpacing1 - clearance;
    } else if (this.accent) {
      const accent = new Box(this.accent, {fontFamily: "Main-Regular"});
      accent.italic = 0;
      const vecClass = this.accent === 8407 ? " ML__accent-vec" : "";
      accentBox = new Box(new Box(accent), {
        classes: "ML__accent-body" + vecClass
      });
    }
    accentBox = new VBox({
      shift: 0,
      children: [
        {box: new Box(base)},
        -clearance,
        {
          box: accentBox,
          marginLeft: base.left + 2 * skew,
          classes: ["ML__center"]
        }
      ]
    });
    const result = new Box(accentBox, {newList: true, type: "mord"});
    if (this.caret)
      result.caret = this.caret;
    this.bind(context, result.wrap(context));
    return this.attachSupsub(context, {base: result});
  }
};

// src/core-atoms/overunder.ts
var OverunderAtom = class extends Atom {
  constructor(command, options) {
    super("overunder", {
      command,
      serialize: options.serialize,
      style: options.style
    });
    this.skipBoundary = options.skipBoundary ?? true;
    this.subsupPlacement = options.supsubPlacement;
    this.body = options.body;
    this.svgAbove = options.svgAbove;
    this.svgBelow = options.svgBelow;
    this.svgBody = options.svgBody;
    this.above = options.above;
    this.below = options.below;
    this.boxType = options.boxType ?? "mord";
    this.padded = options.padded ?? false;
  }
  render(parentContext) {
    let body = this.svgBody ? makeSVGBox(this.svgBody) : Atom.createBox(parentContext, this.body, {newList: true});
    const annotationContext = new Context(parentContext, this.style, "scriptstyle");
    let above = null;
    if (this.svgAbove) {
      above = makeSVGBox(this.svgAbove);
    } else if (this.above) {
      above = Atom.createBox(annotationContext, this.above, {newList: true});
    }
    let below = null;
    if (this.svgBelow) {
      below = makeSVGBox(this.svgBelow);
    } else if (this.below) {
      below = Atom.createBox(annotationContext, this.below, {newList: true});
    }
    if (this.padded) {
      body = new Box([
        makeNullDelimiter(parentContext, "mopen"),
        body,
        makeNullDelimiter(parentContext, "mclose")
      ], {newList: true});
    }
    let base = makeOverunderStack(parentContext, {
      base: body,
      above,
      below,
      type: this.boxType === "mbin" || this.boxType === "mrel" ? this.boxType : "mord"
    });
    if (!base)
      return null;
    if (this.subsupPlacement === "over-under") {
      base = this.attachLimits(parentContext, {base, type: base.type});
    } else {
      base = this.attachSupsub(parentContext, {base});
    }
    if (this.caret)
      base.caret = this.caret;
    return this.bind(parentContext, base);
  }
};
function makeOverunderStack(context, options) {
  if (!options.base)
    return null;
  if (!options.above && !options.below) {
    const box = new Box(options.base, {type: options.type});
    box.setStyle("position", "relative");
    return box;
  }
  let aboveShift = 0;
  if (options.above) {
    aboveShift = -options.above.depth + context.metrics.bigOpSpacing2;
  }
  let result = null;
  const base = options.base;
  const baseShift = 0;
  if (options.below && options.above) {
    const bottom = context.metrics.bigOpSpacing5 + options.below.height + options.below.depth + base.depth + baseShift;
    result = new VBox({
      bottom,
      children: [
        context.metrics.bigOpSpacing5,
        {box: options.below, classes: ["ML__center"]},
        {box: base, classes: ["ML__center"]},
        aboveShift,
        {box: options.above, classes: ["ML__center"]},
        context.metrics.bigOpSpacing5
      ]
    });
  } else if (options.below) {
    result = new VBox({
      top: base.height - baseShift,
      children: [
        context.metrics.bigOpSpacing5,
        {box: options.below, classes: ["ML__center"]},
        {box: base, classes: ["ML__center"]}
      ]
    });
  } else if (options.above) {
    result = new VBox({
      bottom: base.depth + baseShift,
      children: [
        {box: base, classes: ["ML__center"]},
        aboveShift,
        {box: options.above, classes: ["ML__center"]},
        context.metrics.bigOpSpacing5
      ]
    });
  }
  return new Box(result, {type: options.type});
}

// src/core-atoms/box.ts
var BoxAtom = class extends Atom {
  constructor(command, body, options) {
    super("box", {
      command,
      serialize: options.serialize,
      style: options.style
    });
    this.body = body;
    this.framecolor = options.framecolor;
    this.verbatimFramecolor = options.verbatimBackgroundcolor;
    this.backgroundcolor = options.backgroundcolor;
    this.verbatimBackgroundcolor = options.verbatimBackgroundcolor;
    this.padding = options.padding;
    this.border = options.border;
  }
  render(parentContext) {
    const context = new Context(parentContext, this.style);
    const fboxsep = convertDimensionToEm(context.getRegisterAsDimension("fboxsep"));
    const padding = this.padding === void 0 ? fboxsep : convertDimensionToEm(convertToDimension(this.padding, parentContext.registers));
    const content = Atom.createBox(parentContext, this.body);
    if (!content)
      return null;
    content.setStyle("vertical-align", -content.height, "em");
    const base = new Box(content, {type: "mord"});
    const box = new Box(null, {classes: "ML__box"});
    box.height = base.height + padding;
    box.depth = base.depth + padding;
    box.setStyle("box-sizing", "border-box");
    box.setStyle("position", "absolute");
    box.setStyle("height", base.height + base.depth + 2 * padding, "em");
    if (padding === 0) {
      box.setStyle("width", "100%");
    } else {
      box.setStyle("width", `calc(100% + ${2 * padding}em)`);
      box.setStyle("top", fboxsep, "em");
      box.setStyle("left", -padding, "em");
    }
    box.setStyle("z-index", "-1");
    if (this.backgroundcolor) {
      box.setStyle("background-color", this.backgroundcolor);
    }
    if (this.framecolor) {
      box.setStyle("border", `${convertDimensionToEm(context.getRegisterAsDimension("fboxrule"))}em solid ${this.framecolor}`);
    }
    if (this.border)
      box.setStyle("border", this.border);
    base.setStyle("display", "inline-block");
    base.setStyle("height", content.height + content.depth, "em");
    base.setStyle("vertical-align", -padding, "em");
    const result = new Box([box, base]);
    result.setStyle("position", "relative");
    result.setStyle("display", "inline-block");
    result.setStyle("line-height", 0);
    result.height = base.height + padding;
    result.depth = base.depth + padding;
    result.left = padding;
    result.right = padding;
    result.setStyle("height", base.height + padding, "em");
    result.setStyle("top", base.depth - base.height, "em");
    result.setStyle("vertical-align", base.depth + padding, "em");
    if (this.caret)
      result.caret = this.caret;
    return this.attachSupsub(parentContext, {base: result});
  }
};

// src/core-atoms/phantom.ts
var PhantomAtom = class extends Atom {
  constructor(command, body, options) {
    super("phantom", {command, style: options.style});
    this.captureSelection = true;
    this.body = body;
    this.isInvisible = options.isInvisible ?? false;
    this.smashDepth = options.smashDepth ?? false;
    this.smashHeight = options.smashHeight ?? false;
    this.smashWidth = options.smashWidth ?? false;
  }
  render(context) {
    const phantom = new Context(context, {isPhantom: true});
    if (!this.smashDepth && !this.smashHeight && !this.smashWidth) {
      console.assert(this.isInvisible);
      return Atom.createBox(phantom, this.body, {classes: "inner"});
    }
    const content = Atom.createBox(this.isInvisible ? phantom : context, this.body);
    if (!content)
      return null;
    if (this.smashWidth) {
      const fix = new Box(null, {classes: "fix"});
      return new Box([content, fix], {classes: "rlap"}).wrap(context);
    }
    if (!this.smashHeight && !this.smashDepth)
      return content;
    if (this.smashHeight)
      content.height = 0;
    if (this.smashDepth)
      content.depth = 0;
    if (content.children) {
      for (const box of content.children) {
        if (this.smashHeight)
          box.height = 0;
        if (this.smashDepth)
          box.depth = 0;
      }
    }
    return new VBox({firstBaseline: [{box: content}]}, {type: "mord"}).wrap(context);
  }
};

// src/core-atoms/delim.ts
var DelimAtom = class extends Atom {
  constructor(command, delim, options) {
    super("delim", {command, style: options?.style});
    this.value = delim;
    this.size = options?.size;
  }
  render(_context) {
    const box = new Box(null);
    box.delim = this.value;
    return box;
  }
  serialize(_options) {
    if (this.value.length === 1) {
      return this.command + this.value;
    }
    return this.command + "{" + this.value + "}";
  }
};
var SizedDelimAtom = class extends Atom {
  constructor(command, delim, options) {
    super("sizeddelim", {command, style: options.style});
    this.value = delim;
    this.delimClass = options.delimClass;
    this.size = options.size;
  }
  render(context) {
    const result = this.bind(context, makeSizedDelim(this.value, this.size, context, {
      classes: this.delimClass
    }));
    if (!result)
      return null;
    if (this.caret)
      result.caret = this.caret;
    return result;
  }
  serialize(_options) {
    if (this.value.length === 1) {
      return this.command + this.value;
    }
    return this.command + "{" + this.value + "}";
  }
};

// src/core-atoms/line.ts
var LineAtom = class extends Atom {
  constructor(command, body, options) {
    super("line", {command, style: options.style});
    this.skipBoundary = true;
    this.body = body;
    this.position = options.position;
  }
  render(parentContext) {
    const context = new Context(parentContext, this.style, "cramp");
    const inner = Atom.createBox(context, this.body);
    if (!inner)
      return null;
    const ruleWidth = context.metrics.defaultRuleThickness / context.scalingFactor;
    const line = new Box(null, {classes: this.position + "-line"});
    line.height = ruleWidth;
    line.maxFontSize = ruleWidth * 1.125 * context.scalingFactor;
    let stack;
    if (this.position === "overline") {
      stack = new VBox({
        shift: 0,
        children: [{box: inner}, 3 * ruleWidth, {box: line}, ruleWidth]
      });
    } else {
      stack = new VBox({
        top: inner.height,
        children: [ruleWidth, {box: line}, 3 * ruleWidth, {box: inner}]
      });
    }
    if (this.caret)
      stack.caret = this.caret;
    return new Box(stack, {
      classes: this.position,
      type: "mord"
    });
  }
};

// src/core-atoms/overlap.ts
var OverlapAtom = class extends Atom {
  constructor(command, body, options) {
    super("overlap", {command, style: options?.style});
    this.skipBoundary = true;
    if (typeof body === "string") {
      this.body = [new Atom("mord", {value: body})];
    } else {
      this.body = body;
    }
    this.align = options?.align ?? "left";
    this.boxType = options?.boxType ?? "mord";
  }
  render(context) {
    const inner = Atom.createBox(context, this.body, {classes: "inner"});
    if (!inner)
      return null;
    if (this.caret)
      inner.caret = this.caret;
    return this.bind(context, new Box([inner, new Box(null, {classes: "fix"})], {
      classes: this.align === "left" ? "llap" : "rlap",
      type: this.boxType
    }));
  }
};

// src/core-atoms/genfrac.ts
var GenfracAtom = class extends Atom {
  constructor(command, above, below, options) {
    super("genfrac", {
      style: options.style,
      command,
      serialize: options.serialize,
      displayContainsHighlight: true
    });
    this.above = above;
    this.below = below;
    this.hasBarLine = options?.hasBarLine ?? true;
    this.continuousFraction = options?.continuousFraction ?? false;
    this.numerPrefix = options?.numerPrefix;
    this.denomPrefix = options?.denomPrefix;
    this.mathstyleName = options?.mathstyleName;
    this.leftDelim = options?.leftDelim;
    this.rightDelim = options?.rightDelim;
  }
  serialize(options) {
    return this.command + `{${this.aboveToLatex(options)}}{${this.belowToLatex(options)}}`;
  }
  render(context) {
    const fracContext = new Context(context, this.style, this.mathstyleName);
    const metrics = fracContext.metrics;
    const numContext = new Context(fracContext, this.style, this.continuousFraction ? "" : "numerator");
    const numerBox = this.numerPrefix ? new Box([new Box(this.numerPrefix), Atom.createBox(numContext, this.above)], {isTight: numContext.isTight, newList: true}) : Atom.createBox(numContext, this.above, {newList: true}) ?? new Box(null, {newList: true});
    const denomContext = new Context(fracContext, this.style, this.continuousFraction ? "" : "denominator");
    const denomBox = this.denomPrefix ? new Box([
      new Box(this.denomPrefix),
      Atom.createBox(denomContext, this.below, {newList: true})
    ]) : Atom.createBox(denomContext, this.below, {newList: true}) ?? new Box(null, {newList: true});
    const ruleWidth = this.hasBarLine ? metrics.defaultRuleThickness : 0;
    let numerShift;
    let clearance = 0;
    let denomShift;
    if (fracContext.isDisplayStyle) {
      numerShift = metrics.num1;
      clearance = ruleWidth > 0 ? 3 * ruleWidth : 7 * ruleWidth;
      denomShift = metrics.denom1;
    } else {
      if (ruleWidth > 0) {
        numerShift = metrics.num2;
        clearance = ruleWidth;
      } else {
        numerShift = metrics.num3;
        clearance = 3 * ruleWidth;
      }
      denomShift = metrics.denom2;
    }
    const numerDepth = numerBox.depth;
    const denomHeight = denomBox.height;
    let frac;
    if (ruleWidth <= 0) {
      const candidateClearance = numerShift - numerDepth - (denomHeight - denomShift);
      if (candidateClearance < clearance) {
        numerShift += (clearance - candidateClearance) / 2;
        denomShift += (clearance - candidateClearance) / 2;
      }
      frac = new VBox({
        individualShift: [
          {
            box: numerBox,
            shift: -numerShift,
            classes: ["ML__center"]
          },
          {
            box: denomBox,
            shift: denomShift,
            classes: ["ML__center"]
          }
        ]
      }).wrap(fracContext);
    } else {
      const numerLine = AXIS_HEIGHT + ruleWidth / 2;
      const denomLine = AXIS_HEIGHT - ruleWidth / 2;
      if (numerShift < clearance + numerDepth + numerLine) {
        numerShift = clearance + numerDepth + numerLine;
      }
      if (denomShift < clearance + denomHeight - denomLine) {
        denomShift = clearance + denomHeight - denomLine;
      }
      const fracLine = new Box(null, {
        classes: "ML__frac-line",
        mode: this.mode,
        style: this.style
      });
      fracLine.height = ruleWidth / 2;
      fracLine.depth = ruleWidth / 2;
      frac = new VBox({
        individualShift: [
          {
            box: denomBox,
            shift: denomShift,
            classes: ["ML__center"]
          },
          {box: fracLine, shift: -denomLine},
          {
            box: numerBox,
            shift: -numerShift,
            classes: ["ML__center"]
          }
        ]
      }).wrap(fracContext);
    }
    const delimSize = fracContext.isDisplayStyle ? metrics.delim1 : metrics.delim2;
    const leftDelim = this.leftDelim ? this.bind(context, makeCustomSizedDelim("mopen", this.leftDelim, delimSize, true, context, {style: this.style, mode: this.mode})) : makeNullDelimiter(fracContext, "mopen");
    let rightDelim = null;
    if (this.continuousFraction) {
      rightDelim = new Box(null, {type: "mclose"});
    } else if (!this.rightDelim) {
      rightDelim = makeNullDelimiter(fracContext, "mclose");
    } else {
      rightDelim = this.bind(context, makeCustomSizedDelim("mclose", this.rightDelim, delimSize, true, context, {style: this.style, mode: this.mode}));
    }
    const result = this.bind(context, new Box([leftDelim, frac, rightDelim], {
      isTight: fracContext.isTight,
      type: "mord",
      classes: "mfrac"
    }));
    if (!result)
      return null;
    if (this.caret)
      result.caret = this.caret;
    return this.attachSupsub(context, {base: result});
  }
};

// src/core-atoms/rule.ts
var RuleAtom = class extends Atom {
  constructor(command, options) {
    super("rule", {command, style: options.style});
    this.shift = options.shift ?? {dimension: 0};
    this.height = options.height;
    this.width = options.width;
  }
  render(parentContext) {
    const context = new Context(parentContext, this.style, "textstyle");
    const shift = convertDimensionToEm(this.shift);
    const width = convertDimensionToEm(this.width);
    const height = convertDimensionToEm(this.height);
    const result = new Box(null, {classes: "rule", type: "mord"});
    result.setStyle("border-right-width", width, "em");
    result.setStyle("border-top-width", height, "em");
    result.setStyle("border-color", this.style.color);
    result.setStyle("vertical-align", shift, "em");
    if (context.isSelected)
      result.setStyle("opacity", "50%");
    result.width = width;
    result.height = height + shift;
    result.depth = -shift;
    this.bind(parentContext, result);
    if (this.caret)
      result.caret = this.caret;
    return result.wrap(context);
  }
  serialize(_options) {
    let result = this.command ?? "";
    if (this.shift) {
      result += `[${serializeDimension(this.shift)}]`;
    }
    result += `{${serializeDimension(this.width)}}{${serializeDimension(this.height)}}`;
    return result;
  }
};

// src/core-atoms/operator.ts
var OperatorAtom = class extends Atom {
  constructor(command, symbol, options) {
    super(options.type ?? "mop", {
      command,
      style: options.style,
      isFunction: options?.isFunction
    });
    if (typeof symbol === "string") {
      this.value = symbol;
    } else {
      this.body = symbol;
    }
    this.captureSelection = options.captureSelection;
    this.variant = options?.variant;
    this.variantStyle = options?.variantStyle;
    this.subsupPlacement = options?.limits;
    this.isExtensibleSymbol = options?.isExtensibleSymbol ?? false;
  }
  render(context) {
    let base;
    let baseShift = 0;
    let slant = 0;
    if (this.isExtensibleSymbol) {
      const large = context.isDisplayStyle && this.value !== "\\smallint";
      base = new Box(this.value, {
        fontFamily: large ? "Size2-Regular" : "Size1-Regular",
        classes: "op-symbol " + (large ? "large-op" : "small-op"),
        type: "mop",
        maxFontSize: context.scalingFactor
      });
      if (!base)
        return null;
      baseShift = (base.height - base.depth) / 2 - AXIS_HEIGHT * context.scalingFactor;
      slant = base.italic;
      base.setStyle("color", this.style.color);
      base.setStyle("background-color", this.style.backgroundColor);
    } else if (this.body) {
      base = Atom.createBox(context, this.body, {newList: true});
      if (!base)
        return null;
      base.setStyle("color", this.style.color);
      base.setStyle("background-color", this.style.backgroundColor);
    } else {
      console.assert(this.type === "mop");
      base = new Box(this.value, {
        type: "mop",
        mode: "math",
        maxFontSize: context.scalingFactor,
        style: {
          color: this.style.color,
          backgroundColor: this.style.backgroundColor,
          letterShapeStyle: context.letterShapeStyle,
          variant: this.variant,
          variantStyle: this.variantStyle
        }
      });
    }
    if (this.isExtensibleSymbol)
      base.setTop(baseShift);
    let result = base;
    if (this.superscript || this.subscript) {
      const limits = this.subsupPlacement ?? "auto";
      result = limits === "over-under" || limits === "auto" && context.isDisplayStyle ? this.attachLimits(context, {base, baseShift, slant}) : this.attachSupsub(context, {base});
    }
    if (this.caret)
      result.caret = this.caret;
    return new Box(this.bind(context, result), {
      type: "mop",
      classes: "op-group"
    });
  }
  serialize(options) {
    const result = [];
    if (this.value !== "\u200B") {
      result.push(this.command === "\\mathop" || this.command === "\\operatorname" ? this.command + `{${this.bodyToLatex(options)}}` : this.command ?? "");
      if (this.explicitSubsupPlacement) {
        if (this.subsupPlacement === "over-under")
          result.push("\\limits");
        if (this.subsupPlacement === "adjacent")
          result.push("\\nolimits");
        if (this.subsupPlacement === "auto")
          result.push("\\displaylimits");
      }
    }
    result.push(this.supsubToLatex(options));
    return joinLatex(result);
  }
};

// src/core-definitions/styling.ts
defineFunction("ensuremath", "{:math}", {
  createAtom: (_name, args, style) => new GroupAtom(args[0], {
    mode: "math",
    latexOpen: "\\ensuremath{",
    latexClose: "}",
    style
  })
});
defineFunction("color", "{:string}", {
  applyStyle: (_name, args, options) => {
    const color = args[0];
    return {
      verbatimColor: args[0],
      color: options.colorMap?.(color) ?? color
    };
  }
});
defineFunction("textcolor", "{:string}{content:auto*}", {
  applyStyle: (_name, args, options) => {
    const color = args[0];
    return {
      verbatimColor: color,
      color: options.colorMap?.(color) ?? color
    };
  }
});
defineFunction("boxed", "{content:math}", {
  createAtom: (name, args, style) => new BoxAtom(name, args[0], {
    framecolor: "black",
    style
  })
});
defineFunction("colorbox", "{:string}{content:auto*}", {
  applyMode: "text",
  applyStyle: (_name, args, options) => {
    const color = args[0];
    return {
      verbatimBackgroundColor: args[0],
      backgroundColor: options.backgroundColorMap?.(color) ?? color
    };
  }
});
defineFunction("fcolorbox", "{frame-color:string}{background-color:string}{content:auto}", {
  applyMode: "text",
  createAtom: (name, args, style, options) => {
    const color = args[0];
    const bgColor = args[1];
    return new BoxAtom(name, args[2], {
      verbatimFramecolor: color,
      framecolor: options.colorMap?.(color) ?? color,
      verbatimBackgroundcolor: args[1],
      backgroundcolor: options.backgroundColorMap?.(bgColor) ?? bgColor,
      style,
      serialize: (atom, options2) => `${atom.command}{${atom.verbatimFramecolor ?? atom.framecolor}{${atom.verbatimBackgroundcolor ?? atom.backgroundcolor}}{${atom.bodyToLatex(options2)}}`
    });
  }
});
defineFunction("bbox", "[:bbox]{body:auto}", {
  createAtom: (name, args, style) => {
    if (args[0]) {
      const arg = args[0];
      return new BoxAtom(name, args[1], {
        padding: arg.padding,
        border: arg.border,
        backgroundcolor: arg.backgroundcolor,
        style,
        serialize: (atom, options) => {
          let result = name;
          if (Number.isFinite(atom.padding) || atom.border !== void 0 || atom.backgroundcolor !== void 0) {
            const bboxParameters = [];
            if (atom.padding) {
              bboxParameters.push(atom.padding);
            }
            if (atom.border) {
              bboxParameters.push(`border: ${atom.border}`);
            }
            if (atom.verbatimBackgroundcolor || atom.backgroundcolor) {
              bboxParameters.push(atom.verbatimBackgroundcolor ?? atom.backgroundcolor);
            }
            result += `[${bboxParameters.join(",")}]`;
          }
          return result + `{${atom.bodyToLatex(options)}}`;
        }
      });
    }
    return new BoxAtom(name, args[1], {style});
  }
});
defineFunction(["displaystyle", "textstyle", "scriptstyle", "scriptscriptstyle"], "{:rest}", {
  createAtom: (name, args, style) => new GroupAtom(args[0], {
    latexOpen: `{${name} `,
    latexClose: "}",
    style,
    mathstyleName: name.slice(1)
  })
});
defineFunction([
  "tiny",
  "scriptsize",
  "footnotesize",
  "small",
  "normalsize",
  "large",
  "Large",
  "LARGE",
  "huge",
  "Huge"
], "", {
  applyStyle: (name, _args) => {
    return {
      fontSize: {
        "\\tiny": 1,
        "\\scriptsize": 2,
        "\\footnotesize": 3,
        "\\small": 4,
        "\\normalsize": 5,
        "\\large": 6,
        "\\Large": 7,
        "\\LARGE": 8,
        "\\huge": 9,
        "\\Huge": 10
      }[name]
    };
  }
});
defineFunction("fontseries", "{:string}", {
  ifMode: "text",
  applyStyle: (_name, args) => {
    return {fontSeries: args[0]};
  }
});
defineFunction("fontshape", "{:string}", {
  ifMode: "text",
  applyStyle: (_name, args) => {
    return {fontShape: args[0]};
  }
});
defineFunction("fontfamily", "{:string}", {
  ifMode: "text",
  applyStyle: (_name, args) => {
    return {fontFamily: args[0]};
  }
});
defineFunction("selectfont", "", {
  ifMode: "text",
  applyStyle: (_name, _args) => {
    return {};
  }
});
defineFunction("bf", "", {
  applyStyle: (_name, _args) => {
    return {fontSeries: "b", fontShape: "n", fontFamily: "cmr"};
  }
});
defineFunction(["boldsymbol", "bm"], "{:math*}", {
  applyMode: "math",
  createAtom: (name, args, style) => new GroupAtom(args[0], {
    latexOpen: `${name}{`,
    latexClose: "}",
    style,
    customClass: "ML__boldsymbol"
  })
});
defineFunction("bold", "{:math*}", {
  applyMode: "math",
  applyStyle: (_name, _args) => {
    return {variantStyle: "bold"};
  }
});
defineFunction("bfseries", "", {
  applyMode: "text",
  applyStyle: (_name, _args) => {
    return {fontSeries: "b"};
  }
});
defineFunction("mdseries", "", {
  applyMode: "text",
  applyStyle: (_name, _args) => {
    return {fontSeries: "m"};
  }
});
defineFunction("upshape", "", {
  applyMode: "text",
  applyStyle: (_name, _args) => {
    return {fontShape: "n"};
  }
});
defineFunction("slshape", "", {
  applyMode: "text",
  applyStyle: (_name, _args) => {
    return {fontShape: "sl"};
  }
});
defineFunction("scshape", "", {
  applyMode: "text",
  applyStyle: (_name, _args) => {
    return {fontShape: "sc"};
  }
});
defineFunction("textbf", "{:text*}", {
  applyMode: "text",
  applyStyle: (_name, _args) => {
    return {fontSeries: "b"};
  }
});
defineFunction("textmd", "{:text*}", {
  applyMode: "text",
  applyStyle: (_name, _args) => {
    return {fontSeries: "m"};
  }
});
defineFunction("textup", "{:text*}", {
  applyMode: "text",
  applyStyle: (_name, _args) => {
    return {fontShape: "n"};
  }
});
defineFunction("textnormal", "{:text*}", {
  applyMode: "text",
  applyStyle: (_name, _args) => {
    return {fontShape: "n", fontSeries: "m"};
  }
});
defineFunction("textsl", "{:text*}", {
  applyMode: "text",
  applyStyle: (_name, _args) => {
    return {fontShape: "sl"};
  }
});
defineFunction("textit", "{:text*}", {
  applyMode: "text",
  applyStyle: (_name, _args) => {
    return {fontShape: "it"};
  }
});
defineFunction("textsc", "{:text*}", {
  applyMode: "text",
  applyStyle: (_name, _args) => {
    return {fontShape: "sc"};
  }
});
defineFunction("textrm", "{:text*}", {
  applyMode: "text",
  applyStyle: (_name, _args) => {
    return {fontFamily: "roman"};
  }
});
defineFunction("textsf", "{:text*}", {
  applyMode: "text",
  applyStyle: (_name, _args) => {
    return {fontFamily: "sans-serif"};
  }
});
defineFunction("texttt", "{:text*}", {
  applyMode: "text",
  applyStyle: (_name, _args) => {
    return {fontFamily: "monospace"};
  }
});
defineFunction("mathbf", "{:math*}", {
  applyMode: "math",
  applyStyle: (_name, _args) => {
    return {variant: "normal", variantStyle: "bold"};
  }
});
defineFunction("mathit", "{:math*}", {
  applyMode: "math",
  applyStyle: (_name, _args) => {
    return {variant: "normal", variantStyle: "italic"};
  }
});
defineFunction("mathbfit", "{:math*}", {
  applyMode: "math",
  applyStyle: (_name, _args) => {
    return {variant: "normal", variantStyle: "bolditalic"};
  }
});
defineFunction("mathrm", "{:math*}", {
  applyMode: "math",
  applyStyle: (_name, _args) => {
    return {variant: "normal", variantStyle: "up"};
  }
});
defineFunction("mathsf", "{:math*}", {
  applyMode: "math",
  applyStyle: (_name, _args) => {
    return {variant: "sans-serif", variantStyle: "up"};
  }
});
defineFunction("mathtt", "{:math*}", {
  applyMode: "math",
  applyStyle: (_name, _args) => {
    return {variant: "monospace", variantStyle: "up"};
  }
});
defineFunction("it", "", {
  applyStyle: (_name, _args) => {
    return {
      fontSeries: "m",
      fontShape: "it",
      fontFamily: "cmr",
      variantStyle: "italic"
    };
  }
});
defineFunction("rmfamily", "", {
  applyStyle: (_name, _args) => {
    return {fontFamily: "roman"};
  }
});
defineFunction("sffamily", "", {
  applyStyle: (_name, _args) => {
    return {fontFamily: "sans-serif"};
  }
});
defineFunction("ttfamily", "", {
  applyStyle: (_name, _args) => {
    return {fontFamily: "monospace"};
  }
});
defineFunction(["Bbb", "mathbb"], "{:math*}", {
  applyStyle: (_name, _args) => {
    return {variant: "double-struck", variantStyle: "up"};
  }
});
defineFunction(["frak", "mathfrak"], "{:math*}", {
  applyStyle: (_name, _args) => {
    return {variant: "fraktur", variantStyle: "up"};
  }
});
defineFunction("mathcal", "{:math*}", {
  applyStyle: (_name, _args) => {
    return {variant: "calligraphic", variantStyle: "up"};
  }
});
defineFunction("mathscr", "{:math*}", {
  applyStyle: (_name, _args) => {
    return {variant: "script", variantStyle: "up"};
  }
});
defineFunction("mbox", "{:text}", {
  ifMode: "math",
  createAtom: (_name, args, style) => new GroupAtom(args[0], {
    changeMode: true,
    style,
    mode: "text",
    serialize: (atom, options) => `\\mbox{${atom.bodyToLatex({
      ...options,
      skipModeCommand: true
    })}}`
  })
});
defineFunction("text", "{:text}", {
  ifMode: "math",
  applyMode: "text"
});
defineFunction("class", "{name:string}{content:auto*}", {
  createAtom: (_command, args, style) => new GroupAtom(args[1], {
    customClass: args[0],
    style
  })
});
defineFunction("cssId", "{id:string}{content:auto}", {
  createAtom: (command, args, style) => new GroupAtom(args[1], {
    cssId: args[0],
    style
  })
});
defineFunction("htmlData", "{data:string}{content:auto}", {
  createAtom: (command, args, style) => new GroupAtom(args[1], {
    htmlData: args[0],
    style
  })
});
defineFunction("htmlStyle", "{data:string}{content:auto}", {
  createAtom: (command, args, style) => new GroupAtom(args[1], {
    htmlStyle: args[0],
    style
  })
});
defineFunction("em", "{:auto*}", {
  createAtom: (command, args, style) => new GroupAtom(args[0], {
    latexOpen: "\\em",
    latexClose: "",
    customClass: "ML__emph",
    style
  })
});
defineFunction("emph", "{:auto}", {
  createAtom: (command, args, style) => new GroupAtom(args[0], {
    latexOpen: "\\emph{",
    latexClose: "}",
    customClass: "ML__emph",
    style
  })
});
var DELIMITER_SIZES = {
  "\\bigl": {mclass: "mopen", size: 1},
  "\\Bigl": {mclass: "mopen", size: 2},
  "\\biggl": {mclass: "mopen", size: 3},
  "\\Biggl": {mclass: "mopen", size: 4},
  "\\bigr": {mclass: "mclose", size: 1},
  "\\Bigr": {mclass: "mclose", size: 2},
  "\\biggr": {mclass: "mclose", size: 3},
  "\\Biggr": {mclass: "mclose", size: 4},
  "\\bigm": {mclass: "mrel", size: 1},
  "\\Bigm": {mclass: "mrel", size: 2},
  "\\biggm": {mclass: "mrel", size: 3},
  "\\Biggm": {mclass: "mrel", size: 4},
  "\\big": {mclass: "mord", size: 1},
  "\\Big": {mclass: "mord", size: 2},
  "\\bigg": {mclass: "mord", size: 3},
  "\\Bigg": {mclass: "mord", size: 4}
};
defineFunction([
  "bigl",
  "Bigl",
  "biggl",
  "Biggl",
  "bigr",
  "Bigr",
  "biggr",
  "Biggr",
  "bigm",
  "Bigm",
  "biggm",
  "Biggm",
  "big",
  "Big",
  "bigg",
  "Bigg"
], "{:delim}", {
  createAtom: (name, args, style) => new SizedDelimAtom(name, args[0], {
    size: DELIMITER_SIZES[name].size,
    delimClass: DELIMITER_SIZES[name].mclass,
    style
  })
});
defineFunction([
  "hspace",
  "hspace*"
], "{width:glue}", {
  createAtom: (name, args, style) => new SpacingAtom(name, style, args[0] ?? {glue: {dimension: 0}})
});
defineFunction("mathop", "{:auto}", {
  createAtom: (command, args, style) => new OperatorAtom(command, args[0], {
    type: "mop",
    captureSelection: true,
    limits: "over-under",
    isFunction: true,
    style
  })
});
defineFunction([
  "mathbin",
  "mathrel",
  "mathopen",
  "mathclose",
  "mathpunct",
  "mathord",
  "mathinner"
], "{:auto}", {
  createAtom: (command, args, style) => new OperatorAtom(command, args[0], {
    type: {
      "\\mathbin": "mbin",
      "\\mathrel": "mrel",
      "\\mathopen": "mopen",
      "\\mathclose": "mclose",
      "\\mathpunct": "mpunct",
      "\\mathord": "mord",
      "\\mathinner": "minner"
    }[command],
    captureSelection: true,
    style
  })
});
defineFunction(["operatorname", "operatorname*"], "{operator:math}", {
  createAtom: (name, args, style) => {
    const result = new OperatorAtom(name, args[0], {
      isFunction: true,
      limits: name === "\\operatorname" ? "adjacent" : "over-under",
      style
    });
    result.captureSelection = true;
    if (result.body) {
      result.body.forEach((x3) => {
        if (x3.type !== "first") {
          x3.type = "mord";
          x3.value = {"\u2217": "*", "\u2212": "-"}[x3.value] ?? x3.value;
          x3.isFunction = false;
          if (!x3.style.variant && !x3.style.variantStyle) {
            x3.style.variant = "main";
            x3.style.variantStyle = "up";
          }
        }
      });
    }
    return result;
  }
});
var UnicodeAtom = class extends Atom {
  constructor(arg, style) {
    let codepoint = Number.parseInt(arg);
    if (!Number.isFinite(codepoint))
      codepoint = 10067;
    super("mord", {
      value: String.fromCodePoint(codepoint),
      style
    });
    this.codepoint = codepoint;
  }
  serialize(_options) {
    return '\\unicode"' + ("000000" + this.codepoint.toString(16)).toUpperCase().slice(-6);
  }
};
defineFunction("unicode", "{charcode:number}", {
  createAtom: (name, args, style) => new UnicodeAtom(args[0], style)
});
defineFunction("rule", "[raise:dimen]{width:dimen}{thickness:dimen}", {
  createAtom: (name, args, style) => new RuleAtom(name, {
    shift: args[0],
    width: args[1],
    height: args[2],
    style
  })
});
defineFunction("overline", "{:auto}", {
  createAtom: (name, args, style) => new LineAtom(name, args[0], {
    position: "overline",
    style
  })
});
defineFunction("underline", "{:auto}", {
  createAtom: (name, args, style) => new LineAtom(name, args[0], {
    position: "underline",
    style
  })
});
function binRelType(atoms) {
  if (atoms.length === 1) {
    const atom = atoms[0];
    if (atom.type === "mbin")
      return "mbin";
    if (atom.type === "mrel")
      return "mrel";
  }
  return "mord";
}
defineFunction("overset", "{above:auto}{base:auto}", {
  createAtom: (name, args, style) => new OverunderAtom(name, {
    above: args[0],
    body: args[1],
    skipBoundary: false,
    style,
    boxType: binRelType(args[1]),
    serialize: (atom, options) => `${atom.command}{${atom.aboveToLatex(options)}}{${atom.bodyToLatex(options)}}`
  })
});
defineFunction("underset", "{below:auto}{base:auto}", {
  createAtom: (name, args, style) => new OverunderAtom(name, {
    below: args[0],
    body: args[1],
    skipBoundary: false,
    style,
    boxType: binRelType(args[1]),
    serialize: (atom, options) => `${name}{${atom.belowToLatex(options)}}{${atom.bodyToLatex(options)}}`
  })
});
defineFunction("overunderset", "{above:auto}{below:auto}{base:auto}", {
  createAtom: (name, args, style) => new OverunderAtom(name, {
    above: args[0],
    below: args[1],
    body: args[2],
    skipBoundary: false,
    style,
    boxType: binRelType(args[2]),
    serialize: (atom, options) => `${atom.command}{${atom.aboveToLatex(options)}}{${atom.bodyToLatex(options)}}`
  })
});
defineFunction(["stackrel", "stackbin"], "[below:auto]{above:auto}{base:auto}", {
  createAtom: (name, args, style) => new OverunderAtom(name, {
    body: args[2],
    above: args[1],
    below: args[0],
    skipBoundary: false,
    style,
    boxType: name === "\\stackrel" ? "mrel" : "mbin",
    serialize: (atom, options) => `${atom.command}{${atom.aboveToLatex(options)}}{${atom.bodyToLatex(options)}}`
  })
});
defineFunction(["overwithdelims", "atopwithdelims"], "{numer:auto}{denom:auto}{left-delim:delim}{right-delim:delim}", {
  infix: true,
  createAtom: (name, args, style) => new GenfracAtom(name, args[0], args[1], {
    leftDelim: args[2],
    rightDelim: args[3],
    hasBarLine: false,
    style,
    serialize: (atom, options) => `${atom.aboveToLatex(options)} ${atom.command}${atom.leftDelim}${atom.rightDelim}${atom.belowToLatex(options)}`
  })
});
defineFunction("smash", "[:string]{:auto}", {
  createAtom: (name, args, style) => {
    if (!args[0]) {
      return new PhantomAtom(name, args[1], {
        smashHeight: true,
        smashDepth: true,
        style
      });
    }
    return new PhantomAtom(name, args[1], {
      smashHeight: args[0].includes("t"),
      smashDepth: args[0].includes("b"),
      style
    });
  }
});
defineFunction(["vphantom"], "{:auto*}", {
  createAtom: (name, args, style) => new PhantomAtom(name, args[1], {
    isInvisible: true,
    smashWidth: true,
    style
  })
});
defineFunction(["hphantom"], "{:auto*}", {
  createAtom: (name, args, style) => new PhantomAtom(name, args[1], {
    isInvisible: true,
    smashHeight: true,
    smashDepth: true,
    style
  })
});
defineFunction(["phantom"], "{:auto*}", {
  createAtom: (name, args, style) => new PhantomAtom(name, args[1], {
    isInvisible: true,
    style
  })
});
defineFunction("not", "{:math}", {
  createAtom: (name, args, style) => {
    if (args.length < 1 || args[0] === null) {
      return new Atom("mrel", {command: name, style, value: "\uE020"});
    }
    const arg = args[0];
    return new GroupAtom([
      new OverlapAtom(name, "\uE020", {
        align: "right",
        style,
        boxType: "mrel"
      }),
      ...arg
    ], {
      boxType: "mrel",
      captureSelection: true,
      serialize: (atom, options) => {
        const argLatex = Atom.serialize(arg, options);
        if (argLatex.length === 1 && !/[a-zA-Z]/.test(argLatex)) {
          return "\\not" + argLatex;
        }
        return `\\not{${argLatex}}`;
      }
    });
  }
});
defineFunction(["ne", "neq"], "", {
  createAtom: (name, _args, style) => new GroupAtom([
    new OverlapAtom(name, "\uE020", {
      align: "right",
      style,
      boxType: "mrel"
    }),
    new Atom("mrel", {style, value: "="})
  ], {boxType: "mrel", captureSelection: true, serialize: () => name})
});
defineFunction("rlap", "{:auto}", {
  createAtom: (name, args, style) => new OverlapAtom(name, args[0], {align: "right", style})
});
defineFunction("llap", "{:auto}", {
  createAtom: (name, args, style) => new OverlapAtom(name, args[0], {style})
});
defineFunction("mathllap", "{:auto}", {
  createAtom: (name, args, style) => new OverlapAtom(name, args[0], {style})
});
defineFunction("mathrlap", "{:auto}", {
  createAtom: (name, args, style) => new OverlapAtom(name, args[0], {align: "right", style})
});

// src/core-definitions/accents.ts
var ACCENTS = {
  acute: 714,
  grave: 715,
  dot: 729,
  ddot: 168,
  mathring: 730,
  tilde: 126,
  bar: 713,
  breve: 728,
  check: 711,
  hat: 94,
  vec: 8407
};
defineFunction(Object.keys(ACCENTS), "{body:auto}", {
  createAtom: (command, args, style) => new AccentAtom(command, args[0], {
    accentChar: ACCENTS[command.slice(1)],
    style
  })
});
defineFunction(["widehat", "widecheck", "widetilde"], "{body:auto}", {
  createAtom: (command, args, style) => {
    const baseString = parseArgAsString(args[0]);
    return new AccentAtom(command, args[0], {
      style,
      svgAccent: command.slice(1) + (baseString.length > 5 ? "4" : ["1", "1", "2", "2", "3", "3"][baseString.length])
    });
  }
});
defineFunction(["overarc", "overparen", "wideparen"], "{body:auto}", {
  createAtom: (command, args, style) => {
    return new AccentAtom(command, args[0], {
      style,
      svgAccent: "overarc"
    });
  }
});
defineFunction(["underarc", "underparen"], "{body:auto}", {
  createAtom: (command, args, style) => {
    return new OverunderAtom(command, {
      body: args[0],
      style,
      svgBelow: "underarc"
    });
  }
});
defineFunction("utilde", "{body:auto}", {
  createAtom: (command, args, style) => {
    const baseString = parseArgAsString(args[0]);
    const accent = "widetilde" + (baseString.length > 5 ? "4" : ["1", "1", "2", "2", "3", "3"][baseString.length]);
    return new OverunderAtom(command, {
      body: args[0],
      svgBelow: accent,
      style,
      boxType: binRelType(args[0])
    });
  }
});
defineFunction("^", "{:string}", {
  createAtom: (command, args, style) => new Atom("mord", {
    command,
    isFunction: false,
    limits: "adjacent",
    style,
    value: args[0] ? {
      a: "\xE2",
      e: "\xEA",
      i: "\xEE",
      o: "\xF4",
      u: "\xFB",
      A: "\xC2",
      E: "\xCA",
      I: "\xCE",
      O: "\xD4",
      U: "\xDB"
    }[args[0]] ?? "^" : "^"
  })
});
defineFunction("`", "{:string}", {
  createAtom: (command, args, style) => new Atom("mord", {
    command,
    isFunction: false,
    limits: "adjacent",
    style,
    value: args[0] ? {
      a: "\xE0",
      e: "\xE8",
      i: "\xEC",
      o: "\xF2",
      u: "\xF9",
      A: "\xC0",
      E: "\xC8",
      I: "\xCC",
      O: "\xD2",
      U: "\xD9"
    }[args[0]] ?? "`" : "`"
  })
});
defineFunction("'", "{:string}", {
  createAtom: (command, args, style) => new Atom("mord", {
    command,
    isFunction: false,
    limits: "adjacent",
    style,
    value: args[0] ? {
      a: "\xE1",
      e: "\xE9",
      i: "\xED",
      o: "\xF3",
      u: "\xFA",
      A: "\xC1",
      E: "\xC9",
      I: "\xCD",
      O: "\xD3",
      U: "\xDA"
    }[args[0]] ?? "^" : "^"
  })
});
defineFunction("~", "{:string}", {
  createAtom: (command, args, style) => new Atom("mord", {
    command,
    isFunction: false,
    limits: "adjacent",
    style,
    value: args[0] ? {n: "\xF1", N: "\xD1", a: "\xE3", o: "\xF5", A: "\xC3", O: "\xD5"}[args[0]] ?? "\xB4" : "\xB4"
  })
});
defineFunction("c", "{:string}", {
  createAtom: (command, args, style) => new Atom("mord", {
    command,
    isFunction: false,
    limits: "adjacent",
    style,
    value: args[0] ? {c: "\xE7", C: "\xC7"}[args[0]] ?? "" : ""
  })
});

// src/core-atoms/enclose.ts
var EncloseAtom = class extends Atom {
  constructor(command, body, notation, options) {
    super("enclose", {command, style: options.style});
    this.body = body;
    this.backgroundcolor = options.backgroundcolor;
    if (notation.updiagonalarrow) {
      notation.updiagonalstrike = false;
    }
    if (notation.box) {
      notation.left = false;
      notation.right = false;
      notation.bottom = false;
      notation.top = false;
    }
    this.notation = notation;
    this.shadow = options.shadow;
    this.strokeWidth = options.strokeWidth;
    this.strokeStyle = options.strokeStyle;
    this.svgStrokeStyle = options.svgStrokeStyle;
    this.strokeColor = options.strokeColor;
    this.borderStyle = options.borderStyle;
    this.padding = options.padding;
    this.captureSelection = true;
  }
  serialize(options) {
    let result = this.command ?? "";
    if (this.command === "\\enclose") {
      result += "{" + Object.keys(this.notation).join(" ") + "}";
      let style = "";
      let sep = "";
      if (this.backgroundcolor && this.backgroundcolor !== "transparent") {
        style += sep + 'mathbackground="' + this.backgroundcolor + '"';
        sep = ",";
      }
      if (this.shadow && this.shadow !== "auto") {
        style += sep + 'shadow="' + this.shadow + '"';
        sep = ",";
      }
      if (this.strokeWidth || this.strokeStyle !== "solid") {
        style += sep + this.borderStyle;
        sep = ",";
      } else if (this.strokeColor && this.strokeColor !== "currentColor") {
        style += sep + 'mathcolor="' + this.strokeColor + '"';
        sep = ",";
      }
      if (style) {
        result += `[${style}]`;
      }
    }
    result += `{${this.bodyToLatex(options)}}`;
    return result;
  }
  render(parentContext) {
    const context = new Context(parentContext, this.style);
    const base = Atom.createBox(context, this.body);
    if (!base)
      return null;
    const padding = convertDimensionToEm(this.padding && this.padding !== "auto" ? convertToDimension(this.padding, parentContext.registers) : context.getRegisterAsDimension("fboxsep")) ?? 0;
    const notation = new Box(null, {classes: "ML__notation"});
    notation.setStyle("position", "absolute");
    notation.setStyle("height", base.height + base.depth + 2 * padding, "em");
    notation.height = base.height + padding;
    notation.depth = base.depth + padding;
    if (padding !== 0) {
      notation.setStyle("width", `calc(100% + ${2 * padding}em)`);
    } else {
      notation.setStyle("width", "100%");
    }
    notation.setStyle("top", -base.height + 2 * padding, "em");
    notation.setStyle("left", -padding, "em");
    notation.setStyle("z-index", "-1");
    notation.setStyle("box-sizing", "border-box");
    if (this.backgroundcolor) {
      notation.setStyle("background-color", this.backgroundcolor);
    }
    if (this.notation.box)
      notation.setStyle("border", this.borderStyle);
    if (this.notation.actuarial) {
      notation.setStyle("border-top", this.borderStyle);
      notation.setStyle("border-right", this.borderStyle);
    }
    if (this.notation.madruwb) {
      notation.setStyle("border-bottom", this.borderStyle);
      notation.setStyle("border-right", this.borderStyle);
    }
    if (this.notation.roundedbox) {
      notation.setStyle("border-radius", (base.height + base.depth) / 2, "em");
      notation.setStyle("border", this.borderStyle);
    }
    if (this.notation.circle) {
      notation.setStyle("border-radius", "50%");
      notation.setStyle("border", this.borderStyle);
    }
    if (this.notation.top) {
      notation.setStyle("border-top", this.borderStyle);
    }
    if (this.notation.left) {
      notation.setStyle("border-left", this.borderStyle);
    }
    if (this.notation.right) {
      notation.setStyle("border-right", this.borderStyle);
    }
    if (this.notation.bottom) {
      notation.setStyle("border-bottom", this.borderStyle);
    }
    let svg = "";
    if (this.notation.horizontalstrike) {
      svg += '<line x1="3%"  y1="50%" x2="97%" y2="50%"';
      svg += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`;
      svg += ' stroke-linecap="round"';
      if (this.svgStrokeStyle) {
        svg += ` stroke-dasharray="${this.svgStrokeStyle}"`;
      }
      svg += "/>";
    }
    if (this.notation.verticalstrike) {
      svg += '<line x1="50%"  y1="3%" x2="50%" y2="97%"';
      svg += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`;
      svg += ' stroke-linecap="round"';
      if (this.svgStrokeStyle) {
        svg += ` stroke-dasharray="${this.svgStrokeStyle}"`;
      }
      svg += "/>";
    }
    if (this.notation.updiagonalstrike) {
      svg += '<line x1="3%"  y1="97%" x2="97%" y2="3%"';
      svg += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`;
      svg += ' stroke-linecap="round"';
      if (this.svgStrokeStyle) {
        svg += ` stroke-dasharray="${this.svgStrokeStyle}"`;
      }
      svg += "/>";
    }
    if (this.notation.downdiagonalstrike) {
      svg += '<line x1="3%"  y1="3%" x2="97%" y2="97%"';
      svg += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`;
      svg += ' stroke-linecap="round"';
      if (this.svgStrokeStyle) {
        svg += ` stroke-dasharray="${this.svgStrokeStyle}"`;
      }
      svg += "/>";
    }
    if (svg) {
      let svgStyle;
      if (this.shadow !== "none") {
        svgStyle = this.shadow === "auto" ? "filter: drop-shadow(0 0 .5px rgba(255, 255, 255, .7)) drop-shadow(1px 1px 2px #333)" : "filter: drop-shadow(" + this.shadow + ")";
      }
      addSVGOverlay(notation, svg, svgStyle);
    }
    const result = new Box([notation, base]);
    result.setStyle("position", "relative");
    result.setStyle("display", "inline");
    result.height = base.height + padding;
    result.depth = base.depth + padding;
    result.left = padding;
    result.right = padding;
    if (this.caret)
      result.caret = this.caret;
    return result.wrap(context);
  }
};

// src/core-definitions/enclose.ts
defineFunction("enclose", "{notation:string}[style:string]{body:auto}", {
  createAtom: (command, args, style) => {
    const options = {
      strokeColor: "currentColor",
      strokeWidth: "",
      strokeStyle: "solid",
      backgroundcolor: "transparent",
      padding: "auto",
      shadow: "auto",
      svgStrokeStyle: void 0,
      borderStyle: void 0,
      style
    };
    if (args[1]) {
      const styles = args[1].split(/,(?![^(]*\)(?:(?:[^(]*\)){2})*[^"]*$)/);
      for (const s3 of styles) {
        const shorthand = s3.match(/\s*(\S+)\s+(\S+)\s+(.*)/);
        if (shorthand) {
          options.strokeWidth = shorthand[1];
          options.strokeStyle = shorthand[2];
          options.strokeColor = shorthand[3];
        } else {
          const attribute = s3.match(/\s*([a-z]*)\s*=\s*"(.*)"/);
          if (attribute) {
            if (attribute[1] === "mathbackground") {
              options.backgroundcolor = attribute[2];
            } else if (attribute[1] === "mathcolor") {
              options.strokeColor = attribute[2];
            } else if (attribute[1] === "padding") {
              options.padding = attribute[2];
            } else if (attribute[1] === "shadow") {
              options.shadow = attribute[2];
            }
          }
        }
      }
      if (options.strokeStyle === "dashed") {
        options.svgStrokeStyle = "5,5";
      } else if (options.strokeStyle === "dotted") {
        options.svgStrokeStyle = "1,5";
      }
    }
    options.borderStyle = `${options.strokeWidth}px ${options.strokeStyle} ${options.strokeColor}`;
    const notation = {};
    (args[0] ?? "").split(/[, ]/).filter((v3) => v3.length > 0).forEach((x3) => {
      notation[x3.toLowerCase()] = true;
    });
    return new EncloseAtom(command, args[2], notation, options);
  }
});
defineFunction("cancel", "{body:auto}", {
  createAtom: (name, args, style) => new EncloseAtom(name, args[0], {updiagonalstrike: true}, {
    strokeColor: "currentColor",
    strokeWidth: "",
    strokeStyle: "solid",
    borderStyle: "1px solid currentColor",
    backgroundcolor: "transparent",
    padding: "auto",
    shadow: "auto",
    style
  })
});
defineFunction("bcancel", "{body:auto}", {
  createAtom: (name, args, style) => new EncloseAtom(name, args[0], {downdiagonalstrike: true}, {
    strokeColor: "currentColor",
    strokeWidth: "",
    strokeStyle: "solid",
    borderStyle: "1px solid currentColor",
    backgroundcolor: "transparent",
    padding: "auto",
    shadow: "auto",
    style
  })
});
defineFunction("xcancel", "{body:auto}", {
  createAtom: (name, args, style) => new EncloseAtom(name, args[0], {updiagonalstrike: true, downdiagonalstrike: true}, {
    strokeColor: "currentColor",
    strokeWidth: "",
    strokeStyle: "solid",
    borderStyle: "1px solid currentColor",
    backgroundcolor: "transparent",
    padding: "auto",
    shadow: "auto",
    style
  })
});

// src/core-atoms/array.ts
function normalizeArray(atom, array, colFormat) {
  let maxColCount = 0;
  for (const colSpec of colFormat) {
    if ("align" in colSpec)
      maxColCount += 1;
  }
  let colCount = 0;
  const rows = [];
  for (const row of array) {
    let colIndex2 = 0;
    colCount = Math.max(colCount, Math.min(row.length, maxColCount));
    while (colIndex2 < row.length) {
      const newRow = [];
      const lastCol = Math.min(row.length, colIndex2 + maxColCount);
      while (colIndex2 < lastCol) {
        if (row[colIndex2].length > 0 && row[colIndex2][0].type !== "first") {
          newRow.push([
            new Atom("first", {mode: atom.mode}),
            ...row[colIndex2]
          ]);
        } else {
          newRow.push(row[colIndex2]);
        }
        colIndex2 += 1;
      }
      rows.push(newRow);
    }
  }
  if (rows[rows.length - 1].length === 1 && rows[rows.length - 1][0].length === 0) {
    rows.pop();
  }
  const result = [];
  for (const row of rows) {
    if (row.length !== colCount) {
      for (let i3 = row.length; i3 < colCount; i3++) {
        row.push([
          new Atom("first", {mode: atom.mode}),
          new PlaceholderAtom()
        ]);
      }
    }
    result.push(row);
  }
  let rowIndex = 0;
  let colIndex = 0;
  for (const row of result) {
    colIndex = 0;
    for (const cell of row) {
      for (const element of cell) {
        element.parent = atom;
        element.treeBranch = [rowIndex, colIndex];
      }
      colIndex += 1;
    }
    rowIndex += 1;
  }
  atom.isDirty = true;
  return result;
}
var ArrayAtom = class extends Atom {
  constructor(envName, array, rowGaps, options = {}) {
    super("array");
    this.environmentName = envName;
    this.rowGaps = rowGaps;
    if (options.mathstyleName)
      this.mathstyleName = options.mathstyleName;
    if (options.columns) {
      if (options.columns.length === 0) {
        this.colFormat = [{align: "l"}];
      } else {
        this.colFormat = options.columns;
      }
    }
    if (!this.colFormat) {
      this.colFormat = [
        {align: "l"},
        {align: "l"},
        {align: "l"},
        {align: "l"},
        {align: "l"},
        {align: "l"},
        {align: "l"},
        {align: "l"},
        {align: "l"},
        {align: "l"}
      ];
    }
    this.array = normalizeArray(this, array, this.colFormat);
    if (options.leftDelim)
      this.leftDelim = options.leftDelim;
    if (options.rightDelim)
      this.rightDelim = options.rightDelim;
    if (options.jot !== void 0)
      this.jot = options.jot;
    if (options.arraycolsep)
      this.arraycolsep = options.arraycolsep;
    this.colSeparationType = options.colSeparationType;
    this.arraystretch = options.arraystretch ?? 1;
  }
  branch(cell) {
    if (!isColRowBranch(cell))
      return void 0;
    return this.array[cell[0]][cell[1]] ?? void 0;
  }
  get branches() {
    const result = super.branches;
    this.array.forEach((_3, col) => {
      this.array[col].forEach((_4, row) => {
        if (this.array[col][row]) {
          result.push([col, row]);
        }
      });
    });
    return result;
  }
  createBranch(cell) {
    if (!isColRowBranch(cell))
      return [];
    this.isDirty = true;
    return this.branch(cell) ?? [];
  }
  get rowCount() {
    return this.array.length;
  }
  get colCount() {
    return this.array[0].length;
  }
  removeBranch(name) {
    if (isNamedBranch(name)) {
      return super.removeBranch(name);
    }
    const children = this.branch(name);
    this.array[name[0]][name[1]] = void 0;
    children.forEach((x3) => {
      x3.parent = void 0;
      x3.treeBranch = void 0;
    });
    console.assert(children[0].type === "first");
    children.shift();
    this.isDirty = true;
    return children;
  }
  get hasChildren() {
    return this.children.length > 0;
  }
  get children() {
    const result = [];
    for (const row of this.array) {
      for (const cell of row) {
        if (cell) {
          for (const atom of cell) {
            result.push(...atom.children);
            result.push(atom);
          }
        }
      }
    }
    return [...result, ...super.children];
  }
  render(context) {
    const innerContext = new Context(context, this.style, this.mathstyleName);
    const arrayRuleWidth = innerContext.getRegisterAsEm("arrayrulewidth");
    const arrayColSep = innerContext.getRegisterAsEm("arraycolsep");
    const doubleRuleSep = innerContext.getRegisterAsEm("doublerulesep");
    const arraystretch = this.arraystretch ?? 1;
    let arraycolsep = typeof this.arraycolsep === "number" ? this.arraycolsep : arrayColSep;
    if (this.colSeparationType === "small") {
      const localMultiplier = new Context(context, void 0, "scriptstyle").scalingFactor;
      arraycolsep = 0.2778 * (localMultiplier / context.scalingFactor);
    }
    const arrayskip = arraystretch * BASELINE_SKIP;
    const arstrutHeight = 0.7 * arrayskip;
    const arstrutDepth = 0.3 * arrayskip;
    let totalHeight = 0;
    const body = [];
    let nc = 0;
    const nr = this.array.length;
    for (let r3 = 0; r3 < nr; ++r3) {
      const inrow = this.array[r3];
      nc = Math.max(nc, inrow.length);
      const cellContext = new Context(innerContext, this.style, this.mathstyleName);
      let height = arstrutHeight / cellContext.scalingFactor;
      let depth = arstrutDepth / cellContext.scalingFactor;
      const outrow = {cells: [], height: 0, depth: 0, pos: 0};
      for (const element of inrow) {
        const elt = Atom.createBox(cellContext, element, {newList: true}) ?? new Box(null, {newList: true});
        depth = Math.max(depth, elt.depth);
        height = Math.max(height, elt.height);
        outrow.cells.push(elt);
      }
      let gap = convertDimensionToEm(this.rowGaps[r3]) ?? 0;
      if (gap > 0) {
        gap += arstrutDepth;
        depth = Math.max(depth, gap);
        gap = 0;
      }
      if (this.jot !== void 0) {
        depth += this.jot;
      }
      outrow.height = height;
      outrow.depth = depth;
      totalHeight += height;
      outrow.pos = totalHeight;
      totalHeight += depth + gap;
      body.push(outrow);
    }
    const offset = totalHeight / 2 + AXIS_HEIGHT;
    const contentCols = [];
    for (let colIndex = 0; colIndex < nc; colIndex++) {
      const stack = [];
      for (const row of body) {
        const element = row.cells[colIndex];
        element.depth = row.depth;
        element.height = row.height;
        stack.push({box: element, shift: row.pos - offset});
      }
      if (stack.length > 0) {
        contentCols.push(new VBox({individualShift: stack}));
      }
    }
    const cols = [];
    let previousColContent = false;
    let previousColRule = false;
    let currentContentCol = 0;
    let firstColumn = !this.leftDelim;
    const {colFormat} = this;
    for (const colDesc of colFormat) {
      if ("align" in colDesc && currentContentCol >= contentCols.length) {
        break;
      }
      if ("align" in colDesc) {
        if (previousColContent) {
          cols.push(makeColGap(2 * arraycolsep));
        } else if (previousColRule || firstColumn) {
          cols.push(makeColGap(arraycolsep));
        }
        cols.push(new Box(contentCols[currentContentCol], {
          classes: "col-align-" + colDesc.align
        }));
        currentContentCol++;
        previousColContent = true;
        previousColRule = false;
        firstColumn = false;
      } else if ("gap" in colDesc) {
        if (typeof colDesc.gap === "number") {
          cols.push(makeColGap(colDesc.gap));
        } else {
          const col = makeColOfRepeatingElements(context, body, offset, colDesc.gap);
          if (col)
            cols.push(col);
        }
        previousColContent = false;
        previousColRule = false;
        firstColumn = false;
      } else if ("separator" in colDesc) {
        const separator = new Box(null, {classes: "vertical-separator"});
        separator.setStyle("height", totalHeight, "em");
        separator.setStyle("border-right", `${arrayRuleWidth}em ${colDesc.separator} currentColor`);
        separator.setStyle("vertical-align", -(totalHeight - offset), "em");
        let gap = 0;
        if (previousColRule) {
          gap = doubleRuleSep - arrayRuleWidth;
        } else if (previousColContent) {
          gap = arraycolsep - arrayRuleWidth;
        }
        separator.left = gap;
        cols.push(separator);
        previousColContent = false;
        previousColRule = true;
        firstColumn = false;
      }
    }
    if (previousColContent && !this.rightDelim) {
      cols.push(makeColGap(arraycolsep));
    }
    const inner = new Box(cols, {classes: "mtable"});
    if ((!this.leftDelim || this.leftDelim === ".") && (!this.rightDelim || this.rightDelim === ".")) {
      return inner;
    }
    const innerHeight = inner.height;
    const innerDepth = inner.depth;
    const result = this.bind(context, new Box([
      this.bind(context, makeLeftRightDelim("mopen", this.leftDelim ?? ".", innerHeight, innerDepth, innerContext)),
      inner,
      this.bind(context, makeLeftRightDelim("mclose", this.rightDelim ?? ".", innerHeight, innerDepth, innerContext))
    ], {type: "mord"}));
    if (!result)
      return null;
    if (this.caret)
      result.caret = this.caret;
    return this.attachSupsub(context, {base: result});
  }
  serialize(options) {
    let result = "\\begin{" + this.environmentName + "}";
    if (this.environmentName === "array") {
      result += "{";
      if (this.colFormat !== void 0) {
        for (const format of this.colFormat) {
          if ("align" in format) {
            result += format.align;
          } else if ("separator" in format && format.separator === "solid") {
            result += "|";
          } else if ("separator" in format && format.separator === "dashed") {
            result += ":";
          }
        }
      }
      result += "}";
    }
    for (let row = 0; row < this.array.length; row++) {
      for (let col = 0; col < this.array[row].length; col++) {
        if (col > 0)
          result += " & ";
        result = joinLatex([
          result,
          Atom.serialize(this.array[row][col], options)
        ]);
      }
      if (row < this.array.length - 1) {
        result += " \\\\ ";
      }
    }
    result += "\\end{" + this.environmentName + "}";
    return result;
  }
  getCell(row, col) {
    return this.array[row][col];
  }
  setCell(_row, _column, _value) {
    console.assert(this.type === "array" && Array.isArray(this.array));
    this.isDirty = true;
  }
  addRowBefore(_row) {
    console.assert(this.type === "array" && Array.isArray(this.array));
    this.isDirty = true;
  }
  addRowAfter(_row) {
    console.assert(this.type === "array" && Array.isArray(this.array));
    this.isDirty = true;
  }
  addColumnBefore(_col) {
    console.assert(this.type === "array" && Array.isArray(this.array));
    this.isDirty = true;
  }
  addColumnAfter(_col) {
    console.assert(this.type === "array" && Array.isArray(this.array));
    this.isDirty = true;
  }
  get cells() {
    const result = [];
    for (const row of this.array) {
      for (const cell of row) {
        if (cell)
          result.push(cell);
      }
    }
    return result;
  }
};
function makeColGap(width) {
  const separator = new Box(null, {classes: "arraycolsep"});
  separator.width = width;
  return separator;
}
function makeColOfRepeatingElements(context, rows, offset, element) {
  if (!element)
    return null;
  const col = [];
  for (const row of rows) {
    const cell = Atom.createBox(context, element, {newList: true});
    if (cell) {
      cell.depth = row.depth;
      cell.height = row.height;
      col.push({box: cell, shift: row.pos - offset});
    }
  }
  return new VBox({individualShift: col}).wrap(context);
}

// src/core-definitions/environments.ts
defineEnvironment("math", "", (name, array, rowGaps) => new ArrayAtom(name, array, rowGaps, {mathstyleName: "textstyle"}));
defineEnvironment("displaymath", "", (name, array, rowGaps) => new ArrayAtom(name, array, rowGaps, {mathstyleName: "textstyle"}));
defineTabularEnvironment("array", "{columns:colspec}", (name, array, rowGaps, args) => new ArrayAtom(name, array, rowGaps, {
  columns: args[0],
  mathstyleName: "textstyle"
}));
defineTabularEnvironment(["equation", "equation*", "subequations"], "", (name, array, rowGaps) => new ArrayAtom(name, array, rowGaps, {
  columns: [{align: "c"}]
}));
defineTabularEnvironment("multline", "", (name, array, rowGaps) => new ArrayAtom(name, array, rowGaps, {
  columns: [{align: "m"}]
}));
defineTabularEnvironment(["align", "align*", "aligned", "eqnarray"], "", (name, array, rowGaps) => {
  let colCount = 0;
  for (const row of array) {
    colCount = Math.max(colCount, row.length);
  }
  const colFormat = [
    {gap: 0},
    {align: "r"},
    {gap: 0},
    {align: "l"}
  ];
  let i3 = 2;
  while (i3 < colCount) {
    colFormat.push({gap: 1});
    colFormat.push({align: "r"});
    colFormat.push({gap: 0});
    colFormat.push({align: "l"});
    i3 += 2;
  }
  colFormat.push({gap: 0});
  return new ArrayAtom(name, array, rowGaps, {
    arraycolsep: 0,
    columns: colFormat,
    colSeparationType: "align",
    jot: 0.3
  });
});
defineTabularEnvironment("split", "", (name, array, rowGaps) => new ArrayAtom(name, array, rowGaps, {
  columns: [{align: "r"}, {align: "l"}]
}));
defineTabularEnvironment(["gather", "gathered"], "", (name, array, rowGaps) => new ArrayAtom(name, array, rowGaps, {
  columns: [{gap: 0.25}, {align: "c"}, {gap: 0}],
  colSeparationType: "gather"
}));
defineTabularEnvironment([
  "matrix",
  "pmatrix",
  "bmatrix",
  "Bmatrix",
  "vmatrix",
  "Vmatrix",
  "matrix*",
  "pmatrix*",
  "bmatrix*",
  "Bmatrix*",
  "vmatrix*",
  "Vmatrix*"
], "[columns:colspec]", (name, array, rowGaps, args) => {
  let leftDelim = ".";
  let rightDelim = ".";
  switch (name) {
    case "pmatrix":
    case "pmatrix*":
      leftDelim = "(";
      rightDelim = ")";
      break;
    case "bmatrix":
    case "bmatrix*":
      leftDelim = "[";
      rightDelim = "]";
      break;
    case "Bmatrix":
    case "Bmatrix*":
      leftDelim = "\\lbrace";
      rightDelim = "\\rbrace";
      break;
    case "vmatrix":
    case "vmatrix*":
      leftDelim = "\\vert";
      rightDelim = "\\vert";
      break;
    case "Vmatrix":
    case "Vmatrix*":
      leftDelim = "\\Vert";
      rightDelim = "\\Vert";
      break;
    case "matrix":
    case "matrix*":
      leftDelim = ".";
      rightDelim = ".";
      break;
    default:
  }
  return new ArrayAtom(name, array, rowGaps, {
    mathstyleName: "textstyle",
    leftDelim,
    rightDelim,
    columns: args[0] ?? [
      {align: "c"},
      {align: "c"},
      {align: "c"},
      {align: "c"},
      {align: "c"},
      {align: "c"},
      {align: "c"},
      {align: "c"},
      {align: "c"},
      {align: "c"}
    ]
  });
});
defineTabularEnvironment(["smallmatrix", "smallmatrix*"], "[columns:colspec]", (name, array, rowGaps, args) => {
  return new ArrayAtom(name, array, rowGaps, {
    mathstyleName: "scriptstyle",
    columns: args[0] ?? [
      {align: "c"},
      {align: "c"},
      {align: "c"},
      {align: "c"},
      {align: "c"},
      {align: "c"},
      {align: "c"},
      {align: "c"},
      {align: "c"},
      {align: "c"}
    ],
    colSeparationType: "small",
    arraystretch: 0.5
  });
});
defineTabularEnvironment(["cases", "dcases"], "", (name, array, rowGaps) => {
  return new ArrayAtom(name, array, rowGaps, {
    mathstyleName: name === "dcases" ? "displaystyle" : "textstyle",
    arraystretch: 1.2,
    leftDelim: "\\lbrace",
    rightDelim: ".",
    columns: [{align: "l"}, {gap: 1}, {align: "l"}]
  });
});
defineTabularEnvironment("rcases", "", (name, array, rowGaps) => {
  return new ArrayAtom(name, array, rowGaps, {
    arraystretch: 1.2,
    leftDelim: ".",
    rightDelim: "\\rbrace",
    columns: [{align: "l"}, {gap: 1}, {align: "l"}]
  });
});
defineEnvironment("center", "", (name, array, rowGaps) => new ArrayAtom(name, array, rowGaps, {columns: [{align: "c"}]}));

// src/core-definitions/extensible-symbols.ts
defineFunction([
  "overrightarrow",
  "overleftarrow",
  "Overrightarrow",
  "overleftharpoon",
  "overrightharpoon",
  "overleftrightarrow",
  "overlinesegment",
  "overgroup"
], "{:auto}", {
  createAtom: (command, args, style) => new OverunderAtom(command, {
    body: args[0],
    skipBoundary: false,
    supsubPlacement: "over-under",
    padded: true,
    boxType: "mrel",
    style,
    svgAbove: command.slice(1)
  })
});
defineFunction("overbrace", "{:auto}", {
  createAtom: (command, args, style) => new OverunderAtom(command, {
    body: args[0],
    skipBoundary: false,
    supsubPlacement: "over-under",
    padded: true,
    boxType: "mord",
    style,
    svgAbove: command.slice(1)
  })
});
defineFunction([
  "underrightarrow",
  "underleftarrow",
  "underleftrightarrow",
  "underlinesegment",
  "undergroup"
], "{:auto}", {
  createAtom: (command, args, style) => new OverunderAtom(command, {
    body: args[0],
    skipBoundary: false,
    supsubPlacement: "over-under",
    padded: true,
    boxType: "mrel",
    style,
    svgBelow: command.slice(1)
  })
});
defineFunction(["underbrace"], "{:auto}", {
  createAtom: (command, args, style) => new OverunderAtom(command, {
    body: args[0],
    skipBoundary: false,
    supsubPlacement: "over-under",
    padded: true,
    boxType: "mord",
    style,
    svgBelow: command.slice(1)
  })
});
defineFunction([
  "xrightarrow",
  "xleftarrow",
  "xRightarrow",
  "xLeftarrow",
  "xleftharpoonup",
  "xleftharpoondown",
  "xrightharpoonup",
  "xrightharpoondown",
  "xlongequal",
  "xtwoheadleftarrow",
  "xtwoheadrightarrow",
  "xleftrightarrow",
  "xLeftrightarrow",
  "xrightleftharpoons",
  "xleftrightharpoons",
  "xhookleftarrow",
  "xhookrightarrow",
  "xmapsto",
  "xtofrom",
  "xrightleftarrows",
  "xrightequilibrium",
  "xleftequilibrium"
], "[:auto]{:auto}", {
  createAtom: (command, args, style) => new OverunderAtom(command, {
    style,
    svgBody: command.slice(1),
    above: args[1]?.length === 0 ? void 0 : args[1],
    below: args[0] ?? null,
    skipBoundary: false,
    supsubPlacement: "over-under",
    padded: true,
    boxType: "mrel",
    serialize: (atom, options) => command + (!atom.hasEmptyBranch("below") ? `[${atom.belowToLatex(options)}]` : "") + `{${atom.aboveToLatex(options)}}`
  })
});

// src/core-atoms/surd.ts
var SurdAtom = class extends Atom {
  constructor(command, options) {
    super("surd", {
      command,
      mode: options.mode ?? "math",
      style: options.style,
      displayContainsHighlight: true
    });
    this.body = options.body;
    this.above = options.index;
  }
  serialize(options) {
    let args = "";
    if (this.above) {
      args += `[${this.aboveToLatex(options)}]`;
    }
    args += `{${this.bodyToLatex(options)}}`;
    return this.command + args;
  }
  render(parentContext) {
    const innerContext = new Context(parentContext, this.style, "cramp");
    const innerBox = Atom.createBox(innerContext, this.body, {
      style: this.style,
      newList: true
    }) ?? new Box(null);
    const factor = innerContext.scalingFactor;
    const ruleWidth = innerContext.metrics.defaultRuleThickness / factor;
    const phi = parentContext.isDisplayStyle ? X_HEIGHT : ruleWidth;
    const line = new Box(null, {
      classes: "ML__sqrt-line",
      style: this.style,
      height: ruleWidth
    });
    let lineClearance = factor * (ruleWidth + phi / 4);
    const innerTotalHeight = Math.max(factor * 2 * phi, innerBox.height + innerBox.depth);
    const minDelimiterHeight = innerTotalHeight + lineClearance + ruleWidth;
    const delimContext = new Context(parentContext, this.style);
    const delimBox = this.bind(delimContext, new Box(makeCustomSizedDelim("", "\\surd", minDelimiterHeight, false, delimContext), {classes: "ML__sqrt-sign", style: this.style}));
    if (!delimBox)
      return null;
    const delimDepth = delimBox.height + delimBox.depth - ruleWidth;
    if (delimDepth > innerBox.height + innerBox.depth + lineClearance) {
      lineClearance = (lineClearance + delimDepth - (innerBox.height + innerBox.depth)) / 2;
    }
    delimBox.setTop(delimBox.height - innerBox.height - (lineClearance + ruleWidth));
    const bodyBox = new VBox({
      firstBaseline: [
        {box: new Box(innerBox)},
        lineClearance - 2 * ruleWidth,
        {box: line},
        ruleWidth
      ]
    }).wrap(parentContext);
    const indexBox = Atom.createBox(new Context(parentContext, this.style, "scriptscriptstyle"), this.above, {
      style: this.style,
      newList: true
    });
    if (!indexBox) {
      const result2 = new Box([delimBox, bodyBox], {
        classes: this.containsCaret ? "ML__contains-caret" : "",
        type: "mord"
      });
      if (this.caret)
        result2.caret = this.caret;
      return this.bind(parentContext, result2.wrap(parentContext));
    }
    const indexStack = new VBox({
      shift: -0.6 * (Math.max(delimBox.height, bodyBox.height) - Math.max(delimBox.depth, bodyBox.depth)),
      children: [{box: indexBox}]
    });
    const result = new Box([new Box(indexStack, {classes: "ML__sqrt-index"}), delimBox, bodyBox], {type: "mord", classes: this.containsCaret ? "ML__contains-caret" : ""});
    result.height = delimBox.height;
    result.depth = delimBox.depth;
    if (this.caret)
      result.caret = this.caret;
    return this.bind(parentContext, result.wrap(parentContext));
  }
};

// src/core-definitions/functions.ts
defineFunction([
  "arccos",
  "arcsin",
  "arctan",
  "arctg",
  "arcctg",
  "arg",
  "ch",
  "cos",
  "cosh",
  "cot",
  "coth",
  "ctg",
  "cth",
  "cotg",
  "csc",
  "cosec",
  "deg",
  "dim",
  "exp",
  "hom",
  "inf",
  "ker",
  "lg",
  "lb",
  "lg",
  "ln",
  "log",
  "Pr",
  "sec",
  "sh",
  "sin",
  "sinh",
  "sup",
  "tan",
  "tanh",
  "tg",
  "th"
], "", {
  isFunction: true,
  createAtom: (command, _args, style) => new OperatorAtom(command, command.slice(1), {
    limits: "adjacent",
    isFunction: true,
    variant: "main",
    variantStyle: "up",
    style
  })
});
defineFunction(["liminf", "limsup"], "", {
  createAtom: (command, _args, style) => new OperatorAtom(command, {"\\liminf": "lim inf", "\\limsup": "lim sup"}[command], {
    limits: "over-under",
    variant: "main",
    style
  })
});
defineFunction(["lim", "mod"], "", {
  createAtom: (command, _args, style) => new OperatorAtom(command, command.slice(1), {
    limits: "over-under",
    variant: "main",
    style
  })
});
defineFunction(["det", "max", "min"], "", {
  isFunction: true,
  createAtom: (command, _args, style) => new OperatorAtom(command, command.slice(1), {
    limits: "over-under",
    isFunction: true,
    variant: "main",
    style
  })
});
defineFunction("sqrt", "[index:auto]{radicand:auto}", {
  createAtom: (command, args, style) => new SurdAtom(command, {
    body: args[1],
    index: args[0],
    style
  })
});
defineFunction(["frac", "dfrac", "tfrac", "cfrac", "binom", "dbinom", "tbinom"], "{numerator}{denominator}", {
  createAtom: (command, args, style) => {
    const options = {
      style
    };
    switch (command) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        options.hasBarLine = true;
        break;
      case "\\atopfrac":
        options.hasBarLine = false;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        options.hasBarLine = false;
        options.leftDelim = "(";
        options.rightDelim = ")";
        break;
      default:
    }
    switch (command) {
      case "\\dfrac":
      case "\\dbinom":
        options.mathstyleName = "displaystyle";
        break;
      case "\\tfrac":
      case "\\tbinom":
        options.mathstyleName = "textstyle";
        break;
      case "\\cfrac":
        options.hasBarLine = true;
        options.continuousFraction = true;
        break;
      default:
    }
    return new GenfracAtom(command, args[0], args[1], options);
  }
});
defineFunction(["over", "atop", "choose"], "", {
  infix: true,
  createAtom: (command, args, style) => {
    let leftDelim = void 0;
    let rightDelim = void 0;
    if (command === "\\choose") {
      leftDelim = "(";
      rightDelim = ")";
    }
    return new GenfracAtom(command, args[0], args[1], {
      hasBarLine: command === "\\over",
      leftDelim,
      rightDelim,
      style,
      serialize: (atom, options) => `{${atom.aboveToLatex(options)}${atom.command} ${atom.belowToLatex(options)}}`
    });
  }
});
defineFunction("pdiff", "{numerator}{denominator}", {
  createAtom: (command, args, style) => new GenfracAtom(command, args[0], args[1], {
    hasBarLine: true,
    numerPrefix: "\u2202",
    denomPrefix: "\u2202",
    style
  })
});
defineFunction([
  "sum",
  "prod",
  "bigcup",
  "bigcap",
  "coprod",
  "bigvee",
  "bigwedge",
  "biguplus",
  "bigotimes",
  "bigoplus",
  "bigodot",
  "bigsqcup",
  "smallint",
  "intop"
], "", {
  createAtom: (command, args, style) => new OperatorAtom(command, {
    coprod: "\u2210",
    bigvee: "\u22C1",
    bigwedge: "\u22C0",
    biguplus: "\u2A04",
    bigcap: "\u22C2",
    bigcup: "\u22C3",
    intop: "\u222B",
    prod: "\u220F",
    sum: "\u2211",
    bigotimes: "\u2A02",
    bigoplus: "\u2A01",
    bigodot: "\u2A00",
    bigsqcup: "\u2A06",
    smallint: "\u222B"
  }[command.slice(1)], {
    isExtensibleSymbol: true,
    limits: "auto",
    variant: "main",
    style
  })
});
var EXTENSIBLE_SYMBOLS = {
  int: "\u222B",
  iint: "\u222C",
  iiint: "\u222D",
  oint: "\u222E",
  oiint: "\u222F",
  oiiint: "\u2230",
  intclockwise: "\u2231",
  varointclockwise: "\u2232",
  ointctrclockwise: "\u2233",
  intctrclockwise: "\u2A11",
  sqcup: "\u2294",
  sqcap: "\u2293",
  uplus: "\u228E",
  wr: "\u2240",
  amalg: "\u2A3F",
  Cap: "\u22D2",
  Cup: "\u22D3",
  doublecap: "\u22D2",
  doublecup: "\u22D3"
};
defineFunction(Object.keys(EXTENSIBLE_SYMBOLS), "", {
  createAtom: (command, _args, style) => new OperatorAtom(command, EXTENSIBLE_SYMBOLS[command.slice(1)], {
    limits: "adjacent",
    isExtensibleSymbol: true,
    style,
    variant: {"\u22D2": "ams", "\u22D3": "ams"}[EXTENSIBLE_SYMBOLS[command.slice(1)]]
  })
});
defineFunction(["Re", "Im"], "", {
  createAtom: (command, _args, style) => new OperatorAtom(command, {"\\Re": "\u211C", "\\Im": "\u2111"}[command], {
    limits: "adjacent",
    style,
    isFunction: true,
    variant: "fraktur"
  })
});
defineFunction("middle", "{:delim}", {
  createAtom: (command, args, style) => new DelimAtom(command, args[0], {size: 1, style})
});

// src/core-definitions/mhchem.ts
var ChemAtom = class extends Atom {
  constructor(command, arg) {
    super("chem", {command, mode: "math"});
    const tex = texify.go(mhchemParser.go(arg, command === "\\pu" ? "pu" : "ce"), false);
    this.body = parseLatex(tex);
    this.verbatimLatex = command + "{" + arg + "}";
    this.captureSelection = true;
  }
  render(context) {
    const box = Atom.createBox(context, this.body, {
      type: "chem",
      newList: true
    });
    if (this.caret)
      box.caret = this.caret;
    return this.bind(context, box);
  }
  serialize(_options) {
    return this.verbatimLatex;
  }
};
defineFunction(["ce", "pu"], "{chemformula:balanced-string}", {
  createAtom: (command, args, _style) => new ChemAtom(command, args[0])
});
var mhchemParser = {
  go: function(input, stateMachine) {
    if (!input) {
      return [];
    }
    if (stateMachine === void 0) {
      stateMachine = "ce";
    }
    var state = "0";
    var buffer = {};
    buffer["parenthesisLevel"] = 0;
    input = input.replace(/\n/g, " ");
    input = input.replace(/[\u2212\u2013\u2014\u2010]/g, "-");
    input = input.replace(/[\u2026]/g, "...");
    var lastInput;
    var watchdog = 10;
    var output = [];
    while (true) {
      if (lastInput !== input) {
        watchdog = 10;
        lastInput = input;
      } else {
        watchdog--;
      }
      var machine = mhchemParser.stateMachines[stateMachine];
      var t3 = machine.transitions[state] || machine.transitions["*"];
      iterateTransitions:
        for (var i3 = 0; i3 < t3.length; i3++) {
          var matches = mhchemParser.patterns.match_(t3[i3].pattern, input);
          if (matches) {
            var task = t3[i3].task;
            for (var iA = 0; iA < task.action_.length; iA++) {
              var o3;
              if (machine.actions[task.action_[iA].type_]) {
                o3 = machine.actions[task.action_[iA].type_](buffer, matches.match_, task.action_[iA].option);
              } else if (mhchemParser.actions[task.action_[iA].type_]) {
                o3 = mhchemParser.actions[task.action_[iA].type_](buffer, matches.match_, task.action_[iA].option);
              } else {
                throw [
                  "MhchemBugA",
                  "mhchem bug A. Please report. (" + task.action_[iA].type_ + ")"
                ];
              }
              mhchemParser.concatArray(output, o3);
            }
            state = task.nextState || state;
            if (input.length > 0) {
              if (!task.revisit) {
                input = matches.remainder;
              }
              if (!task.toContinue) {
                break iterateTransitions;
              }
            } else {
              return output;
            }
          }
        }
      if (watchdog <= 0) {
        throw ["MhchemBugU", "mhchem bug U. Please report."];
      }
    }
  },
  concatArray: function(a3, b3) {
    if (b3) {
      if (Array.isArray(b3)) {
        for (var iB = 0; iB < b3.length; iB++) {
          a3.push(b3[iB]);
        }
      } else {
        a3.push(b3);
      }
    }
  },
  patterns: {
    patterns: {
      "empty": /^$/,
      "else": /^./,
      "else2": /^./,
      "space": /^\s/,
      "space A": /^\s(?=[A-Z\\$])/,
      "space$": /^\s$/,
      "a-z": /^[a-z]/,
      "x": /^x/,
      "x$": /^x$/,
      "i$": /^i$/,
      "letters": /^(?:[a-zA-Z\u03B1-\u03C9\u0391-\u03A9?@]|(?:\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))))+/,
      "\\greek": /^\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))/,
      "one lowercase latin letter $": /^(?:([a-z])(?:$|[^a-zA-Z]))$/,
      "$one lowercase latin letter$ $": /^\$(?:([a-z])(?:$|[^a-zA-Z]))\$$/,
      "one lowercase greek letter $": /^(?:\$?[\u03B1-\u03C9]\$?|\$?\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega)\s*\$?)(?:\s+|\{\}|(?![a-zA-Z]))$/,
      "digits": /^[0-9]+/,
      "-9.,9": /^[+\-]?(?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))/,
      "-9.,9 no missing 0": /^[+\-]?[0-9]+(?:[.,][0-9]+)?/,
      "(-)(9.,9)(e)(99)": function(input) {
        var m3 = input.match(/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))?(\((?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))\))?(?:([eE]|\s*(\*|x|\\times|\u00D7)\s*10\^)([+\-]?[0-9]+|\{[+\-]?[0-9]+\}))?/);
        if (m3 && m3[0]) {
          return {
            match_: m3.splice(1),
            remainder: input.substr(m3[0].length)
          };
        }
        return null;
      },
      "(-)(9)^(-9)": function(input) {
        var m3 = input.match(/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+)?)\^([+\-]?[0-9]+|\{[+\-]?[0-9]+\})/);
        if (m3 && m3[0]) {
          return {
            match_: m3.splice(1),
            remainder: input.substr(m3[0].length)
          };
        }
        return null;
      },
      "state of aggregation $": function(input) {
        var a3 = mhchemParser.patterns.findObserveGroups(input, "", /^\([a-z]{1,3}(?=[\),])/, ")", "");
        if (a3 && a3.remainder.match(/^($|[\s,;\)\]\}])/)) {
          return a3;
        }
        var m3 = input.match(/^(?:\((?:\\ca\s?)?\$[amothc]\$\))/);
        if (m3) {
          return {
            match_: m3[0],
            remainder: input.substr(m3[0].length)
          };
        }
        return null;
      },
      "_{(state of aggregation)}$": /^_\{(\([a-z]{1,3}\))\}/,
      "{[(": /^(?:\\\{|\[|\()/,
      ")]}": /^(?:\)|\]|\\\})/,
      ", ": /^[,;]\s*/,
      ",": /^[,;]/,
      ".": /^[.]/,
      ". ": /^([.\u22C5\u00B7\u2022])\s*/,
      "...": /^\.\.\.(?=$|[^.])/,
      "* ": /^([*])\s*/,
      "^{(...)}": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "^{", "", "", "}");
      },
      "^($...$)": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "^", "$", "$", "");
      },
      "^a": /^\^([0-9]+|[^\\_])/,
      "^\\x{}{}": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "^", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true);
      },
      "^\\x{}": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "^", /^\\[a-zA-Z]+\{/, "}", "");
      },
      "^\\x": /^\^(\\[a-zA-Z]+)\s*/,
      "^(-1)": /^\^(-?\d+)/,
      "'": /^'/,
      "_{(...)}": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "_{", "", "", "}");
      },
      "_($...$)": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "_", "$", "$", "");
      },
      "_9": /^_([+\-]?[0-9]+|[^\\])/,
      "_\\x{}{}": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "_", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true);
      },
      "_\\x{}": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "_", /^\\[a-zA-Z]+\{/, "}", "");
      },
      "_\\x": /^_(\\[a-zA-Z]+)\s*/,
      "^_": /^(?:\^(?=_)|\_(?=\^)|[\^_]$)/,
      "{}": /^\{\}/,
      "{...}": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "", "{", "}", "");
      },
      "{(...)}": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "{", "", "", "}");
      },
      "$...$": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "", "$", "$", "");
      },
      "${(...)}$": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "${", "", "", "}$");
      },
      "$(...)$": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "$", "", "", "$");
      },
      "=<>": /^[=<>]/,
      "#": /^[#\u2261]/,
      "+": /^\+/,
      "-$": /^-(?=[\s_},;\]/]|$|\([a-z]+\))/,
      "-9": /^-(?=[0-9])/,
      "- orbital overlap": /^-(?=(?:[spd]|sp)(?:$|[\s,;\)\]\}]))/,
      "-": /^-/,
      "pm-operator": /^(?:\\pm|\$\\pm\$|\+-|\+\/-)/,
      "operator": /^(?:\+|(?:[\-=<>]|<<|>>|\\approx|\$\\approx\$)(?=\s|$|-?[0-9]))/,
      "arrowUpDown": /^(?:v|\(v\)|\^|\(\^\))(?=$|[\s,;\)\]\}])/,
      "\\bond{(...)}": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "\\bond{", "", "", "}");
      },
      "->": /^(?:<->|<-->|->|<-|<=>>|<<=>|<=>|[\u2192\u27F6\u21CC])/,
      "CMT": /^[CMT](?=\[)/,
      "[(...)]": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "[", "", "", "]");
      },
      "1st-level escape": /^(&|\\\\|\\hline)\s*/,
      "\\,": /^(?:\\[,\ ;:])/,
      "\\x{}{}": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true);
      },
      "\\x{}": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "", /^\\[a-zA-Z]+\{/, "}", "");
      },
      "\\ca": /^\\ca(?:\s+|(?![a-zA-Z]))/,
      "\\x": /^(?:\\[a-zA-Z]+\s*|\\[_&{}%])/,
      "orbital": /^(?:[0-9]{1,2}[spdfgh]|[0-9]{0,2}sp)(?=$|[^a-zA-Z])/,
      "others": /^[\/~|]/,
      "\\frac{(...)}": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "\\frac{", "", "", "}", "{", "", "", "}");
      },
      "\\overset{(...)}": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "\\overset{", "", "", "}", "{", "", "", "}");
      },
      "\\underset{(...)}": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "\\underset{", "", "", "}", "{", "", "", "}");
      },
      "\\underbrace{(...)}": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "\\underbrace{", "", "", "}_", "{", "", "", "}");
      },
      "\\color{(...)}0": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "\\color{", "", "", "}");
      },
      "\\color{(...)}{(...)}1": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "\\color{", "", "", "}", "{", "", "", "}");
      },
      "\\color(...){(...)}2": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "\\color", "\\", "", /^(?=\{)/, "{", "", "", "}");
      },
      "\\ce{(...)}": function(input) {
        return mhchemParser.patterns.findObserveGroups(input, "\\ce{", "", "", "}");
      },
      "oxidation$": /^(?:[+-][IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,
      "d-oxidation$": /^(?:[+-]?\s?[IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,
      "roman numeral": /^[IVX]+/,
      "1/2$": /^[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+(?:\$[a-z]\$|[a-z])?$/,
      "amount": function(input) {
        var match2;
        match2 = input.match(/^(?:(?:(?:\([+\-]?[0-9]+\/[0-9]+\)|[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+|[+\-]?[0-9]+[.,][0-9]+|[+\-]?\.[0-9]+|[+\-]?[0-9]+)(?:[a-z](?=\s*[A-Z]))?)|[+\-]?[a-z](?=\s*[A-Z])|\+(?!\s))/);
        if (match2) {
          return {
            match_: match2[0],
            remainder: input.substr(match2[0].length)
          };
        }
        var a3 = mhchemParser.patterns.findObserveGroups(input, "", "$", "$", "");
        if (a3) {
          match2 = a3.match_.match(/^\$(?:\(?[+\-]?(?:[0-9]*[a-z]?[+\-])?[0-9]*[a-z](?:[+\-][0-9]*[a-z]?)?\)?|\+|-)\$$/);
          if (match2) {
            return {
              match_: match2[0],
              remainder: input.substr(match2[0].length)
            };
          }
        }
        return null;
      },
      "amount2": function(input) {
        return this["amount"](input);
      },
      "(KV letters),": /^(?:[A-Z][a-z]{0,2}|i)(?=,)/,
      "formula$": function(input) {
        if (input.match(/^\([a-z]+\)$/)) {
          return null;
        }
        var match2 = input.match(/^(?:[a-z]|(?:[0-9\ \+\-\,\.\(\)]+[a-z])+[0-9\ \+\-\,\.\(\)]*|(?:[a-z][0-9\ \+\-\,\.\(\)]+)+[a-z]?)$/);
        if (match2) {
          return {
            match_: match2[0],
            remainder: input.substr(match2[0].length)
          };
        }
        return null;
      },
      "uprightEntities": /^(?:pH|pOH|pC|pK|iPr|iBu)(?=$|[^a-zA-Z])/,
      "/": /^\s*(\/)\s*/,
      "//": /^\s*(\/\/)\s*/,
      "*": /^\s*[*.]\s*/
    },
    findObserveGroups: function(input, begExcl, begIncl, endIncl, endExcl, beg2Excl, beg2Incl, end2Incl, end2Excl, combine) {
      var _match = function(input2, pattern) {
        if (typeof pattern === "string") {
          if (input2.indexOf(pattern) !== 0) {
            return null;
          }
          return pattern;
        } else {
          var match3 = input2.match(pattern);
          if (!match3) {
            return null;
          }
          return match3[0];
        }
      };
      var _findObserveGroups = function(input2, i3, endChars) {
        var braces = 0;
        while (i3 < input2.length) {
          var a3 = input2.charAt(i3);
          var match3 = _match(input2.substr(i3), endChars);
          if (match3 !== null && braces === 0) {
            return {
              endMatchBegin: i3,
              endMatchEnd: i3 + match3.length
            };
          } else if (a3 === "{") {
            braces++;
          } else if (a3 === "}") {
            if (braces === 0) {
              throw [
                "ExtraCloseMissingOpen",
                "Extra close brace or missing open brace"
              ];
            } else {
              braces--;
            }
          }
          i3++;
        }
        if (braces > 0) {
          return null;
        }
        return null;
      };
      var match2 = _match(input, begExcl);
      if (match2 === null) {
        return null;
      }
      input = input.substr(match2.length);
      match2 = _match(input, begIncl);
      if (match2 === null) {
        return null;
      }
      var e3 = _findObserveGroups(input, match2.length, endIncl || endExcl);
      if (e3 === null) {
        return null;
      }
      var match1 = input.substring(0, endIncl ? e3.endMatchEnd : e3.endMatchBegin);
      if (!(beg2Excl || beg2Incl)) {
        return {
          match_: match1,
          remainder: input.substr(e3.endMatchEnd)
        };
      } else {
        var group2 = this.findObserveGroups(input.substr(e3.endMatchEnd), beg2Excl, beg2Incl, end2Incl, end2Excl);
        if (group2 === null) {
          return null;
        }
        var matchRet = [match1, group2.match_];
        return {
          match_: combine ? matchRet.join("") : matchRet,
          remainder: group2.remainder
        };
      }
    },
    match_: function(m3, input) {
      var pattern = mhchemParser.patterns.patterns[m3];
      if (pattern === void 0) {
        throw ["MhchemBugP", "mhchem bug P. Please report. (" + m3 + ")"];
      } else if (typeof pattern === "function") {
        return mhchemParser.patterns.patterns[m3](input);
      } else {
        var match2 = input.match(pattern);
        if (match2) {
          var mm;
          if (match2[2]) {
            mm = [match2[1], match2[2]];
          } else if (match2[1]) {
            mm = match2[1];
          } else {
            mm = match2[0];
          }
          return {
            match_: mm,
            remainder: input.substr(match2[0].length)
          };
        }
        return null;
      }
    }
  },
  actions: {
    "a=": function(buffer, m3) {
      buffer.a = (buffer.a || "") + m3;
    },
    "b=": function(buffer, m3) {
      buffer.b = (buffer.b || "") + m3;
    },
    "p=": function(buffer, m3) {
      buffer.p = (buffer.p || "") + m3;
    },
    "o=": function(buffer, m3) {
      buffer.o = (buffer.o || "") + m3;
    },
    "q=": function(buffer, m3) {
      buffer.q = (buffer.q || "") + m3;
    },
    "d=": function(buffer, m3) {
      buffer.d = (buffer.d || "") + m3;
    },
    "rm=": function(buffer, m3) {
      buffer.rm = (buffer.rm || "") + m3;
    },
    "text=": function(buffer, m3) {
      buffer.text_ = (buffer.text_ || "") + m3;
    },
    "insert": function(buffer, m3, a3) {
      return {type_: a3};
    },
    "insert+p1": function(buffer, m3, a3) {
      return {type_: a3, p1: m3};
    },
    "insert+p1+p2": function(buffer, m3, a3) {
      return {type_: a3, p1: m3[0], p2: m3[1]};
    },
    "copy": function(buffer, m3) {
      return m3;
    },
    "rm": function(buffer, m3) {
      return {type_: "rm", p1: m3 || ""};
    },
    "text": function(buffer, m3) {
      return mhchemParser.go(m3, "text");
    },
    "{text}": function(buffer, m3) {
      var ret = ["{"];
      mhchemParser.concatArray(ret, mhchemParser.go(m3, "text"));
      ret.push("}");
      return ret;
    },
    "tex-math": function(buffer, m3) {
      return mhchemParser.go(m3, "tex-math");
    },
    "tex-math tight": function(buffer, m3) {
      return mhchemParser.go(m3, "tex-math tight");
    },
    "bond": function(buffer, m3, k3) {
      return {type_: "bond", kind_: k3 || m3};
    },
    "color0-output": function(buffer, m3) {
      return {type_: "color0", color: m3[0]};
    },
    "ce": function(buffer, m3) {
      return mhchemParser.go(m3);
    },
    "1/2": function(buffer, m3) {
      var ret = [];
      if (m3.match(/^[+\-]/)) {
        ret.push(m3.substr(0, 1));
        m3 = m3.substr(1);
      }
      var n3 = m3.match(/^([0-9]+|\$[a-z]\$|[a-z])\/([0-9]+)(\$[a-z]\$|[a-z])?$/);
      n3[1] = n3[1].replace(/\$/g, "");
      ret.push({type_: "frac", p1: n3[1], p2: n3[2]});
      if (n3[3]) {
        n3[3] = n3[3].replace(/\$/g, "");
        ret.push({type_: "tex-math", p1: n3[3]});
      }
      return ret;
    },
    "9,9": function(buffer, m3) {
      return mhchemParser.go(m3, "9,9");
    }
  },
  createTransitions: function(o3) {
    var pattern, state;
    var stateArray;
    var i3;
    var transitions = {};
    for (pattern in o3) {
      for (state in o3[pattern]) {
        stateArray = state.split("|");
        o3[pattern][state].stateArray = stateArray;
        for (i3 = 0; i3 < stateArray.length; i3++) {
          transitions[stateArray[i3]] = [];
        }
      }
    }
    for (pattern in o3) {
      for (state in o3[pattern]) {
        stateArray = o3[pattern][state].stateArray || [];
        for (i3 = 0; i3 < stateArray.length; i3++) {
          var p3 = o3[pattern][state];
          if (p3.action_) {
            p3.action_ = [].concat(p3.action_);
            for (var k3 = 0; k3 < p3.action_.length; k3++) {
              if (typeof p3.action_[k3] === "string") {
                p3.action_[k3] = {type_: p3.action_[k3]};
              }
            }
          } else {
            p3.action_ = [];
          }
          var patternArray = pattern.split("|");
          for (var j2 = 0; j2 < patternArray.length; j2++) {
            if (stateArray[i3] === "*") {
              for (var t3 in transitions) {
                transitions[t3].push({
                  pattern: patternArray[j2],
                  task: p3
                });
              }
            } else {
              transitions[stateArray[i3]].push({
                pattern: patternArray[j2],
                task: p3
              });
            }
          }
        }
      }
    }
    return transitions;
  },
  stateMachines: {}
};
mhchemParser.stateMachines = {
  "ce": {
    transitions: mhchemParser.createTransitions({
      "empty": {
        "*": {action_: "output"}
      },
      "else": {
        "0|1|2": {
          action_: "beginsWithBond=false",
          revisit: true,
          toContinue: true
        }
      },
      "oxidation$": {
        "0": {action_: "oxidation-output"}
      },
      "CMT": {
        r: {action_: "rdt=", nextState: "rt"},
        rd: {action_: "rqt=", nextState: "rdt"}
      },
      "arrowUpDown": {
        "0|1|2|as": {
          action_: ["sb=false", "output", "operator"],
          nextState: "1"
        }
      },
      "uprightEntities": {
        "0|1|2": {action_: ["o=", "output"], nextState: "1"}
      },
      "orbital": {
        "0|1|2|3": {action_: "o=", nextState: "o"}
      },
      "->": {
        "0|1|2|3": {action_: "r=", nextState: "r"},
        "a|as": {action_: ["output", "r="], nextState: "r"},
        "*": {action_: ["output", "r="], nextState: "r"}
      },
      "+": {
        "o": {action_: "d= kv", nextState: "d"},
        "d|D": {action_: "d=", nextState: "d"},
        "q": {action_: "d=", nextState: "qd"},
        "qd|qD": {action_: "d=", nextState: "qd"},
        "dq": {action_: ["output", "d="], nextState: "d"},
        "3": {
          action_: ["sb=false", "output", "operator"],
          nextState: "0"
        }
      },
      "amount": {
        "0|2": {action_: "a=", nextState: "a"}
      },
      "pm-operator": {
        "0|1|2|a|as": {
          action_: [
            "sb=false",
            "output",
            {type_: "operator", option: "\\pm"}
          ],
          nextState: "0"
        }
      },
      "operator": {
        "0|1|2|a|as": {
          action_: ["sb=false", "output", "operator"],
          nextState: "0"
        }
      },
      "-$": {
        "o|q": {
          action_: ["charge or bond", "output"],
          nextState: "qd"
        },
        "d": {action_: "d=", nextState: "d"},
        "D": {
          action_: ["output", {type_: "bond", option: "-"}],
          nextState: "3"
        },
        "q": {action_: "d=", nextState: "qd"},
        "qd": {action_: "d=", nextState: "qd"},
        "qD|dq": {
          action_: ["output", {type_: "bond", option: "-"}],
          nextState: "3"
        }
      },
      "-9": {
        "3|o": {
          action_: ["output", {type_: "insert", option: "hyphen"}],
          nextState: "3"
        }
      },
      "- orbital overlap": {
        o: {
          action_: ["output", {type_: "insert", option: "hyphen"}],
          nextState: "2"
        },
        d: {
          action_: ["output", {type_: "insert", option: "hyphen"}],
          nextState: "2"
        }
      },
      "-": {
        "0|1|2": {
          action_: [
            {type_: "output", option: 1},
            "beginsWithBond=true",
            {type_: "bond", option: "-"}
          ],
          nextState: "3"
        },
        "3": {action_: {type_: "bond", option: "-"}},
        "a": {
          action_: ["output", {type_: "insert", option: "hyphen"}],
          nextState: "2"
        },
        "as": {
          action_: [
            {type_: "output", option: 2},
            {type_: "bond", option: "-"}
          ],
          nextState: "3"
        },
        "b": {action_: "b="},
        "o": {
          action_: {type_: "- after o/d", option: false},
          nextState: "2"
        },
        "q": {
          action_: {type_: "- after o/d", option: false},
          nextState: "2"
        },
        "d|qd|dq": {
          action_: {type_: "- after o/d", option: true},
          nextState: "2"
        },
        "D|qD|p": {
          action_: ["output", {type_: "bond", option: "-"}],
          nextState: "3"
        }
      },
      "amount2": {
        "1|3": {action_: "a=", nextState: "a"}
      },
      "letters": {
        "0|1|2|3|a|as|b|p|bp|o": {action_: "o=", nextState: "o"},
        "q|dq": {action_: ["output", "o="], nextState: "o"},
        "d|D|qd|qD": {action_: "o after d", nextState: "o"}
      },
      "digits": {
        "o": {action_: "q=", nextState: "q"},
        "d|D": {action_: "q=", nextState: "dq"},
        "q": {action_: ["output", "o="], nextState: "o"},
        "a": {action_: "o=", nextState: "o"}
      },
      "space A": {
        "b|p|bp": {}
      },
      "space": {
        "a": {nextState: "as"},
        "0": {action_: "sb=false"},
        "1|2": {action_: "sb=true"},
        "r|rt|rd|rdt|rdq": {action_: "output", nextState: "0"},
        "*": {action_: ["output", "sb=true"], nextState: "1"}
      },
      "1st-level escape": {
        "1|2": {
          action_: [
            "output",
            {type_: "insert+p1", option: "1st-level escape"}
          ]
        },
        "*": {
          action_: [
            "output",
            {type_: "insert+p1", option: "1st-level escape"}
          ],
          nextState: "0"
        }
      },
      "[(...)]": {
        "r|rt": {action_: "rd=", nextState: "rd"},
        "rd|rdt": {action_: "rq=", nextState: "rdq"}
      },
      "...": {
        "o|d|D|dq|qd|qD": {
          action_: ["output", {type_: "bond", option: "..."}],
          nextState: "3"
        },
        "*": {
          action_: [
            {type_: "output", option: 1},
            {type_: "insert", option: "ellipsis"}
          ],
          nextState: "1"
        }
      },
      ". |* ": {
        "*": {
          action_: ["output", {type_: "insert", option: "addition compound"}],
          nextState: "1"
        }
      },
      "state of aggregation $": {
        "*": {
          action_: ["output", "state of aggregation"],
          nextState: "1"
        }
      },
      "{[(": {
        "a|as|o": {
          action_: ["o=", "output", "parenthesisLevel++"],
          nextState: "2"
        },
        "0|1|2|3": {
          action_: ["o=", "output", "parenthesisLevel++"],
          nextState: "2"
        },
        "*": {
          action_: ["output", "o=", "output", "parenthesisLevel++"],
          nextState: "2"
        }
      },
      ")]}": {
        "0|1|2|3|b|p|bp|o": {
          action_: ["o=", "parenthesisLevel--"],
          nextState: "o"
        },
        "a|as|d|D|q|qd|qD|dq": {
          action_: ["output", "o=", "parenthesisLevel--"],
          nextState: "o"
        }
      },
      ", ": {
        "*": {action_: ["output", "comma"], nextState: "0"}
      },
      "^_": {
        "*": {}
      },
      "^{(...)}|^($...$)": {
        "0|1|2|as": {action_: "b=", nextState: "b"},
        "p": {action_: "b=", nextState: "bp"},
        "3|o": {action_: "d= kv", nextState: "D"},
        "q": {action_: "d=", nextState: "qD"},
        "d|D|qd|qD|dq": {action_: ["output", "d="], nextState: "D"}
      },
      "^a|^\\x{}{}|^\\x{}|^\\x|'": {
        "0|1|2|as": {action_: "b=", nextState: "b"},
        "p": {action_: "b=", nextState: "bp"},
        "3|o": {action_: "d= kv", nextState: "d"},
        "q": {action_: "d=", nextState: "qd"},
        "d|qd|D|qD": {action_: "d="},
        "dq": {action_: ["output", "d="], nextState: "d"}
      },
      "_{(state of aggregation)}$": {
        "d|D|q|qd|qD|dq": {action_: ["output", "q="], nextState: "q"}
      },
      "_{(...)}|_($...$)|_9|_\\x{}{}|_\\x{}|_\\x": {
        "0|1|2|as": {action_: "p=", nextState: "p"},
        "b": {action_: "p=", nextState: "bp"},
        "3|o": {action_: "q=", nextState: "q"},
        "d|D": {action_: "q=", nextState: "dq"},
        "q|qd|qD|dq": {action_: ["output", "q="], nextState: "q"}
      },
      "=<>": {
        "0|1|2|3|a|as|o|q|d|D|qd|qD|dq": {
          action_: [{type_: "output", option: 2}, "bond"],
          nextState: "3"
        }
      },
      "#": {
        "0|1|2|3|a|as|o": {
          action_: [
            {type_: "output", option: 2},
            {type_: "bond", option: "#"}
          ],
          nextState: "3"
        }
      },
      "{}": {
        "*": {
          action_: {type_: "output", option: 1},
          nextState: "1"
        }
      },
      "{...}": {
        "0|1|2|3|a|as|b|p|bp": {action_: "o=", nextState: "o"},
        "o|d|D|q|qd|qD|dq": {
          action_: ["output", "o="],
          nextState: "o"
        }
      },
      "$...$": {
        "a": {action_: "a="},
        "0|1|2|3|as|b|p|bp|o": {action_: "o=", nextState: "o"},
        "as|o": {action_: "o="},
        "q|d|D|qd|qD|dq": {action_: ["output", "o="], nextState: "o"}
      },
      "\\bond{(...)}": {
        "*": {
          action_: [{type_: "output", option: 2}, "bond"],
          nextState: "3"
        }
      },
      "\\frac{(...)}": {
        "*": {
          action_: [{type_: "output", option: 1}, "frac-output"],
          nextState: "3"
        }
      },
      "\\overset{(...)}": {
        "*": {
          action_: [{type_: "output", option: 2}, "overset-output"],
          nextState: "3"
        }
      },
      "\\underset{(...)}": {
        "*": {
          action_: [{type_: "output", option: 2}, "underset-output"],
          nextState: "3"
        }
      },
      "\\underbrace{(...)}": {
        "*": {
          action_: [{type_: "output", option: 2}, "underbrace-output"],
          nextState: "3"
        }
      },
      "\\color{(...)}{(...)}1|\\color(...){(...)}2": {
        "*": {
          action_: [{type_: "output", option: 2}, "color-output"],
          nextState: "3"
        }
      },
      "\\color{(...)}0": {
        "*": {
          action_: [{type_: "output", option: 2}, "color0-output"]
        }
      },
      "\\ce{(...)}": {
        "*": {
          action_: [{type_: "output", option: 2}, "ce"],
          nextState: "3"
        }
      },
      "\\,": {
        "*": {
          action_: [{type_: "output", option: 1}, "copy"],
          nextState: "1"
        }
      },
      "\\x{}{}|\\x{}|\\x": {
        "0|1|2|3|a|as|b|p|bp|o|c0": {
          action_: ["o=", "output"],
          nextState: "3"
        },
        "*": {action_: ["output", "o=", "output"], nextState: "3"}
      },
      "others": {
        "*": {
          action_: [{type_: "output", option: 1}, "copy"],
          nextState: "3"
        }
      },
      "else2": {
        "a": {action_: "a to o", nextState: "o", revisit: true},
        "as": {
          action_: ["output", "sb=true"],
          nextState: "1",
          revisit: true
        },
        "r|rt|rd|rdt|rdq": {
          action_: ["output"],
          nextState: "0",
          revisit: true
        },
        "*": {action_: ["output", "copy"], nextState: "3"}
      }
    }),
    actions: {
      "o after d": function(buffer, m3) {
        var ret;
        if ((buffer.d || "").match(/^[0-9]+$/)) {
          var tmp = buffer.d;
          buffer.d = void 0;
          ret = this["output"](buffer);
          buffer.b = tmp;
        } else {
          ret = this["output"](buffer);
        }
        mhchemParser.actions["o="](buffer, m3);
        return ret;
      },
      "d= kv": function(buffer, m3) {
        buffer.d = m3;
        buffer.dType = "kv";
      },
      "charge or bond": function(buffer, m3) {
        if (buffer["beginsWithBond"]) {
          var ret = [];
          mhchemParser.concatArray(ret, this["output"](buffer));
          mhchemParser.concatArray(ret, mhchemParser.actions["bond"](buffer, m3, "-"));
          return ret;
        } else {
          buffer.d = m3;
        }
      },
      "- after o/d": function(buffer, m3, isAfterD) {
        var c1 = mhchemParser.patterns.match_("orbital", buffer.o || "");
        var c22 = mhchemParser.patterns.match_("one lowercase greek letter $", buffer.o || "");
        var c3 = mhchemParser.patterns.match_("one lowercase latin letter $", buffer.o || "");
        var c4 = mhchemParser.patterns.match_("$one lowercase latin letter$ $", buffer.o || "");
        var hyphenFollows = m3 === "-" && (c1 && c1.remainder === "" || c22 || c3 || c4);
        if (hyphenFollows && !buffer.a && !buffer.b && !buffer.p && !buffer.d && !buffer.q && !c1 && c3) {
          buffer.o = "$" + buffer.o + "$";
        }
        var ret = [];
        if (hyphenFollows) {
          mhchemParser.concatArray(ret, this["output"](buffer));
          ret.push({type_: "hyphen"});
        } else {
          c1 = mhchemParser.patterns.match_("digits", buffer.d || "");
          if (isAfterD && c1 && c1.remainder === "") {
            mhchemParser.concatArray(ret, mhchemParser.actions["d="](buffer, m3));
            mhchemParser.concatArray(ret, this["output"](buffer));
          } else {
            mhchemParser.concatArray(ret, this["output"](buffer));
            mhchemParser.concatArray(ret, mhchemParser.actions["bond"](buffer, m3, "-"));
          }
        }
        return ret;
      },
      "a to o": function(buffer) {
        buffer.o = buffer.a;
        buffer.a = void 0;
      },
      "sb=true": function(buffer) {
        buffer.sb = true;
      },
      "sb=false": function(buffer) {
        buffer.sb = false;
      },
      "beginsWithBond=true": function(buffer) {
        buffer["beginsWithBond"] = true;
      },
      "beginsWithBond=false": function(buffer) {
        buffer["beginsWithBond"] = false;
      },
      "parenthesisLevel++": function(buffer) {
        buffer["parenthesisLevel"]++;
      },
      "parenthesisLevel--": function(buffer) {
        buffer["parenthesisLevel"]--;
      },
      "state of aggregation": function(buffer, m3) {
        return {
          type_: "state of aggregation",
          p1: mhchemParser.go(m3, "o")
        };
      },
      "comma": function(buffer, m3) {
        var a3 = m3.replace(/\s*$/, "");
        var withSpace = a3 !== m3;
        if (withSpace && buffer["parenthesisLevel"] === 0) {
          return {type_: "comma enumeration L", p1: a3};
        } else {
          return {type_: "comma enumeration M", p1: a3};
        }
      },
      "output": function(buffer, m3, entityFollows) {
        var ret;
        if (!buffer.r) {
          ret = [];
          if (!buffer.a && !buffer.b && !buffer.p && !buffer.o && !buffer.q && !buffer.d && !entityFollows) {
          } else {
            if (buffer.sb) {
              ret.push({type_: "entitySkip"});
            }
            if (!buffer.o && !buffer.q && !buffer.d && !buffer.b && !buffer.p && entityFollows !== 2) {
              buffer.o = buffer.a;
              buffer.a = void 0;
            } else if (!buffer.o && !buffer.q && !buffer.d && (buffer.b || buffer.p)) {
              buffer.o = buffer.a;
              buffer.d = buffer.b;
              buffer.q = buffer.p;
              buffer.a = buffer.b = buffer.p = void 0;
            } else {
              if (buffer.o && buffer.dType === "kv" && mhchemParser.patterns.match_("d-oxidation$", buffer.d || "")) {
                buffer.dType = "oxidation";
              } else if (buffer.o && buffer.dType === "kv" && !buffer.q) {
                buffer.dType = void 0;
              }
            }
            ret.push({
              type_: "chemfive",
              a: mhchemParser.go(buffer.a, "a"),
              b: mhchemParser.go(buffer.b, "bd"),
              p: mhchemParser.go(buffer.p, "pq"),
              o: mhchemParser.go(buffer.o, "o"),
              q: mhchemParser.go(buffer.q, "pq"),
              d: mhchemParser.go(buffer.d, buffer.dType === "oxidation" ? "oxidation" : "bd"),
              dType: buffer.dType
            });
          }
        } else {
          var rd;
          if (buffer.rdt === "M") {
            rd = mhchemParser.go(buffer.rd, "tex-math");
          } else if (buffer.rdt === "T") {
            rd = [{type_: "text", p1: buffer.rd || ""}];
          } else {
            rd = mhchemParser.go(buffer.rd);
          }
          var rq;
          if (buffer.rqt === "M") {
            rq = mhchemParser.go(buffer.rq, "tex-math");
          } else if (buffer.rqt === "T") {
            rq = [{type_: "text", p1: buffer.rq || ""}];
          } else {
            rq = mhchemParser.go(buffer.rq);
          }
          ret = {
            type_: "arrow",
            r: buffer.r,
            rd,
            rq
          };
        }
        for (var p3 in buffer) {
          if (p3 !== "parenthesisLevel" && p3 !== "beginsWithBond") {
            delete buffer[p3];
          }
        }
        return ret;
      },
      "oxidation-output": function(buffer, m3) {
        var ret = ["{"];
        mhchemParser.concatArray(ret, mhchemParser.go(m3, "oxidation"));
        ret.push("}");
        return ret;
      },
      "frac-output": function(buffer, m3) {
        return {
          type_: "frac-ce",
          p1: mhchemParser.go(m3[0]),
          p2: mhchemParser.go(m3[1])
        };
      },
      "overset-output": function(buffer, m3) {
        return {
          type_: "overset",
          p1: mhchemParser.go(m3[0]),
          p2: mhchemParser.go(m3[1])
        };
      },
      "underset-output": function(buffer, m3) {
        return {
          type_: "underset",
          p1: mhchemParser.go(m3[0]),
          p2: mhchemParser.go(m3[1])
        };
      },
      "underbrace-output": function(buffer, m3) {
        return {
          type_: "underbrace",
          p1: mhchemParser.go(m3[0]),
          p2: mhchemParser.go(m3[1])
        };
      },
      "color-output": function(buffer, m3) {
        return {
          type_: "color",
          color1: m3[0],
          color2: mhchemParser.go(m3[1])
        };
      },
      "r=": function(buffer, m3) {
        buffer.r = m3;
      },
      "rdt=": function(buffer, m3) {
        buffer.rdt = m3;
      },
      "rd=": function(buffer, m3) {
        buffer.rd = m3;
      },
      "rqt=": function(buffer, m3) {
        buffer.rqt = m3;
      },
      "rq=": function(buffer, m3) {
        buffer.rq = m3;
      },
      "operator": function(buffer, m3, p1) {
        return {type_: "operator", kind_: p1 || m3};
      }
    }
  },
  "a": {
    transitions: mhchemParser.createTransitions({
      "empty": {
        "*": {}
      },
      "1/2$": {
        "0": {action_: "1/2"}
      },
      "else": {
        "0": {nextState: "1", revisit: true}
      },
      "$(...)$": {
        "*": {action_: "tex-math tight", nextState: "1"}
      },
      ",": {
        "*": {action_: {type_: "insert", option: "commaDecimal"}}
      },
      "else2": {
        "*": {action_: "copy"}
      }
    }),
    actions: {}
  },
  "o": {
    transitions: mhchemParser.createTransitions({
      "empty": {
        "*": {}
      },
      "1/2$": {
        "0": {action_: "1/2"}
      },
      "else": {
        "0": {nextState: "1", revisit: true}
      },
      "letters": {
        "*": {action_: "rm"}
      },
      "\\ca": {
        "*": {action_: {type_: "insert", option: "circa"}}
      },
      "\\x{}{}|\\x{}|\\x": {
        "*": {action_: "copy"}
      },
      "${(...)}$|$(...)$": {
        "*": {action_: "tex-math"}
      },
      "{(...)}": {
        "*": {action_: "{text}"}
      },
      "else2": {
        "*": {action_: "copy"}
      }
    }),
    actions: {}
  },
  "text": {
    transitions: mhchemParser.createTransitions({
      "empty": {
        "*": {action_: "output"}
      },
      "{...}": {
        "*": {action_: "text="}
      },
      "${(...)}$|$(...)$": {
        "*": {action_: "tex-math"}
      },
      "\\greek": {
        "*": {action_: ["output", "rm"]}
      },
      "\\,|\\x{}{}|\\x{}|\\x": {
        "*": {action_: ["output", "copy"]}
      },
      "else": {
        "*": {action_: "text="}
      }
    }),
    actions: {
      output: function(buffer) {
        if (buffer.text_) {
          var ret = {type_: "text", p1: buffer.text_};
          for (var p3 in buffer) {
            delete buffer[p3];
          }
          return ret;
        }
      }
    }
  },
  "pq": {
    transitions: mhchemParser.createTransitions({
      "empty": {
        "*": {}
      },
      "state of aggregation $": {
        "*": {action_: "state of aggregation"}
      },
      "i$": {
        "0": {nextState: "!f", revisit: true}
      },
      "(KV letters),": {
        "0": {action_: "rm", nextState: "0"}
      },
      "formula$": {
        "0": {nextState: "f", revisit: true}
      },
      "1/2$": {
        "0": {action_: "1/2"}
      },
      "else": {
        "0": {nextState: "!f", revisit: true}
      },
      "${(...)}$|$(...)$": {
        "*": {action_: "tex-math"}
      },
      "{(...)}": {
        "*": {action_: "text"}
      },
      "a-z": {
        f: {action_: "tex-math"}
      },
      "letters": {
        "*": {action_: "rm"}
      },
      "-9.,9": {
        "*": {action_: "9,9"}
      },
      ",": {
        "*": {
          action_: {
            type_: "insert+p1",
            option: "comma enumeration S"
          }
        }
      },
      "\\color{(...)}{(...)}1|\\color(...){(...)}2": {
        "*": {action_: "color-output"}
      },
      "\\color{(...)}0": {
        "*": {action_: "color0-output"}
      },
      "\\ce{(...)}": {
        "*": {action_: "ce"}
      },
      "\\,|\\x{}{}|\\x{}|\\x": {
        "*": {action_: "copy"}
      },
      "else2": {
        "*": {action_: "copy"}
      }
    }),
    actions: {
      "state of aggregation": function(buffer, m3) {
        return {
          type_: "state of aggregation subscript",
          p1: mhchemParser.go(m3, "o")
        };
      },
      "color-output": function(buffer, m3) {
        return {
          type_: "color",
          color1: m3[0],
          color2: mhchemParser.go(m3[1], "pq")
        };
      }
    }
  },
  "bd": {
    transitions: mhchemParser.createTransitions({
      "empty": {
        "*": {}
      },
      "x$": {
        "0": {nextState: "!f", revisit: true}
      },
      "formula$": {
        "0": {nextState: "f", revisit: true}
      },
      "else": {
        "0": {nextState: "!f", revisit: true}
      },
      "-9.,9 no missing 0": {
        "*": {action_: "9,9"}
      },
      ".": {
        "*": {action_: {type_: "insert", option: "electron dot"}}
      },
      "a-z": {
        f: {action_: "tex-math"}
      },
      "x": {
        "*": {action_: {type_: "insert", option: "KV x"}}
      },
      "letters": {
        "*": {action_: "rm"}
      },
      "'": {
        "*": {action_: {type_: "insert", option: "prime"}}
      },
      "${(...)}$|$(...)$": {
        "*": {action_: "tex-math"}
      },
      "{(...)}": {
        "*": {action_: "text"}
      },
      "\\color{(...)}{(...)}1|\\color(...){(...)}2": {
        "*": {action_: "color-output"}
      },
      "\\color{(...)}0": {
        "*": {action_: "color0-output"}
      },
      "\\ce{(...)}": {
        "*": {action_: "ce"}
      },
      "\\,|\\x{}{}|\\x{}|\\x": {
        "*": {action_: "copy"}
      },
      "else2": {
        "*": {action_: "copy"}
      }
    }),
    actions: {
      "color-output": function(buffer, m3) {
        return {
          type_: "color",
          color1: m3[0],
          color2: mhchemParser.go(m3[1], "bd")
        };
      }
    }
  },
  "oxidation": {
    transitions: mhchemParser.createTransitions({
      "empty": {
        "*": {}
      },
      "roman numeral": {
        "*": {action_: "roman-numeral"}
      },
      "${(...)}$|$(...)$": {
        "*": {action_: "tex-math"}
      },
      "else": {
        "*": {action_: "copy"}
      }
    }),
    actions: {
      "roman-numeral": function(buffer, m3) {
        return {type_: "roman numeral", p1: m3 || ""};
      }
    }
  },
  "tex-math": {
    transitions: mhchemParser.createTransitions({
      "empty": {
        "*": {action_: "output"}
      },
      "\\ce{(...)}": {
        "*": {action_: ["output", "ce"]}
      },
      "{...}|\\,|\\x{}{}|\\x{}|\\x": {
        "*": {action_: "o="}
      },
      "else": {
        "*": {action_: "o="}
      }
    }),
    actions: {
      output: function(buffer) {
        if (buffer.o) {
          var ret = {type_: "tex-math", p1: buffer.o};
          for (var p3 in buffer) {
            delete buffer[p3];
          }
          return ret;
        }
      }
    }
  },
  "tex-math tight": {
    transitions: mhchemParser.createTransitions({
      "empty": {
        "*": {action_: "output"}
      },
      "\\ce{(...)}": {
        "*": {action_: ["output", "ce"]}
      },
      "{...}|\\,|\\x{}{}|\\x{}|\\x": {
        "*": {action_: "o="}
      },
      "-|+": {
        "*": {action_: "tight operator"}
      },
      "else": {
        "*": {action_: "o="}
      }
    }),
    actions: {
      "tight operator": function(buffer, m3) {
        buffer.o = (buffer.o || "") + "{" + m3 + "}";
      },
      "output": function(buffer) {
        if (buffer.o) {
          var ret = {type_: "tex-math", p1: buffer.o};
          for (var p3 in buffer) {
            delete buffer[p3];
          }
          return ret;
        }
      }
    }
  },
  "9,9": {
    transitions: mhchemParser.createTransitions({
      "empty": {
        "*": {}
      },
      ",": {
        "*": {action_: "comma"}
      },
      "else": {
        "*": {action_: "copy"}
      }
    }),
    actions: {
      comma: function() {
        return {type_: "commaDecimal"};
      }
    }
  },
  "pu": {
    transitions: mhchemParser.createTransitions({
      "empty": {
        "*": {action_: "output"}
      },
      "space$": {
        "*": {action_: ["output", "space"]}
      },
      "{[(|)]}": {
        "0|a": {action_: "copy"}
      },
      "(-)(9)^(-9)": {
        "0": {action_: "number^", nextState: "a"}
      },
      "(-)(9.,9)(e)(99)": {
        "0": {action_: "enumber", nextState: "a"}
      },
      "space": {
        "0|a": {}
      },
      "pm-operator": {
        "0|a": {
          action_: {type_: "operator", option: "\\pm"},
          nextState: "0"
        }
      },
      "operator": {
        "0|a": {action_: "copy", nextState: "0"}
      },
      "//": {
        d: {action_: "o=", nextState: "/"}
      },
      "/": {
        d: {action_: "o=", nextState: "/"}
      },
      "{...}|else": {
        "0|d": {action_: "d=", nextState: "d"},
        "a": {action_: ["space", "d="], nextState: "d"},
        "/|q": {action_: "q=", nextState: "q"}
      }
    }),
    actions: {
      "enumber": function(buffer, m3) {
        var ret = [];
        if (m3[0] === "+-" || m3[0] === "+/-") {
          ret.push("\\pm ");
        } else if (m3[0]) {
          ret.push(m3[0]);
        }
        if (m3[1]) {
          mhchemParser.concatArray(ret, mhchemParser.go(m3[1], "pu-9,9"));
          if (m3[2]) {
            if (m3[2].match(/[,.]/)) {
              mhchemParser.concatArray(ret, mhchemParser.go(m3[2], "pu-9,9"));
            } else {
              ret.push(m3[2]);
            }
          }
          m3[3] = m3[4] || m3[3];
          if (m3[3]) {
            m3[3] = m3[3].trim();
            if (m3[3] === "e" || m3[3].substr(0, 1) === "*") {
              ret.push({type_: "cdot"});
            } else {
              ret.push({type_: "times"});
            }
          }
        }
        if (m3[3]) {
          ret.push("10^{" + m3[5] + "}");
        }
        return ret;
      },
      "number^": function(buffer, m3) {
        var ret = [];
        if (m3[0] === "+-" || m3[0] === "+/-") {
          ret.push("\\pm ");
        } else if (m3[0]) {
          ret.push(m3[0]);
        }
        mhchemParser.concatArray(ret, mhchemParser.go(m3[1], "pu-9,9"));
        ret.push("^{" + m3[2] + "}");
        return ret;
      },
      "operator": function(buffer, m3, p1) {
        return {type_: "operator", kind_: p1 || m3};
      },
      "space": function() {
        return {type_: "pu-space-1"};
      },
      "output": function(buffer) {
        var ret;
        var md = mhchemParser.patterns.match_("{(...)}", buffer.d || "");
        if (md && md.remainder === "") {
          buffer.d = md.match_;
        }
        var mq = mhchemParser.patterns.match_("{(...)}", buffer.q || "");
        if (mq && mq.remainder === "") {
          buffer.q = mq.match_;
        }
        if (buffer.d) {
          buffer.d = buffer.d.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C");
          buffer.d = buffer.d.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F");
        }
        if (buffer.q) {
          buffer.q = buffer.q.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C");
          buffer.q = buffer.q.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F");
          var b5 = {
            d: mhchemParser.go(buffer.d, "pu"),
            q: mhchemParser.go(buffer.q, "pu")
          };
          if (buffer.o === "//") {
            ret = {type_: "pu-frac", p1: b5.d, p2: b5.q};
          } else {
            ret = b5.d;
            if (b5.d.length > 1 || b5.q.length > 1) {
              ret.push({type_: " / "});
            } else {
              ret.push({type_: "/"});
            }
            mhchemParser.concatArray(ret, b5.q);
          }
        } else {
          ret = mhchemParser.go(buffer.d, "pu-2");
        }
        for (var p3 in buffer) {
          delete buffer[p3];
        }
        return ret;
      }
    }
  },
  "pu-2": {
    transitions: mhchemParser.createTransitions({
      "empty": {
        "*": {action_: "output"}
      },
      "*": {
        "*": {action_: ["output", "cdot"], nextState: "0"}
      },
      "\\x": {
        "*": {action_: "rm="}
      },
      "space": {
        "*": {action_: ["output", "space"], nextState: "0"}
      },
      "^{(...)}|^(-1)": {
        "1": {action_: "^(-1)"}
      },
      "-9.,9": {
        "0": {action_: "rm=", nextState: "0"},
        "1": {action_: "^(-1)", nextState: "0"}
      },
      "{...}|else": {
        "*": {action_: "rm=", nextState: "1"}
      }
    }),
    actions: {
      "cdot": function() {
        return {type_: "tight cdot"};
      },
      "^(-1)": function(buffer, m3) {
        buffer.rm += "^{" + m3 + "}";
      },
      "space": function() {
        return {type_: "pu-space-2"};
      },
      "output": function(buffer) {
        var ret = [];
        if (buffer.rm) {
          var mrm = mhchemParser.patterns.match_("{(...)}", buffer.rm || "");
          if (mrm && mrm.remainder === "") {
            ret = mhchemParser.go(mrm.match_, "pu");
          } else {
            ret = {type_: "rm", p1: buffer.rm};
          }
        }
        for (var p3 in buffer) {
          delete buffer[p3];
        }
        return ret;
      }
    }
  },
  "pu-9,9": {
    transitions: mhchemParser.createTransitions({
      "empty": {
        "0": {action_: "output-0"},
        "o": {action_: "output-o"}
      },
      ",": {
        "0": {action_: ["output-0", "comma"], nextState: "o"}
      },
      ".": {
        "0": {action_: ["output-0", "copy"], nextState: "o"}
      },
      "else": {
        "*": {action_: "text="}
      }
    }),
    actions: {
      "comma": function() {
        return {type_: "commaDecimal"};
      },
      "output-0": function(buffer) {
        var ret = [];
        buffer.text_ = buffer.text_ || "";
        if (buffer.text_.length > 4) {
          var a3 = buffer.text_.length % 3;
          if (a3 === 0) {
            a3 = 3;
          }
          for (var i3 = buffer.text_.length - 3; i3 > 0; i3 -= 3) {
            ret.push(buffer.text_.substr(i3, 3));
            ret.push({type_: "1000 separator"});
          }
          ret.push(buffer.text_.substr(0, a3));
          ret.reverse();
        } else {
          ret.push(buffer.text_);
        }
        for (var p3 in buffer) {
          delete buffer[p3];
        }
        return ret;
      },
      "output-o": function(buffer) {
        var ret = [];
        buffer.text_ = buffer.text_ || "";
        if (buffer.text_.length > 4) {
          var a3 = buffer.text_.length - 3;
          for (var i3 = 0; i3 < a3; i3 += 3) {
            ret.push(buffer.text_.substr(i3, 3));
            ret.push({type_: "1000 separator"});
          }
          ret.push(buffer.text_.substr(i3));
        } else {
          ret.push(buffer.text_);
        }
        for (var p3 in buffer) {
          delete buffer[p3];
        }
        return ret;
      }
    }
  }
};
var texify = {
  go: function(input, isInner) {
    if (!input) {
      return "";
    }
    var res = "";
    var cee = false;
    for (var i3 = 0; i3 < input.length; i3++) {
      var inputi = input[i3];
      if (typeof inputi === "string") {
        res += inputi;
      } else {
        res += texify._go2(inputi);
        if (inputi.type_ === "1st-level escape") {
          cee = true;
        }
      }
    }
    if (!isInner && !cee && res) {
      res = "{" + res + "}";
    }
    return res;
  },
  _goInner: function(input) {
    if (!input) {
      return input;
    }
    return texify.go(input, true);
  },
  _go2: function(buf) {
    var res;
    switch (buf.type_) {
      case "chemfive":
        res = "";
        var b5 = {
          a: texify._goInner(buf.a),
          b: texify._goInner(buf.b),
          p: texify._goInner(buf.p),
          o: texify._goInner(buf.o),
          q: texify._goInner(buf.q),
          d: texify._goInner(buf.d)
        };
        if (b5.a) {
          if (b5.a.match(/^[+\-]/)) {
            b5.a = "{" + b5.a + "}";
          }
          res += b5.a + "\\,";
        }
        if (b5.b || b5.p) {
          res += "{\\vphantom{X}}";
          res += "^{\\hphantom{" + (b5.b || "") + "}}_{\\hphantom{" + (b5.p || "") + "}}";
          res += "{\\vphantom{X}}";
          res += "^{\\smash[t]{\\vphantom{2}}\\mathllap{" + (b5.b || "") + "}}";
          res += "_{\\vphantom{2}\\mathllap{\\smash[t]{" + (b5.p || "") + "}}}";
        }
        if (b5.o) {
          if (b5.o.match(/^[+\-]/)) {
            b5.o = "{" + b5.o + "}";
          }
          res += b5.o;
        }
        if (buf.dType === "kv") {
          if (b5.d || b5.q) {
            res += "{\\vphantom{X}}";
          }
          if (b5.d) {
            res += "^{" + b5.d + "}";
          }
          if (b5.q) {
            res += "_{\\smash[t]{" + b5.q + "}}";
          }
        } else if (buf.dType === "oxidation") {
          if (b5.d) {
            res += "{\\vphantom{X}}";
            res += "^{" + b5.d + "}";
          }
          if (b5.q) {
            res += "{\\vphantom{X}}";
            res += "_{\\smash[t]{" + b5.q + "}}";
          }
        } else {
          if (b5.q) {
            res += "{\\vphantom{X}}";
            res += "_{\\smash[t]{" + b5.q + "}}";
          }
          if (b5.d) {
            res += "{\\vphantom{X}}";
            res += "^{" + b5.d + "}";
          }
        }
        break;
      case "rm":
        res = "\\mathrm{" + buf.p1 + "}";
        break;
      case "text":
        if (buf.p1.match(/[\^_]/)) {
          buf.p1 = buf.p1.replace(" ", "~").replace("-", "\\text{-}");
          res = "\\mathrm{" + buf.p1 + "}";
        } else {
          res = "\\text{" + buf.p1 + "}";
        }
        break;
      case "roman numeral":
        res = "\\mathrm{" + buf.p1 + "}";
        break;
      case "state of aggregation":
        res = "\\mskip2mu " + texify._goInner(buf.p1);
        break;
      case "state of aggregation subscript":
        res = "\\mskip1mu " + texify._goInner(buf.p1);
        break;
      case "bond":
        res = texify._getBond(buf.kind_);
        if (!res) {
          throw [
            "MhchemErrorBond",
            "mhchem Error. Unknown bond type (" + buf.kind_ + ")"
          ];
        }
        break;
      case "frac":
        var c3 = "\\frac{" + buf.p1 + "}{" + buf.p2 + "}";
        res = "\\mathchoice{\\textstyle" + c3 + "}{" + c3 + "}{" + c3 + "}{" + c3 + "}";
        break;
      case "pu-frac":
        var d3 = "\\frac{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
        res = "\\mathchoice{\\textstyle" + d3 + "}{" + d3 + "}{" + d3 + "}{" + d3 + "}";
        break;
      case "tex-math":
        res = buf.p1 + " ";
        break;
      case "frac-ce":
        res = "\\frac{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
        break;
      case "overset":
        res = "\\overset{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
        break;
      case "underset":
        res = "\\underset{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
        break;
      case "underbrace":
        res = "\\underbrace{" + texify._goInner(buf.p1) + "}_{" + texify._goInner(buf.p2) + "}";
        break;
      case "color":
        res = "{\\color{" + buf.color1 + "}{" + texify._goInner(buf.color2) + "}}";
        break;
      case "color0":
        res = "\\color{" + buf.color + "}";
        break;
      case "arrow":
        var b6 = {
          rd: texify._goInner(buf.rd),
          rq: texify._goInner(buf.rq)
        };
        var arrow = "\\x" + texify._getArrow(buf.r);
        if (b6.rq) {
          arrow += "[{" + b6.rq + "}]";
        }
        if (b6.rd) {
          arrow += "{" + b6.rd + "}";
        } else {
          arrow += "{}";
        }
        res = arrow;
        break;
      case "operator":
        res = texify._getOperator(buf.kind_);
        break;
      case "1st-level escape":
        res = buf.p1 + " ";
        break;
      case "space":
        res = " ";
        break;
      case "entitySkip":
        res = "~";
        break;
      case "pu-space-1":
        res = "~";
        break;
      case "pu-space-2":
        res = "\\mkern3mu ";
        break;
      case "1000 separator":
        res = "\\mkern2mu ";
        break;
      case "commaDecimal":
        res = "{,}";
        break;
      case "comma enumeration L":
        res = "{" + buf.p1 + "}\\mkern6mu ";
        break;
      case "comma enumeration M":
        res = "{" + buf.p1 + "}\\mkern3mu ";
        break;
      case "comma enumeration S":
        res = "{" + buf.p1 + "}\\mkern1mu ";
        break;
      case "hyphen":
        res = "\\text{-}";
        break;
      case "addition compound":
        res = "\\,{\\cdot}\\,";
        break;
      case "electron dot":
        res = "\\mkern1mu \\bullet\\mkern1mu ";
        break;
      case "KV x":
        res = "{\\times}";
        break;
      case "prime":
        res = "\\prime ";
        break;
      case "cdot":
        res = "\\cdot ";
        break;
      case "tight cdot":
        res = "\\mkern1mu{\\cdot}\\mkern1mu ";
        break;
      case "times":
        res = "\\times ";
        break;
      case "circa":
        res = "{\\sim}";
        break;
      case "^":
        res = "uparrow";
        break;
      case "v":
        res = "downarrow";
        break;
      case "ellipsis":
        res = "\\ldots ";
        break;
      case "/":
        res = "/";
        break;
      case " / ":
        res = "\\,/\\,";
        break;
      default:
        assertNever(buf);
        throw ["MhchemBugT", "mhchem bug T. Please report."];
    }
    assertString(res);
    return res;
  },
  _getArrow: function(a3) {
    switch (a3) {
      case "->":
        return "rightarrow";
      case "\u2192":
        return "rightarrow";
      case "\u27F6":
        return "rightarrow";
      case "<-":
        return "leftarrow";
      case "<->":
        return "leftrightarrow";
      case "<-->":
        return "rightleftarrows";
      case "<=>":
        return "rightleftharpoons";
      case "\u21CC":
        return "rightleftharpoons";
      case "<=>>":
        return "rightequilibrium";
      case "<<=>":
        return "leftequilibrium";
      default:
        assertNever(a3);
        throw ["MhchemBugT", "mhchem bug T. Please report."];
    }
  },
  _getBond: function(a3) {
    switch (a3) {
      case "-":
        return "{-}";
      case "1":
        return "{-}";
      case "=":
        return "{=}";
      case "2":
        return "{=}";
      case "#":
        return "{\\equiv}";
      case "3":
        return "{\\equiv}";
      case "~":
        return "{\\tripledash}";
      case "~-":
        return "{\\mathrlap{\\raisebox{-.1em}{$-$}}\\raisebox{.1em}{$\\tripledash$}}";
      case "~=":
        return "{\\mathrlap{\\raisebox{-.2em}{$-$}}\\mathrlap{\\raisebox{.2em}{$\\tripledash$}}-}";
      case "~--":
        return "{\\mathrlap{\\raisebox{-.2em}{$-$}}\\mathrlap{\\raisebox{.2em}{$\\tripledash$}}-}";
      case "-~-":
        return "{\\mathrlap{\\raisebox{-.2em}{$-$}}\\mathrlap{\\raisebox{.2em}{$-$}}\\tripledash}";
      case "...":
        return "{{\\cdot}{\\cdot}{\\cdot}}";
      case "....":
        return "{{\\cdot}{\\cdot}{\\cdot}{\\cdot}}";
      case "->":
        return "{\\rightarrow}";
      case "<-":
        return "{\\leftarrow}";
      case "<":
        return "{<}";
      case ">":
        return "{>}";
      default:
        assertNever(a3);
        throw ["MhchemBugT", "mhchem bug T. Please report."];
    }
  },
  _getOperator: function(a3) {
    switch (a3) {
      case "+":
        return " {}+{} ";
      case "-":
        return " {}-{} ";
      case "=":
        return " {}={} ";
      case "<":
        return " {}<{} ";
      case ">":
        return " {}>{} ";
      case "<<":
        return " {}\\ll{} ";
      case ">>":
        return " {}\\gg{} ";
      case "\\pm":
        return " {}\\pm{} ";
      case "\\approx":
        return " {}\\approx{} ";
      case "$\\approx$":
        return " {}\\approx{} ";
      case "v":
        return " \\downarrow{} ";
      case "(v)":
        return " \\downarrow{} ";
      case "^":
        return " \\uparrow{} ";
      case "(^)":
        return " \\uparrow{} ";
      default:
        assertNever(a3);
        throw ["MhchemBugT", "mhchem bug T. Please report."];
    }
  }
};
function assertNever(a3) {
}
function assertString(a3) {
}

// src/core-definitions/symbols.ts
newSymbols("0123456789/@.?!");
newSymbolRange(65, 90);
newSymbolRange(97, 122);
newSymbols([
  ["\\forall", 8704],
  ["\\exists", 8707],
  ["\\nexists", 8708, "mord", "ams"],
  ["\\mid", 8739, "mrel"],
  ["\\top", 8868],
  ["\\bot", 8869]
]);
newSymbols([
  ["\\sharp", 9839],
  ["\\flat", 9837],
  ["\\natural", 9838],
  ["\\#", 35],
  ["\\&", 38],
  ["\\clubsuit", 9827],
  ["\\heartsuit", 9825],
  ["\\spadesuit", 9824],
  ["\\diamondsuit", 9826]
]);
newSymbols([
  ["\\backslash", 92],
  ["\\nabla", 8711],
  ["\\partial", 8706],
  ["\\ell", 8467],
  ["\\hbar", 8463],
  ["\\Q", 81, "mord", "double-struck"],
  ["\\C", 67, "mord", "double-struck"],
  ["\\P", 80, "mord", "double-struck"],
  ["\\pounds", 163],
  ["\\euro", 8364]
]);
newSymbols([
  ["\\rightarrow", 8594],
  ["\\to", 8594],
  ["\\leftarrow", 8592],
  ["\\gets", 8592],
  ["\\Rightarrow", 8658],
  ["\\Leftarrow", 8656],
  ["\\longrightarrow", 10230],
  ["\\longleftarrow", 10229],
  ["\\Longrightarrow", 10233],
  ["\\implies", 10233],
  ["\\Longleftarrow", 10232],
  ["\\impliedby", 10232],
  ["\\longleftrightarrow", 10231],
  ["\\biconditional", 10231],
  ["\\Longleftrightarrow", 10234],
  ["\\mapsto", 8614],
  ["\\longmapsto", 10236],
  ["\\uparrow", 8593],
  ["\\downarrow", 8595],
  ["\\Uparrow", 8657],
  ["\\Downarrow", 8659],
  ["\\updownarrow", 8597],
  ["\\Updownarrow", 8661],
  ["\\hookrightarrow", 8618],
  ["\\hookleftarrow", 8617],
  ["\\rightharpoonup", 8640],
  ["\\leftharpoonup", 8636],
  ["\\rightharpoondown", 8641],
  ["\\leftharpoondown", 8637],
  ["\\searrow", 8600],
  ["\\nearrow", 8599],
  ["\\swarrow", 8601],
  ["\\nwarrow", 8598],
  ["\\originalof", 8886],
  ["\\laplace", 8886],
  ["\\imageof", 8887],
  ["\\Laplace", 8887]
], "mrel");
newSymbols([
  ["\\lbrace", 123, "mopen"],
  ["\\rbrace", 125, "mclose"],
  ["\\lparen", 40, "mopen"],
  ["\\rparen", 41, "mclose"],
  ["\\langle", 10216, "mopen"],
  ["\\rangle", 10217, "mclose"],
  ["\\lfloor", 8970, "mopen"],
  ["\\rfloor", 8971, "mclose"],
  ["\\lceil", 8968, "mopen"],
  ["\\rceil", 8969, "mclose"],
  ["\\vert", 8739],
  ["\\lvert", 8739, "mopen"],
  ["\\rvert", 8739, "mclose"],
  ["\\|", 8741],
  ["\\Vert", 8741],
  ["\\mVert", 8741],
  ["\\lVert", 8741, "mopen"],
  ["\\rVert", 8741, "mclose"],
  ["\\lbrack", 91, "mopen"],
  ["\\rbrack", 93, "mclose"],
  ["\\{", 123, "mopen"],
  ["\\}", 125, "mclose"],
  ["(", 40, "mopen"],
  [")", 41, "mclose"],
  ["[", 91, "mopen"],
  ["]", 93, "mclose"],
  ["\\ulcorner", 9484, "mopen", "ams"],
  ["\\urcorner", 9488, "mclose", "ams"],
  ["\\llcorner", 9492, "mopen", "ams"],
  ["\\lrcorner", 9496, "mclose", "ams"],
  ["\\lgroup", 10222, "mopen"],
  ["\\rgroup", 10223, "mclose"],
  ["\\lmoustache", 9136, "mopen"],
  ["\\rmoustache", 9137, "mclose"]
]);
newSymbols([
  ["\\dashrightarrow", 8674],
  ["\\dashleftarrow", 8672],
  ["\\Rrightarrow", 8667],
  ["\\Lleftarrow", 8666],
  ["\\leftrightarrows", 8646],
  ["\\rightleftarrows", 8644],
  ["\\curvearrowright", 8631],
  ["\\curvearrowleft", 8630],
  ["\\rightrightarrows", 8649],
  ["\\leftleftarrows", 8647],
  ["\\upuparrows", 8648],
  ["\\downdownarrows", 8650],
  ["\\vartriangle", 9651],
  ["\\triangleq", 8796],
  ["\\vartriangleleft", 8882],
  ["\\trianglelefteq", 8884],
  ["\\ntriangleleft", 8938],
  ["\\ntrianglelefteq", 8940],
  ["\\vartriangleright", 8883],
  ["\\trianglerighteq", 8885],
  ["\\ntriangleright", 8939],
  ["\\ntrianglerighteq", 8941],
  ["\\blacktriangleleft", 9664],
  ["\\blacktriangleright", 9654],
  ["\\leftarrowtail", 8610],
  ["\\rightarrowtail", 8611],
  ["\\looparrowright", 8620],
  ["\\looparrowleft", 8619],
  ["\\twoheadleftarrow", 8606],
  ["\\twoheadrightarrow", 8608],
  ["\\rightleftharpoons", 8652],
  ["\\leftrightharpoons", 8651],
  ["\\Rsh", 8625],
  ["\\Lsh", 8624],
  ["\\circlearrowright", 8635],
  ["\\circlearrowleft", 8634],
  ["\\restriction", 8638],
  ["\\upharpoonright", 8638],
  ["\\upharpoonleft", 8639],
  ["\\downharpoonright", 8642],
  ["\\downharpoonleft", 8643],
  ["\\rightsquigarrow", 8669],
  ["\\leadsto", 8669],
  ["\\leftrightsquigarrow", 8621],
  ["\\multimap", 8888],
  ["\\nrightarrow", 8603],
  ["\\nleftarrow", 8602],
  ["\\nRightarrow", 8655],
  ["\\nLeftarrow", 8653],
  ["\\nleftrightarrow", 8622],
  ["\\nLeftrightarrow", 8654],
  ["\\shortparallel", 8741],
  ["\\nless", 8814],
  ["\\nleqslant", 57360],
  ["\\lneq", 10887],
  ["\\lneqq", 8808],
  ["\\nleqq", 57361],
  ["\\lvertneqq", 57356],
  ["\\lnsim", 8934],
  ["\\lnapprox", 10889],
  ["\\nprec", 8832],
  ["\\npreceq", 8928],
  ["\\precnsim", 8936],
  ["\\precnapprox", 10937],
  ["\\nsim", 8769],
  ["\\nshortmid", 57350],
  ["\\nmid", 8740],
  ["\\nvdash", 8876],
  ["\\nvDash", 8877],
  ["\\ngtr", 8815],
  ["\\ngeqslant", 57359],
  ["\\ngeqq", 57358],
  ["\\gneq", 10888],
  ["\\gneqq", 8809],
  ["\\gvertneqq", 57357],
  ["\\gnsim", 8935],
  ["\\gnapprox", 10890],
  ["\\nsucc", 8833],
  ["\\nsucceq", 8929],
  ["\\succnsim", 8937],
  ["\\succnapprox", 10938],
  ["\\ncong", 8774],
  ["\\nshortparallel", 57351],
  ["\\nparallel", 8742],
  ["\\nVDash", 8879],
  ["\\nsupseteqq", 57368],
  ["\\supsetneq", 8843],
  ["\\varsupsetneq", 57371],
  ["\\supsetneqq", 10956],
  ["\\varsupsetneqq", 57369],
  ["\\nVdash", 8878],
  ["\\precneqq", 10933],
  ["\\succneqq", 10934],
  ["\\nsubseteqq", 57366],
  ["\\leqslant", 10877],
  ["\\geqslant", 10878],
  ["\\gtrsim", 8819],
  ["\\approxeq", 8778],
  ["\\thickapprox", 8776],
  ["\\lessapprox", 10885],
  ["\\gtrapprox", 10886],
  ["\\precapprox", 10935],
  ["\\succapprox", 10936],
  ["\\thicksim", 8764],
  ["\\succsim", 8831],
  ["\\precsim", 8830],
  ["\\backsim", 8765],
  ["\\eqsim", 8770],
  ["\\backsimeq", 8909],
  ["\\lesssim", 8818],
  ["\\nleq", 8816],
  ["\\ngeq", 8817],
  ["\\smallsmile", 8995],
  ["\\smallfrown", 8994],
  ["\\leqq", 8806],
  ["\\eqslantless", 10901],
  ["\\lll", 8920],
  ["\\lessgtr", 8822],
  ["\\lesseqgtr", 8922],
  ["\\lesseqqgtr", 10891],
  ["\\risingdotseq", 8787],
  ["\\fallingdotseq", 8786],
  ["\\subseteqq", 10949],
  ["\\Subset", 8912],
  ["\\sqsubset", 8847],
  ["\\preccurlyeq", 8828],
  ["\\curlyeqprec", 8926],
  ["\\vDash", 8872],
  ["\\Vvdash", 8874],
  ["\\bumpeq", 8783],
  ["\\Bumpeq", 8782],
  ["\\geqq", 8807],
  ["\\eqslantgtr", 10902],
  ["\\ggg", 8921],
  ["\\gtrless", 8823],
  ["\\gtreqless", 8923],
  ["\\gtreqqless", 10892],
  ["\\supseteqq", 10950],
  ["\\Supset", 8913],
  ["\\sqsupset", 8848],
  ["\\succcurlyeq", 8829],
  ["\\curlyeqsucc", 8927],
  ["\\Vdash", 8873],
  ["\\shortmid", 8739],
  ["\\between", 8812],
  ["\\pitchfork", 8916],
  ["\\varpropto", 8733],
  ["\\backepsilon", 8717],
  ["\\llless", 8920],
  ["\\gggtr", 8921],
  ["\\doteqdot", 8785],
  ["\\Doteq", 8785],
  ["\\eqcirc", 8790],
  ["\\circeq", 8791],
  ["\\therefore", 8756],
  ["\\because", 8757]
], "mrel", "ams");
newSymbols([
  ["+", 43],
  ["-", 8722],
  ["\u2212", 8722],
  ["\\pm", 177],
  ["\\mp", 8723],
  ["*", 8727],
  ["\\times", 215],
  ["\\div", 247],
  ["\\divides", 8739],
  ["\\cdot", 8901],
  ["\\cap", 8745],
  ["\\cup", 8746],
  ["\\setminus", 8726],
  ["\\land", 8743],
  ["\\wedge", 8743],
  ["\\lor", 8744],
  ["\\vee", 8744],
  ["\\circ", 8728],
  ["\\bigcirc", 9711],
  ["\\bullet", 8729],
  ["\\oplus", 8853],
  ["\\ominus", 8854],
  ["\\otimes", 8855],
  ["\\odot", 8857],
  ["\\oslash", 8856],
  ["\\bigtriangleup", 9651],
  ["\\bigtriangledown", 9661],
  ["\\triangleleft", 9667],
  ["\\triangleright", 9657],
  ["\\And", 38],
  ["\\dagger", 8224],
  ["\\dag", 8224],
  ["\\ddag", 8225],
  ["\\ddagger", 8225],
  ["\\ast", 8727],
  ["\\star", 8902],
  ["\\bigstar", 9733],
  ["\\diamond", 8900]
], "mbin");
newSymbols([
  ["\\lhd", 8882],
  ["\\rhd", 8883],
  ["\\lessdot", 8918],
  ["\\gtrdot", 8919],
  ["\\ltimes", 8905],
  ["\\rtimes", 8906],
  ["\\leftthreetimes", 8907],
  ["\\rightthreetimes", 8908],
  ["\\intercal", 8890],
  ["\\dotplus", 8724],
  ["\\doublebarwedge", 10846],
  ["\\divideontimes", 8903],
  ["\\centerdot", 8901],
  ["\\smallsetminus", 8726],
  ["\\barwedge", 8892],
  ["\\veebar", 8891],
  ["\\nor", 8891],
  ["\\curlywedge", 8911],
  ["\\curlyvee", 8910],
  ["\\boxminus", 8863],
  ["\\boxplus", 8862],
  ["\\boxtimes", 8864],
  ["\\boxdot", 8865],
  ["\\circleddash", 8861],
  ["\\circledast", 8859],
  ["\\circledcirc", 8858],
  ["\\unlhd", 8884],
  ["\\unrhd", 8885]
], "mbin", "ams");
newSymbols([
  ["\\surd", 8730],
  ["\\infty", 8734],
  ["\\prime", 8242],
  ["\\doubleprime", 8243],
  ["\\angle", 8736],
  ["`", 8216],
  ["\\$", 36],
  ["\\%", 37],
  ["\\_", 95],
  ["\\alpha", 945],
  ["\\beta", 946],
  ["\\gamma", 947],
  ["\\delta", 948],
  ["\\epsilon", 1013],
  ["\\varepsilon", 949],
  ["\\zeta", 950],
  ["\\eta", 951],
  ["\\theta", 952],
  ["\\vartheta", 977],
  ["\\iota", 953],
  ["\\kappa", 954],
  ["\\varkappa", 1008, "mord", "ams"],
  ["\\lambda", 955],
  ["\\mu", 956],
  ["\\nu", 957],
  ["\\xi", 958],
  ["\\omicron", 111],
  ["\\pi", 960],
  ["\\varpi", 982],
  ["\\rho", 961],
  ["\\varrho", 1009],
  ["\\sigma", 963],
  ["\\varsigma", 962],
  ["\\tau", 964],
  ["\\phi", 981],
  ["\\varphi", 966],
  ["\\upsilon", 965],
  ["\\chi", 967],
  ["\\psi", 968],
  ["\\omega", 969],
  ["\\Gamma", 915],
  ["\\Delta", 916],
  ["\\Theta", 920],
  ["\\Lambda", 923],
  ["\\Xi", 926],
  ["\\Pi", 928],
  ["\\Sigma", 931],
  ["\\Upsilon", 933],
  ["\\Phi", 934],
  ["\\Psi", 936],
  ["\\Omega", 937],
  ["\\digamma", 989, "mord", "ams"],
  ["\\emptyset", 8709]
]);
newSymbols([
  ["=", 61],
  ["<", 60],
  ["\\lt", 60],
  [">", 62],
  ["\\gt", 62],
  ["\\le", 8804],
  ["\\leq", 8804],
  ["\\ge", 8805],
  ["\\geq", 8805],
  ["\\ll", 8810],
  ["\\gg", 8811],
  ["\\coloneq", 8788],
  ["\\measeq", 8797],
  ["\\eqdef", 8798],
  ["\\questeq", 8799],
  [":", 58],
  ["\\cong", 8773],
  ["\\equiv", 8801],
  ["\\prec", 8826],
  ["\\preceq", 10927],
  ["\\succ", 8827],
  ["\\succeq", 10928],
  ["\\perp", 8869],
  ["\\propto", 8733],
  ["\\Colon", 8759],
  ["\\smile", 8995],
  ["\\frown", 8994],
  ["\\sim", 8764],
  ["\\doteq", 8784],
  ["\\bowtie", 8904],
  ["\\Join", 8904],
  ["\\asymp", 8781],
  ["\\sqsubseteq", 8849],
  ["\\sqsupseteq", 8850],
  ["\\approx", 8776],
  ["\\~", 126],
  ["\\leftrightarrow", 8596],
  ["\\Leftrightarrow", 8660],
  ["\\models", 8872],
  ["\\vdash", 8866],
  ["\\dashv", 8867],
  ["\\roundimplies", 10608],
  ["\\in", 8712],
  ["\\notin", 8713],
  ["\\ni", 8715],
  ["\\owns", 8715],
  ["\\subset", 8834],
  ["\\supset", 8835],
  ["\\subseteq", 8838],
  ["\\supseteq", 8839],
  ["\\differencedelta", 8710],
  ["\\mvert", 8739],
  ["\\parallel", 8741],
  ["\\simeq", 8771]
], "mrel");
newSymbols([
  ["\\lnot", 172],
  ["\\neg", 172],
  ["\\triangle", 9651],
  ["\\subsetneq", 8842],
  ["\\varsubsetneq", 57370],
  ["\\subsetneqq", 10955],
  ["\\varsubsetneqq", 57367],
  ["\\nsubset", 8836],
  ["\\nsupset", 8837],
  ["\\nsubseteq", 8840],
  ["\\nsupseteq", 8841]
], "mrel", "ams");
newSymbols([
  ["\\wp", 8472],
  ["\\aleph", 8501]
]);
newSymbols([
  ["\\blacktriangle", 9650],
  ["\\hslash", 8463],
  ["\\Finv", 8498],
  ["\\Game", 8513],
  ["\\eth", 240],
  ["\\mho", 8487],
  ["\\Bbbk", 107],
  ["\\yen", 165],
  ["\\square", 9633],
  ["\\Box", 9633],
  ["\\blacksquare", 9632],
  ["\\circledS", 9416],
  ["\\circledR", 174],
  ["\\triangledown", 9661],
  ["\\blacktriangledown", 9660],
  ["\\checkmark", 10003],
  ["\\diagup", 9585],
  ["\\measuredangle", 8737],
  ["\\sphericalangle", 8738],
  ["\\backprime", 8245],
  ["\\backdoubleprime", 8246],
  ["\\Diamond", 9674],
  ["\\lozenge", 9674],
  ["\\blacklozenge", 10731],
  ["\\varnothing", 8709],
  ["\\complement", 8705],
  ["\\maltese", 10016],
  ["\\beth", 8502],
  ["\\daleth", 8504],
  ["\\gimel", 8503]
], "mord", "ams");
newSymbols([
  ["\\ ", 160],
  ["~", 160],
  ["\\space", 160]
], "space");
defineFunction(["!", ",", ":", ";", "enskip", "enspace", "quad", "qquad"], "", {
  createAtom: (command, _args, style) => new SpacingAtom(command, style)
});
newSymbols([
  ["\\colon", 58],
  ["\\cdotp", 8901],
  ["\\vdots", 8942, "mord"],
  ["\\ldotp", 46],
  [",", 44],
  [";", 59]
], "mpunct");
newSymbols([
  ["\\cdots", 8943],
  ["\\ddots", 8945],
  ["\\ldots", 8230],
  ["\\mathellipsis", 8230]
], "minner");
newSymbols([
  ["\\/", 47],
  ["|", 8739, "mord"],
  ["\\imath", 305],
  ["\\jmath", 567],
  ["\\degree", 176],
  ["'", 8242],
  ['"', 8221]
]);

// src/common/script-url.ts
function getFileUrl() {
  const stackTraceFrames = String(new Error().stack).replace(/^Error.*\n/, "").split("\n");
  if (stackTraceFrames.length === 0) {
    console.error(`Can't use relative paths to specify assets location because the sourcefile location could not be determined (unexpected stack trace format "${new Error().stack}").`);
    return "";
  }
  let callerFrame = stackTraceFrames[1];
  let m3 = callerFrame.match(/http.*\.ts[\?:]/);
  if (m3) {
    callerFrame = stackTraceFrames[2];
  }
  m3 = callerFrame.match(/(http.*(\.mjs|\.js))[\?:]/);
  if (!m3) {
    m3 = callerFrame.match(/at (.*(\.ts))[\?:]/);
    if (!m3) {
      m3 = callerFrame.match(/at (.*(\.mjs|\.js))[\?:]/);
    }
  }
  if (!m3) {
    console.error(stackTraceFrames);
    console.error(`Can't use relative paths to specify assets location because the source file location could not be determined (unexpected location "${callerFrame}").`);
    return "";
  }
  return m3[1];
}
function resolveRelativeUrl(url) {
  let result = "";
  try {
    result = new URL(url, gScriptUrl).toString();
  } catch (e3) {
    console.error(`Invalid URL "${url}" (relative to "${gScriptUrl}")`);
  }
  return result;
}
var gScriptUrl = globalThis?.document?.currentScript?.src || getFileUrl();

// src/core/fonts.ts
function makeFontFace(name, source, descriptors = {}) {
  return new FontFace(name, `url(${source}.woff2) format('woff2')`, descriptors);
}
async function loadFonts(fontsDirectory, onError) {
  if (!isBrowser() || document.body.classList.contains("ML__fonts-loading")) {
    return;
  }
  const useStaticFonts = getComputedStyle(document.documentElement).getPropertyValue("--ML__static-fonts") ?? false;
  if (useStaticFonts)
    return;
  if ("fonts" in document) {
    const fontFamilies = [
      "KaTeX_Main",
      "KaTeX_Math",
      "KaTeX_AMS",
      "KaTeX_Caligraphic",
      "KaTeX_Fraktur",
      "KaTeX_SansSerif",
      "KaTeX_Script",
      "KaTeX_Size1",
      "KaTeX_Size2",
      "KaTeX_Size3",
      "KaTeX_Size4"
    ];
    let fontsLoaded = false;
    if (supportLocalFontEnumeration()) {
      try {
        fontsLoaded = fontFamilies.every((x3) => document.fonts.check("16px " + x3));
      } catch {
        fontsLoaded = false;
      }
    }
    if (fontsLoaded)
      return;
    const fontsFolder = resolveRelativeUrl(fontsDirectory ?? "./fonts");
    if (!fontsFolder)
      return;
    document.body.classList.add("ML__fonts-loading");
    const fonts = [
      ["KaTeX_Main-Regular"],
      ["KaTeX_Main-BoldItalic", {style: "italic", weight: "bold"}],
      ["KaTeX_Main-Bold", {weight: "bold"}],
      ["KaTeX_Main-Italic", {style: "italic"}],
      ["KaTeX_Math-Italic", {style: "italic"}],
      ["KaTeX_Math-BoldItalic", {style: "italic", weight: "bold"}],
      ["KaTeX_AMS-Regular"],
      ["KaTeX_Caligraphic-Regular"],
      ["KaTeX_Caligraphic-Bold", {weight: "bold"}],
      ["KaTeX_Fraktur-Regular"],
      ["KaTeX_Fraktur-Bold", {weight: "bold"}],
      ["KaTeX_SansSerif-Regular", {style: "italic"}],
      ["KaTeX_SansSerif-Bold", {weight: "bold"}],
      ["KaTeX_SansSerif-Italic", {style: "italic"}],
      ["KaTeX_Script-Regular"],
      ["KaTeX_Typewriter-Regular"],
      ["KaTeX_Size1-Regular"],
      ["KaTeX_Size2-Regular"],
      ["KaTeX_Size3-Regular"],
      ["KaTeX_Size4-Regular"]
    ].map((x3) => makeFontFace(x3[0].replace(/-[a-zA-Z]+$/, ""), fontsFolder + "/" + x3[0], x3[1]));
    try {
      const loadedFonts = await Promise.all(fonts.map((x3) => {
        try {
          return x3.load();
        } catch {
        }
        return void 0;
      }));
      loadedFonts.forEach((font) => document.fonts.add(font));
    } catch (error) {
      console.error(`The mathlive fonts could not be loaded from "${fontsFolder}" (${error})`);
      if (typeof onError === "function") {
        onError({
          code: "font-not-found",
          arg: error
        });
      }
    }
    document.body.classList.remove("ML__fonts-loading");
  }
}

// src/common/stylesheet.ts
function inject(element, css, id) {
  throwIfNotInBrowser();
  if (!css)
    return null;
  let root = element?.getRootNode() ?? document?.head;
  if (!root)
    return null;
  if (root === document)
    root = document.head;
  const element_ = root.querySelector(`style[data-id="${id}"]`);
  if (element_) {
    const refCount = Number.parseFloat(element_.getAttribute("data-refcount") ?? "0");
    element_.dataset.refcount = Number(refCount + 1).toString();
  } else {
    const styleNode = document.createElement("style");
    styleNode.dataset.id = id;
    styleNode.dataset.refcount = "1";
    styleNode.append(document.createTextNode(css));
    root.appendChild(styleNode);
  }
  return {
    release: () => {
      const element_2 = document.head.querySelector(`style[data-id="${id}"]`);
      if (element_2) {
        const refCount = Number.parseFloat(element_2.getAttribute("data-refcount") ?? "0");
        if (refCount === 1) {
          element_2.remove();
        } else {
          element_2.dataset.refcount = Number(refCount - 1).toString();
        }
      }
    }
  };
}

// css/core.less
var core_default = ".ML__sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border: 0;\n}\n.ML__isInline {\n  display: inline-block;\n}\n.ML__base {\n  visibility: inherit;\n  display: inline-block;\n  position: relative;\n  cursor: text;\n  padding: 0;\n  margin: 0;\n  box-sizing: content-box;\n  border: 0;\n  outline: 0;\n  vertical-align: baseline;\n  font-weight: inherit;\n  font-family: inherit;\n  font-style: inherit;\n  text-decoration: none;\n  width: min-content;\n}\nbody.ML__fonts-loading .ML__base {\n  visibility: hidden;\n}\n.ML__strut,\n.ML__strut--bottom {\n  display: inline-block;\n  min-height: 0.5em;\n}\n.ML__small-delim {\n  font-family: KaTeX_Main;\n}\n/* Text mode */\n.ML__text {\n  font-family: var(--text-font-family, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif);\n  white-space: pre;\n}\n/* Use cmr for 'math upright' */\n.ML__cmr {\n  font-family: KaTeX_Main;\n  font-style: normal;\n}\n.ML__mathit {\n  font-family: KaTeX_Math;\n  /* The KaTeX_Math font is italic by default, so the font-style below is only \n     useful when a fallback font is used\n  */\n  font-style: italic;\n}\n.ML__mathbf {\n  font-family: KaTeX_Main;\n  font-weight: bold;\n}\n/* Lowercase greek symbols should stick to math font when \\mathbf is applied \n   to match TeX idiosyncratic behavior */\n.lcGreek.ML__mathbf {\n  font-family: KaTeX_Math;\n  font-weight: normal;\n}\n.ML__mathbfit {\n  font-family: KaTeX_Math;\n  font-weight: bold;\n  font-style: italic;\n}\n.ML__ams {\n  font-family: KaTeX_AMS;\n}\n/* Blackboard */\n.ML__bb {\n  font-family: KaTeX_AMS;\n}\n.ML__cal {\n  font-family: KaTeX_Caligraphic;\n}\n.ML__frak {\n  font-family: KaTeX_Fraktur;\n}\n.ML__tt {\n  font-family: KaTeX_Typewriter;\n}\n.ML__script {\n  font-family: KaTeX_Script;\n}\n.ML__sans {\n  font-family: KaTeX_SansSerif;\n}\n.ML__series_ul {\n  font-weight: 100;\n}\n.ML__series_el {\n  font-weight: 100;\n}\n.ML__series_l {\n  font-weight: 200;\n}\n.ML__series_sl {\n  font-weight: 300;\n}\n.ML__series_sb {\n  font-weight: 500;\n}\n.ML__bold,\n.ML__boldsymbol {\n  font-weight: 700;\n}\n.ML__series_eb {\n  font-weight: 800;\n}\n.ML__series_ub {\n  font-weight: 900;\n}\n.ML__series_uc {\n  font-stretch: ultra-condensed;\n}\n.ML__series_ec {\n  font-stretch: extra-condensed;\n}\n.ML__series_c {\n  font-stretch: condensed;\n}\n.ML__series_sc {\n  font-stretch: semi-condensed;\n}\n.ML__series_sx {\n  font-stretch: semi-expanded;\n}\n.ML__series_x {\n  font-stretch: expanded;\n}\n.ML__series_ex {\n  font-stretch: extra-expanded;\n}\n.ML__series_ux {\n  font-stretch: ultra-expanded;\n}\n.ML__it {\n  font-style: italic;\n}\n.ML__shape_ol {\n  -webkit-text-stroke: 1px black;\n  text-stroke: 1px black;\n  color: transparent;\n}\n.ML__shape_sc {\n  font-variant: small-caps;\n}\n.ML__shape_sl {\n  font-style: oblique;\n}\n/* First level emphasis */\n.ML__emph {\n  color: #bc2612;\n}\n/* Second level emphasis */\n.ML__emph .ML__emph {\n  color: #0c7f99;\n}\n.ML__highlight {\n  color: #007cb2;\n  background: #edd1b0;\n}\n.ML__center {\n  text-align: center;\n}\n.ML__frac-line {\n  width: 100%;\n  min-height: 1px;\n}\n.ML__frac-line:after {\n  content: '';\n  display: block;\n  margin-top: -0.04em;\n  min-height: 0.04em;\n  /* There's a bug since Chrome 62 where \n            sub-pixel border lines don't draw at some zoom \n            levels (110%, 90%). \n            Setting the min-height used to work around it, but that workaround\n            broke in Chrome 84 or so.\n            Setting the background (and the min-height) seems to work for now.\n            */\n  background: currentColor;\n  box-sizing: content-box;\n  /* Vuetify sets the box-sizing to inherit \n            causes the fraction line to not draw at all sizes (see #26) */\n  /* On some versions of Firefox on Windows, the line fails to \n            draw at some zoom levels, but setting the transform triggers\n            the hardware accelerated path, which works */\n  transform: translate(0, 0);\n}\n.ML__sqrt {\n  display: inline-block;\n}\n.ML__sqrt-sign {\n  display: inline-block;\n  font-family: KaTeX_Main;\n  position: relative;\n}\n.ML__sqrt-line {\n  display: inline-block;\n  height: 0.04em;\n  width: 100%;\n}\n.ML__sqrt-line:before {\n  content: '';\n  display: block;\n  margin-top: -0.04em;\n  min-height: 0.04em;\n  background: currentColor;\n}\n.ML__sqrt-line:after {\n  border-bottom-width: 1px;\n  content: ' ';\n  display: block;\n  margin-top: -0.1em;\n  /* On some versions of Firefox on Windows, the line fails to \n              draw at some zoom levels, but setting the transform triggers\n              the hardware accelerated path, which works */\n  transform: translate(0, 0);\n}\n.ML__sqrt-index {\n  margin-left: 0.27777778em;\n  margin-right: -0.55555556em;\n}\n.ML__delim-size1 {\n  font-family: KaTeX_Size1;\n}\n.ML__delim-size2 {\n  font-family: KaTeX_Size2;\n}\n.ML__delim-size3 {\n  font-family: KaTeX_Size3;\n}\n.ML__delim-size4 {\n  font-family: KaTeX_Size4;\n}\n.ML__delim-mult .delim-size1 > span {\n  font-family: KaTeX_Size1;\n}\n.ML__delim-mult .delim-size4 > span {\n  font-family: KaTeX_Size4;\n}\n.ML__accent-body > span {\n  font-family: KaTeX_Main;\n  width: 0;\n}\n.ML__accent-vec > span {\n  position: relative;\n  left: 0.38em;\n}\n.ML__mathlive {\n  display: inline-block;\n  direction: ltr;\n  text-align: left;\n  text-indent: 0;\n  text-rendering: auto;\n  font-family: KaTeX_Main;\n  font-style: normal;\n  font-size-adjust: none;\n  font-stretch: normal;\n  font-variant-caps: normal;\n  letter-spacing: normal;\n  word-wrap: normal;\n  word-spacing: normal;\n  white-space: nowrap;\n  text-shadow: none;\n  -webkit-user-select: none;\n  user-select: none;\n  width: min-content;\n  transform: translateZ(0);\n}\n.ML__mathlive .style-wrap {\n  position: relative;\n}\n.ML__mathlive .mfrac,\n.ML__mathlive .left-right {\n  display: inline-block;\n}\n.ML__mathlive .vlist-t {\n  display: inline-table;\n  table-layout: fixed;\n  border-collapse: collapse;\n}\n.ML__mathlive .vlist-r {\n  display: table-row;\n}\n.ML__mathlive .vlist {\n  display: table-cell;\n  vertical-align: bottom;\n  position: relative;\n}\n.ML__mathlive .vlist > span {\n  display: block;\n  height: 0;\n  position: relative;\n}\n.ML__mathlive .vlist > span > span {\n  display: inline-block;\n}\n.ML__mathlive .vlist > span > .pstrut {\n  overflow: hidden;\n  width: 0;\n}\n.ML__mathlive .vlist-t2 {\n  margin-right: -2px;\n}\n.ML__mathlive .vlist-s {\n  display: table-cell;\n  vertical-align: bottom;\n  font-size: 1px;\n  width: 2px;\n  min-width: 2px;\n}\n.ML__mathlive .msubsup {\n  text-align: left;\n}\n.ML__mathlive .negativethinspace {\n  display: inline-block;\n  margin-left: -0.16667em;\n}\n.ML__mathlive .thinspace {\n  display: inline-block;\n  width: 0.16667em;\n}\n.ML__mathlive .mediumspace {\n  display: inline-block;\n  width: 0.22222em;\n}\n.ML__mathlive .thickspace {\n  display: inline-block;\n  width: 0.27778em;\n}\n.ML__mathlive .enspace {\n  display: inline-block;\n  width: 0.5em;\n}\n.ML__mathlive .quad {\n  display: inline-block;\n  width: 1em;\n}\n.ML__mathlive .qquad {\n  display: inline-block;\n  width: 2em;\n}\n.ML__mathlive .llap,\n.ML__mathlive .rlap {\n  width: 0;\n  position: relative;\n  display: inline-block;\n}\n.ML__mathlive .llap > .inner,\n.ML__mathlive .rlap > .inner {\n  position: absolute;\n}\n.ML__mathlive .llap > .fix,\n.ML__mathlive .rlap > .fix {\n  display: inline-block;\n}\n.ML__mathlive .llap > .inner {\n  right: 0;\n}\n.ML__mathlive .rlap > .inner {\n  left: 0;\n}\n.ML__mathlive .rule {\n  display: inline-block;\n  border: solid 0;\n  position: relative;\n  box-sizing: border-box;\n}\n.ML__mathlive .overline .overline-line,\n.ML__mathlive .underline .underline-line {\n  width: 100%;\n}\n.ML__mathlive .overline .overline-line:before,\n.ML__mathlive .underline .underline-line:before {\n  border-bottom-style: solid;\n  border-bottom-width: 0.04em;\n  content: '';\n  display: block;\n}\n.ML__mathlive .overline .overline-line:after,\n.ML__mathlive .underline .underline-line:after {\n  border-bottom-style: solid;\n  border-bottom-width: 0.04em;\n  min-height: thin;\n  /* There's a bug since Chrome 62 where \n            sub-pixel border lines don't draw at some zoom \n            levels (110%, 90%). Setting the min-height seems to work around it.\n            */\n  content: '';\n  display: block;\n  margin-top: -1px;\n}\n.ML__mathlive .stretchy {\n  display: block;\n  position: absolute;\n  width: 100%;\n  left: 0;\n  overflow: hidden;\n}\n.ML__mathlive .stretchy:before,\n.ML__mathlive .stretchy:after {\n  content: '';\n}\n.ML__mathlive .stretchy svg {\n  display: block;\n  position: absolute;\n  width: 100%;\n  height: inherit;\n  fill: currentColor;\n  stroke: currentColor;\n  fill-rule: nonzero;\n  fill-opacity: 1;\n  stroke-width: 1;\n  stroke-linecap: butt;\n  stroke-linejoin: miter;\n  stroke-miterlimit: 4;\n  stroke-dasharray: none;\n  stroke-dashoffset: 0;\n  stroke-opacity: 1;\n}\n.ML__mathlive .slice-1-of-2 {\n  display: inline-flex;\n  position: absolute;\n  left: 0;\n  width: 50.2%;\n  overflow: hidden;\n}\n.ML__mathlive .slice-2-of-2 {\n  display: inline-flex;\n  position: absolute;\n  right: 0;\n  width: 50.2%;\n  overflow: hidden;\n}\n.ML__mathlive .slice-1-of-3 {\n  display: inline-flex;\n  position: absolute;\n  left: 0;\n  width: 25.1%;\n  overflow: hidden;\n}\n.ML__mathlive .slice-2-of-3 {\n  display: inline-flex;\n  position: absolute;\n  left: 25%;\n  width: 50%;\n  overflow: hidden;\n}\n.ML__mathlive .slice-3-of-3 {\n  display: inline-flex;\n  position: absolute;\n  right: 0;\n  width: 25.1%;\n  overflow: hidden;\n}\n.ML__mathlive .slice-1-of-1 {\n  display: inline-flex;\n  position: absolute;\n  width: 100%;\n  left: 0;\n  overflow: hidden;\n}\n.ML__mathlive .nulldelimiter {\n  width: 0.12em;\n  display: inline-block;\n}\n.ML__mathlive .op-group {\n  display: inline-block;\n}\n.ML__mathlive .op-symbol {\n  position: relative;\n}\n.ML__mathlive .op-symbol.small-op {\n  font-family: KaTeX_Size1;\n}\n.ML__mathlive .op-symbol.large-op {\n  font-family: KaTeX_Size2;\n}\n.ML__mathlive .accent > .vlist > span {\n  text-align: center;\n}\n.ML__mathlive .mtable .vertical-separator {\n  display: inline-block;\n  min-width: 1px;\n  box-sizing: border-box;\n}\n.ML__mathlive .mtable .arraycolsep {\n  display: inline-block;\n}\n.ML__mathlive .mtable .col-align-m > .vlist-t {\n  text-align: center;\n}\n.ML__mathlive .mtable .col-align-c > .vlist-t {\n  text-align: center;\n}\n.ML__mathlive .mtable .col-align-l > .vlist-t {\n  text-align: left;\n}\n.ML__mathlive .mtable .col-align-r > .vlist-t {\n  text-align: right;\n}\n.ML__error {\n  background-image: radial-gradient(ellipse at center, hsl(341, 100%, 40%), rgba(0, 0, 0, 0) 70%);\n  background-repeat: repeat-x;\n  background-size: 3px 3px;\n  background-position: 0 98%;\n}\n.ML__composition {\n  background: #fff1c2;\n  color: black;\n  text-decoration: underline var(--caret, hsl(var(--hue, 212), 40%, 49%));\n}\n@media (prefers-color-scheme: dark) {\n  .ML__composition {\n    background: #69571c;\n    color: white;\n  }\n}\n.ML__placeholder {\n  color: var(--caret, hsl(var(--hue, 212), 40%, 49%));\n  padding-left: 0.4ex;\n  padding-right: 0.4ex;\n  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;\n}\n.ML__placeholdercontainer {\n  display: none;\n}\n.ML__isReadOnly .ML__placeholdercontainer {\n  display: block;\n}\n";

// src/editor/shortcuts.ts
function getInlineShortcutsStartingWith(s3, config) {
  const result = [];
  for (let i3 = 0; i3 <= s3.length - 1; i3++) {
    const s22 = s3.slice(Math.max(0, i3));
    for (const key of Object.keys(config.inlineShortcuts)) {
      if (key.startsWith(s22) && !result.includes(key)) {
        result.push(key);
      }
    }
  }
  return result;
}
function validateShortcut(siblings, shortcut) {
  if (!shortcut)
    return "";
  if (typeof shortcut === "string")
    return shortcut;
  if (!siblings)
    return shortcut.value;
  let nothing = false;
  let letter = false;
  let digit = false;
  let isFunction = false;
  let frac = false;
  let surd = false;
  let binop = false;
  let relop = false;
  let operator = false;
  let punct = false;
  let array = false;
  let openfence = false;
  let closefence = false;
  let text = false;
  let space = false;
  let sibling = siblings[siblings.length - 1];
  let index = siblings.length - 1;
  while (sibling && /msubsup|placeholder/.test(sibling.type)) {
    index -= 1;
    sibling = siblings[index];
  }
  nothing = !sibling || sibling.type === "first";
  if (sibling) {
    if (shortcut.mode !== void 0 && sibling.mode !== shortcut.mode) {
      return "";
    }
    text = sibling.mode === "text";
    letter = !text && sibling.type === "mord" && LETTER.test(sibling.value);
    digit = !text && sibling.type === "mord" && /\d+$/.test(sibling.value);
    isFunction = !text && sibling.isFunction;
    frac = sibling.type === "genfrac";
    surd = sibling.type === "surd";
    binop = sibling.type === "mbin";
    relop = sibling.type === "mrel";
    operator = sibling.type === "mop";
    punct = sibling.type === "mpunct" || sibling.type === "minner";
    array = sibling.type === "array";
    openfence = sibling.type === "mopen";
    closefence = sibling.type === "mclose" || sibling.type === "leftright";
    space = sibling.type === "space";
  }
  if (shortcut.after !== void 0) {
    if (shortcut.after.includes("nothing") && nothing || shortcut.after.includes("letter") && letter || shortcut.after.includes("digit") && digit || shortcut.after.includes("function") && isFunction || shortcut.after.includes("frac") && frac || shortcut.after.includes("surd") && surd || shortcut.after.includes("binop") && binop || shortcut.after.includes("relop") && relop || shortcut.after.includes("operator") && operator || shortcut.after.includes("punct") && punct || shortcut.after.includes("array") && array || shortcut.after.includes("openfence") && openfence || shortcut.after.includes("closefence") && closefence || shortcut.after.includes("text") && text || shortcut.after.includes("space") && space) {
      return shortcut.value;
    }
    return "";
  }
  return shortcut.value;
}
function getInlineShortcut(context, s3, shortcuts) {
  if (!shortcuts)
    return "";
  return validateShortcut(context, shortcuts[s3]);
}

// src/editor/shortcuts-definitions.ts
var INLINE_SHORTCUTS = {
  "%": "\\%",
  "''": {mode: "math", value: "^{\\doubleprime}"},
  "alpha": "\\alpha",
  "delta": "\\delta",
  "Delta": "\\Delta",
  "pi": {mode: "math", value: "\\pi"},
  "pi ": {mode: "text", value: "\\pi "},
  "Pi": {mode: "math", value: "\\Pi"},
  "theta": "\\theta",
  "Theta": "\\Theta",
  "ii": {
    after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
    value: "\\imaginaryI"
  },
  "jj": {
    after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
    value: "\\imaginaryJ"
  },
  "ee": {
    mode: "math",
    after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
    value: "\\exponentialE"
  },
  "nabla": {mode: "math", value: "\\nabla"},
  "grad": {mode: "math", value: "\\nabla"},
  "del": {mode: "math", value: "\\partial"},
  "infty": {mode: "math", value: "\\infty"},
  "\u221E": "\\infty",
  "oo": {
    mode: "math",
    after: "nothing+digit+frac+surd+binop+relop+punct+array+openfence+closefence+space",
    value: "\\infty"
  },
  "\u2211": {mode: "math", value: "\\sum"},
  "sum": {mode: "math", value: "\\sum_{#?}^{#?}"},
  "int": {mode: "math", value: "\\int_{#?}^{#?}"},
  "prod": {mode: "math", value: "\\prod_{#?}^{#?}"},
  "sqrt": {mode: "math", value: "\\sqrt{#?}"},
  "\u2206": {mode: "math", value: "\\differentialD"},
  "\u2202": {mode: "math", value: "\\differentialD"},
  "arcsin": {mode: "math", value: "\\arcsin"},
  "arccos": {mode: "math", value: "\\arccos"},
  "arctan": {mode: "math", value: "\\arctan"},
  "sin": {mode: "math", value: "\\sin"},
  "sinh": {mode: "math", value: "\\sinh"},
  "cos": {mode: "math", value: "\\cos"},
  "cosh": {mode: "math", value: "\\cosh"},
  "tan": {mode: "math", value: "\\tan"},
  "tanh": {mode: "math", value: "\\tanh"},
  "sec": {mode: "math", value: "\\sec"},
  "csc": {mode: "math", value: "\\csc"},
  "cot": {mode: "math", value: "\\cot"},
  "log": {mode: "math", value: "\\log"},
  "ln": {mode: "math", value: "\\ln"},
  "exp": {mode: "math", value: "\\exp"},
  "lim": {mode: "math", value: "\\lim_{#?}"},
  "dx": {
    mode: "math",
    after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
    value: "\\differentialD x"
  },
  "dy": {
    mode: "math",
    after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
    value: "\\differentialD y"
  },
  "dt": {
    mode: "math",
    after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
    value: "\\differentialD t"
  },
  "AA": {mode: "math", value: "\\forall"},
  "EE": {mode: "math", value: "\\exists"},
  "!EE": {mode: "math", value: "\\nexists"},
  "&&": {mode: "math", value: "\\land"},
  "xin": {
    mode: "math",
    after: "nothing+text+relop+punct+openfence+space",
    value: "x \\in"
  },
  "in": {
    mode: "math",
    after: "nothing+letter+closefence",
    value: "\\in"
  },
  "!in": {mode: "math", value: "\\notin"},
  "NN": "\\N",
  "ZZ": "\\Z",
  "QQ": "\\Q",
  "RR": "\\R",
  "CC": "\\C",
  "PP": "\\P",
  "xx": {mode: "math", value: "\\times"},
  "+-": {mode: "math", value: "\\pm"},
  "!=": {mode: "math", value: "\\ne"},
  ">=": {mode: "math", value: "\\ge"},
  "<=": {mode: "math", value: "\\le"},
  "<<": {mode: "math", value: "\\ll"},
  ">>": {mode: "math", value: "\\gg"},
  "~~": {mode: "math", value: "\\approx"},
  "\u2248": {mode: "math", value: "\\approx"},
  "?=": {mode: "math", value: "\\questeq"},
  "\xF7": {mode: "math", value: "\\div"},
  "\xAC": {mode: "math", value: "\\neg"},
  ":=": {mode: "math", value: "\\coloneq"},
  "::": {mode: "math", value: "\\Colon"},
  "(:": {mode: "math", value: "\\langle"},
  ":)": {mode: "math", value: "\\rangle"},
  "beta": "\\beta",
  "chi": "\\chi",
  "epsilon": "\\epsilon",
  "varepsilon": "\\varepsilon",
  "eta": {
    mode: "math",
    after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
    value: "\\eta"
  },
  "eta ": {
    mode: "text",
    after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
    value: "\\eta "
  },
  "gamma": "\\gamma",
  "Gamma": "\\Gamma",
  "iota": "\\iota",
  "kappa": "\\kappa",
  "lambda": "\\lambda",
  "Lambda": "\\Lambda",
  "mu": {
    mode: "math",
    after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
    value: "\\mu"
  },
  "mu ": {
    mode: "text",
    after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
    value: "\\mu "
  },
  "nu": {
    mode: "math",
    after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
    value: "\\nu"
  },
  "nu ": {
    mode: "text",
    after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
    value: "\\nu "
  },
  "\xB5": "\\mu",
  "phi": {
    after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
    value: "\\phi"
  },
  "Phi": {
    after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
    value: "\\Phi"
  },
  "varphi": "\\varphi",
  "psi": {
    after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
    value: "\\psi"
  },
  "Psi": {
    after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
    value: "\\Psi"
  },
  "rho": {
    after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
    value: "\\rho"
  },
  "sigma": "\\sigma",
  "Sigma": "\\Sigma",
  "tau": {
    after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
    value: "\\tau"
  },
  "vartheta": "\\vartheta",
  "upsilon": "\\upsilon",
  "xi": {
    after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
    value: "\\xi"
  },
  "Xi": {
    after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
    value: "\\Xi"
  },
  "zeta": "\\zeta",
  "omega": "\\omega",
  "Omega": "\\Omega",
  "\u03A9": "\\omega",
  "forall": {mode: "math", value: "\\forall"},
  "exists": {
    mode: "math",
    value: "\\exists"
  },
  "!exists": {
    mode: "math",
    value: "\\nexists"
  },
  ":.": {
    mode: "math",
    value: "\\therefore"
  },
  "liminf": "\\operatorname*{lim~inf}_{#?}",
  "limsup": "\\operatorname*{lim~sup}_{#?}",
  "argmin": "\\operatorname*{arg~min}_{#?}",
  "argmax": "\\operatorname*{arg~max}_{#?}",
  "det": "\\det",
  "mod": {
    mode: "math",
    value: "\\mod"
  },
  "max": {
    mode: "math",
    value: "\\max"
  },
  "min": {
    mode: "math",
    value: "\\min"
  },
  "erf": "\\operatorname{erf}",
  "erfc": "\\operatorname{erfc}",
  "bessel": {
    mode: "math",
    value: "\\operatorname{bessel}"
  },
  "mean": {
    mode: "math",
    value: "\\operatorname{mean}"
  },
  "median": {
    mode: "math",
    value: "\\operatorname{median}"
  },
  "fft": {
    mode: "math",
    value: "\\operatorname{fft}"
  },
  "lcm": {
    mode: "math",
    value: "\\operatorname{lcm}"
  },
  "gcd": {
    mode: "math",
    value: "\\operatorname{gcd}"
  },
  "randomReal": "\\operatorname{randomReal}",
  "randomInteger": "\\operatorname{randomInteger}",
  "Re": {
    mode: "math",
    value: "\\operatorname{Re}"
  },
  "Im": {
    mode: "math",
    value: "\\operatorname{Im}"
  },
  "mm": {
    mode: "math",
    after: "nothing+digit+operator",
    value: "\\operatorname{mm}"
  },
  "cm": {
    mode: "math",
    after: "nothing+digit+operator",
    value: "\\operatorname{cm}"
  },
  "km": {
    mode: "math",
    after: "nothing+digit+operator",
    value: "\\operatorname{km}"
  },
  "kg": {
    mode: "math",
    after: "nothing+digit+operator",
    value: "\\operatorname{kg}"
  },
  "...": "\\ldots",
  "+...": "+\\cdots",
  "-...": "-\\cdots",
  "->...": "\\to\\cdots",
  "->": "\\to",
  "|->": "\\mapsto",
  "-->": "\\longrightarrow",
  "<--": "\\longleftarrow",
  "=>": "\\Rightarrow",
  "==>": "\\Longrightarrow",
  "<=>": "\\Leftrightarrow",
  "<->": "\\leftrightarrow",
  "(.)": "\\odot",
  "(+)": "\\oplus",
  "(/)": "\\oslash",
  "(*)": "\\otimes",
  "(-)": "\\ominus",
  "||": "\\Vert",
  "{": "\\{",
  "}": "\\}",
  "*": "\\cdot"
};

// src/editor/parse-math-string.ts
function parseMathString(s3, options) {
  let format;
  [format, s3] = inferFormat(s3);
  if (format === "latex")
    return ["latex", s3];
  format = "ascii-math";
  s3 = s3.replace(/\u2061/gu, "");
  s3 = s3.replace(/\u3016/gu, "{");
  s3 = s3.replace(/\u3017/gu, "}");
  s3 = s3.replace(/([^\\])sinx/g, "$1\\sin x");
  s3 = s3.replace(/([^\\])cosx/g, "$1\\cos x ");
  s3 = s3.replace(/\u2013/g, "-");
  return [
    format,
    parseMathExpression(s3, {inlineShortcuts: options?.inlineShortcuts})
  ];
}
function parseMathExpression(s3, options) {
  if (!s3)
    return "";
  let done = false;
  let m3;
  const inlineShortcuts = options.inlineShortcuts ?? INLINE_SHORTCUTS;
  if (!done && (s3.startsWith("^") || s3.startsWith("_"))) {
    m3 = parseMathArgument(s3.slice(1), {inlineShortcuts, noWrap: true});
    s3 = s3[0] + "{" + m3.match + "}";
    s3 += parseMathExpression(m3.rest, options);
    done = true;
  }
  if (!done) {
    m3 = s3.match(/^(sqrt|\u221A)(.*)/);
    if (m3) {
      m3 = parseMathArgument(m3[2], {inlineShortcuts, noWrap: true});
      const sqrtArgument = m3.match ?? "\\placeholder{}";
      s3 = "\\sqrt{" + sqrtArgument + "}";
      s3 += parseMathExpression(m3.rest, options);
      done = true;
    }
  }
  if (!done) {
    m3 = s3.match(/^(\\cbrt|\u221B)(.*)/);
    if (m3) {
      m3 = parseMathArgument(m3[2], {inlineShortcuts, noWrap: true});
      const sqrtArgument = m3.match ?? "\\placeholder{}";
      s3 = "\\sqrt[3]{" + sqrtArgument + "}";
      s3 += parseMathExpression(m3.rest, options);
      done = true;
    }
  }
  if (!done) {
    m3 = s3.match(/^abs(.*)/);
    if (m3) {
      m3 = parseMathArgument(m3[1], {inlineShortcuts, noWrap: true});
      s3 = "\\left|" + m3.match + "\\right|";
      s3 += parseMathExpression(m3.rest, options);
      done = true;
    }
  }
  if (!done) {
    m3 = s3.match(/^["](.*?)["](.*)/);
    if (m3) {
      s3 = "\\text{" + m3[1] + "}";
      s3 += parseMathExpression(m3[2], options);
      done = true;
    }
  }
  if (!done) {
    m3 = s3.match(/^([^a-zA-Z({[_^\\\s"]+)(.*)/);
    if (m3) {
      s3 = paddedShortcut(m3[1], inlineShortcuts);
      s3 += parseMathExpression(m3[2], options);
      done = true;
    }
  }
  if (!done && /^([fgh])[^a-zA-Z]/.test(s3)) {
    m3 = parseMathArgument(s3.slice(1), {inlineShortcuts, noWrap: true});
    s3 = s3[1] === "(" ? s3[0] + "\\mleft(" + m3.match + "\\mright)" : s3[0] + m3.match;
    s3 += parseMathExpression(m3.rest, options);
    done = true;
  }
  if (!done) {
    m3 = s3.match(/^([a-zA-Z]+)(.*)/);
    if (m3) {
      s3 = paddedShortcut(m3[1], inlineShortcuts);
      s3 += parseMathExpression(m3[2], options);
      done = true;
    }
  }
  if (!done) {
    m3 = parseMathArgument(s3, {inlineShortcuts, noWrap: true});
    if (m3.match && m3.rest[0] === "/") {
      const m22 = parseMathArgument(m3.rest.slice(1), {
        inlineShortcuts,
        noWrap: true
      });
      if (m22.match) {
        s3 = "\\frac{" + m3.match + "}{" + m22.match + "}" + parseMathExpression(m22.rest, options);
      }
      done = true;
    } else if (m3.match) {
      s3 = s3.startsWith("(") ? "\\left(" + m3.match + "\\right)" + parseMathExpression(m3.rest, options) : m3.match + parseMathExpression(m3.rest, options);
      done = true;
    }
  }
  if (!done) {
    m3 = s3.match(/^(\s+)(.*)$/);
    if (m3) {
      s3 = " " + parseMathExpression(m3[2], options);
      done = true;
    }
  }
  return s3;
}
function parseMathArgument(s3, options) {
  let match2 = "";
  s3 = s3.trim();
  let rest = s3;
  let lFence = s3.charAt(0);
  let rFence = {"(": ")", "{": "}", "[": "]"}[lFence];
  if (rFence) {
    let level = 1;
    let i3 = 1;
    while (i3 < s3.length && level > 0) {
      if (s3[i3] === lFence)
        level++;
      if (s3[i3] === rFence)
        level--;
      i3++;
    }
    if (level === 0) {
      if (options.noWrap && lFence === "(") {
        match2 = parseMathExpression(s3.substring(1, i3 - 1), options);
      } else {
        if (lFence === "{" && rFence === "}") {
          lFence = "\\{";
          rFence = "\\}";
        }
        match2 = "\\left" + lFence + parseMathExpression(s3.substring(1, i3 - 1), options) + "\\right" + rFence;
      }
      rest = s3.slice(Math.max(0, i3));
    } else {
      match2 = s3.substring(1, i3);
      rest = "";
    }
  } else {
    let m3 = s3.match(/^([a-zA-Z]+)/);
    if (m3) {
      let shortcut = getInlineShortcut(null, s3, options.inlineShortcuts);
      if (shortcut) {
        shortcut = shortcut.replace("_{#?}", "");
        shortcut = shortcut.replace("^{#?}", "");
        return {match: shortcut, rest: s3.slice(shortcut.length)};
      }
    }
    m3 = s3.match(/^([a-zA-Z])/);
    if (m3) {
      return {match: m3[1], rest: s3.slice(1)};
    }
    m3 = s3.match(/^(-)?\d+(\.\d*)?/);
    if (m3) {
      return {match: m3[0], rest: s3.slice(m3[0].length)};
    }
    if (!/^\\(left|right)/.test(s3)) {
      m3 = s3.match(/^(\\[a-zA-Z]+)/);
      if (m3) {
        rest = s3.slice(m3[1].length);
        match2 = m3[1];
      }
    }
  }
  return {match: match2, rest};
}
function paddedShortcut(s3, shortcuts) {
  let result = getInlineShortcut(null, s3, shortcuts);
  if (result) {
    result = result.replace("_{#?}", "");
    result = result.replace("^{#?}", "");
    result += " ";
  } else {
    result = s3;
  }
  return result;
}
var MODE_SHIFT_COMMANDS = [
  ["\\[", "\\]"],
  ["\\(", "\\)"],
  ["$$", "$$"],
  ["$", "$"],
  ["\\begin{math}", "\\end{math}"],
  ["\\begin{displaymath}", "\\end{displaymath}"],
  ["\\begin{equation}", "\\end{equation}"],
  ["\\begin{equation*}", "\\end{equation*}"]
];
function trimModeShiftCommand(s3) {
  const trimedString = s3.trim();
  for (const mode of MODE_SHIFT_COMMANDS) {
    if (trimedString.startsWith(mode[0]) && trimedString.endsWith(mode[1])) {
      return [
        true,
        trimedString.substring(mode[0].length, trimedString.length - mode[1].length)
      ];
    }
  }
  return [false, s3];
}
function inferFormat(s3) {
  s3 = s3.trim();
  if (!s3)
    return ["latex", ""];
  if (s3.length <= 1)
    return ["latex", s3];
  s3 = s3.replace(/\\\\([^\s\n])/g, "\\$1");
  let hasLatexModeShiftCommand;
  [hasLatexModeShiftCommand, s3] = trimModeShiftCommand(s3);
  if (hasLatexModeShiftCommand)
    return ["latex", s3];
  if (s3.startsWith("`") && s3.endsWith("`")) {
    s3 = s3.substring(1, s3.length - 1);
    return ["ascii-math", s3];
  }
  if (s3.includes("\\")) {
    return ["latex", s3];
  }
  if (/\$(.+)\$/.test(s3)) {
    return ["latex", `\\text{${s3}}`];
  }
  return [void 0, s3];
}

// src/common/hash-code.ts
function hashCode(s3) {
  let hash2 = 0;
  if (s3.length === 0) {
    return hash2;
  }
  for (let i3 = 0; i3 < s3.length; i3++) {
    const char = s3.charCodeAt(i3);
    hash2 = (hash2 << 5) - hash2 + char;
    hash2 &= hash2;
  }
  return Math.abs(hash2);
}

// src/addons/auto-render.ts
function findEndOfMath(delimiter, text, startIndex) {
  let index = startIndex;
  let braceLevel = 0;
  const delimLength = delimiter.length;
  while (index < text.length) {
    const character = text[index];
    if (braceLevel <= 0 && text.slice(index, index + delimLength) === delimiter) {
      return index;
    }
    if (character === "\\") {
      index++;
    } else if (character === "{") {
      braceLevel++;
    } else if (character === "}") {
      braceLevel--;
    }
    index++;
  }
  return -1;
}
function splitAtDelimiters(startData, leftDelim, rightDelim, mathstyle, format = "latex") {
  const finalData = [];
  for (const startDatum of startData) {
    if (startDatum.type === "text") {
      const text = startDatum.data;
      let lookingForLeft = true;
      let currIndex = 0;
      let nextIndex;
      nextIndex = text.indexOf(leftDelim);
      if (nextIndex !== -1) {
        currIndex = nextIndex;
        if (currIndex > 0) {
          finalData.push({
            type: "text",
            data: text.slice(0, currIndex)
          });
        }
        lookingForLeft = false;
      }
      let done = false;
      while (!done) {
        if (lookingForLeft) {
          nextIndex = text.indexOf(leftDelim, currIndex);
          if (nextIndex === -1) {
            done = true;
            break;
          }
          if (currIndex !== nextIndex) {
            finalData.push({
              type: "text",
              data: text.slice(currIndex, nextIndex)
            });
          }
          currIndex = nextIndex;
        } else {
          nextIndex = findEndOfMath(rightDelim, text, currIndex + leftDelim.length);
          if (nextIndex === -1) {
            done = true;
            break;
          }
          let formula = text.slice(currIndex + leftDelim.length, nextIndex);
          if (format === "ascii-math") {
            [, formula] = parseMathString(formula, {format: "ascii-math"});
          }
          finalData.push({
            type: "math",
            data: formula,
            rawData: text.slice(currIndex, nextIndex + rightDelim.length),
            mathstyle
          });
          currIndex = nextIndex + rightDelim.length;
        }
        lookingForLeft = !lookingForLeft;
      }
      if (currIndex < text.length) {
        finalData.push({
          type: "text",
          data: text.slice(currIndex)
        });
      }
    } else {
      finalData.push(startDatum);
    }
  }
  return finalData;
}
function splitWithDelimiters(text, texDelimiters, mathAsciiDelimiters) {
  let data = [{type: "text", data: text}];
  if (texDelimiters?.inline) {
    texDelimiters.inline.forEach(([openDelim, closeDelim]) => {
      data = splitAtDelimiters(data, openDelim, closeDelim, "textstyle");
    });
  }
  if (texDelimiters?.display) {
    texDelimiters.display.forEach(([openDelim, closeDelim]) => {
      data = splitAtDelimiters(data, openDelim, closeDelim, "displaystyle");
    });
  }
  if (mathAsciiDelimiters?.inline) {
    mathAsciiDelimiters.inline.forEach(([openDelim, closeDelim]) => {
      data = splitAtDelimiters(data, openDelim, closeDelim, "textstyle", "ascii-math");
    });
  }
  if (mathAsciiDelimiters?.display) {
    mathAsciiDelimiters.display.forEach(([openDelim, closeDelim]) => {
      data = splitAtDelimiters(data, openDelim, closeDelim, "displaystyle", "ascii-math");
    });
  }
  return data;
}
function createMathMLNode(latex, options) {
  throwIfNotInBrowser();
  const span = document.createElement("span");
  try {
    const html = "<math xmlns='http://www.w3.org/1998/Math/MathML'>" + options.renderToMathML(latex, options) + "</math>";
    span.innerHTML = options.createHTML ? options.createHTML(html) : html;
  } catch (error) {
    console.error("Could not convert '" + latex + "' to MathML with ", error);
    span.textContent = latex;
  }
  span.className = "ML__sr-only";
  return span;
}
function createMarkupNode(text, options, mathstyle, createNodeOnFailure) {
  throwIfNotInBrowser();
  const element = document.createElement(mathstyle === "displaystyle" ? "div" : "span");
  element.setAttribute("aria-hidden", "true");
  try {
    const html = options.renderToMarkup(text, {
      mathstyle: mathstyle ?? "displaystyle",
      format: "html",
      macros: options.macros
    });
    element.innerHTML = options.createHTML ? options.createHTML(html) : html;
  } catch (error) {
    console.error("Could not parse'" + text + "' with ", error);
    if (createNodeOnFailure) {
      return document.createTextNode(text);
    }
    return null;
  }
  return element;
}
function createAccessibleMarkupPair(latex, mathstyle, options, createNodeOnFailure) {
  const markupNode = createMarkupNode(latex, options, mathstyle, createNodeOnFailure);
  const accessibleContent = options.renderAccessibleContent ?? "";
  if (markupNode && /\b(mathml|speakable-text)\b/i.test(accessibleContent)) {
    throwIfNotInBrowser();
    const fragment = document.createElement("span");
    if (/\bmathml\b/i.test(accessibleContent) && options.renderToMathML) {
      fragment.append(createMathMLNode(latex, options));
    }
    if (/\bspeakable-text\b/i.test(accessibleContent) && options.renderToSpeakableText) {
      const span = document.createElement("span");
      const html = options.renderToSpeakableText(latex, options);
      span.innerHTML = options.createHTML ? options.createHTML(html) : html;
      span.className = "ML__sr-only";
      fragment.append(span);
    }
    fragment.append(markupNode);
    return fragment;
  }
  return markupNode;
}
function scanText(text, options) {
  throwIfNotInBrowser();
  let fragment = null;
  if (options.TeX?.processEnvironments && /^\s*\\begin/.test(text)) {
    fragment = document.createDocumentFragment();
    const node = createAccessibleMarkupPair(text, "", options, true);
    if (node)
      fragment.appendChild(node);
  } else {
    if (!text.trim())
      return null;
    const data = splitWithDelimiters(text, options.TeX?.delimiters, options.asciiMath?.delimiters);
    if (data.length === 1 && data[0].type === "text") {
      return null;
    }
    fragment = document.createDocumentFragment();
    for (const datum of data) {
      if (datum.type === "text") {
        fragment.appendChild(document.createTextNode(datum.data));
      } else {
        const node = createAccessibleMarkupPair(datum.data, datum.mathstyle ?? "", options, true);
        if (node)
          fragment.appendChild(node);
      }
    }
  }
  return fragment;
}
function scanElement(element, options) {
  const originalContent = element.getAttribute("data-" + options.namespace + "original-content");
  if (originalContent) {
    const mathstyle = element.getAttribute("data-" + options.namespace + "mathstyle");
    const span = createAccessibleMarkupPair(originalContent, mathstyle, options, false);
    if (span !== null) {
      element.textContent = "";
      element.append(span);
    }
    return;
  }
  if (element.childNodes.length === 1 && element.childNodes[0].nodeType === 3) {
    const text = element.childNodes[0].textContent;
    if (options.TeX?.processEnvironments && /^\s*\\begin/.test(text)) {
      element.textContent = "";
      element.append(createAccessibleMarkupPair(text, "", options, true));
      return;
    }
    const data = splitWithDelimiters(text, options.TeX?.delimiters, options.asciiMath?.delimiters);
    if (data.length === 1 && data[0].type === "math") {
      element.textContent = "";
      element.append(createAccessibleMarkupPair(data[0].data, data[0].mathstyle ?? "", options, true));
      return;
    }
    if (data.length === 1 && data[0].type === "text") {
      return;
    }
  }
  for (let i3 = element.childNodes.length - 1; i3 >= 0; i3--) {
    const childNode = element.childNodes[i3];
    if (childNode.nodeType === 3) {
      const frag = scanText(childNode.textContent, options);
      if (frag) {
        i3 += frag.childNodes.length - 1;
        childNode.replaceWith(frag);
      }
    } else if (childNode.nodeType === 1) {
      const tag = childNode.nodeName.toLowerCase();
      if (tag === "script" && options.processScriptTypePattern?.test(childNode.type)) {
        let style = "displaystyle";
        for (const l3 of childNode.type.split(";")) {
          const v3 = l3.split("=");
          if (v3[0].toLowerCase() === "mode") {
            style = v3[1].toLoweCase() === "display" ? "displaystyle" : "textstyle";
          }
        }
        const span = createAccessibleMarkupPair(childNode.textContent, style, options, true);
        childNode.parentNode.replaceChild(span, childNode);
      } else if (tag !== "script") {
        const shouldRender = (options.processClassPattern?.test(childNode.className) ?? false) || !((options.skipTags?.includes(tag) ?? false) || (options.ignoreClassPattern?.test(childNode.className) ?? false));
        if (shouldRender) {
          if (element.childNodes.length === 1 && element.childNodes[0].nodeType === 3) {
            const formula = element.textContent;
            element.textContent = "";
            element.append(createAccessibleMarkupPair(formula, "displaystyle", options, true));
          } else {
            scanElement(childNode, options);
          }
        }
      }
    }
  }
}
var DEFAULT_AUTO_RENDER_OPTIONS = {
  namespace: "",
  skipTags: [
    "math-field",
    "noscript",
    "style",
    "textarea",
    "pre",
    "code",
    "annotation",
    "annotation-xml"
  ],
  processScriptType: "math/tex",
  ignoreClass: "tex2jax_ignore",
  processClass: "tex2jax_process",
  renderAccessibleContent: "mathml",
  asciiMath: {
    delimiters: {
      display: [
        ["`", "`"]
      ]
    }
  },
  TeX: {
    processEnvironments: true,
    delimiters: {
      inline: [["\\(", "\\)"]],
      display: [
        ["$$", "$$"],
        ["\\[", "\\]"]
      ]
    }
  }
};
function autoRenderMathInElement(element, options) {
  try {
    options = {...DEFAULT_AUTO_RENDER_OPTIONS, ...options};
    options.ignoreClassPattern = new RegExp(options.ignoreClass ?? "");
    options.processClassPattern = new RegExp(options.processClass ?? "");
    options.processScriptTypePattern = new RegExp(options.processScriptType ?? "");
    options.macros = getMacros(options.macros);
    if (options.namespace) {
      if (!/^[a-z]+-?$/.test(options.namespace)) {
        throw new Error("options.namespace must be a string of lowercase characters only");
      }
      if (!options.namespace.endsWith("-")) {
        options.namespace += "-";
      }
    }
    void loadFonts(options.fontsDirectory);
    inject(null, core_default, hashCode(core_default).toString(36));
    scanElement(element, options);
  } catch (error) {
    if (error instanceof Error) {
      console.error("renderMathInElement(): " + error.message);
    } else {
      console.error("renderMathInElement(): Could not render math for element", element);
    }
  }
}

// src/editor/keybindings-definitions.ts
var DEFAULT_KEYBINDINGS = [
  {key: "left", command: "moveToPreviousChar"},
  {key: "right", command: "moveToNextChar"},
  {key: "up", command: "moveUp"},
  {key: "down", command: "moveDown"},
  {key: "shift+[ArrowLeft]", command: "extendSelectionBackward"},
  {key: "shift+[ArrowRight]", command: "extendSelectionForward"},
  {key: "shift+[ArrowUp]", command: "extendSelectionUpward"},
  {key: "shift+[ArrowDown]", command: "extendSelectionDownward"},
  {key: "[Backspace]", command: "deleteBackward"},
  {key: "alt+[Delete]", command: "deleteBackward"},
  {key: "[Delete]", command: "deleteForward"},
  {key: "alt+[Backspace]", command: "deleteForward"},
  {key: "alt+[ArrowLeft]", command: "moveToPreviousWord"},
  {key: "alt+[ArrowRight]", command: "moveToNextWord"},
  {key: "shift+alt+[ArrowLeft]", command: "extendToPreviousWord"},
  {key: "shift+alt+[ArrowRight]", command: "extendToNextWord"},
  {key: "ctrl+[ArrowLeft]", command: "moveToGroupStart"},
  {key: "ctrl+[ArrowRight]", command: "moveToGroupEnd"},
  {key: "shift+ctrl+[ArrowLeft]", command: "extendToGroupStart"},
  {key: "shift+ctrl+[ArrowRight]", command: "extendToGroupEnd"},
  {key: "[Space]", ifMode: "math", command: "moveAfterParent"},
  {key: "shift+[Space]", ifMode: "math", command: "moveBeforeParent"},
  {key: "[Home]", command: "moveToMathFieldStart"},
  {key: "cmd+[ArrowLeft]", command: "moveToMathFieldStart"},
  {key: "shift+[Home]", command: "extendToMathFieldStart"},
  {key: "shift+cmd+[ArrowLeft]", command: "extendToMathFieldStart"},
  {key: "[End]", command: "moveToMathFieldEnd"},
  {key: "cmd+[ArrowRight]", command: "moveToMathFieldEnd"},
  {key: "shift+[End]", command: "extendToMathFieldEnd"},
  {key: "shift+cmd+[ArrowRight]", command: "extendToMathFieldEnd"},
  {key: "[Pageup]", command: "moveToGroupStart"},
  {key: "[Pagedown]", command: "moveToGroupEnd"},
  {key: "[Tab]", ifMode: "math", command: "moveToNextPlaceholder"},
  {
    key: "shift+[Tab]",
    ifMode: "math",
    command: "moveToPreviousPlaceholder"
  },
  {key: "[Tab]", ifMode: "text", command: "moveToNextPlaceholder"},
  {
    key: "shift+[Tab]",
    ifMode: "text",
    command: "moveToPreviousPlaceholder"
  },
  {key: "[Escape]", ifMode: "math", command: ["switchMode", "latex"]},
  {key: "[Escape]", ifMode: "text", command: ["switchMode", "latex"]},
  {
    key: "\\",
    ifMode: "math",
    command: ["switchMode", "latex", "\\"]
  },
  {
    key: "[IntlBackslash]",
    ifMode: "math",
    command: ["switchMode", "latex", "\\"]
  },
  {
    key: "[Escape]",
    ifMode: "latex",
    command: ["complete", "complete", {selectItem: "true"}]
  },
  {
    key: "[Tab]",
    ifMode: "latex",
    command: ["complete", "accept-suggestion"]
  },
  {key: "[Return]", ifMode: "latex", command: "complete"},
  {key: "[Enter]", ifMode: "latex", command: "complete"},
  {
    key: "shift+[Escape]",
    ifMode: "latex",
    command: ["complete", "reject"]
  },
  {key: "[ArrowDown]", ifMode: "latex", command: "nextSuggestion"},
  {key: "[ArrowUp]", ifMode: "latex", command: "previousSuggestion"},
  {key: "ctrl+a", ifPlatform: "!macos", command: "selectAll"},
  {key: "cmd+a", command: "selectAll"},
  {key: "[Cut]", command: "cutToClipboard"},
  {key: "[Copy]", command: "copyToClipboard"},
  {key: "[Paste]", command: "pasteFromClipboard"},
  {key: "[Clear]", command: "deleteBackward"},
  {key: "ctrl+z", ifPlatform: "!macos", command: "undo"},
  {key: "cmd+z", command: "undo"},
  {key: "[Undo]", command: "undo"},
  {key: "ctrl+y", ifPlatform: "!macos", command: "redo"},
  {key: "shift+cmd+y", command: "redo"},
  {key: "shift+ctrl+z", ifPlatform: "!macos", command: "redo"},
  {key: "shift+cmd+z", command: "redo"},
  {key: "[Redo]", command: "redo"},
  {key: "[EraseEof]", command: "deleteToGroupEnd"},
  {key: "ctrl+b", ifPlatform: "macos", command: "moveToPreviousChar"},
  {key: "ctrl+f", ifPlatform: "macos", command: "moveToNextChar"},
  {key: "ctrl+p", ifPlatform: "macos", command: "moveUp"},
  {key: "ctrl+n", ifPlatform: "macos", command: "moveDown"},
  {key: "ctrl+a", ifPlatform: "macos", command: "moveToMathFieldStart"},
  {key: "ctrl+e", ifPlatform: "macos", command: "moveToMathFieldEnd"},
  {
    key: "shift+ctrl+b",
    ifPlatform: "macos",
    command: "extendSelectionBackward"
  },
  {
    key: "shift+ctrl+f",
    ifPlatform: "macos",
    command: "extendSelectionForward"
  },
  {
    key: "shift+ctrl+p",
    ifPlatform: "macos",
    command: "extendSelectionUpward"
  },
  {
    key: "shift+ctrl+n",
    ifPlatform: "macos",
    command: "extendSelectionDownward"
  },
  {
    key: "shift+ctrl+a",
    ifPlatform: "macos",
    command: "extendToMathFieldStart"
  },
  {
    key: "shift+ctrl+e",
    ifPlatform: "macos",
    command: "extendToMathFieldEnd"
  },
  {key: "alt+ctrl+b", ifPlatform: "macos", command: "moveToPreviousWord"},
  {key: "alt+ctrl+f", ifPlatform: "macos", command: "moveToNextWord"},
  {
    key: "shift+alt+ctrl+b",
    ifPlatform: "macos",
    command: "extendToPreviousWord"
  },
  {
    key: "shift+alt+ctrl+f",
    ifPlatform: "macos",
    command: "extendToNextWord"
  },
  {key: "ctrl+h", ifPlatform: "macos", command: "deleteBackward"},
  {key: "ctrl+d", ifPlatform: "macos", command: "deleteForward"},
  {key: "ctrl+l", ifPlatform: "macos", command: "scrollIntoView"},
  {
    key: "ctrl+[Digit2]",
    ifMode: "math",
    command: ["insert", "\\sqrt{#0}"]
  },
  {key: "ctrl+[Digit5]", ifMode: "math", command: "moveToOpposite"},
  {key: "ctrl+[Digit6]", ifMode: "math", command: "moveToSuperscript"},
  {key: "ctrl+[Return]", ifMode: "math", command: "addRowAfter"},
  {key: "ctrl+[Enter]", ifMode: "math", command: "addRowAfter"},
  {key: "cmd+[Return]", ifMode: "math", command: "addRowAfter"},
  {key: "cmd+[Enter]", ifMode: "math", command: "addRowAfter"},
  {key: "alt+p", ifMode: "math", command: ["insert", "\\pi"]},
  {key: "alt+v", ifMode: "math", command: ["insert", "\\sqrt{#0}"]},
  {
    key: "alt+w",
    ifMode: "math",
    command: ["insert", "\\sum_{i=#?}^{#?}"]
  },
  {key: "alt+b", command: ["insert", "\\int_{#?}^{#?}"]},
  {key: "alt+u", ifMode: "math", command: ["insert", "\\cup"]},
  {key: "alt+n", ifMode: "math", command: ["insert", "\\cap"]},
  {key: "alt+o", ifMode: "math", command: ["insert", "\\emptyset"]},
  {
    key: "alt+d",
    ifMode: "math",
    command: ["insert", "\\differentialD"]
  },
  {
    key: "shift+alt+o",
    ifMode: "math",
    command: ["insert", "\\varnothing"]
  },
  {
    key: "shift+alt+d",
    ifMode: "math",
    command: ["insert", "\\partial"]
  },
  {
    key: "shift+alt+p",
    ifMode: "math",
    command: ["insert", "\\prod_{i=#?}^{#?}"]
  },
  {key: "shift+alt+u", ifMode: "math", command: ["insert", "\\bigcup"]},
  {key: "shift+alt+n", ifMode: "math", command: ["insert", "\\bigcap"]},
  {key: "shift+alt+a", ifMode: "math", command: ["insert", "\\forall"]},
  {key: "shift+alt+e", ifMode: "math", command: ["insert", "\\exists"]},
  {
    key: "alt+[Backslash]",
    ifMode: "math",
    command: ["insert", "\\backslash"]
  },
  {
    key: "[NumpadDivide]",
    ifMode: "math",
    command: ["insert", "\\frac{#@}{#?}"]
  },
  {
    key: "alt+[NumpadDivide]",
    ifMode: "math",
    command: ["insert", "\\frac{#?}{#@}"]
  },
  {key: "shift+alt+k", command: "toggleKeystrokeCaption"},
  {key: "alt+[Space]", command: "toggleVirtualKeyboard"},
  {
    key: "alt+ctrl+[ArrowUp]",
    command: ["speak", "all", {withHighlighting: false}]
  },
  {
    key: "alt+ctrl+[ArrowDown]",
    command: ["speak", "selection", {withHighlighting: false}]
  },
  {
    key: "alt+[Equal]",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "math",
    command: ["applyStyle", {mode: "text"}]
  },
  {
    key: "alt+[Equal]",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "text",
    command: ["applyStyle", {mode: "math"}]
  },
  {
    key: "shift+[Quote]",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "math",
    command: ["switchMode", "text", "", "\u201C"]
  },
  {
    key: "shift+[Quote]",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "text",
    command: ["switchMode", "math", "\u201D", ""]
  },
  {
    key: "/",
    ifMode: "math",
    command: ["insert", "\\frac{#@}{#?}"]
  },
  {
    key: "alt+/",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "math",
    command: ["insert", "\\/"]
  },
  {
    key: "alt+[BracketLeft]",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "math",
    command: ["insert", "\\left\\lbrack #0 \\right\\rbrack"]
  },
  {
    key: "ctrl+[Minus]",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "math",
    command: "moveToSubscript"
  },
  {
    key: "shift+alt+[BracketLeft]",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "math",
    command: ["insert", "\\left\\lbrace #0 \\right\\rbrace"]
  },
  {
    key: "ctrl+;",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "math",
    command: "addRowAfter"
  },
  {
    key: "cmd+;",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "math",
    command: "addRowAfter"
  },
  {
    key: "shift+ctrl+;",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "math",
    command: "addRowBefore"
  },
  {
    key: "shift+cmd+;",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "math",
    command: "addRowBefore"
  },
  {
    key: "ctrl+[Comma]",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "math",
    command: "addColumnAfter"
  },
  {
    key: "cmd+[Comma]",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "math",
    command: "addColumnAfter"
  },
  {
    key: "shift+ctrl+[Comma]",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "math",
    command: "addColumnAfter"
  },
  {
    key: "shift+cmd+[Comma]",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "math",
    command: "addColumnAfter"
  },
  {
    key: "alt+[Digit5]",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "math",
    command: ["insert", "$\\infty"]
  },
  {
    key: "alt+[Digit6]",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "math",
    command: ["insert", "\\wedge"]
  },
  {
    key: "shift+alt+[Digit6]",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "math",
    command: ["insert", "\\vee"]
  },
  {
    key: "alt+[Digit9]",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "math",
    command: ["insert", "("]
  },
  {
    key: "alt+[Digit0]",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "math",
    command: ["insert", ")"]
  },
  {
    key: "alt+|",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "math",
    command: ["insert", "|"]
  },
  {
    key: "shift+[Backquote]",
    ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
    ifMode: "math",
    command: ["insert", "\\~"]
  }
];
var REVERSE_KEYBINDINGS = {
  "\\theta": "alt+q",
  "\\sqrt": ["alt+v", "ctrl+[Digit2]"],
  "\\pi": "alt+p",
  "\\prod": "shift+alt+p",
  "\\sum": "alt+w",
  "\\int": "alt+b",
  "\\cup": "alt+u",
  "\\cap": "alt+n",
  "\\bigcup": "shift+alt+u",
  "\\bigcap": "shift+alt+n",
  "\\forall": "shift+alt+a",
  "\\exists": "shift+alt+e",
  "\\infty": "alt+[Digit5]",
  "\\wedge": "alt+[Digit5]",
  "\\vee": "shift+alt+[Digit6]",
  "\\differentialD": "alt+d",
  "\\partial": "shift+alt+d",
  "\\frac": "Slash",
  "\\emptyset": "alt+o",
  "\\varnothing": "shift+alt+o",
  "\\~": "~"
};

// src/editor/keyboard-layout.ts
function keystrokeModifiersFromString(key) {
  const segments = key.split("+");
  const result = {
    shift: false,
    alt: false,
    cmd: false,
    win: false,
    meta: false,
    ctrl: false,
    key: segments.pop()
  };
  if (segments.includes("shift"))
    result.shift = true;
  if (segments.includes("alt"))
    result.alt = true;
  if (segments.includes("ctrl"))
    result.ctrl = true;
  if (segments.includes("cmd"))
    result.cmd = true;
  if (segments.includes("win"))
    result.win = true;
  if (segments.includes("meta"))
    result.meta = true;
  return result;
}
function keystrokeModifiersToString(key) {
  let result = "";
  if (key.shift)
    result += "shift+";
  if (key.alt)
    result += "alt+";
  if (key.ctrl)
    result += "ctrl+";
  if (key.cmd)
    result += "cmd+";
  if (key.win)
    result += "win+";
  if (key.meta)
    result += "meta+";
  return result + key.key;
}
var DEFAULT_KEYBOARD_LAYOUT = platform() === "apple" ? {
  id: "apple.en-intl",
  displayName: "English (international)",
  virtualLayout: "qwerty",
  platform: "apple",
  locale: "en",
  score: 0,
  mapping: {
    KeyA: ["a", "A", "\xE5", "\xC5"],
    KeyB: ["b", "B", "\u222B", "\u0131"],
    KeyC: ["c", "C", "\xE7", "\xC7"],
    KeyD: ["d", "D", "\u2202", "\xCE"],
    KeyE: ["e", "E", "\xB4", "\xB4"],
    KeyF: ["f", "F", "\u0192", "\xCF"],
    KeyG: ["g", "G", "\xA9", "\u02DD"],
    KeyH: ["h", "H", "\u02D9", "\xD3"],
    KeyI: ["i", "I", "\u02C6", "\u02C6"],
    KeyJ: ["j", "J", "\u2206", "\xD4"],
    KeyK: ["k", "K", "\u02DA", "\uF8FF"],
    KeyL: ["l", "L", "\xAC", "\xD2"],
    KeyM: ["m", "M", "\xB5", "\xC2"],
    KeyN: ["n", "N", "\u02DC", "\u02DC"],
    KeyO: ["o", "O", "\xF8", "\xD8"],
    KeyP: ["p", "P", "\u03C0", "\u220F"],
    KeyQ: ["q", "Q", "\u0153", "\u0152"],
    KeyR: ["r", "R", "\xAE", "\u2030"],
    KeyS: ["s", "S", "\xDF", "\xCD"],
    KeyT: ["t", "T", "\u2020", "\u02C7"],
    KeyU: ["u", "U", "\xA8", "\xA8"],
    KeyV: ["v", "V", "\u221A", "\u25CA"],
    KeyW: ["w", "W", "\u2211", "\u201E"],
    KeyX: ["x", "X", "\u2248", "\u02DB"],
    KeyY: ["y", "Y", "\xA5", "\xC1"],
    KeyZ: ["z", "Z", "\u03A9", "\xB8"],
    Digit1: ["1", "!", "\xA1", "\u2044"],
    Digit2: ["2", "@", "\u2122", "\u20AC"],
    Digit3: ["3", "#", "\xA3", "\u2039"],
    Digit4: ["4", "$", "\xA2", "\u203A"],
    Digit5: ["5", "%", "\u221E", "\uFB01"],
    Digit6: ["6", "^", "\xA7", "\uFB02"],
    Digit7: ["7", "&", "\xB6", "\u2021"],
    Digit8: ["8", "*", "\u2022", "\xB0"],
    Digit9: ["9", "(", "\xAA", "\xB7"],
    Digit0: ["0", ")", "\xBA", "\u201A"],
    Space: [" ", " ", " ", " "],
    Minus: ["-", "_", "\u2013", "\u2014"],
    Equal: ["=", "+", "\u2260", "\xB1"],
    BracketLeft: ["[", "{", "\u201C", "\u201D"],
    BracketRight: ["]", "}", "\u2018", "\u2019"],
    Backslash: ["\\", "|", "\xAB", "\xBB"],
    Semicolon: [";", ":", "\u2026", "\xDA"],
    Quote: ["'", '"', "\xE6", "\xC6"],
    Backquote: ["`", "\u02DC", "`", "`"],
    Comma: [",", "<", "\u2264", "\xAF"],
    Period: [".", ">", "\u2265", "\u02D8"],
    Slash: ["/", "?", "\xF7", "\xBF"],
    NumpadDivide: ["/", "/", "/", "/"],
    NumpadMultiply: ["*", "*", "*", "*"],
    NumpadSubtract: ["-", "-", "-", "-"],
    NumpadAdd: ["+", "+", "+", "+"],
    Numpad1: ["1", "1", "1", "1"],
    Numpad2: ["2", "2", "2", "2"],
    Numpad3: ["3", "3", "3", "3"],
    Numpad4: ["4", "4", "4", "4"],
    Numpad5: ["5", "5", "5", "5"],
    Numpad6: ["6", "6", "6", "6"],
    Numpad7: ["7", "7", "7", "7"],
    Numpad8: ["8", "8", "8", "8"],
    Numpad9: ["9", "9", "9", "9"],
    Numpad0: ["0", "0", "0", "0"],
    NumpadDecimal: [".", ".", ".", "."],
    IntlBackslash: ["\xA7", "\xB1", "\xA7", "\xB1"],
    NumpadEqual: ["=", "=", "=", "="],
    AudioVolumeUp: ["", "=", "", "="]
  }
} : platform() === "windows" ? {
  id: "windows.en-intl",
  displayName: "English (international)",
  platform: "windows",
  virtualLayout: "qwerty",
  locale: "en",
  score: 0,
  mapping: {
    KeyA: ["a", "A", "\xE1", "\xC1"],
    KeyB: ["b", "B", "", ""],
    KeyC: ["c", "C", "\xA9", "\xA2"],
    KeyD: ["d", "D", "\xF0", "\xD0"],
    KeyE: ["e", "E", "\xE9", "\xC9"],
    KeyF: ["f", "F", "", ""],
    KeyG: ["g", "G", "", ""],
    KeyH: ["h", "H", "", ""],
    KeyI: ["i", "I", "\xED", "\xCD"],
    KeyJ: ["j", "J", "", ""],
    KeyK: ["k", "K", "", ""],
    KeyL: ["l", "L", "\xF8", "\xD8"],
    KeyM: ["m", "M", "\xB5", ""],
    KeyN: ["n", "N", "\xF1", "\xD1"],
    KeyO: ["o", "O", "\xF3", "\xD3"],
    KeyP: ["p", "P", "\xF6", "\xD6"],
    KeyQ: ["q", "Q", "\xE4", "\xC4"],
    KeyR: ["r", "R", "\xAE", ""],
    KeyS: ["s", "S", "\xDF", "\xA7"],
    KeyT: ["t", "T", "\xFE", "\xDE"],
    KeyU: ["u", "U", "\xFA", "\xDA"],
    KeyV: ["v", "V", "", ""],
    KeyW: ["w", "W", "\xE5", "\xC5"],
    KeyX: ["x", "X", "", ""],
    KeyY: ["y", "Y", "\xFC", "\xDC"],
    KeyZ: ["z", "Z", "\xE6", "\xC6"],
    Digit1: ["1", "!", "\xA1", "\xB9"],
    Digit2: ["2", "@", "\xB2", ""],
    Digit3: ["3", "#", "\xB3", ""],
    Digit4: ["4", "$", "\xA4", "\xA3"],
    Digit5: ["5", "%", "\u20AC", ""],
    Digit6: ["6", "^", "\xBC", ""],
    Digit7: ["7", "&", "\xBD", ""],
    Digit8: ["8", "*", "\xBE", ""],
    Digit9: ["9", "(", "\u2018", ""],
    Digit0: ["0", ")", "\u2019", ""],
    Space: [" ", " ", "", ""],
    Minus: ["-", "_", "\xA5", ""],
    Equal: ["=", "+", "\xD7", "\xF7"],
    BracketLeft: ["[", "{", "\xAB", ""],
    BracketRight: ["]", "}", "\xBB", ""],
    Backslash: ["\\", "|", "\xAC", "\xA6"],
    Semicolon: [";", ":", "\xB6", "\xB0"],
    Quote: ["'", '"', "\xB4", "\xA8"],
    Backquote: ["`", "~", "", ""],
    Comma: [",", "<", "\xE7", "\xC7"],
    Period: [".", ">", "", ""],
    Slash: ["/", "?", "\xBF", ""],
    NumpadDivide: ["/", "/", "", ""],
    NumpadMultiply: ["*", "*", "", ""],
    NumpadSubtract: ["-", "-", "", ""],
    NumpadAdd: ["+", "+", "", ""],
    IntlBackslash: ["\\", "|", "", ""]
  }
} : {
  id: "linux.en",
  displayName: "English",
  platform: "linux",
  virtualLayout: "qwerty",
  locale: "en",
  score: 0,
  mapping: {
    KeyA: ["a", "A", "a", "A"],
    KeyB: ["b", "B", "b", "B"],
    KeyC: ["c", "C", "c", "C"],
    KeyD: ["d", "D", "d", "D"],
    KeyE: ["e", "E", "e", "E"],
    KeyF: ["f", "F", "f", "F"],
    KeyG: ["g", "G", "g", "G"],
    KeyH: ["h", "H", "h", "H"],
    KeyI: ["i", "I", "i", "I"],
    KeyJ: ["j", "J", "j", "J"],
    KeyK: ["k", "K", "k", "K"],
    KeyL: ["l", "L", "l", "L"],
    KeyM: ["m", "M", "m", "M"],
    KeyN: ["n", "N", "n", "N"],
    KeyO: ["o", "O", "o", "O"],
    KeyP: ["p", "P", "p", "P"],
    KeyQ: ["q", "Q", "q", "Q"],
    KeyR: ["r", "R", "r", "R"],
    KeyS: ["s", "S", "s", "S"],
    KeyT: ["t", "T", "t", "T"],
    KeyU: ["u", "U", "u", "U"],
    KeyV: ["v", "V", "v", "V"],
    KeyW: ["w", "W", "w", "W"],
    KeyX: ["x", "X", "x", "X"],
    KeyY: ["y", "Y", "y", "Y"],
    KeyZ: ["z", "Z", "z", "Z"],
    Digit1: ["1", "!", "1", "!"],
    Digit2: ["2", "@", "2", "@"],
    Digit3: ["3", "#", "3", "#"],
    Digit4: ["4", "$", "4", "$"],
    Digit5: ["5", "%", "5", "%"],
    Digit6: ["6", "^", "6", "^"],
    Digit7: ["7", "&", "7", "&"],
    Digit8: ["8", "*", "8", "*"],
    Digit9: ["9", "(", "9", "("],
    Digit0: ["0", ")", "0", ")"],
    Space: [" ", " ", " ", " "],
    Minus: ["-", "_", "-", "_"],
    Equal: ["=", "+", "=", "+"],
    BracketLeft: ["[", "{", "[", "{"],
    BracketRight: ["]", "}", "]", "}"],
    Backslash: ["\\", "|", "\\", "|"],
    Semicolon: [";", ":", ";", ":"],
    Quote: ["'", '"', "'", '"'],
    Backquote: ["`", "~", "`", "~"],
    Comma: [",", "<", ",", "<"],
    Period: [".", ">", ".", ">"],
    Slash: ["/", "?", "/", "?"],
    NumpadDivide: ["/", "/", "/", "/"],
    NumpadMultiply: ["*", "*", "*", "*"],
    NumpadSubtract: ["-", "-", "-", "-"],
    NumpadAdd: ["+", "+", "+", "+"],
    Numpad1: ["1", "1", "1", "1"],
    Numpad2: ["2", "2", "2", "2"],
    Numpad3: ["3", "3", "3", "3"],
    Numpad4: ["4", "4", "4", "4"],
    Numpad5: ["5", "5", "5", "5"],
    Numpad6: ["6", "6", "6", "6"],
    Numpad7: ["7", "7", "7", "7"],
    Numpad8: ["8", "8", "8", "8"],
    Numpad9: ["9", "9", "9", "9"],
    Numpad0: ["0", "0", "0", "0"],
    NumpadDecimal: ["", ".", "", "."],
    IntlBackslash: ["<", ">", "|", "\xA6"],
    NumpadEqual: ["=", "=", "=", "="],
    NumpadComma: [".", ".", ".", "."],
    NumpadParenLeft: ["(", "(", "(", "("],
    NumpadParenRight: [")", ")", ")", ")"]
  }
};
var BASE_LAYOUT_MAPPING = {
  enter: "[Enter]",
  escape: "[Escape]",
  backspace: "[Backspace]",
  tab: "[Tab]",
  space: "[Space]",
  pausebreak: "[Pause]",
  insert: "[Insert]",
  home: "[Home]",
  pageup: "[PageUp]",
  delete: "[Delete]",
  end: "[End]",
  pagedown: "[PageDown]",
  right: "[ArrowRight]",
  left: "[ArrowLeft]",
  down: "[ArrowDown]",
  up: "[ArrowUp]",
  numpad0: "[Numpad0]",
  numpad1: "[Numpad1]",
  numpad2: "[Numpad2]",
  numpad3: "[Numpad3]",
  numpad4: "[Numpad4]",
  numpad5: "[Numpad5]",
  numpad6: "[Numpad6]",
  numpad7: "[Numpad7]",
  numpad8: "[Numpad8]",
  numpad9: "[Numpad9]",
  "numpad_divide": "[NumpadDivide]",
  "numpad_multiply": "[NumpadMultiply]",
  "numpad_subtract": "[NumpadSubtract]",
  "numpad_add": "[NumpadAdd]",
  "numpad_decimal": "[NumpadDecimal]",
  "numpad_separator": "[NumpadComma]",
  capslock: "[Capslock]",
  f1: "[F1]",
  f2: "[F2]",
  f3: "[F3]",
  f4: "[F4]",
  f5: "[F5]",
  f6: "[F6]",
  f7: "[F7]",
  f8: "[F8]",
  f9: "[F9]",
  f10: "[F10]",
  f11: "[F11]",
  f12: "[F12]",
  f13: "[F13]",
  f14: "[F14]",
  f15: "[F15]",
  f16: "[F16]",
  f17: "[F17]",
  f18: "[F18]",
  f19: "[F19]"
};
var gKeyboardLayouts = [];
var gKeyboardLayout;
function platform() {
  switch (osPlatform()) {
    case "macos":
    case "ios":
      return "apple";
    case "windows":
      return "windows";
  }
  return "linux";
}
function register(layout) {
  if (!layout.platform || layout.platform === platform()) {
    gKeyboardLayouts.push(layout);
  }
}
function getCodeForKey(k3, layout) {
  const result = {
    shift: false,
    alt: false,
    cmd: false,
    win: false,
    meta: false,
    ctrl: false,
    key: ""
  };
  if (!k3)
    return result;
  for (const [key, value] of Object.entries(layout.mapping)) {
    if (value[0] === k3) {
      result.key = `[${key}]`;
      return result;
    }
    if (value[1] === k3) {
      result.shift = true;
      result.key = `[${key}]`;
      return result;
    }
    if (value[2] === k3) {
      result.alt = true;
      result.key = `[${key}]`;
      return result;
    }
    if (value[3] === k3) {
      result.shift = true;
      result.alt = true;
      result.key = `[${key}]`;
      return result;
    }
  }
  result.key = BASE_LAYOUT_MAPPING[k3] ?? "";
  return result;
}
function normalizeKeyboardEvent(evt) {
  if (!evt.code) {
    const mapping = Object.entries(getActiveKeyboardLayout().mapping);
    let altKey = false;
    let shiftKey = false;
    let code = "";
    for (let index = 0; index < 4; index++) {
      for (const [key, value] of mapping) {
        if (value[index] === evt.key) {
          code = key;
          if (index === 3) {
            altKey = true;
            shiftKey = true;
          } else if (index === 2) {
            altKey = true;
          } else if (index === 1) {
            shiftKey = true;
          }
          break;
        }
      }
      if (code)
        break;
    }
    return new KeyboardEvent(evt.type, {...evt, altKey, shiftKey, code});
  }
  return new KeyboardEvent(evt.type, evt);
}
function validateKeyboardLayout(evt) {
  if (!evt)
    return;
  const index = evt.shiftKey && evt.altKey ? 3 : evt.altKey ? 2 : evt.shiftKey ? 1 : 0;
  if (evt.key === "Unidentified")
    return;
  if (evt.key === "Dead")
    return;
  for (const layout of gKeyboardLayouts) {
    if (layout.mapping[evt.code]?.[index] === evt.key) {
      layout.score += 1;
    } else if (layout.mapping[evt.code]?.[index]) {
      layout.score = 0;
    }
  }
  gKeyboardLayouts.sort((a3, b3) => b3.score - a3.score);
}
function setKeyboardLayoutLocale(locale) {
  gKeyboardLayout = gKeyboardLayouts.find((x3) => locale.startsWith(x3.locale));
}
function getActiveKeyboardLayout() {
  return gKeyboardLayout ?? gKeyboardLayouts[0];
}
register(DEFAULT_KEYBOARD_LAYOUT);
register({
  id: "apple.french",
  locale: "fr",
  displayName: "French",
  platform: "apple",
  virtualLayout: "azerty",
  score: 0,
  mapping: {
    KeyA: ["q", "Q", "\u2021", "\u03A9"],
    KeyB: ["b", "B", "\xDF", "\u222B"],
    KeyC: ["c", "C", "\xA9", "\xA2"],
    KeyD: ["d", "D", "\u2202", "\u2206"],
    KeyE: ["e", "E", "\xEA", "\xCA"],
    KeyF: ["f", "F", "\u0192", "\xB7"],
    KeyG: ["g", "G", "\uFB01", "\uFB02"],
    KeyH: ["h", "H", "\xCC", "\xCE"],
    KeyI: ["i", "I", "\xEE", "\xEF"],
    KeyJ: ["j", "J", "\xCF", "\xCD"],
    KeyK: ["k", "K", "\xC8", "\xCB"],
    KeyL: ["l", "L", "\xAC", "|"],
    KeyM: [",", "?", "\u221E", "\xBF"],
    KeyN: ["n", "N", "~", "\u0131"],
    KeyO: ["o", "O", "\u0153", "\u0152"],
    KeyP: ["p", "P", "\u03C0", "\u220F"],
    KeyQ: ["a", "A", "\xE6", "\xC6"],
    KeyR: ["r", "R", "\xAE", "\u201A"],
    KeyS: ["s", "S", "\xD2", "\u2211"],
    KeyT: ["t", "T", "\u2020", "\u2122"],
    KeyU: ["u", "U", "\xBA", "\xAA"],
    KeyV: ["v", "V", "\u25CA", "\u221A"],
    KeyW: ["z", "Z", "\xC2", "\xC5"],
    KeyX: ["x", "X", "\u2248", "\u2044"],
    KeyY: ["y", "Y", "\xDA", "\u0178"],
    KeyZ: ["w", "W", "\u2039", "\u203A"],
    Digit1: ["&", "1", "\uF8FF", "\xB4"],
    Digit2: ["\xE9", "2", "\xEB", "\u201E"],
    Digit3: ['"', "3", "\u201C", "\u201D"],
    Digit4: ["'", "4", "\u2018", "\u2019"],
    Digit5: ["(", "5", "{", "["],
    Digit6: ["\xA7", "6", "\xB6", "\xE5"],
    Digit7: ["\xE8", "7", "\xAB", "\xBB"],
    Digit8: ["!", "8", "\xA1", "\xDB"],
    Digit9: ["\xE7", "9", "\xC7", "\xC1"],
    Digit0: ["\xE0", "0", "\xF8", "\xD8"],
    Space: [" ", " ", " ", " "],
    Minus: [")", "\xB0", "}", "]"],
    Equal: ["-", "_", "\u2014", "\u2013"],
    BracketLeft: ["^", "\xA8", "\xF4", "\xD4"],
    BracketRight: ["$", "*", "\u20AC", "\xA5"],
    Backslash: ["`", "\xA3", "@", "#"],
    Semicolon: ["m", "M", "\xB5", "\xD3"],
    Quote: ["\xF9", "%", "\xD9", "\u2030"],
    Backquote: ["<", ">", "\u2264", "\u2265"],
    Comma: [";", ".", "\u2026", "\u2022"],
    Period: [":", "/", "\xF7", "\\"],
    Slash: ["=", "+", "\u2260", "\xB1"],
    NumpadDivide: ["/", "/", "/", "/"],
    NumpadMultiply: ["*", "*", "*", "*"],
    NumpadSubtract: ["-", "-", "-", "-"],
    NumpadAdd: ["+", "+", "+", "+"],
    NumpadDecimal: [",", ".", ",", "."],
    IntlBackslash: ["@", "#", "\u2022", "\u0178"],
    NumpadEqual: ["=", "=", "=", "="]
  }
});
register({
  id: "apple.spanish",
  locale: "es",
  displayName: "Spanish ISO",
  platform: "apple",
  virtualLayout: "qwerty",
  score: 0,
  mapping: {
    KeyA: ["a", "A", "\xE5", "\xC5"],
    KeyB: ["b", "B", "\xDF", ""],
    KeyC: ["c", "C", "\xA9", " "],
    KeyD: ["d", "D", "\u2202", "\u2206"],
    KeyE: ["e", "E", "\u20AC", "\u20AC"],
    KeyF: ["f", "F", "\u0192", "\uFB01"],
    KeyG: ["g", "G", "\uF8FF", "\uFB02"],
    KeyH: ["h", "H", "\u2122", " "],
    KeyI: ["i", "I", " ", " "],
    KeyJ: ["j", "J", "\xB6", "\xAF"],
    KeyK: ["k", "K", "\xA7", "\u02C7"],
    KeyL: ["l", "L", " ", "\u02D8"],
    KeyM: ["m", "M", "\xB5", "\u02DA"],
    KeyN: ["n", "N", " ", "\u02D9"],
    KeyO: ["o", "O", "\xF8", "\xD8"],
    KeyP: ["p", "P", "\u03C0", "\u220F"],
    KeyQ: ["q", "Q", "\u0153", "\u0152"],
    KeyR: ["r", "R", "\xAE", " "],
    KeyS: ["s", "S", "\u222B", " "],
    KeyT: ["t", "T", "\u2020", "\u2021"],
    KeyU: ["u", "U", " ", " "],
    KeyV: ["v", "V", "\u221A", "\u25CA"],
    KeyW: ["w", "W", "\xE6", "\xC6"],
    KeyX: ["x", "X", "\u2211", "\u203A"],
    KeyY: ["y", "Y", "\xA5", " "],
    KeyZ: ["z", "Z", "\u03A9", "\u2039"],
    Digit1: ["1", "!", "|", "\u0131"],
    Digit2: ["2", '"', "@", "\u02DD"],
    Digit3: ["3", "\xB7", "#", "\u2022"],
    Digit4: ["4", "$", "\xA2", "\xA3"],
    Digit5: ["5", "%", "\u221E", "\u2030"],
    Digit6: ["6", "&", "\xAC", " "],
    Digit7: ["7", "/", "\xF7", "\u2044"],
    Digit8: ["8", "(", "\u201C", "\u2018"],
    Digit9: ["9", ")", "\u201D", "\u2019"],
    Digit0: ["0", "=", "\u2260", "\u2248"],
    Space: [" ", " ", " ", " "],
    Minus: ["'", "?", "\xB4", "\xB8"],
    Equal: ["\xA1", "\xBF", "\u201A", "\u02DB"],
    BracketLeft: ["`", "^", "[", "\u02C6"],
    BracketRight: ["+", "*", "]", "\xB1"],
    Backslash: ["\xE7", "\xC7", "}", "\xBB"],
    Semicolon: ["\xF1", "\xD1", "~", "\u02DC"],
    Quote: ["\xB4", "\xA8", "{", "\xAB"],
    Backquote: ["<", ">", "\u2264", "\u2265"],
    Comma: [",", ";", "\u201E", ""],
    Period: [".", ":", "\u2026", "\u2026"],
    Slash: ["-", "_", "\u2013", "\u2014"],
    NumpadDivide: ["/", "/", "/", "/"],
    NumpadMultiply: ["*", "*", "*", "*"],
    NumpadSubtract: ["-", "-", "-", "-"],
    NumpadAdd: ["+", "+", "+", "+"],
    Numpad1: ["1", "1", "1", "1"],
    Numpad2: ["2", "2", "2", "2"],
    Numpad3: ["3", "3", "3", "3"],
    Numpad4: ["4", "4", "4", "4"],
    Numpad5: ["5", "5", "5", "5"],
    Numpad6: ["6", "6", "6", "6"],
    Numpad7: ["7", "7", "7", "7"],
    Numpad8: ["8", "8", "8", "8"],
    Numpad9: ["9", "9", "9", "9"],
    Numpad0: ["0", "0", "0", "0"],
    NumpadDecimal: [",", ",", ",", ","],
    IntlBackslash: ["\xBA", "\xAA", "\\", "\xB0"]
  }
});
register({
  id: "windows.spanish",
  locale: "es",
  displayName: "Spanish",
  platform: "windows",
  virtualLayout: "qwerty",
  score: 0,
  mapping: {
    KeyA: ["a", "A", "", ""],
    KeyB: ["b", "B", "", ""],
    KeyC: ["c", "C", "", ""],
    KeyD: ["d", "D", "", ""],
    KeyE: ["e", "E", "\u20AC", ""],
    KeyF: ["f", "F", "", ""],
    KeyG: ["g", "G", "", ""],
    KeyH: ["h", "H", "", ""],
    KeyI: ["i", "I", "", ""],
    KeyJ: ["j", "J", "", ""],
    KeyK: ["k", "K", "", ""],
    KeyL: ["l", "L", "", ""],
    KeyM: ["m", "M", "", ""],
    KeyN: ["n", "N", "", ""],
    KeyO: ["o", "O", "", ""],
    KeyP: ["p", "P", "", ""],
    KeyQ: ["q", "Q", "", ""],
    KeyR: ["r", "R", "", ""],
    KeyS: ["s", "S", "", ""],
    KeyT: ["t", "T", "", ""],
    KeyU: ["u", "U", "", ""],
    KeyV: ["v", "V", "", ""],
    KeyW: ["w", "W", "", ""],
    KeyX: ["x", "X", "", ""],
    KeyY: ["y", "Y", "", ""],
    KeyZ: ["z", "Z", "", ""],
    Digit1: ["1", "!", "|", ""],
    Digit2: ["2", '"', "@", ""],
    Digit3: ["3", "\xB7", "#", ""],
    Digit4: ["4", "$", "~", ""],
    Digit5: ["5", "%", "\u20AC", ""],
    Digit6: ["6", "&", "\xAC", ""],
    Digit7: ["7", "/", "", ""],
    Digit8: ["8", "(", "", ""],
    Digit9: ["9", ")", "", ""],
    Digit0: ["0", "=", "", ""],
    Space: [" ", " ", "", ""],
    Minus: ["'", "?", "", ""],
    Equal: ["\xA1", "\xBF", "", ""],
    BracketLeft: ["`", "^", "[", ""],
    BracketRight: ["+", "*", "]", ""],
    Backslash: ["\xE7", "\xC7", "}", ""],
    Semicolon: ["\xF1", "\xD1", "", ""],
    Quote: ["\xB4", "\xA8", "{", ""],
    Backquote: ["\xBA", "\xAA", "\\", ""],
    Comma: [",", ";", "", ""],
    Period: [".", ":", "", ""],
    Slash: ["-", "_", "", ""],
    NumpadDivide: ["/", "/", "", ""],
    NumpadMultiply: ["*", "*", "", ""],
    NumpadSubtract: ["-", "-", "", ""],
    NumpadAdd: ["+", "+", "", ""],
    IntlBackslash: ["<", ">", "", ""]
  }
});
register({
  id: "linux.spanish",
  locale: "es",
  displayName: "Spanish",
  platform: "linux",
  virtualLayout: "qwerty",
  score: 0,
  mapping: {
    KeyA: ["a", "A", "\xE6", "\xC6"],
    KeyB: ["b", "B", "\u201D", "\u2019"],
    KeyC: ["c", "C", "\xA2", "\xA9"],
    KeyD: ["d", "D", "\xF0", "\xD0"],
    KeyE: ["e", "E", "\u20AC", "\xA2"],
    KeyF: ["f", "F", "\u0111", "\xAA"],
    KeyG: ["g", "G", "\u014B", "\u014A"],
    KeyH: ["h", "H", "\u0127", "\u0126"],
    KeyI: ["i", "I", "\u2192", "\u0131"],
    KeyJ: ["j", "J", "\u0309", "\u031B"],
    KeyK: ["k", "K", "\u0138", "&"],
    KeyL: ["l", "L", "\u0142", "\u0141"],
    KeyM: ["m", "M", "\xB5", "\xBA"],
    KeyN: ["n", "N", "n", "N"],
    KeyO: ["o", "O", "\xF8", "\xD8"],
    KeyP: ["p", "P", "\xFE", "\xDE"],
    KeyQ: ["q", "Q", "@", "\u03A9"],
    KeyR: ["r", "R", "\xB6", "\xAE"],
    KeyS: ["s", "S", "\xDF", "\xA7"],
    KeyT: ["t", "T", "\u0167", "\u0166"],
    KeyU: ["u", "U", "\u2193", "\u2191"],
    KeyV: ["v", "V", "\u201C", "\u2018"],
    KeyW: ["w", "W", "\u0142", "\u0141"],
    KeyX: ["x", "X", "\xBB", ">"],
    KeyY: ["y", "Y", "\u2190", "\xA5"],
    KeyZ: ["z", "Z", "\xAB", "<"],
    Digit1: ["1", "!", "|", "\xA1"],
    Digit2: ["2", '"', "@", "\u215B"],
    Digit3: ["3", "\xB7", "#", "\xA3"],
    Digit4: ["4", "$", "~", "$"],
    Digit5: ["5", "%", "\xBD", "\u215C"],
    Digit6: ["6", "&", "\xAC", "\u215D"],
    Digit7: ["7", "/", "{", "\u215E"],
    Digit8: ["8", "(", "[", "\u2122"],
    Digit9: ["9", ")", "]", "\xB1"],
    Digit0: ["0", "=", "}", "\xB0"],
    Enter: ["\r", "\r", "\r", "\r"],
    Escape: ["", "", "", ""],
    Backspace: ["\b", "\b", "\b", "\b"],
    Tab: ["	", "", "	", ""],
    Space: [" ", " ", " ", " "],
    Minus: ["'", "?", "\\", "\xBF"],
    Equal: ["\xA1", "\xBF", "\u0303", "~"],
    BracketLeft: ["\u0300", "\u0302", "[", "\u030A"],
    BracketRight: ["+", "*", "]", "\u0304"],
    Backslash: ["\xE7", "\xC7", "}", "\u0306"],
    Semicolon: ["\xF1", "\xD1", "~", "\u030B"],
    Quote: ["\u0301", "\u0308", "{", "{"],
    Backquote: ["\xBA", "\xAA", "\\", "\\"],
    Comma: [",", ";", "\u2500", "\xD7"],
    Period: [".", ":", "\xB7", "\xF7"],
    Slash: ["-", "_", "\u0323", "\u0307"],
    NumpadDivide: ["/", "/", "/", "/"],
    NumpadMultiply: ["*", "*", "*", "*"],
    NumpadSubtract: ["-", "-", "-", "-"],
    NumpadAdd: ["+", "+", "+", "+"],
    NumpadEnter: ["\r", "\r", "\r", "\r"],
    Numpad1: ["", "1", "", "1"],
    Numpad2: ["", "2", "", "2"],
    Numpad3: ["", "3", "", "3"],
    Numpad4: ["", "4", "", "4"],
    Numpad5: ["", "5", "", "5"],
    Numpad6: ["", "6", "", "6"],
    Numpad7: ["", "7", "", "7"],
    Numpad8: ["", "8", "", "8"],
    Numpad9: ["", "9", "", "9"],
    Numpad0: ["", "0", "", "0"],
    NumpadDecimal: ["", ".", "", "."],
    IntlBackslash: ["<", ">", "|", "\xA6"],
    NumpadEqual: ["=", "=", "=", "="],
    NumpadComma: [".", ".", ".", "."],
    NumpadParenLeft: ["(", "(", "(", "("],
    NumpadParenRight: [")", ")", ")", ")"]
  }
});
register({
  id: "linux.french",
  locale: "fr",
  displayName: "French",
  virtualLayout: "azerty",
  platform: "linux",
  score: 0,
  mapping: {
    KeyA: ["q", "Q", "@", "\u03A9"],
    KeyB: ["b", "B", "\u201D", "\u2019"],
    KeyC: ["c", "C", "\xA2", "\xA9"],
    KeyD: ["d", "D", "\xF0", "\xD0"],
    KeyE: ["e", "E", "\u20AC", "\xA2"],
    KeyF: ["f", "F", "\u0111", "\xAA"],
    KeyG: ["g", "G", "\u014B", "\u014A"],
    KeyH: ["h", "H", "\u0127", "\u0126"],
    KeyI: ["i", "I", "\u2192", "\u0131"],
    KeyJ: ["j", "J", "\u0309", "\u031B"],
    KeyK: ["k", "K", "\u0138", "&"],
    KeyL: ["l", "L", "\u0142", "\u0141"],
    KeyM: [",", "?", "\u0301", "\u030B"],
    KeyN: ["n", "N", "n", "N"],
    KeyO: ["o", "O", "\xF8", "\xD8"],
    KeyP: ["p", "P", "\xFE", "\xDE"],
    KeyQ: ["a", "A", "\xE6", "\xC6"],
    KeyR: ["r", "R", "\xB6", "\xAE"],
    KeyS: ["s", "S", "\xDF", "\xA7"],
    KeyT: ["t", "T", "\u0167", "\u0166"],
    KeyU: ["u", "U", "\u2193", "\u2191"],
    KeyV: ["v", "V", "\u201C", "\u2018"],
    KeyW: ["z", "Z", "\xAB", "<"],
    KeyX: ["x", "X", "\xBB", ">"],
    KeyY: ["y", "Y", "\u2190", "\xA5"],
    KeyZ: ["w", "W", "\u0142", "\u0141"],
    Digit1: ["&", "1", "\xB9", "\xA1"],
    Digit2: ["\xE9", "2", "~", "\u215B"],
    Digit3: ['"', "3", "#", "\xA3"],
    Digit4: ["'", "4", "{", "$"],
    Digit5: ["(", "5", "[", "\u215C"],
    Digit6: ["-", "6", "|", "\u215D"],
    Digit7: ["\xE8", "7", "`", "\u215E"],
    Digit8: ["_", "8", "\\", "\u2122"],
    Digit9: ["\xE7", "9", "^", "\xB1"],
    Digit0: ["\xE0", "0", "@", "\xB0"],
    Enter: ["\r", "\r", "\r", "\r"],
    Escape: ["", "", "", ""],
    Backspace: ["\b", "\b", "\b", "\b"],
    Tab: ["	", "", "	", ""],
    Space: [" ", " ", " ", " "],
    Minus: [")", "\xB0", "]", "\xBF"],
    Equal: ["=", "+", "}", "\u0328"],
    BracketLeft: ["\u0302", "\u0308", "\u0308", "\u030A"],
    BracketRight: ["$", "\xA3", "\xA4", "\u0304"],
    Backslash: ["*", "\xB5", "\u0300", "\u0306"],
    Semicolon: ["m", "M", "\xB5", "\xBA"],
    Quote: ["\xF9", "%", "\u0302", "\u030C"],
    Backquote: ["\xB2", "~", "\xAC", "\xAC"],
    Comma: [";", ".", "\u2500", "\xD7"],
    Period: [":", "/", "\xB7", "\xF7"],
    Slash: ["!", "\xA7", "\u0323", "\u0307"],
    NumpadMultiply: ["*", "*", "*", "*"],
    NumpadSubtract: ["-", "-", "-", "-"],
    NumpadAdd: ["+", "+", "+", "+"],
    NumpadDecimal: ["", ".", "", "."],
    IntlBackslash: ["<", ">", "|", "\xA6"]
  }
});
register({
  id: "windows.french",
  locale: "fr",
  displayName: "French",
  virtualLayout: "azerty",
  platform: "windows",
  score: 0,
  mapping: {
    KeyA: ["q", "Q", "", ""],
    KeyB: ["b", "B", "", ""],
    KeyC: ["c", "C", "", ""],
    KeyD: ["d", "D", "", ""],
    KeyE: ["e", "E", "\u20AC", ""],
    KeyF: ["f", "F", "", ""],
    KeyG: ["g", "G", "", ""],
    KeyH: ["h", "H", "", ""],
    KeyI: ["i", "I", "", ""],
    KeyJ: ["j", "J", "", ""],
    KeyK: ["k", "K", "", ""],
    KeyL: ["l", "L", "", ""],
    KeyM: [",", "?", "", ""],
    KeyN: ["n", "N", "", ""],
    KeyO: ["o", "O", "", ""],
    KeyP: ["p", "P", "", ""],
    KeyQ: ["a", "A", "", ""],
    KeyR: ["r", "R", "", ""],
    KeyS: ["s", "S", "", ""],
    KeyT: ["t", "T", "", ""],
    KeyU: ["u", "U", "", ""],
    KeyV: ["v", "V", "", ""],
    KeyW: ["z", "Z", "", ""],
    KeyX: ["x", "X", "", ""],
    KeyY: ["y", "Y", "", ""],
    KeyZ: ["w", "W", "", ""],
    Digit1: ["&", "1", "", ""],
    Digit2: ["\xE9", "2", "~", ""],
    Digit3: ['"', "3", "#", ""],
    Digit4: ["'", "4", "{", ""],
    Digit5: ["(", "5", "[", ""],
    Digit6: ["-", "6", "|", ""],
    Digit7: ["\xE8", "7", "`", ""],
    Digit8: ["_", "8", "\\", ""],
    Digit9: ["\xE7", "9", "^", ""],
    Digit0: ["\xE0", "0", "@", ""],
    Space: [" ", " ", "", ""],
    Minus: [")", "\xB0", "]", ""],
    Equal: ["=", "+", "}", ""],
    BracketLeft: ["^", "\xA8", "", ""],
    BracketRight: ["$", "\xA3", "\xA4", ""],
    Backslash: ["*", "\xB5", "", ""],
    Semicolon: ["m", "M", "", ""],
    Quote: ["\xF9", "%", "", ""],
    Backquote: ["\xB2", "", "", ""],
    Comma: [";", ".", "", ""],
    Period: [":", "/", "", ""],
    Slash: ["!", "\xA7", "", ""],
    NumpadDivide: ["/", "/", "", ""],
    NumpadMultiply: ["*", "*", "", ""],
    NumpadSubtract: ["-", "-", "", ""],
    NumpadAdd: ["+", "+", "", ""],
    IntlBackslash: ["<", ">", "", ""]
  }
});
register({
  id: "windows.german",
  locale: "de",
  displayName: "German",
  platform: "windows",
  virtualLayout: "qwertz",
  score: 0,
  mapping: {
    KeyA: ["a", "A", "", ""],
    KeyB: ["b", "B", "", ""],
    KeyC: ["c", "C", "", ""],
    KeyD: ["d", "D", "", ""],
    KeyE: ["e", "E", "\u20AC", ""],
    KeyF: ["f", "F", "", ""],
    KeyG: ["g", "G", "", ""],
    KeyH: ["h", "H", "", ""],
    KeyI: ["i", "I", "", ""],
    KeyJ: ["j", "J", "", ""],
    KeyK: ["k", "K", "", ""],
    KeyL: ["l", "L", "", ""],
    KeyM: ["m", "M", "\xB5", ""],
    KeyN: ["n", "N", "", ""],
    KeyO: ["o", "O", "", ""],
    KeyP: ["p", "P", "", ""],
    KeyQ: ["q", "Q", "@", ""],
    KeyR: ["r", "R", "", ""],
    KeyS: ["s", "S", "", ""],
    KeyT: ["t", "T", "", ""],
    KeyU: ["u", "U", "", ""],
    KeyV: ["v", "V", "", ""],
    KeyW: ["w", "W", "", ""],
    KeyX: ["x", "X", "", ""],
    KeyY: ["z", "Z", "", ""],
    KeyZ: ["y", "Y", "", ""],
    Digit1: ["1", "!", "", ""],
    Digit2: ["2", '"', "\xB2", ""],
    Digit3: ["3", "\xA7", "\xB3", ""],
    Digit4: ["4", "$", "", ""],
    Digit5: ["5", "%", "", ""],
    Digit6: ["6", "&", "", ""],
    Digit7: ["7", "/", "{", ""],
    Digit8: ["8", "(", "[", ""],
    Digit9: ["9", ")", "]", ""],
    Digit0: ["0", "=", "}", ""],
    Space: [" ", " ", "", ""],
    Minus: ["\xDF", "?", "\\", "\u1E9E"],
    Equal: ["\xB4", "`", "", ""],
    BracketLeft: ["\xFC", "\xDC", "", ""],
    BracketRight: ["+", "*", "~", ""],
    Backslash: ["#", "'", "", ""],
    Semicolon: ["\xF6", "\xD6", "", ""],
    Quote: ["\xE4", "\xC4", "", ""],
    Backquote: ["^", "\xB0", "", ""],
    Comma: [",", ";", "", ""],
    Period: [".", ":", "", ""],
    Slash: ["-", "_", "", ""],
    NumpadDivide: ["/", "/", "", ""],
    NumpadMultiply: ["*", "*", "", ""],
    NumpadSubtract: ["-", "-", "", ""],
    NumpadAdd: ["+", "+", "", ""],
    IntlBackslash: ["<", ">", "|", ""]
  }
});
register({
  id: "apple.german",
  locale: "de",
  displayName: "German",
  virtualLayout: "qwertz",
  platform: "apple",
  score: 0,
  mapping: {
    KeyA: ["a", "A", "\xE5", "\xC5"],
    KeyB: ["b", "B", "\u222B", "\u2039"],
    KeyC: ["c", "C", "\xE7", "\xC7"],
    KeyD: ["d", "D", "\u2202", "\u2122"],
    KeyE: ["e", "E", "\u20AC", "\u2030"],
    KeyF: ["f", "F", "\u0192", "\xCF"],
    KeyG: ["g", "G", "\xA9", "\xCC"],
    KeyH: ["h", "H", "\xAA", "\xD3"],
    KeyI: ["i", "I", "\u2044", "\xDB"],
    KeyJ: ["j", "J", "\xBA", "\u0131"],
    KeyK: ["k", "K", "\u2206", "\u02C6"],
    KeyL: ["l", "L", "@", "\uFB02"],
    KeyM: ["m", "M", "\xB5", "\u02D8"],
    KeyN: ["n", "N", "~", "\u203A"],
    KeyO: ["o", "O", "\xF8", "\xD8"],
    KeyP: ["p", "P", "\u03C0", "\u220F"],
    KeyQ: ["q", "Q", "\xAB", "\xBB"],
    KeyR: ["r", "R", "\xAE", "\xB8"],
    KeyS: ["s", "S", "\u201A", "\xCD"],
    KeyT: ["t", "T", "\u2020", "\u02DD"],
    KeyU: ["u", "U", "\xA8", "\xC1"],
    KeyV: ["v", "V", "\u221A", "\u25CA"],
    KeyW: ["w", "W", "\u2211", "\u201E"],
    KeyX: ["x", "X", "\u2248", "\xD9"],
    KeyY: ["z", "Z", "\u03A9", "\u02C7"],
    KeyZ: ["y", "Y", "\xA5", "\u2021"],
    Digit1: ["1", "!", "\xA1", "\xAC"],
    Digit2: ["2", '"', "\u201C", "\u201D"],
    Digit3: ["3", "\xA7", "\xB6", "#"],
    Digit4: ["4", "$", "\xA2", "\xA3"],
    Digit5: ["5", "%", "[", "\uFB01"],
    Digit6: ["6", "&", "]", "^"],
    Digit7: ["7", "/", "|", "\\"],
    Digit8: ["8", "(", "{", "\u02DC"],
    Digit9: ["9", ")", "}", "\xB7"],
    Digit0: ["0", "=", "\u2260", "\xAF"],
    Space: [" ", " ", " ", " "],
    Minus: ["\xDF", "?", "\xBF", "\u02D9"],
    Equal: ["\xB4", "`", "'", "\u02DA"],
    BracketLeft: ["\xFC", "\xDC", "\u2022", "\xB0"],
    BracketRight: ["+", "*", "\xB1", "\uF8FF"],
    Backslash: ["#", "'", "\u2018", "\u2019"],
    Semicolon: ["\xF6", "\xD6", "\u0153", "\u0152"],
    Quote: ["\xE4", "\xC4", "\xE6", "\xC6"],
    Backquote: ["<", ">", "\u2264", "\u2265"],
    Comma: [",", ";", "\u221E", "\u02DB"],
    Period: [".", ":", "\u2026", "\xF7"],
    Slash: ["-", "_", "\u2013", "\u2014"],
    NumpadDivide: ["/", "/", "/", "/"],
    NumpadMultiply: ["*", "*", "*", "*"],
    NumpadSubtract: ["-", "-", "-", "-"],
    NumpadAdd: ["+", "+", "+", "+"],
    NumpadDecimal: [",", ",", ".", "."],
    IntlBackslash: ["^", "\xB0", "\u201E", "\u201C"],
    NumpadEqual: ["=", "=", "=", "="]
  }
});
register({
  id: "dvorak",
  locale: "en",
  displayName: "Dvorak",
  virtualLayout: "dvorak",
  platform: "",
  score: 0,
  mapping: {
    KeyA: ["a", "A", "\xE5", "\xC5"],
    KeyB: ["x", "X", "\u2248", "\u02DB"],
    KeyC: ["j", "J", "\u2206", "\xD4"],
    KeyD: ["e", "E", "\xB4", "\xB4"],
    KeyE: [".", ">", "\u2265", "\u02D8"],
    KeyF: ["u", "U", "\xA8", "\xA8"],
    KeyG: ["i", "I", "\u02C6", "\u02C6"],
    KeyH: ["d", "D", "\u2202", "\xCE"],
    KeyI: ["c", "C", "\xE7", "\xC7"],
    KeyJ: ["h", "H", "\u02D9", "\xD3"],
    KeyK: ["t", "T", "\u2020", "\u02C7"],
    KeyL: ["n", "N", "\u02DC", "\u02DC"],
    KeyM: ["m", "M", "\xB5", "\xC2"],
    KeyN: ["b", "B", "\u222B", "\u0131"],
    KeyO: ["r", "R", "\xAE", "\u2030"],
    KeyP: ["l", "L", "\xAC", "\xD2"],
    KeyQ: ["'", '"', "\xE6", "\xC6"],
    KeyR: ["p", "P", "\u03C0", "\u220F"],
    KeyS: ["o", "O", "\xF8", "\xD8"],
    KeyT: ["y", "Y", "\xA5", "\xC1"],
    KeyU: ["g", "G", "\xA9", "\u02DD"],
    KeyV: ["k", "K", "\u02DA", "\uF8FF"],
    KeyW: [",", "<", "\u2264", "\xAF"],
    KeyX: ["q", "Q", "\u0153", "\u0152"],
    KeyY: ["f", "F", "\u0192", "\xCF"],
    KeyZ: [";", ":", "\u2026", "\xDA"],
    Digit1: ["1", "!", "\xA1", "\u2044"],
    Digit2: ["2", "@", "\u2122", "\u20AC"],
    Digit3: ["3", "#", "\xA3", "\u2039"],
    Digit4: ["4", "$", "\xA2", "\u203A"],
    Digit5: ["5", "%", "\u221E", "\uFB01"],
    Digit6: ["6", "^", "\xA7", "\uFB02"],
    Digit7: ["7", "&", "\xB6", "\u2021"],
    Digit8: ["8", "*", "\u2022", "\xB0"],
    Digit9: ["9", "(", "\xAA", "\xB7"],
    Digit0: ["0", ")", "\xBA", "\u201A"],
    Space: [" ", " ", " ", " "],
    Minus: ["[", "{", "\u201C", "\u201D"],
    Equal: ["]", "}", "\u2018", "\u2019"],
    BracketLeft: ["/", "?", "\xF7", "\xBF"],
    BracketRight: ["=", "+", "\u2260", "\xB1"],
    Backslash: ["\\", "|", "\xAB", "\xBB"],
    Semicolon: ["s", "S", "\xDF", "\xCD"],
    Quote: ["-", "_", "\u2013", "\u2014"],
    Backquote: ["`", "~", "`", "`"],
    Comma: ["w", "W", "\u2211", "\u201E"],
    Period: ["v", "V", "\u221A", "\u25CA"],
    Slash: ["z", "Z", "\u03A9", "\xB8"],
    NumpadDivide: ["/", "/", "/", "/"],
    NumpadMultiply: ["*", "*", "*", "*"],
    NumpadSubtract: ["-", "-", "-", "-"],
    NumpadAdd: ["+", "+", "+", "+"],
    Numpad1: ["1", "1", "1", "1"],
    Numpad2: ["2", "2", "2", "2"],
    Numpad3: ["3", "3", "3", "3"],
    Numpad4: ["4", "4", "4", "4"],
    Numpad5: ["5", "5", "5", "5"],
    Numpad6: ["6", "6", "6", "6"],
    Numpad7: ["7", "7", "7", "7"],
    Numpad8: ["8", "8", "8", "8"],
    Numpad9: ["9", "9", "9", "9"],
    Numpad0: ["0", "0", "0", "0"],
    NumpadDecimal: [".", ".", ".", "."],
    IntlBackslash: ["\xA7", "\xB1", "\xA7", "\xB1"],
    NumpadEqual: ["=", "=", "=", "="],
    AudioVolumeUp: ["", "=", "", "="]
  }
});

// src/editor/keybindings.ts
function matchPlatform(p3) {
  if (isBrowser() && navigator.platform && navigator.userAgent) {
    const plat = osPlatform();
    const isNeg = p3.startsWith("!");
    const isMatch = p3.endsWith(plat);
    if (isNeg && !isMatch)
      return true;
    if (!isNeg && isMatch)
      return true;
  }
  if (p3 === "!other")
    return false;
  return p3 === "other";
}
function getCommandForKeybinding(keybindings, mode, inKeystroke) {
  if (keybindings.length === 0)
    return "";
  const keystroke = keystrokeModifiersToString(keystrokeModifiersFromString(inKeystroke));
  for (let i3 = keybindings.length - 1; i3 >= 0; i3--) {
    if (keybindings[i3].key === keystroke) {
      if (!keybindings[i3].ifMode || keybindings[i3].ifMode === mode) {
        return keybindings[i3].command;
      }
    }
  }
  return "";
}
function commandToString(command) {
  let result = command;
  if (isArray(result)) {
    result = result.length > 0 ? result[0] + "(" + result.slice(1).join("") + ")" : "";
  }
  return result;
}
function getKeybindingsForCommand(keybindings, command) {
  let result = [];
  if (typeof command === "string") {
    const candidate = REVERSE_KEYBINDINGS[command];
    if (isArray(candidate)) {
      result = candidate.slice();
    } else if (candidate) {
      result.push(candidate);
    }
  }
  const normalizedCommand = commandToString(command);
  const regex = new RegExp("^" + normalizedCommand.replace("\\", "\\\\").replace("|", "\\|").replace("*", "\\*").replace("$", "\\$").replace("^", "\\^") + "([^*a-zA-Z]|$)");
  for (const keybinding of keybindings) {
    if (regex.test(commandToString(keybinding.command))) {
      result.push(keybinding.key);
    }
  }
  return result.map(getKeybindingMarkup);
}
function getKeybindingMarkup(keystroke) {
  const useSymbol = /macos|ios|/.test(osPlatform());
  const segments = keystroke.split("+");
  let result = "";
  for (const segment of segments) {
    if (!useSymbol && result) {
      result += '<span class="ML__shortcut-join">+</span>';
    }
    if (segment.startsWith("[Key")) {
      result += segment.slice(4, 5);
    } else if (segment.startsWith("Key")) {
      result += segment.slice(3, 4);
    } else if (segment.startsWith("[Digit")) {
      result += segment.slice(6, 7);
    } else if (segment.startsWith("Digit")) {
      result += segment.slice(5, 6);
    } else {
      result += {
        "cmd": "\u2318",
        "meta": useSymbol ? "\u2318" : "command",
        "shift": useSymbol ? "\u21E7" : "shift",
        "alt": useSymbol ? "\u2325" : "alt",
        "ctrl": useSymbol ? "\u2303" : "control",
        "\n": useSymbol ? "\u23CE" : "return",
        "[return]": useSymbol ? "\u23CE" : "return",
        "[enter]": useSymbol ? "\u2324" : "enter",
        "[tab]": useSymbol ? "\u21E5" : "tab",
        "[escape]": "esc",
        "[backspace]": useSymbol ? "\u232B" : "backspace",
        "[delete]": useSymbol ? "\u2326" : "del",
        "[pageup]": useSymbol ? "\u21DE" : "page up",
        "[pagedown]": useSymbol ? "\u21DF" : "page down",
        "[home]": useSymbol ? "\u2912" : "home",
        "[end]": useSymbol ? "\u2913" : "end",
        "[space]": "space",
        "[equal]": "=",
        "[minus]": "-",
        "[comma]": ",",
        "[slash]": "/",
        "[backslash]": "\\",
        "[bracketleft]": "[",
        "[bracketright]": "]",
        "semicolon": ";",
        "period": ".",
        "comma": ",",
        "minus": "-",
        "equal": "=",
        "quote": "'",
        "bracketLeft": "[",
        "bracketRight": "]",
        "backslash": "\\",
        "intlbackslash": "\\",
        "backquote": "`",
        "slash": "/",
        "numpadmultiply": "* &#128290;",
        "numpaddivide": "/ &#128290;",
        "numpadsubtract": "- &#128290;",
        "numpadadd": "+ &#128290;",
        "numpaddecimal": ". &#128290;",
        "numpadcomma": ", &#128290;",
        "help": "help",
        "left": "\u21E0",
        "up": "\u21E1",
        "right": "\u21E2",
        "down": "\u21E3",
        "[arrowleft]": "\u21E0",
        "[arrowup]": "\u21E1",
        "[arrowright]": "\u21E2",
        "[arrowdown]": "\u21E3",
        "[digit0]": "0",
        "[digit1]": "1",
        "[digit2]": "2",
        "[digit3]": "3",
        "[digit4]": "4",
        "[digit5]": "5",
        "[digit6]": "6",
        "[digit7]": "7",
        "[digit8]": "8",
        "[digit9]": "9"
      }[segment.toLowerCase()] ?? segment.toUpperCase();
    }
  }
  return result;
}
function normalizeKeybinding(keybinding, layout) {
  if (keybinding.ifPlatform && !/^!?(macos|windows|android|ios|chromeos|other)$/.test(keybinding.ifPlatform)) {
    throw new Error(`Unexpected platform "${keybinding.ifPlatform}" for keybinding ${keybinding.key}`);
  }
  if (keybinding.ifLayout !== void 0 && (layout.score === 0 || !keybinding.ifLayout.includes(layout.id))) {
    return void 0;
  }
  const modifiers = keystrokeModifiersFromString(keybinding.key);
  let platform2 = keybinding.ifPlatform;
  if (modifiers.cmd) {
    if (platform2 && platform2 !== "macos" && platform2 !== "ios") {
      throw new Error('Unexpected "cmd" modifier with platform "' + platform2 + '"\n"cmd" modifier can only be used with macOS or iOS platform.');
    }
    if (!platform2) {
      platform2 = osPlatform() === "ios" ? "ios" : "macos";
    }
    modifiers.win = false;
    modifiers.cmd = false;
    modifiers.meta = true;
  }
  if (modifiers.win) {
    if (platform2 && platform2 !== "windows") {
      throw new Error('Unexpected "win" modifier with platform "' + platform2 + '"\n"win" modifier can only be used with Windows platform.');
    }
    platform2 = "windows";
    modifiers.win = false;
    modifiers.cmd = false;
    modifiers.meta = true;
  }
  if (platform2 && !matchPlatform(platform2))
    return void 0;
  if (!/^\[(.*)]$/.test(modifiers.key)) {
    const code = getCodeForKey(modifiers.key, layout);
    if (!code) {
      throw new Error('Invalid keybinding key "' + keybinding.key + '"');
    }
    if (code.shift && modifiers.shift || code.alt && modifiers.alt) {
      throw new Error(`The keybinding ${keybinding.key} (${selectorToString(keybinding.command)}) is conflicting with the key combination ${keystrokeModifiersToString(code)} using the ${layout.displayName} keyboard layout`);
    }
    code.shift = code.shift || modifiers.shift;
    code.alt = code.alt || modifiers.alt;
    code.meta = modifiers.meta;
    code.ctrl = modifiers.ctrl;
    return {
      ...keybinding,
      ifPlatform: platform2,
      key: keystrokeModifiersToString(code)
    };
  }
  return {
    ...keybinding,
    ifPlatform: platform2,
    key: keystrokeModifiersToString(modifiers)
  };
}
function selectorToString(selector) {
  if (Array.isArray(selector)) {
    const sel = [...selector];
    return sel.shift() + "(" + sel.map((x3) => typeof x3 === "string" ? `"${x3}"` : x3.toString()).join(", ") + ")";
  }
  return selector;
}
function normalizeKeybindings(keybindings, layout, onError) {
  const result = [];
  const errors = [];
  for (const x3 of keybindings) {
    try {
      const keybinding = normalizeKeybinding(x3, layout);
      if (keybinding) {
        const matches = result.filter((x4) => x4.key === keybinding.key && x4.ifMode === keybinding.ifMode);
        if (matches.length > 0) {
          throw new Error(`Ambiguous key binding ${x3.key} (${selectorToString(x3.command)}) matches ${matches[0].key} (${selectorToString(matches[0].command)}) with the ${layout.displayName} keyboard layout`);
        }
        result.push(keybinding);
      }
    } catch (error) {
      if (error instanceof Error) {
        errors.push(error.message);
      }
    }
  }
  if (errors.length > 0)
    onError(errors);
  return result;
}

// src/editor/atom-to-ascii-math.ts
var SPECIAL_IDENTIFIERS = {
  "\u2212": "-",
  "-": "-",
  "\\alpha": "alpha",
  "\\beta": "beta",
  "\\gamma": "gamma",
  "\\delta": "delta",
  "\\epsilon": "epsilon",
  "\\varepsilon": "varepsilon",
  "\\zeta": "zeta",
  "\\eta": "eta",
  "\\theta": "theta",
  "\\vartheta": "vartheta",
  "\\iota": "iota",
  "\\kappa": "kappa",
  "\\lambda": "lambda",
  "\\mu": "mu",
  "\\nu": "nu",
  "\\xi": "xi",
  "\\pi": "pi",
  "\\rho": "rho",
  "\\sigma": "sigma",
  "\\tau": "tau",
  "\\upsilon": "upsilon",
  "\\phi": "phi",
  "\\varphi": "varphi",
  "\\chi": "chi",
  "\\psi": "psi",
  "\\omega": "omega",
  "\\Gamma": "Gamma",
  "\\Delta": "Delta",
  "\\Theta": "Theta",
  "\\Lambda": "Lambda",
  "\\Xi": "Xi",
  "\\Pi": "Pi",
  "\\Sigma": "Sigma",
  "\\Phi": "Phi",
  "\\Psi": "Psi",
  "\\Omega": "Omega",
  "\\exponentialE": "e",
  "\\imaginaryI": "i",
  "\\imaginaryJ": "j"
};
var SPECIAL_OPERATORS = {
  "\\pm": "+-",
  "\\times": "xx",
  "\\colon": ":",
  "\\vert": "|",
  "\\Vert": "||",
  "\\mid": "|",
  "\\lbrace": "{",
  "\\rbrace": "}",
  "\\lparen": "(",
  "\\rparen": ")",
  "\\langle": "(:",
  "\\rangle": ":)"
};
function atomToAsciiMath(atom) {
  if (!atom)
    return "";
  if (isArray(atom)) {
    let result2 = "";
    if (atom.length === 0)
      return "";
    if (atom[0].type === "first")
      atom = atom.slice(1);
    if (atom.length === 0)
      return "";
    if (atom[0].mode === "text") {
      let i3 = 0;
      result2 = '"';
      while (atom[i3]?.mode === "text") {
        result2 += atom[i3].body ? atomToAsciiMath(atom[i3].body) : atom[i3].value;
        i3++;
      }
      result2 += '"' + atomToAsciiMath(atom.slice(i3));
    } else if (atom[0].mode === "math") {
      let i3 = 0;
      while (atom[i3] && atom[i3].mode === "math") {
        result2 += atomToAsciiMath(atom[i3]);
        i3++;
      }
      result2 += atomToAsciiMath(atom.slice(i3));
    } else {
      console.warn("toASCIIMath: Unexpected mode");
    }
    return result2.trim();
  }
  if (atom.mode === "text") {
    return '"' + atom.value + '"';
  }
  let result = "";
  const {command} = atom;
  let m3;
  switch (atom.type) {
    case "first":
      return "";
    case "group":
    case "root":
      result = atomToAsciiMath(atom.body);
      break;
    case "genfrac":
      {
        const genfracAtom = atom;
        if (genfracAtom.leftDelim || genfracAtom.rightDelim) {
          result += genfracAtom.leftDelim === "." || !genfracAtom.leftDelim ? "{:" : genfracAtom.leftDelim;
        }
        if (genfracAtom.hasBarLine) {
          result += "(";
          result += atomToAsciiMath(genfracAtom.above);
          result += ")/(";
          result += atomToAsciiMath(genfracAtom.below);
          result += ")";
        } else {
          result += "(" + atomToAsciiMath(genfracAtom.above) + "),";
          result += "(" + atomToAsciiMath(genfracAtom.below) + ")";
        }
        if (genfracAtom.leftDelim || genfracAtom.rightDelim) {
          result += genfracAtom.rightDelim === "." || !genfracAtom.rightDelim ? "{:" : genfracAtom.rightDelim;
        }
      }
      break;
    case "surd":
      result += !atom.hasEmptyBranch("above") ? "root(" + atomToAsciiMath(atom.above) + ")(" + atomToAsciiMath(atom.body) + ")" : "sqrt(" + atomToAsciiMath(atom.body) + ")";
      break;
    case "leftright":
      {
        const leftrightAtom = atom;
        result += leftrightAtom.leftDelim === "." || !leftrightAtom.leftDelim ? "{:" : leftrightAtom.leftDelim;
        result += atomToAsciiMath(leftrightAtom.body);
        result += leftrightAtom.rightDelim === "." || !leftrightAtom.rightDelim ? ":}" : leftrightAtom.rightDelim;
      }
      break;
    case "sizeddelim":
    case "delim":
      break;
    case "overlap":
      break;
    case "overunder":
      break;
    case "mord":
      result = SPECIAL_IDENTIFIERS[command] ?? command ?? (typeof atom.value === "string" ? atom.value : "");
      if (result.startsWith("\\"))
        result += " ";
      m3 = command ? command.match(/{?\\char"([\dabcdefABCDEF]*)}?/) : null;
      if (m3) {
        result = String.fromCodePoint(Number.parseInt("0x" + m3[1]));
      } else if (result.length > 0 && result.startsWith("\\")) {
        result = typeof atom.value === "string" ? atom.value.charAt(0) : atom.command;
      }
      break;
    case "mbin":
    case "mrel":
    case "minner":
      result = SPECIAL_IDENTIFIERS[command] ?? SPECIAL_OPERATORS[command] ?? atom.value;
      break;
    case "mopen":
    case "mclose":
      result += atom.value;
      break;
    case "mpunct":
      result = SPECIAL_OPERATORS[command] ?? command;
      break;
    case "mop":
      if (atom.value !== "\u200B") {
        result = "";
        result += command === "\\operatorname" ? atomToAsciiMath(atom.body) : atom.value ?? command;
        result += " ";
      }
      break;
    case "array":
      const array = atom.array;
      const environment = atom.environmentName;
      const rowDelim = {
        "bmatrix": ["[", "]"],
        "bmatrix*": ["[", "]"]
      }[environment] ?? ["(", ")"];
      const rows = [];
      for (const row of array) {
        const cells = [];
        for (const cell of row) {
          cells.push(rowDelim[0] + atomToAsciiMath(cell) + rowDelim[1]);
        }
        rows.push(cells.join(","));
      }
      const delim = {
        "bmatrix": ["[", "]"],
        "bmatrix*": ["[", "]"],
        "cases": ["{", ":}"]
      }[environment] ?? ["(", ")"];
      result = delim[0] + rows.join(",") + delim[1];
      break;
    case "box":
      break;
    case "spacing":
      break;
    case "enclose":
      result = "(" + atomToAsciiMath(atom.body) + ")";
      break;
    case "space":
      result = " ";
      break;
    case "msubsup":
      result = "";
      break;
    case "macro":
      result = SPECIAL_IDENTIFIERS[command] ?? SPECIAL_OPERATORS[command] ?? atomToAsciiMath(atom.body);
      break;
  }
  if (!atom.hasEmptyBranch("subscript")) {
    result += "_";
    const arg = atomToAsciiMath(atom.subscript);
    result += arg.length > 1 ? "(" + arg + ")" : arg;
  }
  if (!atom.hasEmptyBranch("superscript")) {
    result += "^";
    const arg = atomToAsciiMath(atom.superscript);
    result += arg.length > 1 ? "(" + arg + ")" : arg;
  }
  return result;
}

// src/addons/debug.ts
function latexToAsciiMath(latex, mode = "math") {
  const root = new Atom("root", {mode: "math"});
  root.body = parseLatex(latex, {parseMode: mode});
  return atomToAsciiMath(root);
}
function asciiMathToLatex(ascii) {
  return parseMathString(ascii, {format: "ascii-math"})[1];
}
var MathliveDebug = {
  latexToAsciiMath,
  asciiMathToLatex,
  FUNCTIONS: LEGACY_COMMANDS,
  MATH_SYMBOLS,
  TEXT_SYMBOLS,
  ENVIRONMENTS,
  DEFAULT_KEYBINDINGS,
  getKeybindingMarkup
};
var debug_default = MathliveDebug;

// src/addons/math-ml.ts
var SPECIAL_OPERATORS2 = {
  "\\pm": "&#177;",
  "\\times": "&#215;",
  "\\colon": ":",
  "\\vert": "|",
  "\\Vert": "\u2225",
  "\\mid": "\u2223",
  "\\lbrace": "{",
  "\\rbrace": "}",
  "\\lparen": "(",
  "\\rparen": ")",
  "\\langle": "\u27E8",
  "\\rangle": "\u27E9",
  "\\lfloor": "\u230A",
  "\\rfloor": "\u230B",
  "\\lceil": "\u2308",
  "\\rceil": "\u2309",
  "\\vec": "&#x20d7;",
  "\\acute": "&#x00b4;",
  "\\grave": "&#x0060;",
  "\\dot": "&#x02d9;",
  "\\ddot": "&#x00a8;",
  "\\tilde": "&#x007e;",
  "\\bar": "&#x00af;",
  "\\breve": "&#x02d8;",
  "\\check": "&#x02c7;",
  "\\hat": "&#x005e;"
};
var APPLY_FUNCTION = "&#x2061;";
var INVISIBLE_TIMES = "&#8290;";
function xmlEscape(string) {
  return string.replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function makeID(id, options) {
  if (!id || !options.generateID)
    return "";
  return ' extid="' + id + '"';
}
function scanIdentifier(stream, final, options) {
  let result = false;
  final = final || stream.atoms.length;
  let mathML = "";
  let body = "";
  const atom = stream.atoms[stream.index];
  if (stream.index < final && atom.type === "mord" && !"0123456789,.".includes(atom.value)) {
    body = atomToMathML(atom, options);
    stream.index += 1;
  }
  if (body.length > 0) {
    result = true;
    mathML = body;
    if ((stream.lastType === "mi" || stream.lastType === "mn" || stream.lastType === "mtext" || stream.lastType === "fence") && !/^<mo>(.*)<\/mo>$/.test(mathML)) {
      mathML = `<mo>${INVISIBLE_TIMES}</mo>${mathML}`;
    }
    if (body.endsWith(">f</mi>") || body.endsWith(">g</mi>")) {
      mathML += `<mo>${APPLY_FUNCTION}</mo>`;
      stream.lastType = "applyfunction";
    } else {
      stream.lastType = /^<mo>(.*)<\/mo>$/.test(mathML) ? "mo" : "mi";
    }
    if (!parseSubsup(body, stream, options)) {
      stream.mathML += mathML;
    }
  }
  return result;
}
function isSuperscriptAtom(stream) {
  return stream.index < stream.atoms.length && stream.atoms[stream.index].superscript && stream.atoms[stream.index].type === "msubsup";
}
function isSubscriptAtom(stream) {
  return stream.index < stream.atoms.length && stream.atoms[stream.index].subscript && stream.atoms[stream.index].type === "msubsup";
}
function indexOfSuperscriptInNumber(stream) {
  let result = -1;
  let i3 = stream.index;
  let done = false;
  let found = false;
  while (i3 < stream.atoms.length && !done && !found) {
    done = stream.atoms[i3].type !== "mord" || !"0123456789,.".includes(stream.atoms[i3].body);
    found = !done && stream.atoms[i3].superscript;
    i3++;
  }
  if (found) {
    result = i3 - 1;
  }
  return result;
}
function parseSubsup(base, stream, options) {
  let result = false;
  let mathML = "";
  let atom = stream.atoms[stream.index - 1];
  if (!atom)
    return false;
  if (!atom.superscript && !atom.subscript) {
    if (isSuperscriptAtom(stream) || isSubscriptAtom(stream)) {
      atom = stream.atoms[stream.index];
      stream.index += 1;
    }
  }
  if (!atom)
    return false;
  const superscript = toMathML(atom.superscript, 0, 0, options).mathML;
  const subscript = toMathML(atom.subscript, 0, 0, options).mathML;
  if (superscript && subscript) {
    mathML = `<msubsup>${base}${subscript}${superscript}</msubsup>`;
  } else if (superscript) {
    mathML = `<msup>${base}${superscript}</msup>`;
  } else if (subscript) {
    mathML = `<msub>${base}${subscript}</msub>`;
  }
  if (mathML.length > 0) {
    result = true;
    stream.mathML += mathML;
    stream.lastType = "";
  }
  return result;
}
function scanText2(stream, final, options) {
  let result = false;
  final = final || stream.atoms.length;
  const initial = stream.index;
  let mathML = "";
  while (stream.index < final && stream.atoms[stream.index].mode === "text") {
    mathML += stream.atoms[stream.index].value ? stream.atoms[stream.index].value : " ";
    stream.index += 1;
  }
  if (mathML.length > 0) {
    result = true;
    mathML = "<mtext" + makeID(stream.atoms[initial].id, options) + ">" + mathML + "</mtext>";
    stream.mathML += mathML;
    stream.lastType = "mtext";
  }
  return result;
}
function scanNumber(stream, final, options) {
  let result = false;
  final = final || stream.atoms.length;
  const initial = stream.index;
  let mathML = "";
  let superscript = indexOfSuperscriptInNumber(stream);
  if (superscript >= 0 && superscript < final) {
    final = superscript;
  }
  while (stream.index < final && stream.atoms[stream.index].type === "mord" && "0123456789,.".includes(stream.atoms[stream.index].value)) {
    mathML += stream.atoms[stream.index].value;
    stream.index += 1;
  }
  if (mathML.length > 0) {
    result = true;
    mathML = "<mn" + makeID(stream.atoms[initial].id, options) + ">" + mathML + "</mn>";
    if (superscript < 0 && isSuperscriptAtom(stream)) {
      superscript = stream.index;
      stream.index += 1;
    }
    if (!parseSubsup(mathML, stream, options)) {
      stream.mathML += mathML;
      stream.lastType = "mn";
    }
  }
  return result;
}
function scanFence(stream, final, options) {
  let result = false;
  final = final || stream.atoms.length;
  let mathML = "";
  let lastType = "";
  if (stream.index < final && stream.atoms[stream.index].type === "mopen") {
    let found = false;
    let depth = 0;
    const openIndex = stream.index;
    let closeIndex = -1;
    let index = openIndex + 1;
    while (index < final && !found) {
      if (stream.atoms[index].type === "mopen") {
        depth += 1;
      } else if (stream.atoms[index].type === "mclose") {
        depth -= 1;
      }
      if (depth === -1) {
        found = true;
        closeIndex = index;
      }
      index += 1;
    }
    if (found) {
      mathML = "<mrow>";
      mathML += toMo(stream.atoms[openIndex], options);
      mathML += toMathML(stream.atoms, openIndex + 1, closeIndex, options).mathML;
      mathML += toMo(stream.atoms[closeIndex], options);
      mathML += "</mrow>";
      if (stream.lastType === "mi" || stream.lastType === "mn" || stream.lastType === "mfrac" || stream.lastType === "fence") {
        mathML = `<mo>${INVISIBLE_TIMES}</mo>${mathML}`;
      }
      stream.index = closeIndex + 1;
      if (parseSubsup(mathML, stream, options)) {
        result = true;
        stream.lastType = "";
        mathML = "";
      }
      lastType = "fence";
    }
  }
  if (mathML.length > 0) {
    result = true;
    stream.mathML += mathML;
    stream.lastType = lastType;
  }
  return result;
}
function scanOperator(stream, final, options) {
  let result = false;
  final = final || stream.atoms.length;
  let mathML = "";
  let lastType = "";
  const atom = stream.atoms[stream.index];
  if (stream.index < final && (atom.type === "mbin" || atom.type === "mrel")) {
    mathML += atomToMathML(stream.atoms[stream.index], options);
    stream.index += 1;
    lastType = "mo";
  } else if (stream.index < final && atom.type === "mop") {
    if (atom.subsupPlacement === "over-under" && (atom.superscript || atom.subscript)) {
      const op = toMo(atom, options);
      if (atom.superscript && atom.subscript) {
        mathML += "<munderover>" + op;
        mathML += toMathML(atom.subscript, 0, 0, options).mathML;
        mathML += toMathML(atom.superscript, 0, 0, options).mathML;
        mathML += "</munderover>";
      } else if (atom.superscript) {
        mathML += "<mover>" + op;
        mathML += toMathML(atom.superscript, 0, 0, options).mathML;
        mathML += "</mover>";
      } else {
        mathML += "<munder>" + op;
        mathML += toMathML(atom.subscript, 0, 0, options).mathML;
        mathML += "</munder>";
      }
      lastType = "mo";
    } else {
      const atom2 = stream.atoms[stream.index];
      const isUnit = atom2.symbol === "\\operatorname";
      const op = isUnit ? '<mi class="MathML-Unit"' + makeID(atom2.id, options) + ">" + toString2(atom2.value) + "</mi>" : toMo(atom2, options);
      mathML += op;
      stream.index += 1;
      if (parseSubsup(mathML, stream, options)) {
        result = true;
        stream.lastType = "";
        mathML = "";
      }
      stream.index -= 1;
      if (!isUnit && !/^<mo>(.*)<\/mo>$/.test(op)) {
        mathML += `<mo>${APPLY_FUNCTION}</mo>`;
        lastType = "applyfunction";
      } else {
        lastType = isUnit ? "mi" : "mo";
      }
    }
    if ((stream.lastType === "mi" || stream.lastType === "mn") && !/^<mo>(.*)<\/mo>$/.test(mathML)) {
      mathML = `<mo>${INVISIBLE_TIMES}</mo>${mathML}`;
    }
    stream.index += 1;
  }
  if (!parseSubsup(mathML, stream, options)) {
    if (mathML.length > 0) {
      result = true;
      stream.mathML += mathML;
      stream.lastType = lastType;
    }
  }
  return result;
}
function toMathML(input, initial, final, options) {
  const result = {
    atoms: input,
    index: initial ?? 0,
    mathML: "",
    lastType: ""
  };
  if (typeof input === "number" || typeof input === "boolean") {
    result.mathML = input.toString();
  } else if (typeof input === "string") {
    result.mathML = input;
  } else if (input instanceof Atom) {
    result.mathML = atomToMathML(input, options);
  } else if (Array.isArray(input)) {
    let count = 0;
    final = final ? final : input ? input.length : 0;
    while (result.index < final) {
      if (scanText2(result, final, options) || scanNumber(result, final, options) || scanIdentifier(result, final, options) || scanOperator(result, final, options) || scanFence(result, final, options)) {
        count += 1;
      } else if (result.index < final) {
        let mathML = atomToMathML(result.atoms[result.index], options);
        if (result.lastType === "mn" && mathML.length > 0 && result.atoms[result.index].type === "genfrac") {
          mathML = "<mo>&#x2064;</mo>" + mathML;
        }
        if (result.atoms[result.index].type === "genfrac") {
          result.lastType = "mfrac";
        } else {
          result.lastType = "";
        }
        if (mathML.length > 0) {
          result.mathML += mathML;
          count += 1;
        }
        result.index += 1;
      }
    }
    if (count > 1) {
      result.mathML = "<mrow>" + result.mathML + "</mrow>";
    }
  }
  return result;
}
function toMo(atom, options) {
  let result = "";
  const body = toString2(atom.value);
  if (body) {
    result = "<mo" + makeID(atom.id, options) + ">" + body + "</mo>";
  }
  return result;
}
function toString2(atoms) {
  if (!atoms)
    return "";
  if (typeof atoms === "string")
    return xmlEscape(atoms);
  if (!Array.isArray(atoms) && typeof atoms.body === "string") {
    return xmlEscape(atoms.body);
  }
  let result = "";
  for (const atom of atoms) {
    if (typeof atom.value === "string") {
      result += atom.value;
    }
  }
  return xmlEscape(result);
}
function atomToMathML(atom, options) {
  const SVG_CODE_POINTS = {
    widehat: "^",
    widecheck: "\u02C7",
    widetilde: "~",
    utilde: "~",
    overleftarrow: "\u2190",
    underleftarrow: "\u2190",
    xleftarrow: "\u2190",
    overrightarrow: "\u2192",
    underrightarrow: "\u2192",
    xrightarrow: "\u2192",
    underbrace: "\u23DF",
    overbrace: "\u23DE",
    overgroup: "\u23E0",
    undergroup: "\u23E1",
    overleftrightarrow: "\u2194",
    underleftrightarrow: "\u2194",
    xleftrightarrow: "\u2194",
    Overrightarrow: "\u21D2",
    xRightarrow: "\u21D2",
    overleftharpoon: "\u21BC",
    xleftharpoonup: "\u21BC",
    overrightharpoon: "\u21C0",
    xrightharpoonup: "\u21C0",
    xLeftarrow: "\u21D0",
    xLeftrightarrow: "\u21D4",
    xhookleftarrow: "\u21A9",
    xhookrightarrow: "\u21AA",
    xmapsto: "\u21A6",
    xrightharpoondown: "\u21C1",
    xleftharpoondown: "\u21BD",
    xrightleftharpoons: "\u21CC",
    xleftrightharpoons: "\u21CB",
    xtwoheadleftarrow: "\u219E",
    xtwoheadrightarrow: "\u21A0",
    xlongequal: "=",
    xtofrom: "\u21C4",
    xrightleftarrows: "\u21C4",
    xrightequilibrium: "\u21CC",
    xleftequilibrium: "\u21CB"
  };
  const SPECIAL_IDENTIFIERS2 = {
    "\\exponentialE": "&#x02147;",
    "\\imaginaryI": "&#x2148;",
    "\\differentialD": "&#x2146;",
    "\\capitalDifferentialD": "&#x2145;",
    "\\alpha": "&#x03b1;",
    "\\pi": "&#x03c0;",
    "\\infty": "&#x221e;",
    "\\forall": "&#x2200;",
    "\\nexists": "&#x2204;",
    "\\exists": "&#x2203;",
    "\\hbar": "\u210F",
    "\\cdotp": "\u22C5",
    "\\ldots": "\u2026",
    "\\cdots": "\u22EF",
    "\\ddots": "\u22F1",
    "\\vdots": "\u22EE",
    "\\ldotp": "."
  };
  const MATH_VARIANTS = {
    cal: "script",
    frak: "fraktur",
    bb: "double-struck",
    scr: "script",
    cmtt: "monospace",
    cmss: "sans-serif"
  };
  const SPACING = {
    "\\!": -3 / 18,
    "\\ ": 6 / 18,
    "\\,": 3 / 18,
    "\\:": 4 / 18,
    "\\;": 5 / 18,
    "\\enspace": 0.5,
    "\\quad": 1,
    "\\qquad": 2,
    "\\enskip": 0.5
  };
  let result = "";
  let sep = "";
  let col;
  let row;
  let i3;
  let underscript;
  let overscript;
  let body;
  let variant = MATH_VARIANTS[atom.fontFamily || atom.font] || "";
  if (variant) {
    variant = ' mathvariant="' + variant + '"';
  }
  const {command} = atom;
  if (atom.mode === "text") {
    result = "<mi" + makeID(atom.id, options) + ">" + atom.value + "</mi>";
  } else {
    switch (atom.type) {
      case "first":
        break;
      case "group":
      case "root":
        result = toMathML(atom.body, 0, 0, options).mathML;
        break;
      case "array":
        if (atom.leftDelim && atom.leftDelim !== "." || atom.rightDelim && atom.rightDelim !== ".") {
          result += "<mrow>";
          if (atom.leftDelim && atom.leftDelim !== ".") {
            result += "<mo>" + (SPECIAL_OPERATORS2[atom.leftDelim] || atom.leftDelim) + "</mo>";
          }
        }
        result += "<mtable";
        if (atom.colFormat) {
          result += ' columnalign="';
          for (i3 = 0; i3 < atom.colFormat.length; i3++) {
            if (atom.colFormat[i3].align) {
              result += {l: "left", c: "center", r: "right"}[atom.colFormat[i3].align] + " ";
            }
          }
          result += '"';
        }
        result += ">";
        for (row = 0; row < atom.array.length; row++) {
          result += "<mtr>";
          for (col = 0; col < atom.array[row].length; col++) {
            result += "<mtd>" + toMathML(atom.array[row][col], 0, 0, options).mathML + "</mtd>";
          }
          result += "</mtr>";
        }
        result += "</mtable>";
        if (atom.leftDelim && atom.leftDelim !== "." || atom.rightDelim && atom.rightDelim !== ".") {
          if (atom.rightDelim && atom.rightDelim !== ".") {
            result += "<mo>" + (SPECIAL_OPERATORS2[atom.leftDelim] || atom.rightDelim) + "</mo>";
          }
          result += "</mrow>";
        }
        break;
      case "genfrac":
        if (atom.leftDelim || atom.rightDelim) {
          result += "<mrow>";
        }
        if (atom.leftDelim && atom.leftDelim !== ".") {
          result += "<mo" + makeID(atom.id, options) + ">" + (SPECIAL_OPERATORS2[atom.leftDelim] || atom.leftDelim) + "</mo>";
        }
        if (atom.hasBarLine) {
          result += "<mfrac>";
          result += toMathML(atom.above, 0, 0, options).mathML || "<mi>&nbsp;</mi>";
          result += toMathML(atom.below, 0, 0, options).mathML || "<mi>&nbsp;</mi>";
          result += "</mfrac>";
        } else {
          result += "<mtable" + makeID(atom.id, options) + ">";
          result += "<mtr>" + toMathML(atom.above, 0, 0, options).mathML + "</mtr>";
          result += "<mtr>" + toMathML(atom.below, 0, 0, options).mathML + "</mtr>";
          result += "</mtable>";
        }
        if (atom.rightDelim && atom.rightDelim !== ".") {
          result += "<mo" + makeID(atom.id, options) + ">" + (SPECIAL_OPERATORS2[atom.rightDelim] || atom.rightDelim) + "</mo>";
        }
        if (atom.leftDelim || atom.rightDelim) {
          result += "</mrow>";
        }
        break;
      case "surd":
        if (!atom.hasEmptyBranch("above")) {
          result += "<mroot" + makeID(atom.id, options) + ">";
          result += toMathML(atom.body, 0, 0, options).mathML;
          result += toMathML(atom.above, 0, 0, options).mathML;
          result += "</mroot>";
        } else {
          result += "<msqrt" + makeID(atom.id, options) + ">";
          result += toMathML(atom.body, 0, 0, options).mathML;
          result += "</msqrt>";
        }
        break;
      case "leftright":
        result = "<mrow>";
        if (atom.leftDelim && atom.leftDelim !== ".") {
          result += "<mo" + makeID(atom.id, options) + ">" + (SPECIAL_OPERATORS2[atom.leftDelim] ?? atom.leftDelim) + "</mo>";
        }
        if (atom.body) {
          result += toMathML(atom.body, 0, 0, options).mathML;
        }
        if (atom.rightDelim && atom.rightDelim !== ".") {
          result += "<mo" + makeID(atom.id, options) + ">" + (SPECIAL_OPERATORS2[atom.rightDelim] ?? atom.rightDelim) + "</mo>";
        }
        result += "</mrow>";
        break;
      case "sizeddelim":
      case "delim":
        result += '<mo separator="true"' + makeID(atom.id, options) + ">" + (SPECIAL_OPERATORS2[atom.delim] || atom.delim) + "</mo>";
        break;
      case "accent":
        result += '<mover accent="true"' + makeID(atom.id, options) + ">";
        result += toMathML(atom.body, 0, 0, options).mathML;
        result += "<mo>" + (SPECIAL_OPERATORS2[command] || atom.accent) + "</mo>";
        result += "</mover>";
        break;
      case "line":
      case "overlap":
        break;
      case "overunder":
        overscript = atom.above;
        underscript = atom.below;
        if ((atom.svgAbove || overscript) && (atom.svgBelow || underscript)) {
          body = atom.body;
        } else if (overscript && overscript.length > 0) {
          body = atom.body;
          if (atom.body?.[0]?.below) {
            underscript = atom.body[0].below;
            body = atom.body[0].body;
          } else if (atom.body?.[0]?.type === "first" && atom.body?.[1]?.below) {
            underscript = atom.body[1].below;
            body = atom.body[1].body;
          }
        } else if (underscript && underscript.length > 0) {
          body = atom.body;
          if (atom.body?.[0]?.above) {
            overscript = atom.body[0].above;
            body = atom.body[0].body;
          } else if (atom.body?.[0]?.type === "first" && atom.body?.[1]?.above) {
            overscript = atom.body[1].overscript;
            body = atom.body[1].body;
          }
        }
        if ((atom.svgAbove || overscript) && (atom.svgBelow || underscript)) {
          result += `<munderover ${variant} ${makeID(atom.id, options)}>`;
          result += SVG_CODE_POINTS[atom.svgBody] || toMathML(body, 0, 0, options).mathML;
          result += SVG_CODE_POINTS[atom.svgBelow] || toMathML(underscript, 0, 0, options).mathML;
          result += SVG_CODE_POINTS[atom.svgAbove] || toMathML(overscript, 0, 0, options).mathML;
          result += "</munderover>";
        } else if (atom.svgAbove || overscript) {
          result += `<mover ${variant} ${makeID(atom.id, options)}>` + (SVG_CODE_POINTS[atom.svgBody] || toMathML(body, 0, 0, options).mathML);
          result += SVG_CODE_POINTS[atom.svgAbove] || toMathML(overscript, 0, 0, options).mathML;
          result += "</mover>";
        } else if (atom.svgBelow || underscript) {
          result += `<munder ${variant} ${makeID(atom.id, options)}>` + (SVG_CODE_POINTS[atom.svgBody] || toMathML(body, 0, 0, options).mathML);
          result += SVG_CODE_POINTS[atom.svgBelow] || toMathML(underscript, 0, 0, options).mathML;
          result += "</munder>";
        }
        break;
      case "placeholder":
      case "mord": {
        result = SPECIAL_IDENTIFIERS2[command] || command || (typeof atom.value === "string" ? atom.value : "");
        const m3 = command ? command.match(/{?\\char"([\dabcdefABCDEF]*)}?/) : null;
        if (m3) {
          result = "&#x" + m3[1] + ";";
        } else if (result.length > 0 && result.startsWith("\\")) {
          if (typeof atom.value === "string" && atom.value.charCodeAt(0) > 255) {
            result = "&#x" + ("000000" + atom.value.charCodeAt(0).toString(16)).slice(-4) + ";";
          } else if (typeof atom.value === "string") {
            result = atom.value.charAt(0);
          } else {
            console.log("Did not expect this");
            result = "";
          }
        }
        const tag = /\d/.test(result) ? "mn" : "mi";
        result = "<" + tag + variant + makeID(atom.id, options) + ">" + xmlEscape(result) + "</" + tag + ">";
        break;
      }
      case "mbin":
      case "mrel":
      case "minner":
        if (command && SPECIAL_IDENTIFIERS2[command]) {
          result = "<mi" + makeID(atom.id, options) + ">" + SPECIAL_IDENTIFIERS2[command] + "</mi>";
        } else if (command && SPECIAL_OPERATORS2[command]) {
          result = "<mo" + makeID(atom.id, options) + ">" + SPECIAL_OPERATORS2[command] + "</mo>";
        } else {
          result = toMo(atom, options);
        }
        break;
      case "mpunct":
        result = '<mo separator="true"' + makeID(atom.id, options) + ">" + (SPECIAL_OPERATORS2[command] || command) + "</mo>";
        break;
      case "mop":
        if (atom.body !== "\u200B") {
          result = "<mo" + makeID(atom.id, options) + ">";
          result += command === "\\operatorname" ? atom.body : command || atom.body;
          result += "</mo>";
        }
        break;
      case "box":
        result = '<menclose notation="box"';
        if (atom.backgroundcolor) {
          result += ' mathbackground="' + atom.backgroundcolor + '"';
        }
        result += makeID(atom.id, options) + ">" + toMathML(atom.body, 0, 0, options).mathML + "</menclose>";
        break;
      case "spacing":
        result += '<mspace width="' + (SPACING[command] || 0) + 'em"/>';
        break;
      case "enclose":
        result = '<menclose notation="';
        for (const notation in atom.notation) {
          if (Object.prototype.hasOwnProperty.call(atom.notation, notation) && atom.notation[notation]) {
            result += sep + notation;
            sep = " ";
          }
        }
        result += makeID(atom.id, options) + '">' + toMathML(atom.body, 0, 0, options).mathML + "</menclose>";
        break;
      case "space":
        result += "&nbsp;";
        break;
      case "msubsup":
        break;
      case "phantom":
        break;
      case "composition":
        break;
      case "rule":
        console.log("In conversion to MathML, unknown type : " + atom.type);
        break;
      case "chem":
        break;
      case "mopen":
        result += toMo(atom, options);
        break;
      case "mclose":
        result += toMo(atom, options);
        break;
      case "macro":
        {
          const body2 = toString2(atom.macroLatex);
          if (body2) {
            result += `<mo ${makeID(atom.id, options)}>${body2}</mo>`;
          }
        }
        break;
      case "error":
        console.log("In conversion to MathML, unknown type : " + atom.type);
        break;
      default:
        console.log("In conversion to MathML, unknown type : " + atom.type);
    }
  }
  return result;
}
function atomsToMathML(atoms, options) {
  return toMathML(atoms, 0, 0, options).mathML;
}

// src/editor/atom-to-speakable-text.ts
var PRONUNCIATION = {
  "\\alpha": "alpha ",
  "\\mu": "mew ",
  "\\sigma": "sigma ",
  "\\pi": "pie ",
  "\\imaginaryI": "eye ",
  "\\sum": "Summation ",
  "\\prod": "Product ",
  "a": '<phoneme alphabet="ipa" ph="e\u026A">a</phoneme>',
  "A": 'capital <phoneme alphabet="ipa" ph="e\u026A">A</phoneme>',
  "+": "plus ",
  "-": "minus ",
  ";": '<break time="150ms"/> semi-colon <break time="150ms"/>',
  ",": '<break time="150ms"/> comma  <break time="150ms"/>',
  "|": '<break time="150ms"/>Vertical bar<break time="150ms"/>',
  "(": '<break time="150ms"/>Open paren. <break time="150ms"/>',
  ")": '<break time="150ms"/> Close paren. <break time="150ms"/>',
  "=": "equals ",
  "<": "is less than ",
  "\\lt": "is less than ",
  "<=": "is less than or equal to ",
  "\\le": "is less than or equal to ",
  "\\gt": "is greater than ",
  ">": "is greater than ",
  "\\ge": "is greater than or equal to ",
  "\\geq": "is greater than or equal to ",
  "\\leq": "is less than or equal to ",
  "!": "factorial ",
  "\\sin": "sine ",
  "\\cos": "cosine ",
  "\u200B": "",
  "\u2212": "minus ",
  ":": '<break time="150ms"/> such that <break time="200ms"/> ',
  "\\colon": '<break time="150ms"/> such that <break time="200ms"/> ',
  "\\hbar": "etch bar ",
  "\\iff": '<break time="200ms"/>if, and only if, <break time="200ms"/>',
  "\\Longleftrightarrow": '<break time="200ms"/>if, and only if, <break time="200ms"/>',
  "\\land": "and ",
  "\\lor": "or ",
  "\\neg": "not ",
  "\\div": "divided by ",
  "\\forall": "for all ",
  "\\exists": "there exists ",
  "\\nexists": "there does not exists ",
  "\\in": "element of ",
  "\\N": 'the set <break time="150ms"/><say-as interpret-as="character">n</say-as>',
  "\\C": 'the set <break time="150ms"/><say-as interpret-as="character">c</say-as>',
  "\\Z": 'the set <break time="150ms"/><say-as interpret-as="character">z</say-as>',
  "\\Q": 'the set <break time="150ms"/><say-as interpret-as="character">q</say-as>',
  "\\infty": "infinity ",
  "\\nabla": "nabla ",
  "\\partial": "partial derivative of ",
  "\\cdot": "times ",
  "\\cdots": "dot dot dot ",
  "\\Rightarrow": "implies ",
  "\\lparen": '<break time="150ms"/>open paren<break time="150ms"/>',
  "\\rparen": '<break time="150ms"/>close paren<break time="150ms"/>',
  "\\lbrace": '<break time="150ms"/>open brace<break time="150ms"/>',
  "\\{": '<break time="150ms"/>open brace<break time="150ms"/>',
  "\\rbrace": '<break time="150ms"/>close brace<break time="150ms"/>',
  "\\}": '<break time="150ms"/>close brace<break time="150ms"/>',
  "\\langle": '<break time="150ms"/>left angle bracket<break time="150ms"/>',
  "\\rangle": '<break time="150ms"/>right angle bracket<break time="150ms"/>',
  "\\lfloor": '<break time="150ms"/>open floor<break time="150ms"/>',
  "\\rfloor": '<break time="150ms"/>close floor<break time="150ms"/>',
  "\\lceil": '<break time="150ms"/>open ceiling<break time="150ms"/>',
  "\\rceil": '<break time="150ms"/>close ceiling<break time="150ms"/>',
  "\\vert": '<break time="150ms"/>vertical bar<break time="150ms"/>',
  "\\mvert": '<break time="150ms"/>divides<break time="150ms"/>',
  "\\lvert": '<break time="150ms"/>left vertical bar<break time="150ms"/>',
  "\\rvert": '<break time="150ms"/>right vertical bar<break time="150ms"/>',
  "\\lbrack": '<break time="150ms"/> open square bracket <break time="150ms"/>',
  "\\rbrack": '<break time="150ms"/> close square bracket <break time="150ms"/>',
  "mm": "millimeters",
  "cm": "centimeters",
  "km": "kilometers",
  "kg": "kilograms"
};
function getSpokenName(latex) {
  let result = "";
  if (latex.startsWith("\\")) {
    result = " " + latex.replace("\\", "") + " ";
  }
  return result;
}
function isAtomic(atoms) {
  let count = 0;
  if (isArray(atoms)) {
    for (const atom of atoms) {
      if (atom.type !== "first") {
        count += 1;
      }
    }
  }
  return count === 1;
}
function atomicID(atoms) {
  if (isArray(atoms)) {
    for (const atom of atoms) {
      if (atom.type !== "first" && atom.id) {
        return atom.id.toString();
      }
    }
  }
  return "";
}
function atomicValue(atoms) {
  let result = "";
  if (isArray(atoms)) {
    for (const atom of atoms) {
      if (atom.type !== "first" && typeof atom.value === "string") {
        result += atom.value;
      }
    }
  }
  return result;
}
function atomsAsText(atoms, _options) {
  if (!atoms)
    return "";
  return atoms.map((atom) => atom.value).join("");
}
function atomToSpeakableFragment(mode, atom, options) {
  function letter(c3) {
    let result2 = "";
    if (!options.textToSpeechMarkup) {
      if (/[a-z]/.test(c3)) {
        result2 += " '" + c3.toUpperCase() + "'";
      } else if (/[A-Z]/.test(c3)) {
        result2 += " 'capital " + c3.toUpperCase() + "'";
      } else {
        result2 += c3;
      }
    } else if (/[a-z]/.test(c3)) {
      result2 += ' <say-as interpret-as="character">' + c3 + "</say-as>";
    } else if (/[A-Z]/.test(c3)) {
      result2 += String("capital " + c3.toLowerCase());
    } else {
      result2 += c3;
    }
    return result2;
  }
  function emph(s3) {
    return "<emphasis>" + s3 + "</emphasis>";
  }
  if (!atom)
    return "";
  let result = "";
  if (isArray(atom)) {
    let isInDigitRun = false;
    let isInTextRun = false;
    for (let i3 = 0; i3 < atom.length; i3++) {
      if (atom[i3].mode !== "text") {
        isInTextRun = false;
      }
      if (i3 < atom.length - 2 && atom[i3].type === "mopen" && atom[i3 + 2].type === "mclose" && atom[i3 + 1].type === "mord") {
        result += " of ";
        result += emph(atomToSpeakableFragment(mode, atom[i3 + 1], options));
        i3 += 2;
      } else if (atom[i3].mode === "text") {
        if (isInTextRun) {
          result += atom[i3].value ?? " ";
        } else {
          isInTextRun = true;
          result += atomToSpeakableFragment("text", atom[i3], options);
        }
      } else if (atom[i3].type === "mord" && /[0123456789,.]/.test(atom[i3].value)) {
        if (isInDigitRun) {
          result += atom[i3].value;
        } else {
          isInDigitRun = true;
          result += atomToSpeakableFragment(mode, atom[i3], options);
        }
      } else {
        isInDigitRun = false;
        result += atomToSpeakableFragment(mode, atom[i3], options);
      }
    }
  } else if (atom.mode === "text") {
    if (atom.id && mode === "math") {
      result += '<mark name="' + atom.id.toString() + '"/>';
    }
    result += atom.value;
  } else {
    if (atom.id && mode === "math") {
      result += '<mark name="' + atom.id.toString() + '"/>';
    }
    let numer = "";
    let denom = "";
    let body = "";
    let supsubHandled = false;
    switch (atom.type) {
      case "group":
      case "root":
        result += atomToSpeakableFragment("math", atom.body, options);
        break;
      case "genfrac":
        numer = atomToSpeakableFragment("math", atom.above, options);
        denom = atomToSpeakableFragment("math", atom.below, options);
        if (isAtomic(atom.above) && isAtomic(atom.below)) {
          const COMMON_FRACTIONS = {
            "1/2": " half ",
            "1/3": " one third ",
            "2/3": " two third",
            "1/4": " one quarter ",
            "3/4": " three quarter ",
            "1/5": " one fifth ",
            "2/5": " two fifths ",
            "3/5": " three fifths ",
            "4/5": " four fifths ",
            "1/6": " one sixth ",
            "5/6": " five sixths ",
            "1/8": " one eight ",
            "3/8": " three eights ",
            "5/8": " five eights ",
            "7/8": " seven eights ",
            "1/9": " one ninth ",
            "2/9": " two ninths ",
            "4/9": " four ninths ",
            "5/9": " five ninths ",
            "7/9": " seven ninths ",
            "8/9": " eight ninths "
          };
          const commonFraction = COMMON_FRACTIONS[atomicValue(atom.above) + "/" + atomicValue(atom.below)];
          if (commonFraction) {
            result = commonFraction;
          } else {
            result += numer + " over " + denom;
          }
        } else {
          result += ' the fraction <break time="150ms"/>' + numer + ', over <break time="150ms"/>' + denom + '.<break time="150ms"/> End fraction.<break time="150ms"/>';
        }
        break;
      case "surd":
        body = atomToSpeakableFragment("math", atom.body, options);
        if (atom.hasEmptyBranch("above")) {
          result += isAtomic(atom.body) ? " the square root of " + body + " , " : ' the square root of <break time="200ms"/>' + body + '. <break time="200ms"/> End square root';
        } else {
          let index = atomToSpeakableFragment("math", atom.above, options);
          index = index.trim();
          const index2 = index.replace(/<mark([^/]*)\/>/g, "");
          if (index2 === "3") {
            result += ' the cube root of <break time="200ms"/>' + body + '. <break time="200ms"/> End cube root';
          } else if (index2 === "n") {
            result += ' the nth root of <break time="200ms"/>' + body + '. <break time="200ms"/> End root';
          } else {
            result += ' the root with index: <break time="200ms"/>' + index + ', of <break time="200ms"/>' + body + '. <break time="200ms"/> End root';
          }
        }
        break;
      case "leftright":
        {
          const delimAtom = atom;
          result += (delimAtom.leftDelim ? PRONUNCIATION[delimAtom.leftDelim] : void 0) ?? delimAtom.leftDelim;
          result += atomToSpeakableFragment("math", atom.body, options);
          result += (delimAtom.rightDelim ? PRONUNCIATION[delimAtom.rightDelim] : void 0) ?? delimAtom.rightDelim;
        }
        break;
      case "rule":
        break;
      case "overunder":
        break;
      case "overlap":
        break;
      case "placeholder":
        result += "placeholder ";
        break;
      case "delim":
      case "sizeddelim":
      case "mord":
      case "minner":
      case "mbin":
      case "mrel":
      case "mpunct":
      case "mopen":
      case "mclose": {
        const {command} = atom;
        if (command === "\\mathbin" || command === "\\mathrel" || command === "\\mathopen" || command === "\\mathclose" || command === "\\mathpunct" || command === "\\mathord" || command === "\\mathinner") {
          result = atomToSpeakableFragment(mode, atom.body, options);
          break;
        }
        let atomValue = atom.value;
        let latexValue = atom.command;
        if (atom.type === "delim" || atom.type === "sizeddelim") {
          latexValue = atom.value;
          atomValue = latexValue;
        }
        if (mode === "text") {
          result += atomValue;
        } else {
          if (atom.type === "mbin") {
            result += '<break time="150ms"/>';
          }
          if (atomValue) {
            const value = PRONUNCIATION[atomValue] || (latexValue ? PRONUNCIATION[latexValue.trim()] : "");
            if (value) {
              result += " " + value;
            } else {
              const spokenName = latexValue ? getSpokenName(latexValue.trim()) : "";
              result += spokenName ? spokenName : letter(atomValue);
            }
          } else {
            result += atomToSpeakableFragment("math", atom.body, options);
          }
          if (atom.type === "mbin") {
            result += '<break time="150ms"/>';
          }
        }
        break;
      }
      case "mop":
        if (atom.value !== "\u200B") {
          const trimLatex = atom.command;
          if (trimLatex === "\\sum") {
            if (!atom.hasEmptyBranch("superscript") && !atom.hasEmptyBranch("subscript")) {
              let sup = atomToSpeakableFragment("math", atom.superscript, options);
              sup = sup.trim();
              let sub = atomToSpeakableFragment("math", atom.subscript, options);
              sub = sub.trim();
              result += ' the summation from <break time="200ms"/>' + sub + '<break time="200ms"/> to  <break time="200ms"/>' + sup + '<break time="200ms"/> of <break time="150ms"/>';
              supsubHandled = true;
            } else if (!atom.hasEmptyBranch("subscript")) {
              let sub = atomToSpeakableFragment("math", atom.subscript, options);
              sub = sub.trim();
              result += ' the summation from <break time="200ms"/>' + sub + '<break time="200ms"/> of <break time="150ms"/>';
              supsubHandled = true;
            } else {
              result += " the summation of";
            }
          } else if (trimLatex === "\\prod") {
            if (!atom.hasEmptyBranch("superscript") && !atom.hasEmptyBranch("subscript")) {
              let sup = atomToSpeakableFragment("math", atom.superscript, options);
              sup = sup.trim();
              let sub = atomToSpeakableFragment("math", atom.subscript, options);
              sub = sub.trim();
              result += ' the product from <break time="200ms"/>' + sub + '<break time="200ms"/> to <break time="200ms"/>' + sup + '<break time="200ms"/> of <break time="150ms"/>';
              supsubHandled = true;
            } else if (!atom.hasEmptyBranch("subscript")) {
              let sub = atomToSpeakableFragment("math", atom.subscript, options);
              sub = sub.trim();
              result += ' the product from <break time="200ms"/>' + sub + '<break time="200ms"/> of <break time="150ms"/>';
              supsubHandled = true;
            } else {
              result += " the product  of ";
            }
          } else if (trimLatex === "\\int") {
            if (!atom.hasEmptyBranch("superscript") && !atom.hasEmptyBranch("subscript")) {
              let sup = atomToSpeakableFragment("math", atom.superscript, options);
              sup = sup.trim();
              let sub = atomToSpeakableFragment("math", atom.subscript, options);
              sub = sub.trim();
              result += ' the integral from <break time="200ms"/>' + emph(sub) + '<break time="200ms"/> to <break time="200ms"/>' + emph(sup) + ' <break time="200ms"/> of ';
              supsubHandled = true;
            } else {
              result += ' the integral of <break time="200ms"/> ';
            }
          } else if (typeof atom.value === "string") {
            const value = PRONUNCIATION[atom.value] ?? (atom.command ? PRONUNCIATION[atom.command] : void 0);
            result += value ? value : " " + atom.value;
          } else if (atom.command) {
            if (atom.command === "\\mathop") {
              result += atomToSpeakableFragment("math", atom.body, options);
            } else if (atom.command === "\\operatorname") {
              result += atomsAsText(atom.body, options);
            } else {
              result += atom.command.startsWith("\\") ? " " + atom.command.slice(1) : " " + atom.command;
            }
          }
        }
        break;
      case "enclose":
        body = atomToSpeakableFragment("math", atom.body, options);
        result += isAtomic(atom.body) ? " crossed out " + body + " , " : " crossed out " + body + ". End cross out";
        break;
      case "space":
      case "spacing":
      case "macro":
        break;
    }
    if (!supsubHandled && !atom.hasEmptyBranch("superscript")) {
      let sup = atomToSpeakableFragment(mode, atom.superscript, options);
      sup = sup.trim();
      const sup2 = sup.replace(/<[^>]*>/g, "");
      if (isAtomic(atom.superscript)) {
        if (mode === "math") {
          const id = atomicID(atom.superscript);
          if (id) {
            result += '<mark name="' + id + '"/>';
          }
        }
        if (sup2 === "\u2032") {
          result += " prime ";
        } else if (sup2 === "2") {
          result += " squared ";
        } else if (sup2 === "3") {
          result += " cubed ";
        } else if (Number.isNaN(Number.parseInt(sup2))) {
          result += " to the " + sup + "; ";
        } else {
          result += ' to the <say-as interpret-as="ordinal">' + sup2 + "</say-as> power; ";
        }
      } else if (Number.isNaN(Number.parseInt(sup2))) {
        result += " raised to the " + sup + "; ";
      } else {
        result += ' raised to the <say-as interpret-as="ordinal">' + sup2 + "</say-as> power; ";
      }
    }
    if (!supsubHandled && !atom.hasEmptyBranch("subscript")) {
      let sub = atomToSpeakableFragment("math", atom.subscript, options);
      sub = sub.trim();
      result += isAtomic(atom.subscript) ? " sub " + sub : " subscript " + sub + ". End subscript. ";
    }
  }
  return result;
}
function atomToSpeakableText(atoms, speechOptions) {
  const options = {
    ...speechOptions,
    textToSpeechRulesOptions: {...speechOptions.textToSpeechRulesOptions}
  };
  if (window.sre && options.textToSpeechRules === "sre") {
    const mathML = atomsToMathML(atoms, options);
    if (mathML) {
      if (options.textToSpeechMarkup) {
        options.textToSpeechRulesOptions = options.textToSpeechRulesOptions ?? {};
        options.textToSpeechRulesOptions.markup = options.textToSpeechMarkup;
        if (options.textToSpeechRulesOptions.markup === "ssml") {
          options.textToSpeechRulesOptions.markup = "ssml_step";
        }
        options.textToSpeechRulesOptions.rate = options.speechEngineRate;
      }
      if (options.textToSpeechRulesOptions) {
        window.sre.System.getInstance().setupEngine(options.textToSpeechRulesOptions);
      }
      return window.sre.System.getInstance().toSpeech(mathML);
    }
    return "";
  }
  let result = atomToSpeakableFragment("math", atoms, options);
  if (options.textToSpeechMarkup === "ssml") {
    let prosody = "";
    if (options.speechEngineRate) {
      prosody = '<prosody rate="' + options.speechEngineRate + '">';
    }
    result = `<?xml version="1.0"?><speak version="1.1" xmlns="http://www.w3.org/2001/10/synthesis" xml:lang="en-US"><amazon:auto-breaths>` + prosody + "<p><s>" + result + "</s></p>" + (prosody ? "</prosody>" : "") + "</amazon:auto-breaths></speak>";
  } else if (options.textToSpeechMarkup === "mac" && osPlatform() === "macos") {
    result = result.replace(/<mark([^/]*)\/>/g, "").replace(/<emphasis>/g, "[[emph+]]").replace(/<\/emphasis>/g, "").replace(/<break time="(\d*)ms"\/>/g, "[[slc $1]]").replace(/<say-as[^>]*>/g, "").replace(/<\/say-as>/g, "");
  } else {
    result = result.replace(/<[^>]*>/g, "").replace(/\s{2,}/g, " ");
  }
  return result;
}

// src/addons/definitions-metadata.ts
var CRYPTIC = 0;
var ARCANE = 200;
var RARE = 1200;
var UNCOMMON = 2e3;
var COMMON = 3e3;
var SUPERCOMMON = 4e3;
function metadata(category, symbols, frequency = COMMON, template = "$0") {
  for (const symbol of symbols) {
    if (MATH_SYMBOLS[symbol]) {
      MATH_SYMBOLS[symbol].frequency = frequency;
      MATH_SYMBOLS[symbol].category = category;
      MATH_SYMBOLS[symbol].template = template.replace(/\$0/g, symbol);
    }
    if (LEGACY_COMMANDS[symbol]) {
      LEGACY_COMMANDS[symbol] = {
        ...LEGACY_COMMANDS[symbol],
        frequency,
        category,
        template: template.replace(/\$0/g, symbol)
      };
    }
  }
}
metadata("Trigonometry", ["\\cos", "\\sin", "\\tan"], SUPERCOMMON);
metadata("Trigonometry", [
  "\\arcsin",
  "\\arccos",
  "\\arctan",
  "\\arctg",
  "\\arcctg",
  "\\arcsec",
  "\\arccsc",
  "\\arsinh",
  "\\arcosh",
  "\\artanh",
  "\\arcsech",
  "\\arccsch",
  "\\arg",
  "\\ch",
  "\\cosec",
  "\\cosh",
  "\\cot",
  "\\cotg",
  "\\coth",
  "\\csc",
  "\\ctg",
  "\\cth",
  "\\lg",
  "\\lb",
  "\\sec",
  "\\sinh",
  "\\sh",
  "\\tanh",
  "\\tg",
  "\\th"
], UNCOMMON);
metadata("Functions", ["\\ln", "\\log", "\\exp", "\\lim"], SUPERCOMMON);
metadata("Functions", ["\\dim", "\\ker", "\\deg", "\\det", "\\mod", "\\min", "\\max"], COMMON);
metadata("Functions", ["\\hom"], RARE);
metadata("Decoration", ["\\rule"], ARCANE, "$0{2em}{1em}");
metadata("Decoration", ["\\color", "\\textcolor"], ARCANE, "{$0{m0}A}{$0{m1}B}{$0{m2}C }{$0{m3}a}{$0{m4}b}{$0{m5}c}{$0{m6}8}");
metadata("Decoration", ["\\overline", "\\underline"], COMMON, "$0{\\placeholder{}}");
metadata("Decoration", ["\\enclose"], RARE, '\\enclose{updiagonalstrike,roundedbox}[1px solid red, mathbackground="#fbc0bd"]{x=0}');
metadata("Decoration", ["\\fcolorbox"], RARE, '\\fcolorbox{#cd0030}{#ffd400}{\\unicode{"2B1A}}');
metadata("Decoration", ["\\colorbox"], RARE, '\\colorbox{#fbc0bd}{\\unicode{"2B1A}}');
metadata("Decoration", ["\\boxed", "\\cancel", "\\bcancel", "\\xcancel"], RARE, "$0{\\placeholder{}}");
metadata("Decoration", ["\\bbox"], RARE, '\\bbox[#ffd400, solid 2px #ffd400]{\\unicode{"2B1A}}');
metadata("Styling", ["\\mathbb"], SUPERCOMMON, "$0{Don Knuth}");
metadata("Styling", [
  "\\textbf",
  "\\textup",
  "\\textit",
  "\\textrm",
  "\\textsf",
  "\\texttt",
  "\\textnormal",
  "\\textmd",
  "\\textsl",
  "\\textsc",
  "\\mathsf",
  "\\mathtt",
  "\\mathrm",
  "\\mathfrak",
  "\\mathcal",
  "\\mathscr",
  "\\mathbf",
  "\\mathmd",
  "\\mathit",
  "\\text",
  "\\mbox",
  "\\Bbb",
  "\\bold",
  "\\bm",
  "\\boldsymbol"
], COMMON, "$0{Don Knuth}");
metadata("Styling", [
  "\\frak",
  "\\tt",
  "\\bf",
  "\\it",
  "\\rmfamily",
  "\\sffamily",
  "\\ttfamily",
  "\\class",
  "\\cssId",
  "\\htmlData",
  "\\htmlStyle"
], RARE, "{$0 Don Knuth}");
metadata("Styling", ["\\bfseries", "\\mdseries", "\\upshape", "\\slshape", "\\scshape"], RARE, "\\text{$0 Don Knuth}");
metadata("Styling", ["\\class", "\\cssId"], RARE, "$0{testIdentifier}{Don Knuth}");
metadata("Styling", ["\\fontseries"], RARE, "\\text{$0{b}Don Knuth}");
metadata("Styling", ["\\fontfamily"], RARE, "\\text{$0{cmtt}Don Knuth}");
metadata("Styling", ["\\fontshape"], RARE, "\\text{$0{sc}Don Knuth}");
metadata("Styling", ["\\selectfont"], RARE, "\\text{$0}");
metadata("Styling", ["\\emph"], RARE, "Don$0{Knuth}");
metadata("Styling", ["\\em"], RARE, "Don{$0 Knuth}");
metadata("Layout", [
  "\\mathop",
  "\\mathbin",
  "\\mathrel",
  "\\mathopen",
  "\\mathclose",
  "\\mathpunct",
  "\\mathord",
  "\\mathinner",
  "\\operatorname",
  "\\operatorname*"
], RARE, "x=$0{arg}=0");
metadata("Layout", ["\\middle"], RARE, "\\left\\{x$0|x>0\\right\\}");
metadata("Layout", ["\\overset", "\\underset", "\\stackrel", "\\stackbin"], RARE, "$0{arg}{x=0}");
metadata("Layout", ["\\rlap", "\\mathrlap"], RARE, "$0{/}0");
metadata("Layout", ["\\llap", "\\mathllap"], RARE, "o$0{/}");
metadata("Fractions", ["\\frac"], SUPERCOMMON, "$0{\\placeholder{}}{\\placeholder{}}");
metadata("Fractions", [
  "\\binom",
  "\\dfrac",
  "\\tfrac",
  "\\dbinom",
  "\\tbinom",
  "\\pdiff",
  "\\cfrac"
], RARE, "$0{\\placeholder{}}{\\placeholder{}}");
metadata("Fractions", ["\\over", "\\atop", "\\choose"], RARE, '\\unicode{"2B1A} $0 \\unicode{"2B1A}');
metadata("Fractions", ["\\overwithdelims", "\\atopwithdelims"], RARE, '{\\unicode{"2B1A} $0{\\lbrace}{\\rbrace} \\unicode{"2B1A}}');
metadata("Extensible Operators", ["\\sum", "\\prod", "\\bigcap", "\\bigcup", "\\int"], SUPERCOMMON);
metadata("Extensible Operators", ["\\bigoplus", "\\smallint", "\\iint", "\\oint"], COMMON);
metadata("Extensible Operators", [
  "\\bigwedge",
  "\\bigvee",
  "\\coprod",
  "\\bigsqcup",
  "\\bigotimes",
  "\\bigodot",
  "\\biguplus",
  "\\intop",
  "\\sqcup",
  "\\sqcap",
  "\\uplus",
  "\\wr",
  "\\Cap",
  "\\Cup",
  "\\doublecap",
  "\\doublecup",
  "\\amalg",
  "\\iiint",
  "\\oiint",
  "\\oiiint",
  "\\intclockwise",
  "\\varointclockwise",
  "\\ointctrclockwise",
  "\\intctrclockwise"
], RARE);
metadata("Accents", ["\\vec"], SUPERCOMMON);
metadata("Accents", ["\\bar", "\\ddot", "\\acute", "\\tilde", "\\check"], COMMON, "$0{\\placeholder{}}");
metadata("Accents", ["\\^", "\\`", "\\'"], RARE, "$0{e}");
metadata("Accents", ["\\c"], RARE, "$0{c}");
metadata("Accents", ["\\~"], RARE, "$0{n}");
metadata("Accents", ["\\mathring", "\\hat", "\\dot", "\\breve", "\\grave"], RARE, "$0{\\placeholder{}}");
metadata("Extensible Symbols", [
  "\\overrightarrow",
  "\\overleftarrow",
  "\\Overrightarrow",
  "\\overleftharpoon",
  "\\overrightharpoon",
  "\\overleftrightarrow",
  "\\overbrace",
  "\\overlinesegment",
  "\\overgroup",
  "\\widehat",
  "\\widecheck",
  "\\widetilde"
], COMMON, "$0{ABC}");
metadata("Extensible Symbols", [
  "\\underrightarrow",
  "\\underleftarrow",
  "\\underleftrightarrow",
  "\\underbrace",
  "\\underlinesegment",
  "\\undergroup",
  "\\utilde"
], COMMON, "$0{ABC}");
metadata("Sizing", [
  "\\tiny",
  "\\scriptsize",
  "\\footnotesize",
  "\\small",
  "\\normalsize",
  "\\large",
  "\\Large",
  "\\LARGE",
  "\\huge",
  "\\Huge"
], RARE, "$0{x=0}");
metadata("Sizing", ["\\big", "\\Big", "\\bigg", "\\Bigg"], RARE, "$0($0)");
metadata("Sizing", ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl"], RARE, "$0(");
metadata("Sizing", ["\\bigr", "\\Bigr", "\\biggr", "\\Biggr"], RARE, "$0)");
metadata("Sizing", ["\\bigm", "\\Bigm", "\\biggm", "\\Biggm"], RARE, "$0|");
metadata("Letterlike Symbols", [
  "\\nabla",
  "\\partial",
  "\\N",
  "\\R",
  "\\Q",
  "\\C",
  "\\Z",
  "\\exponentialE",
  "\\forall",
  "\\exists",
  "\\nexists"
], SUPERCOMMON);
metadata("Letterlike Symbols", [
  "\\doubleStruckCapitalP",
  "\\P",
  "\\ell",
  "\\hbar",
  "\\hslash",
  "\\imath",
  "\\jmath",
  "\\imaginaryI",
  "\\imaginaryJ",
  "\\differentialD",
  "\\rd",
  "\\capitalDifferentialD",
  "\\doubleStruckCapitalN",
  "\\doubleStruckCapitalR",
  "\\doubleStruckCapitalQ",
  "\\doubleStruckCapitalC",
  "\\doubleStruckCapitalZ",
  "\\rD",
  "\\differencedelta",
  "\\mid",
  "@",
  "\\Re",
  "\\Im",
  "\\$",
  "\\%",
  "\\And",
  "\\degree"
], COMMON);
metadata("Letterlike Symbols", [
  "\\top",
  "\\bot",
  "\\scriptCapitalE",
  "\\scriptCapitalH",
  "\\scriptCapitalL",
  "\\gothicCapitalC",
  "\\gothicCapitalH",
  "\\gothicCapitalI",
  "\\gothicCapitalR",
  "\\Bbbk",
  "\\Finv",
  "\\Game",
  "\\wp",
  "\\eth",
  "\\mho",
  "\\pounds",
  "\\yen",
  "\\euro"
], RARE);
metadata("Crosses", ["\\dagger", "\\dag"], SUPERCOMMON);
metadata("Crosses", ["\\ddag", "\\ddagger", "\\maltese", "\\textdagger", "\\textdaggerdbl"], RARE);
metadata("Various", [
  "\\checkmark",
  "\\diagup",
  "\\diagdown",
  "\\angle",
  "\\measuredangle",
  "\\sphericalangle",
  "\\prime",
  "\\doubleprime",
  "\\backprime",
  "\\backdoubleprime",
  "\\sharp",
  "\\flat",
  "\\natural",
  "\\&",
  "\\#",
  "\\clubsuit",
  "\\spadesuit",
  "\\diamondsuit",
  "\\heartsuit",
  "\\backslash",
  "\\infty",
  "/",
  "\\_",
  "\\/",
  "|",
  "'"
], RARE);
metadata("Various", ["\\unicode"], RARE, '$0{"2B1A}');
metadata("Arrows", ["\\longrightarrow", "\\rightarrow", "\\Longrightarrow", "\\Rightarrow"], SUPERCOMMON);
metadata("Arrows", [
  "\\longmapsto",
  "\\mapsto",
  "\\Longleftrightarrow",
  "\\rightleftarrows",
  "\\leftarrow",
  "\\curvearrowleft",
  "\\uparrow",
  "\\downarrow",
  "\\hookrightarrow",
  "\\rightharpoonup",
  "\\rightleftharpoons"
], COMMON);
metadata("Arrows", [
  "\\Leftarrow",
  "\\longleftrightarrow",
  "\\longleftarrow",
  "\\Longleftarrow",
  "\\searrow",
  "\\nearrow",
  "\\swarrow",
  "\\nwarrow",
  "\\Uparrow",
  "\\Downarrow",
  "\\updownarrow",
  "\\Updownarrow",
  "\\hookleftarrow",
  "\\leftharpoonup",
  "\\leftharpoondown",
  "\\rightharpoondown",
  "\\leftrightarrows",
  "\\dashrightarrow",
  "\\dashleftarrow",
  "\\leftleftarrows",
  "\\Lleftarrow",
  "\\twoheadleftarrow",
  "\\leftarrowtail",
  "\\looparrowleft",
  "\\leftrightharpoons",
  "\\circlearrowleft",
  "\\Lsh",
  "\\upuparrows",
  "\\downharpoonleft",
  "\\multimap",
  "\\leftrightsquigarrow",
  "\\twoheadrightarrow",
  "\\rightarrowtail",
  "\\looparrowright",
  "\\curvearrowright",
  "\\circlearrowright",
  "\\Rsh",
  "\\downdownarrows",
  "\\upharpoonright",
  "\\downharpoonright",
  "\\rightsquigarrow",
  "\\leadsto",
  "\\Rrightarrow",
  "\\restriction"
], RARE);
metadata("Arrows", ["\\upharpoonleft", "\\rightrightarrows"], CRYPTIC);
metadata("Negated Arrows", [
  "\\nrightarrow",
  "\\nRightarrow",
  "\\nleftrightarrow",
  "\\nLeftrightarrow",
  "\\nleftarrow",
  "\\nLeftarrow"
], RARE);
metadata("Extensible Symbols", [
  "\\xrightarrow",
  "\\xleftarrow",
  "\\xRightarrow",
  "\\xLeftarrow",
  "\\xleftharpoonup",
  "\\xleftharpoondown",
  "\\xrightharpoonup",
  "\\xrightharpoondown",
  "\\xlongequal",
  "\\xtwoheadleftarrow",
  "\\xtwoheadrightarrow",
  "\\xleftrightarrow",
  "\\xLeftrightarrow",
  "\\xrightleftharpoons",
  "\\xleftrightharpoons",
  "\\xhookleftarrow",
  "\\xhookrightarrow",
  "\\xmapsto",
  "\\xtofrom",
  "\\xrightleftarrows",
  "\\xrightequilibrium",
  "\\xleftequilibrium"
], RARE, "$0[below]{above}=0");
metadata("Negated Relations", [
  "\\nless",
  "\\nleqslant",
  "\\lneq",
  "\\lneqq",
  "\\nleqq",
  "\\unlhd",
  "\\unrhd",
  "\\lvertneqq",
  "\\lnsim",
  "\\lnapprox",
  "\\nprec",
  "\\npreceq",
  "\\precnsim",
  "\\precnapprox",
  "\\nsim",
  "\\nshortmid",
  "\\nmid",
  "\\nvdash",
  "\\nvDash",
  "\\ngtr",
  "\\ngeqslant",
  "\\ngeqq",
  "\\gneq",
  "\\gneqq",
  "\\gvertneqq",
  "\\gnsim",
  "\\nsucc",
  "\\succnsim",
  "\\ncong",
  "\\nshortparallel",
  "\\nparallel",
  "\\nVDash",
  "\\nVdash",
  "\\precneqq",
  "\\succneqq",
  "\\gnapprox",
  "\\succnapprox",
  "\\nsucceq"
], RARE);
metadata("Hebrew", ["\\aleph", "\\beth", "\\daleth", "\\gimel"], RARE);
metadata("Fences", [
  "\\lbrace",
  "\\rbrace",
  "\\vert",
  "\\Vert",
  "\\{",
  "\\}",
  "(",
  ")",
  "[",
  "]"
], SUPERCOMMON);
metadata("Fences", [
  "\\langle",
  "\\rangle",
  "\\lfloor",
  "\\rfloor",
  "\\lceil",
  "\\rceil",
  "\\mvert",
  "\\|",
  "\\mVert"
], COMMON);
metadata("Fences", [
  "\\lvert",
  "\\rvert",
  "\\lVert",
  "\\rVert",
  "\\lbrack",
  "\\rbrack",
  "\\ulcorner",
  "\\urcorner",
  "\\llcorner",
  "\\lrcorner",
  "\\lgroup",
  "\\rgroup",
  "\\lmoustache",
  "\\rmoustache"
], RARE);
metadata("Relations", ["=", "\\ne", "\\neq", "<", ">", "\\leqslant", "\\geqslant", "\\approx"], SUPERCOMMON);
metadata("Relations", [
  "\\lt",
  "\\gt",
  "\\le",
  "\\ge",
  "\\leq",
  "\\geq",
  "\\gg",
  "\\cong",
  "\\equiv",
  "\\prec",
  "\\preceq",
  "\\succ",
  "\\perp",
  "\\parallel",
  "\\propto",
  "\\smile",
  "\\frown",
  "\\sim",
  "\\gtrsim"
], COMMON);
metadata("Relations", [
  "\\coloneq",
  "\\succeq",
  "\\approxeq",
  "\\thickapprox",
  "\\lessapprox",
  "\\gtrapprox",
  "\\precapprox",
  "\\succapprox",
  "\\thicksim",
  "\\succsim",
  "\\precsim",
  "\\backsim",
  "\\eqsim",
  "\\backsimeq",
  "\\simeq",
  "\\lesssim",
  "\\nleq",
  "\\ngeq",
  "\\smallsmile",
  "\\smallfrown",
  "\\bowtie",
  "\\asymp",
  "\\leqq",
  "\\eqslantless",
  "\\ll",
  "\\lll",
  "\\lessgtr",
  "\\lesseqgtr",
  "\\lesseqqgtr",
  "\\risingdotseq",
  "\\fallingdotseq",
  "\\preccurlyeq",
  "\\curlyeqprec",
  "\\vDash",
  "\\Vvdash",
  "\\bumpeq",
  "\\Bumpeq",
  "\\geqq",
  "\\eqslantgtr",
  "\\ggg",
  "\\gtrless",
  "\\gtreqless",
  "\\gtreqqless",
  "\\succcurlyeq",
  "\\curlyeqsucc",
  "\\Vdash",
  "\\shortmid",
  "\\shortparallel",
  "\\between",
  "\\pitchfork",
  "\\varpropto",
  "\\backepsilon",
  "\\llless",
  "\\gggtr",
  "\\lhd",
  "\\rhd",
  "\\Join",
  "\\doteq",
  "\\doteqdot",
  "\\Doteq",
  "\\eqcirc",
  "\\circeq",
  "\\lessdot",
  "\\gtrdot",
  "\\measeq",
  "\\eqdef",
  "\\questeq"
], RARE);
metadata("Logic", ["\\leftrightarrow", "\\Leftrightarrow", "\\to"], SUPERCOMMON);
metadata("Logic", ["\\models", "\\vdash"], COMMON);
metadata("Logic", [
  "\\therefore",
  "\\because",
  "\\implies",
  "\\gets",
  "\\dashv",
  "\\impliedby",
  "\\biconditional",
  "\\roundimplies"
], RARE);
metadata("Operators", ["+", "-", "*", "\\cdot"], SUPERCOMMON);
metadata("Operators", ["\\sqrt"], SUPERCOMMON, "$0{\\placeholder{}}");
metadata("Operators", ["\\pm", "\\mp", "\\times", "\\div", "\\surd"], COMMON);
metadata("Operators", [
  "\\ltimes",
  "\\rtimes",
  "\\leftthreetimes",
  "\\rightthreetimes",
  "\\intercal",
  "\\dotplus",
  "\\centerdot",
  "\\doublebarwedge",
  "\\divideontimes",
  "\\divides"
], RARE);
metadata("Logic", ["\\wedge", "\\vee", "\\neg"], SUPERCOMMON);
metadata("Logic", ["\\lnot"], COMMON);
metadata("Logic", [
  "\\land",
  "\\lor",
  "\\barwedge",
  "\\veebar",
  "\\nor",
  "\\curlywedge",
  "\\curlyvee"
], RARE);
metadata("Greek", [
  "\\alpha",
  "\\beta",
  "\\gamma",
  "\\delta",
  "\\epsilon",
  "\\varepsilon",
  "\\zeta",
  "\\eta",
  "\\theta",
  "\\vartheta",
  "\\iota",
  "\\kappa",
  "\\varkappa",
  "\\lambda",
  "\\mu",
  "\\nu",
  "\\xi",
  "\\pi",
  "\\varpi",
  "\\rho",
  "\\varrho",
  "\\sigma",
  "\\varsigma",
  "\\tau",
  "\\phi",
  "\\varphi",
  "\\upsilon",
  "\\chi",
  "\\psi",
  "\\omega",
  "\\Gamma",
  "\\Delta",
  "\\Theta",
  "\\Lambda",
  "\\Xi",
  "\\Pi",
  "\\Sigma",
  "\\Upsilon",
  "\\Phi",
  "\\Psi",
  "\\Omega",
  "\\digamma",
  "\\omicron"
], COMMON);
metadata("Sets", [
  "\\emptyset",
  "\\varnothing",
  "\\cap",
  "\\cup",
  "\\in",
  "\\notin",
  "\\subset",
  "\\supset",
  "\\subseteq",
  "\\supseteq",
  "\\sqsubseteq"
], SUPERCOMMON);
metadata("Sets", [
  "\\setminus",
  "\\not",
  "\\ni",
  "\\sqsupseteq",
  "\\nsupseteqq",
  "\\supsetneq",
  "\\varsupsetneq",
  "\\supsetneqq",
  "\\varsupsetneqq"
], COMMON);
metadata("Sets", [
  "\\smallsetminus",
  "\\complement",
  "\\owns",
  "\\subsetneq",
  "\\varsubsetneq",
  "\\subsetneqq",
  "\\varsubsetneqq",
  "\\nsubset",
  "\\nsupset",
  "\\nsubseteq",
  "\\nsupseteq",
  "\\nsubseteqq",
  "\\subseteqq",
  "\\Subset",
  "\\sqsubset",
  "\\supseteqq",
  "\\Supset",
  "\\sqsupset"
], RARE);
metadata("Spacing", ["\\space, \\quad", "\\qquad"], COMMON, '\\unicode{"203A}$0\\unicode{"2039}');
metadata("Spacing", ["\\!", "\\,", "\\:", "\\;", "\\enskip", "\\enspace"], RARE, '\\unicode{"203A}$0\\unicode{"2039}');
metadata("Spacing", ["\\hspace", "\\hspace*"], RARE, '\\unicode{"203A}$0{1em}\\unicode{"2039}');
metadata("Punctuation", [
  "\\colon",
  "\\cdotp",
  "\\ldots",
  "\\cdots",
  "\\ddots",
  "\\vdots",
  "?",
  "!",
  ":",
  '"',
  ",",
  ".",
  ";"
], COMMON);
metadata("Punctuation", ["\\mathellipsis", "\\ldotp", "\\Colon"], RARE);
metadata("Boxes", ["\\square", "\\Box"], COMMON);
metadata("Boxes", ["\\blacksquare", "\\boxminus", "\\boxplus", "\\boxtimes", "\\boxdot"], RARE);
metadata("Circles", ["\\circ", "\\bullet", "\\circleddash", "\\oplus", "\\otimes"], COMMON);
metadata("Circles", [
  "\\bigcirc",
  "\\circledast",
  "\\ominus",
  "\\circledcirc",
  "\\oslash",
  "\\circledS",
  "\\circledR",
  "\\odot"
], RARE);
metadata("Triangles", ["\\triangle", "\\triangleq"], COMMON);
metadata("Triangles", [
  "\\bigtriangleup",
  "\\vartriangle",
  "\\triangledown",
  "\\bigtriangledown",
  "\\triangleleft",
  "\\vartriangleleft",
  "\\trianglelefteq",
  "\\ntriangleleft",
  "\\ntrianglelefteq",
  "\\triangleright",
  "\\vartriangleright",
  "\\trianglerighteq",
  "\\ntriangleright",
  "\\ntrianglerighteq",
  "\\blacktriangle",
  "\\blacktriangledown",
  "\\blacktriangleleft",
  "\\blacktriangleright"
], RARE);
metadata("Shapes", ["\\ast", "\\star"], COMMON);
metadata("Shapes", ["\\diamond", "\\Diamond", "\\lozenge", "\\blacklozenge", "\\bigstar"], RARE);

// src/editor/l10n-strings.ts
var STRINGS = {
  en: {
    "keyboard.tooltip.functions": "Functions",
    "keyboard.tooltip.symbols": "Symbols",
    "keyboard.tooltip.greek": "Greek Letters",
    "keyboard.tooltip.command": "LaTeX Command Mode",
    "keyboard.tooltip.numeric": "Numeric",
    "keyboard.tooltip.roman": "Roman Letters",
    "tooltip.copy to clipboard": "Copy to Clipboard",
    "tooltip.redo": "Redo",
    "tooltip.toggle virtual keyboard": "Toggle Virtual Keyboard",
    "tooltip.undo": "Undo",
    "menu.insert matrix": "Insert Matrix",
    "menu.insert vector": "Insert Vector",
    "submenu.array.matrix delimiters": "Matrix Delimiters",
    "menu.array.add row above": "Add Row After",
    "menu.array.add row below": "Add Row Before",
    "menu.array.add column after": "Add Column After",
    "menu.array.add column before": "Add Column Before",
    "menu.array.delete row": "Delete Row",
    "menu.array.delete rows": "Delete Selected Rows",
    "menu.array.delete column": "Delete Column",
    "menu.array.delete columns": "Delete Selected Columns",
    "submenu.array.insert separator": "Insert Separator",
    "menu.insert table": "Insert Table",
    "submenu.table style": "Table Style"
  },
  ar: {
    "keyboard.tooltip.functions": "\u0645\u0647\u0627\u0645",
    "keyboard.tooltip.symbols": "\u062D\u0631\u0641 \u0627\u0648 \u0631\u0645\u0632",
    "keyboard.tooltip.greek": "\u062D\u0631\u0648\u0641 \u064A\u0648\u0646\u0627\u0646\u064A\u0629",
    "keyboard.tooltip.command": "\u062D\u0627\u0644\u0629 \u062A\u0644\u0642\u064A \u0627\u0644\u0623\u0648\u0627\u0645\u0631 \u0627\u0644\u0644\u0627\u062A\u0643",
    "keyboard.tooltip.numeric": "\u0627\u0644\u0631\u0642\u0645\u064A\u0629",
    "keyboard.tooltip.roman": "\u0631\u0645\u0648\u0632 \u0627\u0644\u0627\u062D\u0631\u0641 \u0627\u0644\u0631\u0648\u0645\u0627\u0646\u064A\u0629",
    "tooltip.copy to clipboard": "\u0646\u0633\u062E \u0625\u0644\u0649 \u0627\u0644\u062D\u0627\u0641\u0638\u0629",
    "tooltip.redo": "\u0627\u0644\u0625\u0639\u0627\u062F\u0629",
    "tooltip.toggle virtual keyboard": "\u062A\u0628\u062F\u064A\u0644 \u0644\u0648\u062D\u0629 \u0627\u0644\u0645\u0641\u0627\u062A\u064A\u062D \u0627\u0644\u0625\u0641\u062A\u0631\u0627\u0636\u064A\u0629",
    "tooltip.undo": "\u0625\u0644\u063A\u0627\u0621",
    "menu.insert matrix": "\u0623\u062F\u062E\u0644 \u0627\u0644\u0645\u0635\u0641\u0648\u0641\u0629",
    "menu.insert vector": "\u0623\u062F\u062E\u0644 \u0645\u062A\u062C\u0647",
    "submenu.array.matrix delimiters": "\u0645\u062D\u062F\u062F\u0627\u062A \u0627\u0644\u0645\u0635\u0641\u0648\u0641\u0629",
    "menu.array.add row above": "\u0623\u0636\u0641 \u0635\u0641\u064B\u0627 \u0628\u0639\u062F \u0630\u0644\u0643",
    "menu.array.add row below": "\u0623\u0636\u0641 \u0627\u0644\u0635\u0641 \u0642\u0628\u0644",
    "menu.array.add column after": "\u0623\u0636\u0641 \u0627\u0644\u0639\u0645\u0648\u062F \u0628\u0639\u062F \u0630\u0644\u0643",
    "menu.array.add column before": "\u0623\u0636\u0641 \u0627\u0644\u0639\u0645\u0648\u062F \u0642\u0628\u0644",
    "menu.array.delete row": "\u0627\u062D\u0630\u0641 \u0635\u0641",
    "menu.array.delete rows": "\u062D\u0630\u0641 \u0627\u0644\u0635\u0641\u0648\u0641 \u0627\u0644\u0645\u062D\u062F\u062F\u0629",
    "menu.array.delete column": "\u062D\u0630\u0641 \u0627\u0644\u0639\u0645\u0648\u062F",
    "menu.array.delete columns": "\u062D\u0630\u0641 \u0627\u0644\u0623\u0639\u0645\u062F\u0629 \u0627\u0644\u0645\u062D\u062F\u062F\u0629",
    "submenu.array.insert separator": "\u0623\u062F\u062E\u0644 \u0641\u0627\u0635\u0644",
    "menu.insert table": "\u0625\u062F\u0631\u0627\u062C \u062C\u062F\u0648\u0644",
    "submenu.table style": "\u0646\u0645\u0637 \u0627\u0644\u062C\u062F\u0648\u0644"
  },
  bg: {
    "keyboard.tooltip.functions": "\u0424\u0443\u043D\u043A\u0446\u0438\u0438",
    "keyboard.tooltip.symbols": "\u0421\u0438\u043C\u0432\u043E\u043B\u0438",
    "keyboard.tooltip.greek": "\u0413\u0440\u044A\u0446\u043A\u0438 \u0431\u0443\u043A\u0432\u0438",
    "keyboard.tooltip.command": "\u041A\u043E\u043C\u0430\u043D\u0434\u0435\u043D \u0440\u0435\u0436\u0438\u043C \u043D\u0430 \u043B\u0430\u0442\u0435\u043A\u0441",
    "keyboard.tooltip.numeric": "\u0427\u0438\u0441\u043B\u043E\u0432\u0438",
    "keyboard.tooltip.roman": "\u0420\u0438\u043C\u0441\u043A\u0438 \u0431\u0443\u043A\u0432\u0438",
    "tooltip.copy to clipboard": "\u041A\u043E\u043F\u0438\u0440\u0430\u043D\u0435 \u0432 \u043A\u043B\u0438\u043F\u0431\u043E\u0440\u0434\u0430",
    "tooltip.redo": "\u041F\u043E\u0432\u0442\u043E\u0440\u043D\u043E",
    "tooltip.toggle virtual keyboard": "\u041F\u0440\u0435\u0432\u043A\u043B\u044E\u0447\u0432\u0430\u043D\u0435 \u043D\u0430 \u0432\u0438\u0440\u0442\u0443\u0430\u043B\u043D\u0430 \u043A\u043B\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u0430",
    "tooltip.undo": "\u041E\u0442\u043C\u044F\u043D\u0430",
    "menu.insert matrix": "\u0412\u043C\u044A\u043A\u0432\u0430\u043D\u0435 \u043D\u0430 \u043C\u0430\u0442\u0440\u0438\u0446\u0430",
    "menu.insert vector": "\u0412\u043C\u044A\u043A\u0432\u0430\u043D\u0435 \u043D\u0430 \u0432\u0435\u043A\u0442\u043E\u0440",
    "submenu.array.matrix delimiters": "\u041C\u0430\u0442\u0440\u0438\u0447\u043D\u0438 \u0440\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u0438",
    "menu.array.add row above": "\u0414\u043E\u0431\u0430\u0432\u044F\u043D\u0435 \u043D\u0430 \u0440\u0435\u0434 \u0441\u043B\u0435\u0434",
    "menu.array.add row below": "\u0414\u043E\u0431\u0430\u0432\u044F\u043D\u0435 \u043D\u0430 \u0440\u0435\u0434 \u043F\u0440\u0435\u0434\u0438",
    "menu.array.add column after": "\u0414\u043E\u0431\u0430\u0432\u044F\u043D\u0435 \u043D\u0430 \u043A\u043E\u043B\u043E\u043D\u0430 \u0441\u043B\u0435\u0434",
    "menu.array.add column before": "\u0414\u043E\u0431\u0430\u0432\u044F\u043D\u0435 \u043D\u0430 \u043A\u043E\u043B\u043E\u043D\u0430 \u043F\u0440\u0435\u0434\u0438",
    "menu.array.delete row": "\u0418\u0437\u0442\u0440\u0438\u0432\u0430\u043D\u0435 \u043D\u0430 \u0440\u0435\u0434\u0430",
    "menu.array.delete rows": "\u0418\u0437\u0442\u0440\u0438\u0432\u0430\u043D\u0435 \u043D\u0430 \u0438\u0437\u0431\u0440\u0430\u043D\u0438\u0442\u0435 \u0440\u0435\u0434\u043E\u0432\u0435",
    "menu.array.delete column": "\u0418\u0437\u0442\u0440\u0438\u0432\u0430\u043D\u0435 \u043D\u0430 \u043A\u043E\u043B\u043E\u043D\u0430",
    "menu.array.delete columns": "\u0418\u0437\u0442\u0440\u0438\u0432\u0430\u043D\u0435 \u043D\u0430 \u0438\u0437\u0431\u0440\u0430\u043D\u0438\u0442\u0435 \u043A\u043E\u043B\u043E\u043D\u0438",
    "submenu.array.insert separator": "\u041F\u043E\u0441\u0442\u0430\u0432\u0435\u0442\u0435 \u0440\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B",
    "menu.insert table": "\u0412\u043C\u044A\u043A\u0432\u0430\u043D\u0435 \u043D\u0430 \u0442\u0430\u0431\u043B\u0438\u0446\u0430",
    "submenu.table style": "\u0422\u0430\u0431\u043B\u0438\u0447\u0435\u043D \u0441\u0442\u0438\u043B"
  },
  bs: {
    "keyboard.tooltip.functions": "Funkcije",
    "keyboard.tooltip.symbols": "Simboli",
    "keyboard.tooltip.greek": "Gr\u010Dka slova",
    "keyboard.tooltip.command": "LaTeX naredbeni na\u010Din",
    "keyboard.tooltip.numeric": "Numeri\u010Dki",
    "keyboard.tooltip.roman": "Rimska slova",
    "tooltip.copy to clipboard": "Kopirati u clipboard",
    "tooltip.redo": "Ponovi",
    "tooltip.toggle virtual keyboard": "Uklju\u010Di / isklju\u010Di virtualnu tipkovnicu",
    "tooltip.undo": "Poni\u0161ti",
    "menu.insert matrix": "Umetni matricu",
    "menu.insert vector": "Umetni vektor",
    "submenu.array.matrix delimiters": "Matri\u010Dni razdjelnici",
    "menu.array.add row above": "Dodaj redak nakon",
    "menu.array.add row below": "Dodaj red prije",
    "menu.array.add column after": "Dodaj stupac nakon",
    "menu.array.add column before": "Dodaj stupac prije",
    "menu.array.delete row": "Izbri\u0161i red",
    "menu.array.delete rows": "Izbri\u0161i odabrane redove",
    "menu.array.delete column": "Izbri\u0161i stupac",
    "menu.array.delete columns": "Izbri\u0161i odabrane stupce",
    "submenu.array.insert separator": "Umetni separator",
    "menu.insert table": "Ubaci tabelu",
    "submenu.table style": "Stil tabele"
  },
  cs: {
    "keyboard.tooltip.functions": "Funkce",
    "keyboard.tooltip.symbols": "Symboly",
    "keyboard.tooltip.greek": "\u0158eck\xE9 dopisy",
    "keyboard.tooltip.command": "P\u0159\xEDkazov\xFD re\u017Eim LaTeX",
    "keyboard.tooltip.numeric": "\u010C\xEDseln\xE9",
    "keyboard.tooltip.roman": "\u0158\xEDmsk\xE9 dopisy",
    "tooltip.copy to clipboard": "Zkop\xEDrovat do schr\xE1nky",
    "tooltip.redo": "P\u0159ed\u011Blat",
    "tooltip.toggle virtual keyboard": "P\u0159epnout virtu\xE1ln\xED kl\xE1vesnici",
    "tooltip.undo": "Vr\xE1tit",
    "menu.insert matrix": "Vlo\u017Ete matici",
    "menu.insert vector": "Vlo\u017Eit vektor",
    "submenu.array.matrix delimiters": "Odd\u011Blova\u010De matic",
    "menu.array.add row above": "P\u0159idat \u0159\xE1dek za",
    "menu.array.add row below": "P\u0159idat \u0159\xE1dek p\u0159ed",
    "menu.array.add column after": "P\u0159idat sloupec za",
    "menu.array.add column before": "P\u0159idat sloupec d\u0159\xEDve",
    "menu.array.delete row": "Odstranit \u0159\xE1dek",
    "menu.array.delete rows": "Odstranit vybran\xE9 \u0159\xE1dky",
    "menu.array.delete column": "Odstranit sloupec",
    "menu.array.delete columns": "Odstranit vybran\xE9 sloupce",
    "submenu.array.insert separator": "Vlo\u017Ete odd\u011Blova\u010D",
    "menu.insert table": "Vlo\u017Eit tabulku",
    "submenu.table style": "Styl tabulky"
  },
  da: {
    "keyboard.tooltip.functions": "Funktioner",
    "keyboard.tooltip.symbols": "Symboler",
    "keyboard.tooltip.greek": "Gr\xE6ske bogstaver",
    "keyboard.tooltip.command": "LaTeX kommandotilstand",
    "keyboard.tooltip.numeric": "Numerisk",
    "keyboard.tooltip.roman": "Romerske breve",
    "tooltip.copy to clipboard": "Kopier til udklipsholder",
    "tooltip.redo": "Gentag igen",
    "tooltip.toggle virtual keyboard": "Skift virtuelt tastatur",
    "tooltip.undo": "Fortryd",
    "menu.insert matrix": "Inds\xE6t matrix",
    "menu.insert vector": "Inds\xE6t vektor",
    "submenu.array.matrix delimiters": "Matrixafgr\xE6nsere",
    "menu.array.add row above": "Tilf\xF8j r\xE6kke efter",
    "menu.array.add row below": "Tilf\xF8j r\xE6kke f\xF8r",
    "menu.array.add column after": "Tilf\xF8j kolonne efter",
    "menu.array.add column before": "Tilf\xF8j kolonne f\xF8r",
    "menu.array.delete row": "Slet r\xE6kke",
    "menu.array.delete rows": "Slet valgte r\xE6kker",
    "menu.array.delete column": "Slet kolonne",
    "menu.array.delete columns": "Slet valgte kolonner",
    "submenu.array.insert separator": "Inds\xE6t separator",
    "menu.insert table": "Inds\xE6t tabel",
    "submenu.table style": "Tabelstil"
  },
  de: {
    "keyboard.tooltip.functions": "Funktionen",
    "keyboard.tooltip.symbols": "Symbole",
    "keyboard.tooltip.greek": "Griechische Buchstaben",
    "keyboard.tooltip.command": "LaTeX-Befehlsmodus",
    "keyboard.tooltip.numeric": "Numerisch",
    "keyboard.tooltip.roman": "R\xF6mische Buchstaben",
    "tooltip.copy to clipboard": "In die Zwischenablage kopieren",
    "tooltip.redo": "Wiederholen",
    "tooltip.toggle virtual keyboard": "Virtuelle Tastatur umschalten",
    "tooltip.undo": "Widerrufen",
    "menu.insert matrix": "Matrix einf\xFCgen",
    "menu.insert vector": "Vektor einf\xFCgen",
    "submenu.array.matrix delimiters": "Matrixtrennzeichen",
    "menu.array.add row above": "Zeile hinzuf\xFCgen nach",
    "menu.array.add row below": "Zeile hinzuf\xFCgen vor",
    "menu.array.add column after": "Spalte hinzuf\xFCgen nach",
    "menu.array.add column before": "Spalte hinzuf\xFCgen vor",
    "menu.array.delete row": "Zeile l\xF6schen",
    "menu.array.delete rows": "Ausgew\xE4hlte Zeilen l\xF6schen",
    "menu.array.delete column": "Spalte l\xF6schen",
    "menu.array.delete columns": "Ausgew\xE4hlte Spalten l\xF6schen",
    "submenu.array.insert separator": "Trennzeichen einf\xFCgen",
    "menu.insert table": "Tabelle einf\xFCgen",
    "submenu.table style": "Tabellenstil"
  },
  el: {
    "keyboard.tooltip.functions": "\u03C3\u03C5\u03BD\u03B1\u03C1\u03C4\u03AE\u03C3\u03B5\u03B9\u03C2",
    "keyboard.tooltip.symbols": "\u03C3\u03CD\u03BC\u03B2\u03BF\u03BB\u03B1",
    "keyboard.tooltip.greek": "\u03B5\u03BB\u03BB\u03B7\u03BD\u03B9\u03BA\u03AC \u03B3\u03C1\u03AC\u03BC\u03BC\u03B1\u03C4\u03B1",
    "keyboard.tooltip.command": "\u039B\u03B5\u03B9\u03C4\u03BF\u03C5\u03C1\u03B3\u03AF\u03B1 \u03B5\u03BD\u03C4\u03BF\u03BB\u03CE\u03BD LaTeX",
    "keyboard.tooltip.numeric": "\u0391\u03C1\u03B9\u03B8\u03BC\u03B7\u03C4\u03B9\u03BA\u03CC\u03C2",
    "keyboard.tooltip.roman": "\u03A1\u03C9\u03BC\u03B1\u03CA\u03BA\u03AC \u03B3\u03C1\u03AC\u03BC\u03BC\u03B1\u03C4\u03B1",
    "tooltip.copy to clipboard": "\u0391\u03BD\u03C4\u03B9\u03B3\u03C1\u03B1\u03C6\u03AE \u03C3\u03C4\u03BF \u03C0\u03C1\u03CC\u03C7\u03B5\u03B9\u03C1\u03BF",
    "tooltip.redo": "\u039E\u03B1\u03BD\u03B1\u03BA\u03AC\u03BD\u03C9",
    "tooltip.toggle virtual keyboard": "\u0395\u03BD\u03B1\u03BB\u03BB\u03B1\u03B3\u03AE \u03B5\u03B9\u03BA\u03BF\u03BD\u03B9\u03BA\u03BF\u03CD \u03C0\u03BB\u03B7\u03BA\u03C4\u03C1\u03BF\u03BB\u03BF\u03B3\u03AF\u03BF\u03C5",
    "tooltip.undo": "\u039E\u03B5\u03BA\u03AC\u03BD\u03C9",
    "menu.insert matrix": "\u0395\u03B9\u03C3\u03B1\u03B3\u03C9\u03B3\u03AE Matrix",
    "menu.insert vector": "\u0395\u03B9\u03C3\u03B1\u03B3\u03C9\u03B3\u03AE \u03B4\u03B9\u03B1\u03BD\u03CD\u03C3\u03BC\u03B1\u03C4\u03BF\u03C2",
    "submenu.array.matrix delimiters": "\u039F\u03C1\u03B9\u03BF\u03B8\u03AD\u03C4\u03B5\u03C2 Matrix",
    "menu.array.add row above": "\u03A0\u03C1\u03BF\u03C3\u03B8\u03AE\u03BA\u03B7 \u03C3\u03B5\u03B9\u03C1\u03AC\u03C2 \u03BC\u03B5\u03C4\u03AC",
    "menu.array.add row below": "\u03A0\u03C1\u03BF\u03C3\u03B8\u03AE\u03BA\u03B7 \u03C3\u03B5\u03B9\u03C1\u03AC\u03C2 \u03C0\u03C1\u03B9\u03BD",
    "menu.array.add column after": "\u03A0\u03C1\u03BF\u03C3\u03B8\u03AE\u03BA\u03B7 \u03C3\u03C4\u03AE\u03BB\u03B7\u03C2 \u03BC\u03B5\u03C4\u03AC",
    "menu.array.add column before": "\u03A0\u03C1\u03BF\u03C3\u03B8\u03AE\u03BA\u03B7 \u03C3\u03C4\u03AE\u03BB\u03B7\u03C2 \u03C0\u03C1\u03B9\u03BD",
    "menu.array.delete row": "\u0394\u03B9\u03B1\u03B3\u03C1\u03B1\u03C6\u03AE \u03C3\u03B5\u03B9\u03C1\u03AC\u03C2",
    "menu.array.delete rows": "\u0394\u03B9\u03B1\u03B3\u03C1\u03B1\u03C6\u03AE \u03B5\u03C0\u03B9\u03BB\u03B5\u03B3\u03BC\u03AD\u03BD\u03C9\u03BD \u03C3\u03B5\u03B9\u03C1\u03CE\u03BD",
    "menu.array.delete column": "\u0394\u03B9\u03B1\u03B3\u03C1\u03B1\u03C6\u03AE \u03C3\u03C4\u03AE\u03BB\u03B7\u03C2",
    "menu.array.delete columns": "\u0394\u03B9\u03B1\u03B3\u03C1\u03B1\u03C6\u03AE \u03B5\u03C0\u03B9\u03BB\u03B5\u03B3\u03BC\u03AD\u03BD\u03C9\u03BD \u03C3\u03C4\u03B7\u03BB\u03CE\u03BD",
    "submenu.array.insert separator": "\u0395\u03B9\u03C3\u03B1\u03B3\u03C9\u03B3\u03AE \u03B4\u03B9\u03B1\u03C7\u03C9\u03C1\u03B9\u03C3\u03C4\u03B9\u03BA\u03BF\u03CD",
    "menu.insert table": "\u0395\u03B9\u03C3\u03B1\u03B3\u03C9\u03B3\u03AE \u03C0\u03AF\u03BD\u03B1\u03BA\u03B1",
    "submenu.table style": "\u03A3\u03C4\u03C5\u03BB \u03C0\u03AF\u03BD\u03B1\u03BA\u03B1"
  },
  es: {
    "keyboard.tooltip.functions": "Funciones",
    "keyboard.tooltip.symbols": "S\xEDmbolos",
    "keyboard.tooltip.greek": "Letras griegas",
    "keyboard.tooltip.command": "Modo Comando LaTeX",
    "keyboard.tooltip.numeric": "Num\xE9rico",
    "keyboard.tooltip.roman": "Letras romanas",
    "tooltip.copy to clipboard": "Copiar al portapapeles",
    "tooltip.redo": "Rehacer",
    "tooltip.toggle virtual keyboard": "Alternar teclado virtual",
    "tooltip.undo": "Deshacer",
    "menu.insert matrix": "A\xF1adir Matriz",
    "menu.insert vector": "A\xF1adir vector",
    "submenu.array.matrix delimiters": "Delimitadores de Matriz",
    "menu.array.add row above": "A\xF1adir L\xEDnea Antes",
    "menu.array.add row below": "A\xF1adir L\xEDnea Despues",
    "menu.array.add column after": "A\xF1adir Columna Despues",
    "menu.array.add column before": "A\xF1adir Columna Antes",
    "menu.array.delete row": "Borrar L\xEDnea",
    "menu.array.delete rows": "Borrar L\xEDneas Seleccionadas",
    "menu.array.delete column": "Borrar Columna",
    "menu.array.delete columns": "Borrar Columnas Seleccionadas",
    "submenu.array.insert separator": "Insertar un Separador",
    "menu.insert table": "Insertar Tabla",
    "submenu.table style": "Estilo de Tabla"
  },
  et: {
    "keyboard.tooltip.functions": "Funktsioonid",
    "keyboard.tooltip.symbols": "S\xFCmbolid",
    "keyboard.tooltip.greek": "Kreeka kirjad",
    "keyboard.tooltip.command": "LaTeXi k\xE4sure\u017Eiim",
    "keyboard.tooltip.numeric": "Numbriline",
    "keyboard.tooltip.roman": "Rooma kirjad",
    "tooltip.copy to clipboard": "Kopeerida l\xF5ikelauale",
    "tooltip.redo": "Tee uuesti",
    "tooltip.toggle virtual keyboard": "L\xFClitage sisse virtuaalne klaviatuur",
    "tooltip.undo": "V\xF5ta tagasi",
    "menu.insert matrix": "Sisesta maatriks",
    "menu.insert vector": "Sisesta vektor",
    "submenu.array.matrix delimiters": "Maatriksi eraldajad",
    "menu.array.add row above": "Lisa rida p\xE4rast",
    "menu.array.add row below": "Lisa rida enne",
    "menu.array.add column after": "Lisa veerg p\xE4rast",
    "menu.array.add column before": "Lisa veerg enne",
    "menu.array.delete row": "Kustuta rida",
    "menu.array.delete rows": "Kustuta valitud read",
    "menu.array.delete column": "Kustuta veerg",
    "menu.array.delete columns": "Kustuta valitud veerud",
    "submenu.array.insert separator": "Sisestage eraldaja",
    "menu.insert table": "Sisesta tabeli",
    "submenu.table style": "Tabeli stiilis"
  },
  fa: {
    "keyboard.tooltip.functions": "\u062A\u0648\u0627\u0628\u0639",
    "keyboard.tooltip.symbols": "\u0646\u0645\u0627\u062F\u0647\u0627",
    "keyboard.tooltip.greek": "\u062D\u0631\u0648\u0641 \u06CC\u0648\u0646\u0627\u0646\u06CC",
    "keyboard.tooltip.command": "\u062D\u0627\u0644\u062A \u062F\u0633\u062A\u0648\u0631 \u0644\u0627\u062A\u06A9",
    "keyboard.tooltip.numeric": "\u0639\u062F\u062F\u06CC",
    "keyboard.tooltip.roman": "\u062D\u0631\u0648\u0641 \u0631\u0648\u0645\u06CC",
    "tooltip.copy to clipboard": "\u06A9\u067E\u06CC \u0628\u0647 \u06A9\u0644\u06CC\u067E\u0628\u0648\u0631\u062F",
    "tooltip.redo": "\u0628\u0627\u0632\u06AF\u0634\u062A \u0628\u0647 \u0628\u0639\u062F",
    "tooltip.toggle virtual keyboard": "\u0646\u0645\u0627\u06CC\u0634/\u0646\u0647\u0641\u062A\u0646 \u06A9\u06CC\u0628\u0648\u0631\u062F \u0645\u062C\u0627\u0632\u06CC",
    "tooltip.undo": "\u0628\u0627\u0632\u06AF\u0634\u062A \u0628\u0647 \u0642\u0628\u0644",
    "menu.insert matrix": "\u0645\u0627\u062A\u0631\u06CC\u0633 \u0631\u0627 \u0648\u0627\u0631\u062F \u06A9\u0646\u06CC\u062F",
    "menu.insert vector": "\u062F\u0631\u062C \u0628\u0631\u062F\u0627\u0631",
    "submenu.array.matrix delimiters": "\u0645\u0631\u0632\u0647\u0627\u06CC \u0645\u0627\u062A\u0631\u06CC\u0633",
    "menu.array.add row above": "\u0628\u0639\u062F \u0627\u0632 \u0622\u0646 \u0631\u062F\u06CC\u0641 \u0627\u0636\u0627\u0641\u0647 \u06A9\u0646\u06CC\u062F",
    "menu.array.add row below": "\u0631\u062F\u06CC\u0641 \u0631\u0627 \u0642\u0628\u0644 \u0627\u0636\u0627\u0641\u0647 \u06A9\u0646\u06CC\u062F",
    "menu.array.add column after": "\u0627\u0636\u0627\u0641\u0647 \u06A9\u0631\u062F\u0646 \u0633\u062A\u0648\u0646 \u0628\u0639\u062F",
    "menu.array.add column before": "\u0633\u062A\u0648\u0646 \u0642\u0628\u0644 \u0631\u0627 \u0627\u0636\u0627\u0641\u0647 \u06A9\u0646\u06CC\u062F",
    "menu.array.delete row": "\u0631\u062F\u06CC\u0641 \u0631\u0627 \u062D\u0630\u0641 \u06A9\u0646\u06CC\u062F",
    "menu.array.delete rows": "\u0631\u062F\u06CC\u0641 \u0647\u0627\u06CC \u0627\u0646\u062A\u062E\u0627\u0628 \u0634\u062F\u0647 \u0631\u0627 \u062D\u0630\u0641 \u06A9\u0646\u06CC\u062F",
    "menu.array.delete column": "\u062D\u0630\u0641 \u0633\u062A\u0648\u0646",
    "menu.array.delete columns": "\u0633\u062A\u0648\u0646 \u0647\u0627\u06CC \u0627\u0646\u062A\u062E\u0627\u0628 \u0634\u062F\u0647 \u0631\u0627 \u062D\u0630\u0641 \u06A9\u0646\u06CC\u062F",
    "submenu.array.insert separator": "\u062F\u0631\u062C \u062C\u062F\u0627 \u06A9\u0646\u0646\u062F\u0647",
    "menu.insert table": "\u0642\u0631\u0627\u0631 \u062F\u0627\u062F\u0646 \u062C\u062F\u0648\u0644",
    "submenu.table style": "\u0633\u0628\u06A9 \u0645\u06CC\u0632"
  },
  fi: {
    "keyboard.tooltip.functions": "Toiminnot",
    "keyboard.tooltip.symbols": "Symbolit",
    "keyboard.tooltip.greek": "Kreikkalaiset kirjeet",
    "keyboard.tooltip.command": "LaTeX-komentotila",
    "keyboard.tooltip.numeric": "Numeerinen",
    "keyboard.tooltip.roman": "Roomalaiset kirjeet",
    "tooltip.copy to clipboard": "Kopioi leikep\xF6yd\xE4lle",
    "tooltip.redo": "Tee uudelleen",
    "tooltip.toggle virtual keyboard": "Vaihda virtuaalin\xE4pp\xE4imist\xF6",
    "tooltip.undo": "Kumoa",
    "menu.insert matrix": "Lis\xE4\xE4 matriisi",
    "menu.insert vector": "Lis\xE4\xE4 vektori",
    "submenu.array.matrix delimiters": "Matriisin erottimet",
    "menu.array.add row above": "Lis\xE4\xE4 rivi j\xE4lkeen",
    "menu.array.add row below": "Lis\xE4\xE4 rivi ennen",
    "menu.array.add column after": "Lis\xE4\xE4 sarake j\xE4lkeen",
    "menu.array.add column before": "Lis\xE4\xE4 sarake ennen",
    "menu.array.delete row": "Poista rivi",
    "menu.array.delete rows": "Poista valitut rivit",
    "menu.array.delete column": "Poista sarake",
    "menu.array.delete columns": "Poista valitut sarakkeet",
    "submenu.array.insert separator": "Aseta erotin",
    "menu.insert table": "Lis\xE4\xE4 taulukko",
    "submenu.table style": "Taulukon tyyli"
  },
  fr: {
    "keyboard.tooltip.functions": "Fonctions",
    "keyboard.tooltip.symbols": "Symboles",
    "keyboard.tooltip.greek": "Lettres grecques",
    "keyboard.tooltip.command": "Mode de commandes LaTeX",
    "keyboard.tooltip.numeric": "Num\xE9rique",
    "keyboard.tooltip.roman": "Lettres romaines",
    "tooltip.copy to clipboard": "Copier dans le presse-papiers",
    "tooltip.redo": "R\xE9tablir",
    "tooltip.toggle virtual keyboard": "Afficher/Masquer le clavier virtuel",
    "tooltip.undo": "Annuler",
    "menu.insert matrix": "Ins\xE9rer une Matrice",
    "menu.insert vector": "Ins\xE9rer un Vecteur",
    "submenu.array.matrix delimiters": "D\xE9limiteurs de la Matrice",
    "menu.array.add row above": "Ajouter une Ligne Avant",
    "menu.array.add row below": "Ajouter une Ligne Apr\xE8s",
    "menu.array.add column before": "Ajouter une Colonne Avant",
    "menu.array.add column after": "Ajouter une Colonne Apr\xE8s",
    "menu.array.delete row": "Enlever une Ligne",
    "menu.array.delete rows": "Enlever les Lignes S\xE9lection\xE9es",
    "menu.array.delete column": "Enlever une Colone",
    "menu.array.delete columns": "Enlever les Colonnes S\xE9lection\xE9es",
    "submenu.array.insert separator": "Ins\xE9rer un S\xE9parateur",
    "menu.insert table": "Ins\xE9rer une Table",
    "submenu.table style": "Style de la  Table"
  },
  ga: {
    "keyboard.tooltip.functions": "Feidhmeanna",
    "keyboard.tooltip.symbols": "Siombail\xED",
    "keyboard.tooltip.greek": "Litreacha na Gr\xE9ige",
    "keyboard.tooltip.command": "M\xF3d Ord\xFA LaTeX",
    "keyboard.tooltip.numeric": "Uimhri\xFAil",
    "keyboard.tooltip.roman": "Litreacha R\xF3mh\xE1nacha",
    "tooltip.copy to clipboard": "C\xF3ipe\xE1il chuig an Ghearrthaisce",
    "tooltip.redo": "Athdh\xE9an",
    "tooltip.toggle virtual keyboard": "M\xE9archl\xE1ir F\xEDor\xFAil a Fh\xE1il",
    "tooltip.undo": "Cealaigh",
    "menu.insert matrix": "Cuir isteach Maitr\xEDs",
    "menu.insert vector": "Cuir isteach Veicteoir",
    "submenu.array.matrix delimiters": "Delimiters Maitr\xEDs",
    "menu.array.add row above": "Cuir Rae Tar \xE9is",
    "menu.array.add row below": "Cuir Rae Roimh",
    "menu.array.add column after": "Cuir Col\xFAn Tar \xE9is",
    "menu.array.add column before": "Cuir Col\xFAn Roimh",
    "menu.array.delete row": "Scrios Rae",
    "menu.array.delete rows": "Scrios Sraitheanna Roghnaithe",
    "menu.array.delete column": "Scrios Col\xFAn",
    "menu.array.delete columns": "Scrios Col\xFAin Roghnaithe",
    "submenu.array.insert separator": "Cuir Deighilteoir isteach",
    "menu.insert table": "Ions\xE1igh T\xE1bla",
    "submenu.table style": "St\xEDl T\xE1bla"
  },
  he: {
    "keyboard.tooltip.functions": "\u05E4\u05D5\u05E0\u05E7\u05E6\u05D9\u05D5\u05EA",
    "keyboard.tooltip.symbols": "\u05E1\u05DE\u05DC\u05D9\u05DD",
    "keyboard.tooltip.greek": "\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA \u05D9\u05D5\u05D5\u05E0\u05D9\u05D5\u05EA",
    "keyboard.tooltip.command": "\u05DE\u05E6\u05D1 \u05E4\u05E7\u05D5\u05D3\u05D4 \u05DC\u05D8\u05E7\u05E1",
    "keyboard.tooltip.numeric": "\u05DE\u05E1\u05E4\u05E8\u05D9",
    "keyboard.tooltip.roman": "\u05DE\u05DB\u05EA\u05D1\u05D9\u05DD \u05E8\u05D5\u05DE\u05D9\u05D9\u05DD",
    "tooltip.copy to clipboard": "\u05D4\u05E2\u05EA\u05E7 \u05DC\u05DC\u05D5\u05D7",
    "tooltip.redo": "\u05DC\u05B7\u05E2\u05B2\u05E9\u05C2\u05D5\u05B9\u05EA \u05E9\u05C1\u05D5\u05BC\u05D1",
    "tooltip.toggle virtual keyboard": "\u05D4\u05D7\u05DC\u05E3 \u05D0\u05EA \u05D4\u05DE\u05E7\u05DC\u05D3\u05EA \u05D4\u05D5\u05D5\u05D9\u05E8\u05D8\u05D5\u05D0\u05DC\u05D9\u05EA",
    "tooltip.undo": "\u05DC\u05D1\u05D8\u05DC",
    "menu.insert matrix": "\u05D4\u05DB\u05E0\u05E1 \u05DE\u05D8\u05E8\u05D9\u05E7\u05E1",
    "menu.insert vector": "\u05D4\u05DB\u05E0\u05E1 \u05D5\u05E7\u05D8\u05D5\u05E8",
    "submenu.array.matrix delimiters": "\u05DE\u05E4\u05E8\u05D9\u05D3\u05D9 \u05DE\u05D8\u05E8\u05D9\u05E7\u05E1",
    "menu.array.add row above": "\u05D4\u05D5\u05E1\u05E3 \u05E9\u05D5\u05E8\u05D4 \u05D0\u05D7\u05E8\u05D9",
    "menu.array.add row below": "\u05D4\u05D5\u05E1\u05E3 \u05E9\u05D5\u05E8\u05D4 \u05DC\u05E4\u05E0\u05D9",
    "menu.array.add column after": "\u05D4\u05D5\u05E1\u05E3 \u05E2\u05DE\u05D5\u05D3\u05D4 \u05D0\u05D7\u05E8\u05D9",
    "menu.array.add column before": "\u05D4\u05D5\u05E1\u05E3 \u05E2\u05DE\u05D5\u05D3\u05D4 \u05DC\u05E4\u05E0\u05D9",
    "menu.array.delete row": "\u05DE\u05D7\u05E7 \u05E9\u05D5\u05E8\u05D4",
    "menu.array.delete rows": "\u05DE\u05D7\u05E7 \u05E9\u05D5\u05E8\u05D5\u05EA \u05E9\u05E0\u05D1\u05D7\u05E8\u05D5",
    "menu.array.delete column": "\u05DE\u05D7\u05E7 \u05E2\u05DE\u05D5\u05D3\u05D4",
    "menu.array.delete columns": "\u05DE\u05D7\u05E7 \u05E2\u05DE\u05D5\u05D3\u05D5\u05EA \u05E9\u05E0\u05D1\u05D7\u05E8\u05D5",
    "submenu.array.insert separator": "\u05D4\u05DB\u05E0\u05E1 \u05DE\u05E4\u05E8\u05D9\u05D3",
    "menu.insert table": "\u05D4\u05DB\u05E0\u05E1 \u05D8\u05D1\u05DC\u05D4",
    "submenu.table style": "\u05D8\u05D1\u05DC\u05D4 \u05E1\u05B4\u05D2\u05B0\u05E0\u05D5\u05B9\u05DF"
  },
  hr: {
    "keyboard.tooltip.functions": "Funkcije",
    "keyboard.tooltip.symbols": "Simboli",
    "keyboard.tooltip.greek": "Gr\u010Dka slova",
    "keyboard.tooltip.command": "LaTeX naredbeni na\u010Din",
    "keyboard.tooltip.numeric": "Numeri\u010Dki",
    "keyboard.tooltip.roman": "Rimska slova",
    "tooltip.copy to clipboard": "Kopirati u me\u0111uspremnik",
    "tooltip.redo": "Ponovi",
    "tooltip.toggle virtual keyboard": "Uklju\u010Di / isklju\u010Di virtualnu tipkovnicu",
    "tooltip.undo": "Poni\u0161ti",
    "menu.insert matrix": "Umetni matricu",
    "menu.insert vector": "Umetni vektor",
    "submenu.array.matrix delimiters": "Matri\u010Dni razdjelnici",
    "menu.array.add row above": "Dodaj redak nakon",
    "menu.array.add row below": "Dodaj redak prije",
    "menu.array.add column after": "Dodaj stupac nakon",
    "menu.array.add column before": "Dodaj stupac prije",
    "menu.array.delete row": "Izbri\u0161i redak",
    "menu.array.delete rows": "Izbri\u0161i odabrane retke",
    "menu.array.delete column": "Izbri\u0161i stupac",
    "menu.array.delete columns": "Izbri\u0161i odabrane stupce",
    "submenu.array.insert separator": "Umetni separator",
    "menu.insert table": "Umetni tablicu",
    "submenu.table style": "Stil tabele"
  },
  id: {
    "keyboard.tooltip.functions": "Fungsi",
    "keyboard.tooltip.symbols": "Simbol",
    "keyboard.tooltip.greek": "Huruf Yunani",
    "keyboard.tooltip.command": "Mode Perintah LaTeX",
    "keyboard.tooltip.numeric": "Numerik",
    "keyboard.tooltip.roman": "Surat Romawi",
    "tooltip.copy to clipboard": "Menyalin ke clipboard",
    "tooltip.redo": "Mengulangi",
    "tooltip.toggle virtual keyboard": "Alihkan Keyboard Virtual",
    "tooltip.undo": "Membuka",
    "menu.insert matrix": "Sisipkan Matriks",
    "menu.insert vector": "Sisipkan Vektor",
    "submenu.array.matrix delimiters": "Pembatas Matriks",
    "menu.array.add row above": "Tambahkan Baris Setelah",
    "menu.array.add row below": "Tambahkan Baris Sebelumnya",
    "menu.array.add column after": "Tambahkan Kolom Setelah",
    "menu.array.add column before": "Tambahkan Kolom Sebelumnya",
    "menu.array.delete row": "Hapus Baris",
    "menu.array.delete rows": "Hapus Baris yang Dipilih",
    "menu.array.delete column": "Hapus Kolom",
    "menu.array.delete columns": "Hapus Kolom yang Dipilih",
    "submenu.array.insert separator": "Sisipkan Pemisah",
    "menu.insert table": "Sisipkan Tabel",
    "submenu.table style": "Gaya Tabel"
  },
  hi: {
    "keyboard.tooltip.functions": "\u0915\u093E\u0930\u094D\u092F\u094B\u0902",
    "keyboard.tooltip.symbols": "\u092A\u094D\u0930\u0924\u0940\u0915",
    "keyboard.tooltip.greek": "\u0917\u094D\u0930\u0940\u0915 \u0905\u0915\u094D\u0937\u0930",
    "keyboard.tooltip.command": "\u0932\u093E\u091F\u0947\u0915\u094D\u0938 \u0915\u092E\u093E\u0902\u0921 \u092E\u094B\u0921",
    "keyboard.tooltip.numeric": "\u0938\u0902\u0916\u094D\u092F\u093E\u0924\u094D\u092E\u0915",
    "keyboard.tooltip.roman": "\u0930\u094B\u092E\u0928 \u092A\u0924\u094D\u0930",
    "tooltip.copy to clipboard": "\u0915\u094D\u0932\u093F\u092A\u092C\u094B\u0930\u094D\u0921 \u092A\u0930 \u0915\u0949\u092A\u0940 \u0915\u0930\u0947\u0902",
    "tooltip.redo": "\u092B\u093F\u0930 \u0938\u0947 \u0915\u0930\u0947\u0902",
    "tooltip.toggle virtual keyboard": "\u0935\u0930\u094D\u091A\u0941\u0905\u0932 \u0915\u0940\u092C\u094B\u0930\u094D\u0921 \u091F\u0949\u0917\u0932 \u0915\u0930\u0947\u0902",
    "tooltip.undo": "\u092A\u0942\u0930\u094D\u0935\u0935\u0924",
    "menu.insert matrix": "\u092E\u0948\u091F\u094D\u0930\u093F\u0915\u094D\u0938 \u0921\u093E\u0932\u0947\u0902",
    "menu.insert vector": "\u0935\u0947\u0915\u094D\u091F\u0930 \u0921\u093E\u0932\u0947\u0902",
    "submenu.array.matrix delimiters": "\u092E\u0948\u091F\u094D\u0930\u093F\u0915\u094D\u0938 \u0938\u0940\u092E\u093E\u0902\u0915\u0915",
    "menu.array.add row above": "\u092C\u093E\u0926 \u092E\u0947\u0902 \u092A\u0902\u0915\u094D\u0924\u093F \u091C\u094B\u0921\u093C\u0947\u0902",
    "menu.array.add row below": "\u092A\u0939\u0932\u0947 \u092A\u0902\u0915\u094D\u0924\u093F \u091C\u094B\u0921\u093C\u0947\u0902",
    "menu.array.add column after": "\u092C\u093E\u0926 \u092E\u0947\u0902 \u0915\u0949\u0932\u092E \u091C\u094B\u0921\u093C\u0947\u0902",
    "menu.array.add column before": "\u092A\u0939\u0932\u0947 \u0915\u0949\u0932\u092E \u091C\u094B\u0921\u093C\u0947\u0902",
    "menu.array.delete row": "\u092A\u0902\u0915\u094D\u0924\u093F \u0915\u094B \u0939\u091F\u093E\u090F\u0902",
    "menu.array.delete rows": "\u091A\u092F\u0928\u093F\u0924 \u092A\u0902\u0915\u094D\u0924\u093F\u092F\u094B\u0902 \u0915\u094B \u0939\u091F\u093E\u090F\u0902",
    "menu.array.delete column": "\u0915\u0949\u0932\u092E \u0939\u091F\u093E\u090F\u0902",
    "menu.array.delete columns": "\u091A\u092F\u0928\u093F\u0924 \u0915\u0949\u0932\u092E \u0939\u091F\u093E\u090F\u0902",
    "submenu.array.insert separator": "\u0935\u093F\u092D\u093E\u091C\u0915 \u0921\u093E\u0932\u0947\u0902",
    "menu.insert table": "\u091F\u0947\u092C\u0932 \u0907\u0902\u0938\u0930\u094D\u091F \u0915\u0930\u0947\u0902",
    "submenu.table style": "\u091F\u0947\u092C\u0932 \u0938\u094D\u091F\u093E\u0907\u0932"
  },
  hu: {
    "keyboard.tooltip.functions": "Funkci\xF3k",
    "keyboard.tooltip.symbols": "Szimb\xF3lumok",
    "keyboard.tooltip.greek": "G\xF6r\xF6g levelek",
    "keyboard.tooltip.command": "LaTeX Parancs m\xF3d",
    "keyboard.tooltip.numeric": "Numerikus",
    "keyboard.tooltip.roman": "R\xF3mai levelek",
    "tooltip.copy to clipboard": "M\xE1solja a v\xE1g\xF3lapra",
    "tooltip.redo": "\xDAjra",
    "tooltip.toggle virtual keyboard": "V\xE1lt\xE1s a virtu\xE1lis billenty\u0171zetre",
    "tooltip.undo": "Visszavon\xE1s",
    "menu.insert matrix": "Helyezze be a M\xE1trixot",
    "menu.insert vector": "Vektor besz\xFAr\xE1sa",
    "submenu.array.matrix delimiters": "M\xE1trixhat\xE1rol\xF3k",
    "menu.array.add row above": "Sor hozz\xE1ad\xE1sa ut\xE1n",
    "menu.array.add row below": "Add Add Sor el\u0151tt",
    "menu.array.add column after": "Oszlop hozz\xE1ad\xE1sa ut\xE1n",
    "menu.array.add column before": "Add oszlop el\u0151tt",
    "menu.array.delete row": "Sor t\xF6rl\xE9se",
    "menu.array.delete rows": "Kijel\xF6lt sorok t\xF6rl\xE9se",
    "menu.array.delete column": "Oszlop t\xF6rl\xE9se",
    "menu.array.delete columns": "A kijel\xF6lt oszlopok t\xF6rl\xE9se",
    "submenu.array.insert separator": "Helyezze be az elv\xE1laszt\xF3t",
    "menu.insert table": "Helyezze be a t\xE1bl\xE1zatot",
    "submenu.table style": "T\xE1bl\xE1zatos st\xEDlus"
  },
  it: {
    "keyboard.tooltip.functions": "Funzioni",
    "keyboard.tooltip.symbols": "Simboli",
    "keyboard.tooltip.greek": "Lettere greche",
    "keyboard.tooltip.command": "Modalit\xE0 di comando LaTeX",
    "keyboard.tooltip.numeric": "Numerico",
    "keyboard.tooltip.roman": "Lettere romane",
    "tooltip.copy to clipboard": "Copia negli appunti",
    "tooltip.redo": "Rifare",
    "tooltip.toggle virtual keyboard": "Attiva / disattiva la tastiera virtuale",
    "tooltip.undo": "Disfare",
    "menu.insert matrix": "Inserisci una Matrice",
    "menu.insert vector": "Inserisci Vettore",
    "submenu.array.matrix delimiters": "Delimitatori di Matrice",
    "menu.array.add row above": "Aggiungi una Riga Prima",
    "menu.array.add row below": "Aggiungi una Riga Dopo",
    "menu.array.add column before": "Aggiungi una Colonna Prima",
    "menu.array.add column after": "Aggiungi una Colonna Dopo",
    "menu.array.delete row": "Rimuovi una Riga",
    "menu.array.delete rows": "Rimuovi le Righe Selezionate",
    "menu.array.delete column": "Rimuovi una Colonna",
    "menu.array.delete columns": "Rimuovi le Colonne Selezionate",
    "submenu.array.insert separator": "Inserisci un Separatore",
    "menu.insert table": "Inserisci Tabella",
    "submenu.table style": "Stile tabella"
  },
  is: {
    "keyboard.tooltip.functions": "A\xF0ger\xF0ir",
    "keyboard.tooltip.symbols": "T\xE1kn",
    "keyboard.tooltip.greek": "Gr\xEDsk br\xE9f",
    "keyboard.tooltip.command": "LaTeX stj\xF3rnunarstilling",
    "keyboard.tooltip.numeric": "T\xF6lulegt",
    "keyboard.tooltip.roman": "R\xF3mversk br\xE9f",
    "tooltip.copy to clipboard": "Afrita\xF0u \xE1 klemmuspjald",
    "tooltip.redo": "Endurtaka",
    "tooltip.toggle virtual keyboard": "Skiptu um s\xFDndarlyklabor\xF0",
    "tooltip.undo": "Afturkalla",
    "menu.insert matrix": "Settu fylki inn",
    "menu.insert vector": "Settu inn Vector",
    "submenu.array.matrix delimiters": "Matrix afm\xF6rkun",
    "menu.array.add row above": "B\xE6ta vi\xF0 r\xF6\xF0 \xE1 eftir",
    "menu.array.add row below": "B\xE6ta vi\xF0 r\xF6\xF0 \xE1\xF0ur",
    "menu.array.add column after": "B\xE6ta vi\xF0 d\xE1lki \xE1 eftir",
    "menu.array.add column before": "B\xE6ta vi\xF0 d\xE1lki \xE1\xF0ur",
    "menu.array.delete row": "Ey\xF0a r\xF6\xF0",
    "menu.array.delete rows": "Ey\xF0a v\xF6ldum l\xEDnum",
    "menu.array.delete column": "Ey\xF0a d\xE1lki",
    "menu.array.delete columns": "Ey\xF0a v\xF6ldum d\xE1lkum",
    "submenu.array.insert separator": "Settu skiljuna \xED",
    "menu.insert table": "Settu inn t\xF6flu",
    "submenu.table style": "T\xF6flu st\xEDl"
  },
  ja: {
    "keyboard.tooltip.functions": "\u95A2\u6570",
    "keyboard.tooltip.symbols": "\u30B7\u30F3\u30DC\u30EB",
    "keyboard.tooltip.greek": "\u30AE\u30EA\u30B7\u30E3\u6587\u5B57",
    "keyboard.tooltip.command": "\u30E9\u30C6\u30C3\u30AF\u30B9\u30B3\u30DE\u30F3\u30C9\u30E2\u30FC\u30C9",
    "keyboard.tooltip.numeric": "\u6570\u5024",
    "keyboard.tooltip.roman": "\u30ED\u30FC\u30DE\u5B57",
    "tooltip.copy to clipboard": "\u30AF\u30EA\u30C3\u30D7\u30DC\u30FC\u30C9\u306B\u30B3\u30D4\u30FC",
    "tooltip.redo": "\u3084\u308A\u76F4\u3057",
    "tooltip.toggle virtual keyboard": "\u4EEE\u60F3\u30AD\u30FC\u30DC\u30FC\u30C9\u306E\u5207\u308A\u66FF\u3048",
    "tooltip.undo": "\u5143\u306B\u623B\u3059",
    "menu.insert matrix": "\u30DE\u30C8\u30EA\u30C3\u30AF\u30B9\u3092\u633F\u5165",
    "menu.insert vector": "\u30D9\u30AF\u30C8\u30EB\u3092\u633F\u5165",
    "submenu.array.matrix delimiters": "\u884C\u5217\u533A\u5207\u308A\u6587\u5B57",
    "menu.array.add row above": "\u5F8C\u306B\u884C\u3092\u8FFD\u52A0",
    "menu.array.add row below": "\u524D\u306B\u884C\u3092\u8FFD\u52A0",
    "menu.array.add column after": "\u5F8C\u306B\u5217\u3092\u8FFD\u52A0",
    "menu.array.add column before": "\u524D\u306B\u5217\u3092\u8FFD\u52A0",
    "menu.array.delete row": "\u884C\u3092\u524A\u9664",
    "menu.array.delete rows": "\u9078\u629E\u3057\u305F\u884C\u3092\u524A\u9664\u3059\u308B",
    "menu.array.delete column": "\u5217\u3092\u524A\u9664",
    "menu.array.delete columns": "\u9078\u629E\u3057\u305F\u5217\u3092\u524A\u9664\u3059\u308B",
    "submenu.array.insert separator": "\u30BB\u30D1\u30EC\u30FC\u30BF\u30FC\u3092\u633F\u5165",
    "menu.insert table": "\u30C6\u30FC\u30D6\u30EB\u3092\u633F\u5165",
    "submenu.table style": "\u30C6\u30FC\u30D6\u30EB\u30B9\u30BF\u30A4\u30EB"
  },
  ko: {
    "keyboard.tooltip.functions": "\uAE30\uB2A5",
    "keyboard.tooltip.symbols": "\uAE30\uD638",
    "keyboard.tooltip.greek": "\uADF8\uB9AC\uC2A4 \uBB38\uC790",
    "keyboard.tooltip.command": "\uC720\uC561 \uBA85\uB839 \uBAA8\uB4DC",
    "keyboard.tooltip.numeric": "\uC22B\uC790",
    "keyboard.tooltip.roman": "\uB85C\uB9C8 \uBB38\uC790",
    "tooltip.copy to clipboard": "\uD074\uB9BD \uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC",
    "tooltip.redo": "\uB2E4\uC2DC \uD558\uB2E4",
    "tooltip.toggle virtual keyboard": "\uAC00\uC0C1 \uD0A4\uBCF4\uB4DC \uC804\uD658",
    "tooltip.undo": "\uC2E4\uD589 \uCDE8\uC18C",
    "menu.insert matrix": "\uB9E4\uD2B8\uB9AD\uC2A4 \uC0BD\uC785",
    "menu.insert vector": "\uBCA1\uD130 \uC0BD\uC785",
    "submenu.array.matrix delimiters": "\uD589\uB82C \uAD6C\uBD84 \uAE30\uD638",
    "menu.array.add row above": "\uB4A4\uC5D0 \uD589 \uCD94\uAC00",
    "menu.array.add row below": "\uC55E\uC5D0 \uD589 \uCD94\uAC00",
    "menu.array.add column after": "\uB4A4\uC5D0 \uC5F4 \uCD94\uAC00",
    "menu.array.add column before": "\uC55E\uC5D0 \uC5F4 \uCD94\uAC00",
    "menu.array.delete row": "\uD589 \uC0AD\uC81C",
    "menu.array.delete rows": "\uC120\uD0DD\uD55C \uD589 \uC0AD\uC81C",
    "menu.array.delete column": "\uC5F4 \uC0AD\uC81C",
    "menu.array.delete columns": "\uC120\uD0DD\uD55C \uC5F4 \uC0AD\uC81C",
    "submenu.array.insert separator": "\uAD6C\uBD84\uC790 \uC0BD\uC785",
    "menu.insert table": "\uD45C \uC0BD\uC785",
    "submenu.table style": "\uD14C\uC774\uBE14 \uC2A4\uD0C0\uC77C"
  },
  lv: {
    "keyboard.tooltip.functions": "Funkcijas",
    "keyboard.tooltip.symbols": "Simboli",
    "keyboard.tooltip.greek": "Grie\u0137u burti",
    "keyboard.tooltip.command": "LaTeX komandu re\u017E\u012Bms",
    "keyboard.tooltip.numeric": "Ciparu skaitlis",
    "keyboard.tooltip.roman": "Romie\u0161u v\u0113stules",
    "tooltip.copy to clipboard": "Kop\u0113t starpliktuv\u0113",
    "tooltip.redo": "P\u0101rtais\u012Bt",
    "tooltip.toggle virtual keyboard": "P\u0101rsl\u0113gt virtu\u0101lo tastat\u016Bru",
    "tooltip.undo": "Atsaukt",
    "menu.insert matrix": "Ievietojiet matricu",
    "menu.insert vector": "Ievietot vektoru",
    "submenu.array.matrix delimiters": "Matricas norobe\u017Eot\u0101ji",
    "menu.array.add row above": "Pievienot rindu p\u0113c",
    "menu.array.add row below": "Pievienot rindu pirms",
    "menu.array.add column after": "Pievienot kolonnu p\u0113c",
    "menu.array.add column before": "Pievienot kolonnu pirms",
    "menu.array.delete row": "Dz\u0113st rindu",
    "menu.array.delete rows": "Dz\u0113st atlas\u012Bt\u0101s rindas",
    "menu.array.delete column": "Dz\u0113st kolonnu",
    "menu.array.delete columns": "Dz\u0113st atlas\u012Bt\u0101s kolonnas",
    "submenu.array.insert separator": "Ievietojiet atdal\u012Bt\u0101ju",
    "menu.insert table": "Ievietojiet tabulu",
    "submenu.table style": "Galda stils"
  },
  lt: {
    "keyboard.tooltip.functions": "Funkcijos",
    "keyboard.tooltip.symbols": "Simboliai",
    "keyboard.tooltip.greek": "Graiki\u0161kos raid\u0117s",
    "keyboard.tooltip.command": "LaTeX komand\u0173 re\u017Eimas",
    "keyboard.tooltip.numeric": "Skaitmeninis",
    "keyboard.tooltip.roman": "Romos lai\u0161kai",
    "tooltip.copy to clipboard": "Nukopijuoti \u012F i\u0161karpin\u0119",
    "tooltip.redo": "Perdaryti",
    "tooltip.toggle virtual keyboard": "Perjungti virtuali\u0105j\u0105 klaviat\u016Br\u0105",
    "tooltip.undo": "At\u0161aukti",
    "menu.insert matrix": "Ievietojiet matricu",
    "menu.insert vector": "Ievietot vektoru",
    "submenu.array.matrix delimiters": "Matricas norobe\u017Eot\u0101ji",
    "menu.array.add row above": "Pievienot rindu p\u0113c",
    "menu.array.add row below": "Pievienot rindu pirms",
    "menu.array.add column after": "Pievienot kolonnu p\u0113c",
    "menu.array.add column before": "Pievienot kolonnu pirms",
    "menu.array.delete row": "Dz\u0113st rindu",
    "menu.array.delete rows": "Dz\u0113st atlas\u012Bt\u0101s rindas",
    "menu.array.delete column": "Dz\u0113st kolonnu",
    "menu.array.delete columns": "Dz\u0113st atlas\u012Bt\u0101s kolonnas",
    "submenu.array.insert separator": "Ievietojiet atdal\u012Bt\u0101ju",
    "menu.insert table": "Ievietojiet tabulu",
    "submenu.table style": "Tabulas stili"
  },
  lu: {
    "keyboard.tooltip.functions": "Funktiounen",
    "keyboard.tooltip.symbols": "Symboler",
    "keyboard.tooltip.greek": "Griichesch Br\xE9iwer",
    "keyboard.tooltip.command": "Latex Kommando Modus",
    "keyboard.tooltip.numeric": "Numeresch",
    "keyboard.tooltip.roman": "R\xE9imesch Br\xE9iwer",
    "tooltip.copy to clipboard": "Kop\xE9iert op Clipboard",
    "tooltip.redo": "Nees nei maachen",
    "tooltip.toggle virtual keyboard": "Wiesselt Virtuell Tastatur",
    "tooltip.undo": "Undoen",
    "menu.insert matrix": "Matrix asetzen",
    "menu.insert vector": "Insert Vector",
    "submenu.array.matrix delimiters": "Matrix Ofgrenzer",
    "menu.array.add row above": "Dob\xE4izemaachen Rei No",
    "menu.array.add row below": "F\xFC\xFCgt Rei vir",
    "menu.array.add column after": "Dob\xE4izemaachen Kolonn No",
    "menu.array.add column before": "Kolonn derb\xE4i Virun",
    "menu.array.delete row": "Rad l\xE4schen",
    "menu.array.delete rows": "L\xE4scht Ausgewielte Reien",
    "menu.array.delete column": "L\xE4scht Kolonn",
    "menu.array.delete columns": "L\xE4scht Ausgewielte Kolonnen",
    "submenu.array.insert separator": "Insert Separator",
    "menu.insert table": "D\xEBsch anzeginn",
    "submenu.table style": "D\xEBsch Style"
  },
  nl: {
    "keyboard.tooltip.functions": "Functies",
    "keyboard.tooltip.symbols": "Symbolen",
    "keyboard.tooltip.greek": "Griekse letters",
    "keyboard.tooltip.command": "LaTeX commando mode",
    "keyboard.tooltip.numeric": "Numeriek",
    "keyboard.tooltip.roman": "Romeinse letters",
    "tooltip.copy to clipboard": "Kopi\xEBren naar klembord",
    "tooltip.redo": "Opnieuw",
    "tooltip.toggle virtual keyboard": "Schakel naar virtueel toetsenbord",
    "tooltip.undo": "Ongedaan maken",
    "menu.insert matrix": "Matrix invoegen",
    "menu.insert vector": "Vector invoegen",
    "submenu.array.matrix delimiters": "Matrixscheidingstekens",
    "menu.array.add row above": "Rij toevoegen na",
    "menu.array.add row below": "Rij toevoegen eerder",
    "menu.array.add column after": "Kolom toevoegen na",
    "menu.array.add column before": "Kolom toevoegen voor",
    "menu.array.delete row": "Verwijder rij",
    "menu.array.delete rows": "Geselecteerde rijen verwijderen",
    "menu.array.delete column": "Kolom verwijderen",
    "menu.array.delete columns": "Geselecteerde kolommen verwijderen",
    "submenu.array.insert separator": "Scheidingsteken invoegen",
    "menu.insert table": "Tabel invoegen",
    "submenu.table style": "Tabelstijl"
  },
  no: {
    "keyboard.tooltip.functions": "Funksjoner",
    "keyboard.tooltip.symbols": "Symboler",
    "keyboard.tooltip.greek": "Greske bokstaver",
    "keyboard.tooltip.command": "LaTeX kommandomodus",
    "keyboard.tooltip.numeric": "Numerisk",
    "keyboard.tooltip.roman": "Romerske bokstaver",
    "tooltip.copy to clipboard": "Kopiere til utklippstavle",
    "tooltip.redo": "Gj\xF8re om",
    "tooltip.toggle virtual keyboard": "Bytt virtuelt tastatur",
    "tooltip.undo": "Angre",
    "menu.insert matrix": "Sett inn matrise",
    "menu.insert vector": "Sett inn vektor",
    "submenu.array.matrix delimiters": "Matrix avgrensere",
    "menu.array.add row above": "Legg til rad etter",
    "menu.array.add row below": "Legg til rad f\xF8r",
    "menu.array.add column after": "Legg til kolonne etter",
    "menu.array.add column before": "Legg til kolonne f\xF8r",
    "menu.array.delete row": "Slett rad",
    "menu.array.delete rows": "Slett valgte rader",
    "menu.array.delete column": "Slett kolonne",
    "menu.array.delete columns": "Slett valgte kolonner",
    "submenu.array.insert separator": "Sett inn skilletegn",
    "menu.insert table": "Sett inn tabell",
    "submenu.table style": "Tabellstil"
  },
  mk: {
    "keyboard.tooltip.functions": "\u0424\u0443\u043D\u043A\u0446\u0438\u0438",
    "keyboard.tooltip.symbols": "\u0421\u0438\u043C\u0431\u043E\u043B\u0438",
    "keyboard.tooltip.greek": "\u0413\u0440\u0447\u043A\u0438 \u0431\u0443\u043A\u0432\u0438",
    "keyboard.tooltip.command": "\u0420\u0435\u0436\u0438\u043C \u043D\u0430 \u043A\u043E\u043C\u0430\u043D\u0434\u0430 \u0432\u043E \u043B\u0430\u0442\u0435\u043A\u0441",
    "keyboard.tooltip.numeric": "\u041D\u0443\u043C\u0435\u0440\u0438\u0447\u043A\u0438",
    "keyboard.tooltip.roman": "\u0420\u0438\u043C\u0441\u043A\u0438 \u043F\u0438\u0441\u043C\u0430",
    "tooltip.copy to clipboard": "\u041A\u043E\u043F\u0438\u0440\u0430\u0458\u0442\u0435 \u0432\u043E \u043A\u043B\u0438\u043F\u0431\u043E\u0440\u0434",
    "tooltip.redo": "\u041F\u043E\u0432\u0442\u043E\u0440\u043D\u043E",
    "tooltip.toggle virtual keyboard": "\u0412\u043A\u043B\u0443\u0447\u0435\u0442\u0435 \u0458\u0430 \u0432\u0438\u0440\u0442\u0443\u0435\u043B\u043D\u0430\u0442\u0430 \u0442\u0430\u0441\u0442\u0430\u0442\u0443\u0440\u0430",
    "tooltip.undo": "\u0412\u0440\u0430\u0442\u0438",
    "menu.insert matrix": "\u0412\u043C\u0435\u0442\u043D\u0435\u0442\u0435 \u043C\u0430\u0442\u0440\u0438\u0446\u0430",
    "menu.insert vector": "\u0412\u043C\u0435\u0442\u043D\u0438 \u0432\u0435\u043A\u0442\u043E\u0440",
    "submenu.array.matrix delimiters": "\u0420\u0430\u0437\u0433\u0440\u0430\u043D\u0438\u0447\u0443\u0432\u0430\u0447\u0438 \u043D\u0430 \u043C\u0430\u0442\u0440\u0438\u0446\u0430",
    "menu.array.add row above": "\u0414\u043E\u0434\u0430\u0434\u0435\u0442\u0435 \u0440\u0435\u0434 \u043F\u043E\u0441\u043B\u0435",
    "menu.array.add row below": "\u0414\u043E\u0434\u0430\u0434\u0438 \u0440\u0435\u0434 \u043F\u0440\u0435\u0434 \u0442\u043E\u0430",
    "menu.array.add column after": "\u0414\u043E\u0434\u0430\u0434\u0435\u0442\u0435 \u043A\u043E\u043B\u043E\u043D\u0430 \u043F\u043E\u0441\u043B\u0435",
    "menu.array.add column before": "\u0414\u043E\u0434\u0430\u0434\u0435\u0442\u0435 \u043A\u043E\u043B\u043E\u043D\u0430 \u043F\u0440\u0435\u0434 \u0442\u043E\u0430",
    "menu.array.delete row": "\u0418\u0437\u0431\u0440\u0438\u0448\u0438 \u0433\u043E \u0440\u0435\u0434\u043E\u0442",
    "menu.array.delete rows": "\u0418\u0437\u0431\u0440\u0438\u0448\u0435\u0442\u0435 \u0433\u0438 \u0438\u0437\u0431\u0440\u0430\u043D\u0438\u0442\u0435 \u0440\u0435\u0434\u043E\u0432\u0438",
    "menu.array.delete column": "\u0418\u0437\u0431\u0440\u0438\u0448\u0438 \u0458\u0430 \u043A\u043E\u043B\u043E\u043D\u0430\u0442\u0430",
    "menu.array.delete columns": "\u0418\u0437\u0431\u0440\u0438\u0448\u0438 \u0458\u0430 \u043A\u043E\u043B\u043E\u043D\u0430\u0442\u0430",
    "submenu.array.insert separator": "\u0412\u043C\u0435\u0442\u043D\u0435\u0442\u0435 \u0441\u0435\u043F\u0430\u0440\u0430\u0442\u043E\u0440",
    "menu.insert table": "\u0412\u043C\u0435\u0442\u043D\u0438 \u0442\u0430\u0431\u0435\u043B\u0430",
    "submenu.table style": "\u0422\u0430\u0431\u0435\u043B\u0430 \u0441\u0442\u0438\u043B"
  },
  pl: {
    "keyboard.tooltip.functions": "Funkcje",
    "keyboard.tooltip.symbols": "Symbolika",
    "keyboard.tooltip.greek": "Litery greckie",
    "keyboard.tooltip.command": "Tryb polece\u0144 LaTeX",
    "keyboard.tooltip.numeric": "Numeryczne",
    "keyboard.tooltip.roman": "Litery rzymskie",
    "tooltip.copy to clipboard": "Kopiuj do Schowka",
    "tooltip.redo": "Przywr\xF3\u0107",
    "tooltip.toggle virtual keyboard": "Prze\u0142\u0105cz wirtualn\u0105 klawiatur\u0119",
    "tooltip.undo": "Cofnij",
    "menu.insert matrix": "Wstaw macierz",
    "menu.insert vector": "Wstaw wektor",
    "submenu.array.matrix delimiters": "Ograniczniki macierzy",
    "menu.array.add row above": "Dodaj wiersz po",
    "menu.array.add row below": "Dodaj wiersz przed",
    "menu.array.add column after": "Dodaj kolumn\u0119 po",
    "menu.array.add column before": "Dodaj kolumn\u0119 przed",
    "menu.array.delete row": "Usu\u0144 wiersz",
    "menu.array.delete rows": "Usu\u0144 wybrane wiersze",
    "menu.array.delete column": "Usu\u0144 kolumn\u0119",
    "menu.array.delete columns": "Usu\u0144 wybrane kolumny",
    "submenu.array.insert separator": "Wstaw separator",
    "menu.insert table": "Wype\u0142nij tabel\u0119",
    "submenu.table style": "Styl tabel\u0119"
  },
  pt: {
    "keyboard.tooltip.functions": "Functions",
    "keyboard.tooltip.symbols": "S\xEDmbolos",
    "keyboard.tooltip.greek": "Letras gregas",
    "keyboard.tooltip.command": "Modo de Comando LaTeX",
    "keyboard.tooltip.numeric": "Num\xE9rico",
    "keyboard.tooltip.roman": "Letras romanas",
    "tooltip.copy to clipboard": "Copiar para \xE1rea de transfer\xEAncia",
    "tooltip.redo": "Refazer",
    "tooltip.toggle virtual keyboard": "Alternar teclado virtual",
    "tooltip.undo": "Desfazer",
    "menu.insert matrix": "Inserir Matriz",
    "menu.insert vector": "Inserir vetor",
    "submenu.array.matrix delimiters": "Delimitadores de matriz",
    "menu.array.add row above": "Adicionar linha depois",
    "menu.array.add row below": "Adicionar linha antes",
    "menu.array.add column after": "Adicionar coluna depois",
    "menu.array.add column before": "Adicionar coluna antes",
    "menu.array.delete row": "Excluir linha",
    "menu.array.delete rows": "Excluir linhas selecionadas",
    "menu.array.delete column": "Apagar Coluna",
    "menu.array.delete columns": "Excluir Colunas Selecionadas",
    "submenu.array.insert separator": "Inserir Separador",
    "menu.insert table": "Insira a tabela",
    "submenu.table style": "Estilo tabela"
  },
  ro: {
    "keyboard.tooltip.functions": "Func\u021Bii",
    "keyboard.tooltip.symbols": "Simboluri",
    "keyboard.tooltip.greek": "Scrisori grece\u0219ti",
    "keyboard.tooltip.command": "Modul de comand\u0103 latex",
    "keyboard.tooltip.numeric": "Numeric",
    "keyboard.tooltip.roman": "Scrisori romane",
    "tooltip.copy to clipboard": "Copia\u021Bi \xEEn clipboard",
    "tooltip.redo": "A reface",
    "tooltip.toggle virtual keyboard": "Comuta\u021Bi tastatura virtual\u0103",
    "tooltip.undo": "Anula",
    "menu.insert matrix": "Introduce\u021Bi Matrix",
    "menu.insert vector": "Insera\u021Bi Vector",
    "submenu.array.matrix delimiters": "Delimitatori de matrice",
    "menu.array.add row above": "Ad\u0103uga\u021Bi r\xE2ndul dup\u0103",
    "menu.array.add row below": "Ad\u0103uga\u021Bi r\xE2ndul \xEEnainte",
    "menu.array.add column after": "Ad\u0103uga\u021Bi o coloan\u0103 dup\u0103",
    "menu.array.add column before": "Ad\u0103uga\u021Bi o coloan\u0103 \xEEnainte",
    "menu.array.delete row": "\u0218terge\u021Bi r\xE2ndul",
    "menu.array.delete rows": "\u0218terge\u021Bi r\xE2ndurile selectate",
    "menu.array.delete column": "\u0218terge\u021Bi coloana",
    "menu.array.delete columns": "\u0218terge\u021Bi coloanele selectate",
    "submenu.array.insert separator": "Introduce\u021Bi separatorul",
    "menu.insert table": "Introduce\u021Bi tabelul",
    "submenu.table style": "Table style"
  },
  ru: {
    "keyboard.tooltip.functions": "\u0424\u0443\u043D\u043A\u0446\u0438\u0438",
    "keyboard.tooltip.symbols": "\u0421\u0438\u043C\u0432\u043E\u043B\u044B",
    "keyboard.tooltip.greek": "\u0413\u0440\u0435\u0447\u0435\u0441\u043A\u0438\u0435 \u0431\u0443\u043A\u0432\u044B",
    "keyboard.tooltip.command": "\u0420\u0435\u0436\u0438\u043C \u043A\u043E\u043C\u0430\u043D\u0434\u043D\u043E\u0439 \u0441\u0442\u0440\u043E\u043A\u0438 \u041B\u0430\u0442\u0435\u043A\u0441",
    "keyboard.tooltip.numeric": "\u0447\u0438\u0441\u043B\u043E\u0432\u043E\u0439",
    "keyboard.tooltip.roman": "\u041B\u0430\u0442\u0438\u043D\u0441\u043A\u0438\u0435 \u0431\u0443\u043A\u0432\u044B",
    "tooltip.copy to clipboard": "\u0421\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0432 \u0431\u0443\u0444\u0435\u0440 \u043E\u0431\u043C\u0435\u043D\u0430",
    "tooltip.redo": "\u043F\u0435\u0440\u0435\u0434\u0435\u043B\u044B\u0432\u0430\u0442\u044C",
    "tooltip.toggle virtual keyboard": "\u041F\u0435\u0440\u0435\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0432\u0438\u0440\u0442\u0443\u0430\u043B\u044C\u043D\u0443\u044E \u043A\u043B\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u0443",
    "tooltip.undo": "\u0440\u0430\u0441\u0441\u0442\u0435\u0433\u0438\u0432\u0430\u0442\u044C",
    "menu.insert matrix": "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u043C\u0430\u0442\u0440\u0438\u0446\u0443",
    "menu.insert vector": "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u0432\u0435\u043A\u0442\u043E\u0440",
    "submenu.array.matrix delimiters": "\u041C\u0430\u0442\u0440\u0438\u0447\u043D\u044B\u0435 \u0440\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u0438",
    "menu.array.add row above": "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0441\u0442\u0440\u043E\u043A\u0443 \u043F\u043E\u0441\u043B\u0435",
    "menu.array.add row below": "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0441\u0442\u0440\u043E\u043A\u0443 \u043F\u0435\u0440\u0435\u0434",
    "menu.array.add column after": "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0441\u0442\u043E\u043B\u0431\u0435\u0446 \u043F\u043E\u0441\u043B\u0435",
    "menu.array.add column before": "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0441\u0442\u043E\u043B\u0431\u0435\u0446 \u043F\u0435\u0440\u0435\u0434",
    "menu.array.delete row": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0441\u0442\u0440\u043E\u043A\u0443",
    "menu.array.delete rows": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0432\u044B\u0431\u0440\u0430\u043D\u043D\u044B\u0435 \u0441\u0442\u0440\u043E\u043A\u0438",
    "menu.array.delete column": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0441\u0442\u043E\u043B\u0431\u0435\u0446",
    "menu.array.delete columns": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0432\u044B\u0431\u0440\u0430\u043D\u043D\u044B\u0435 \u0441\u0442\u043E\u043B\u0431\u0446\u044B",
    "submenu.array.insert separator": "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u0440\u0430\u0437\u0434\u0435\u043B\u0438\u0442\u0435\u043B\u044C",
    "menu.insert table": "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u0442\u0430\u0431\u043B\u0438\u0446\u0443",
    "submenu.table style": "\u0422\u0430\u0431\u043B\u0438\u0447\u043D\u044B\u0439 \u0441\u0442\u0438\u043B\u044C"
  },
  sk: {
    "keyboard.tooltip.functions": "Functions",
    "keyboard.tooltip.symbols": "Symboly",
    "keyboard.tooltip.greek": "Gr\xE9cke listy",
    "keyboard.tooltip.command": "Pr\xEDkazov\xFD re\u017Eim LaTeX",
    "keyboard.tooltip.numeric": "Numerick\xE9",
    "keyboard.tooltip.roman": "R\xEDmske listy",
    "tooltip.copy to clipboard": "Skop\xEDrova\u0165 do schr\xE1nky",
    "tooltip.redo": "Znova",
    "tooltip.toggle virtual keyboard": "Prepn\xFA\u0165 virtu\xE1lnu kl\xE1vesnicu",
    "tooltip.undo": "Vr\xE1tenie sp\xE4\u0165",
    "menu.insert matrix": "Vlo\u017Ete maticu",
    "menu.insert vector": "Vlo\u017Ete vektor",
    "submenu.array.matrix delimiters": "Odde\u013Eova\u010De mat\xEDc",
    "menu.array.add row above": "Pridajte riadok za",
    "menu.array.add row below": "Pridajte riadok pred",
    "menu.array.add column after": "Prida\u0165 st\u013Apec za",
    "menu.array.add column before": "Pridajte st\u013Apec predt\xFDm",
    "menu.array.delete row": "Odstr\xE1ni\u0165 riadok",
    "menu.array.delete rows": "Odstr\xE1ni\u0165 vybrat\xE9 riadky",
    "menu.array.delete column": "Odstr\xE1ni\u0165 st\u013Apec",
    "menu.array.delete columns": "Odstr\xE1ni\u0165 vybrat\xE9 st\u013Apce",
    "submenu.array.insert separator": "Vlo\u017Ete odde\u013Eova\u010D",
    "menu.insert table": "Vlo\u017Ete tabu\u013Eku",
    "submenu.table style": "\u0160t\xFDl tabu\u013Eky"
  },
  sl: {
    "keyboard.tooltip.functions": "Funkcije",
    "keyboard.tooltip.symbols": "Simboli",
    "keyboard.tooltip.greek": "Gr\u0161ka pisma",
    "keyboard.tooltip.command": "Ukazni na\u010Din LaTeX",
    "keyboard.tooltip.numeric": "\u0160tevilsko",
    "keyboard.tooltip.roman": "Rimska pisma",
    "tooltip.copy to clipboard": "Kopirati v odlo\u017Ei\u0161\u010De",
    "tooltip.redo": "Ponovi",
    "tooltip.toggle virtual keyboard": "Preklop navidezne tipkovnice",
    "tooltip.undo": "Razveljavi",
    "menu.insert matrix": "Vstavi matrico",
    "menu.insert vector": "Vstavi vektor",
    "submenu.array.matrix delimiters": "Matri\u010Dni lo\u010Devalniki",
    "menu.array.add row above": "Dodaj vrstico po",
    "menu.array.add row below": "Dodaj vrstico prej",
    "menu.array.add column after": "Dodaj stolpec po",
    "menu.array.add column before": "Dodaj stolpec prej",
    "menu.array.delete row": "Izbri\u0161i vrstico",
    "menu.array.delete rows": "Izbri\u0161i izbrane vrstice",
    "menu.array.delete column": "Izbri\u0161i stolpec",
    "menu.array.delete columns": "Izbri\u0161i izbrane stolpce",
    "submenu.array.insert separator": "Vstavi lo\u010Dilo",
    "menu.insert table": "Vstavi tabelo",
    "submenu.table style": "Tabela slog"
  },
  sq: {
    "keyboard.tooltip.functions": "Funksione",
    "keyboard.tooltip.symbols": "Simbolet",
    "keyboard.tooltip.greek": "Letrat Greke",
    "keyboard.tooltip.command": "Modaliteti i komand\xEBs latex",
    "keyboard.tooltip.numeric": "Numerike",
    "keyboard.tooltip.roman": "Letrat romake",
    "tooltip.copy to clipboard": "Kopjoni n\xEB Clipboard",
    "tooltip.redo": "Riparo",
    "tooltip.toggle virtual keyboard": "Aktivizo tastier\xEBn virtuale",
    "tooltip.undo": "Zhb\xEBj",
    "menu.insert matrix": "Vendosni Matric\xEBn",
    "menu.insert vector": "Vendos vektorin",
    "submenu.array.matrix delimiters": "P\xEBrcaktuesit e matric\xEBs",
    "menu.array.add row above": "Shto Rreshtin Pas",
    "menu.array.add row below": "Shto Rreshtin Para",
    "menu.array.add column after": "Shto kolon\xEBn pas",
    "menu.array.add column before": "Shto kolon\xEBn para",
    "menu.array.delete row": "Fshi Rreshtin",
    "menu.array.delete rows": "Fshi rreshtat e zgjedhur",
    "menu.array.delete column": "Fshi kolon\xEBn",
    "menu.array.delete columns": "Fshi kolonat e zgjedhura",
    "submenu.array.insert separator": "Vendos Ndar\xEBsin",
    "menu.insert table": "Vendos tabel\xEBn",
    "submenu.table style": "Stili tabel\xEBn"
  },
  sr: {
    "keyboard.tooltip.functions": "\u0424\u0443\u043D\u043A\u0446\u0438\u0458\u0435",
    "keyboard.tooltip.symbols": "\u0421\u0438\u043C\u0431\u043E\u043B\u0438",
    "keyboard.tooltip.greek": "\u0413\u0440\u0435\u0435\u043A \u041B\u0435\u0442\u0442\u0435\u0440\u0441",
    "keyboard.tooltip.command": "\u041B\u0430\u0422\u0435\u041A\u0441 \u043A\u043E\u043C\u0430\u043D\u0434\u043D\u0438 \u0440\u0435\u0436\u0438\u043C",
    "keyboard.tooltip.numeric": "\u041D\u0443\u043C\u0435\u0440\u0438\u0447\u043A\u0438",
    "keyboard.tooltip.roman": "\u0420\u0438\u043C\u0441\u043A\u0430 \u043F\u0438\u0441\u043C\u0430",
    "tooltip.copy to clipboard": "\u041A\u043E\u043F\u0438\u0440\u0430\u0458\u0442\u0435 \u0443 \u043C\u0435\u0452\u0443\u0441\u043F\u0440\u0435\u043C\u043D\u0438\u043A",
    "tooltip.redo": "\u041F\u043E\u043D\u043E\u0432\u0438",
    "tooltip.toggle virtual keyboard": "\u0423\u043A\u0459\u0443\u0447\u0438 / \u0438\u0441\u043A\u0459\u0443\u0447\u0438 \u0432\u0438\u0440\u0442\u0443\u0435\u043B\u043D\u0443 \u0442\u0430\u0441\u0442\u0430\u0442\u0443\u0440\u0443",
    "tooltip.undo": "\u041E\u043F\u043E\u0437\u043E\u0432\u0438",
    "menu.insert matrix": "\u0423\u043C\u0435\u0442\u043D\u0438 \u043C\u0430\u0442\u0440\u0438\u0446\u0443",
    "menu.insert vector": "\u0423\u043C\u0435\u0442\u043D\u0438 \u0432\u0435\u043A\u0442\u043E\u0440",
    "submenu.array.matrix delimiters": "\u041C\u0430\u0442\u0440\u0438\u043A \u0414\u0435\u043B\u0438\u043C\u0438\u0442\u0435\u0440\u0441",
    "menu.array.add row above": "\u0414\u043E\u0434\u0430\u0458 \u0440\u0435\u0434 \u043F\u043E\u0441\u043B\u0435",
    "menu.array.add row below": "\u0414\u043E\u0434\u0430\u0458 \u0440\u0435\u0434 \u043F\u0440\u0435",
    "menu.array.add column after": "\u0414\u043E\u0434\u0430\u0458 \u043A\u043E\u043B\u043E\u043D\u0443 \u043F\u043E\u0441\u043B\u0435",
    "menu.array.add column before": "\u0414\u043E\u0434\u0430\u0458 \u043A\u043E\u043B\u043E\u043D\u0443 \u043F\u0440\u0435",
    "menu.array.delete row": "\u0418\u0437\u0431\u0440\u0438\u0448\u0438 \u0440\u0435\u0434",
    "menu.array.delete rows": "\u0418\u0437\u0431\u0440\u0438\u0448\u0438 \u0438\u0437\u0430\u0431\u0440\u0430\u043D\u0435 \u0440\u0435\u0434\u043E\u0432\u0435",
    "menu.array.delete column": "\u0418\u0437\u0431\u0440\u0438\u0448\u0438 \u043A\u043E\u043B\u043E\u043D\u0443",
    "menu.array.delete columns": "\u0418\u0437\u0431\u0440\u0438\u0448\u0438 \u0438\u0437\u0430\u0431\u0440\u0430\u043D\u0435 \u043A\u043E\u043B\u043E\u043D\u0435",
    "submenu.array.insert separator": "\u0423\u043C\u0435\u0442\u043D\u0438 \u0441\u0435\u043F\u0430\u0440\u0430\u0442\u043E\u0440",
    "menu.insert table": "\u0423\u0431\u0430\u0446\u0438 \u0442\u0430\u0431\u0435\u043B\u0443",
    "submenu.table style": "\u0422\u0430\u0431\u0435\u043B\u0430\u0440\u043D\u0438 \u0441\u0442\u0438\u043B"
  },
  sv: {
    "keyboard.tooltip.functions": "Funktioner",
    "keyboard.tooltip.symbols": "Symboler",
    "keyboard.tooltip.greek": "Grekiska bokst\xE4ver",
    "keyboard.tooltip.command": "LaTeX kommandol\xE4ge",
    "keyboard.tooltip.numeric": "Numerisk",
    "keyboard.tooltip.roman": "Romerska bokst\xE4ver",
    "tooltip.copy to clipboard": "Kopiera till Urklipp",
    "tooltip.redo": "G\xF6ra om",
    "tooltip.toggle virtual keyboard": "V\xE4xla virtuellt tangentbord",
    "tooltip.undo": "\xC5ngra",
    "menu.insert matrix": "S\xE4tt in matris",
    "menu.insert vector": "Infoga vektor",
    "submenu.array.matrix delimiters": "Matrisavgr\xE4nsare",
    "menu.array.add row above": "L\xE4gg till rad efter",
    "menu.array.add row below": "L\xE4gg till rad f\xF6re",
    "menu.array.add column after": "L\xE4gg till kolumn efter",
    "menu.array.add column before": "L\xE4gg till kolumn f\xF6re",
    "menu.array.delete row": "Radera rad",
    "menu.array.delete rows": "Ta bort valda rader",
    "menu.array.delete column": "Ta bort kolumn",
    "menu.array.delete columns": "Ta bort valda kolumner",
    "submenu.array.insert separator": "S\xE4tt i separator",
    "menu.insert table": "Infoga tabell",
    "submenu.table style": "Tabellstil"
  },
  th: {
    "keyboard.tooltip.functions": "\u0E1F\u0E31\u0E07\u0E01\u0E4C\u0E0A\u0E31\u0E48\u0E19",
    "keyboard.tooltip.symbols": "\u0E2A\u0E31\u0E0D\u0E25\u0E31\u0E01\u0E29\u0E13\u0E4C",
    "keyboard.tooltip.greek": "\u0E2D\u0E31\u0E01\u0E29\u0E23\u0E01\u0E23\u0E35\u0E01",
    "keyboard.tooltip.command": "\u0E42\u0E2B\u0E21\u0E14\u0E04\u0E33\u0E2A\u0E31\u0E48\u0E07 \u0E19\u0E49\u0E33\u0E22\u0E32\u0E07",
    "keyboard.tooltip.numeric": "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02",
    "keyboard.tooltip.roman": "\u0E2D\u0E31\u0E01\u0E29\u0E23\u0E42\u0E23\u0E21\u0E31\u0E19",
    "tooltip.copy to clipboard": "\u0E04\u0E31\u0E14\u0E25\u0E2D\u0E01\u0E44\u0E1B\u0E17\u0E35\u0E48\u0E04\u0E25\u0E34\u0E1B\u0E1A\u0E2D\u0E23\u0E4C\u0E14",
    "tooltip.redo": "\u0E17\u0E33\u0E0B\u0E49\u0E33",
    "tooltip.toggle virtual keyboard": "\u0E2A\u0E25\u0E31\u0E1A\u0E41\u0E1B\u0E49\u0E19\u0E1E\u0E34\u0E21\u0E1E\u0E4C\u0E40\u0E2A\u0E21\u0E37\u0E2D\u0E19",
    "tooltip.undo": "\u0E40\u0E25\u0E34\u0E01\u0E17\u0E33",
    "menu.insert matrix": "\u0E41\u0E17\u0E23\u0E01\u0E40\u0E21\u0E17\u0E23\u0E34\u0E01\u0E0B\u0E4C",
    "menu.insert vector": "\u0E41\u0E17\u0E23\u0E01\u0E40\u0E27\u0E01\u0E40\u0E15\u0E2D\u0E23\u0E4C",
    "submenu.array.matrix delimiters": "\u0E15\u0E31\u0E27\u0E04\u0E31\u0E48\u0E19\u0E40\u0E21\u0E17\u0E23\u0E34\u0E01\u0E0B\u0E4C",
    "menu.array.add row above": "\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E41\u0E16\u0E27\u0E2B\u0E25\u0E31\u0E07",
    "menu.array.add row below": "\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E41\u0E16\u0E27\u0E01\u0E48\u0E2D\u0E19",
    "menu.array.add column after": "\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E04\u0E2D\u0E25\u0E31\u0E21\u0E19\u0E4C\u0E2B\u0E25\u0E31\u0E07",
    "menu.array.add column before": "\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E04\u0E2D\u0E25\u0E31\u0E21\u0E19\u0E4C\u0E01\u0E48\u0E2D\u0E19",
    "menu.array.delete row": "\u0E25\u0E1A\u0E41\u0E16\u0E27",
    "menu.array.delete rows": "\u0E25\u0E1A\u0E41\u0E16\u0E27\u0E17\u0E35\u0E48\u0E40\u0E25\u0E37\u0E2D\u0E01",
    "menu.array.delete column": "\u0E25\u0E1A\u0E04\u0E2D\u0E25\u0E31\u0E21\u0E19\u0E4C",
    "menu.array.delete columns": "\u0E25\u0E1A\u0E04\u0E2D\u0E25\u0E31\u0E21\u0E19\u0E4C\u0E17\u0E35\u0E48\u0E40\u0E25\u0E37\u0E2D\u0E01",
    "submenu.array.insert separator": "\u0E15\u0E31\u0E27\u0E04\u0E31\u0E48\u0E19\u0E41\u0E17\u0E23\u0E01",
    "menu.insert table": "\u0E41\u0E17\u0E23\u0E01\u0E15\u0E32\u0E23\u0E32\u0E07",
    "submenu.table style": "\u0E2A\u0E44\u0E15\u0E25\u0E4C\u0E15\u0E32\u0E23\u0E32\u0E07"
  },
  tr: {
    "keyboard.tooltip.functions": "Fonksiyonlar",
    "keyboard.tooltip.symbols": "Semboller",
    "keyboard.tooltip.greek": "Yunan harfleri",
    "keyboard.tooltip.command": "LaTeX Komut Modu",
    "keyboard.tooltip.numeric": "Say\u0131sal",
    "keyboard.tooltip.roman": "Roma Harfleri",
    "tooltip.copy to clipboard": "Panoya kopyala",
    "tooltip.redo": "Yeniden yap",
    "tooltip.toggle virtual keyboard": "Sanal Klavyeyi A\xE7/Kapat",
    "tooltip.undo": "Geri alma",
    "menu.insert matrix": "Matris Ekle",
    "menu.insert vector": "Vekt\xF6r Ekle",
    "submenu.array.matrix delimiters": "Matris S\u0131n\u0131rlay\u0131c\u0131lar",
    "menu.array.add row above": "Sat\u0131rdan Sonra Ekle",
    "menu.array.add row below": "\xD6nce Sat\u0131r Ekle",
    "menu.array.add column after": "Sonra S\xFCtun Ekle",
    "menu.array.add column before": "\xD6nce S\xFCtun Ekle",
    "menu.array.delete row": "S\u0131ray\u0131 sil",
    "menu.array.delete rows": "Se\xE7ili Sat\u0131rlar\u0131 Sil",
    "menu.array.delete column": "S\xFCtunu Sil",
    "menu.array.delete columns": "Se\xE7ili S\xFCtunlar\u0131 Sil",
    "submenu.array.insert separator": "Ay\u0131r\u0131c\u0131 Ekle",
    "menu.insert table": "Tablo Ekle",
    "submenu.table style": "Tablo Stili"
  },
  uk: {
    "keyboard.tooltip.functions": "\u0424\u0443\u043D\u043A\u0446\u0456\u0457",
    "keyboard.tooltip.symbols": "\u0421\u0438\u043C\u0432\u043E\u043B\u0438",
    "keyboard.tooltip.greek": "\u0413\u0440\u0435\u0446\u044C\u043A\u0456 \u043B\u0456\u0442\u0435\u0440\u0438",
    "keyboard.tooltip.command": "\u041A\u043E\u043C\u0430\u043D\u0434\u043D\u0438\u0439 \u0440\u0435\u0436\u0438\u043C \u043B\u0430\u0442\u0435\u043A\u0441\u0443",
    "keyboard.tooltip.numeric": "\u0427\u0438\u0441\u043B\u043E\u0432\u0438\u0439",
    "keyboard.tooltip.roman": "\u0420\u0438\u043C\u0441\u044C\u043A\u0456 \u043B\u0456\u0442\u0435\u0440\u0438",
    "tooltip.copy to clipboard": "\u041A\u043E\u043F\u0456\u044E\u0432\u0430\u0442\u0438 \u0432 \u0431\u0443\u0444\u0435\u0440 \u043E\u0431\u043C\u0456\u043D\u0443",
    "tooltip.redo": "\u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u0438",
    "tooltip.toggle virtual keyboard": "\u041F\u0435\u0440\u0435\u043A\u043B\u044E\u0447\u0438\u0442\u0438 \u0432\u0456\u0440\u0442\u0443\u0430\u043B\u044C\u043D\u0443 \u043A\u043B\u0430\u0432\u0456\u0430\u0442\u0443\u0440\u0443",
    "tooltip.undo": "\u0421\u043A\u0430\u0441\u0443\u0432\u0430\u0442\u0438",
    "menu.insert matrix": "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u0438 \u043C\u0430\u0442\u0440\u0438\u0446\u044E",
    "menu.insert vector": "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u0438 \u0432\u0435\u043A\u0442\u043E\u0440",
    "submenu.array.matrix delimiters": "\u041C\u0430\u0442\u0440\u0438\u0447\u043D\u0456 \u0440\u043E\u0437\u0434\u0456\u043B\u044C\u043D\u0438\u043A\u0438",
    "menu.array.add row above": "\u0414\u043E\u0434\u0430\u0442\u0438 \u0440\u044F\u0434\u043E\u043A \u043F\u0456\u0441\u043B\u044F",
    "menu.array.add row below": "\u0414\u043E\u0434\u0430\u0442\u0438 \u0440\u044F\u0434\u043E\u043A \u0434\u043E",
    "menu.array.add column after": "\u0414\u043E\u0434\u0430\u0442\u0438 \u0441\u0442\u043E\u0432\u043F\u0435\u0446\u044C \u043F\u0456\u0441\u043B\u044F",
    "menu.array.add column before": "\u0414\u043E\u0434\u0430\u0442\u0438 \u0441\u0442\u043E\u0432\u043F\u0435\u0446\u044C \u043F\u0435\u0440\u0435\u0434",
    "menu.array.delete row": "\u0412\u0438\u0434\u0430\u043B\u0438\u0442\u0438 \u0440\u044F\u0434\u043E\u043A",
    "menu.array.delete rows": "\u0412\u0438\u0434\u0430\u043B\u0438\u0442\u0438 \u0432\u0438\u0431\u0440\u0430\u043D\u0456 \u0440\u044F\u0434\u043A\u0438",
    "menu.array.delete column": "\u0412\u0438\u0434\u0430\u043B\u0438\u0442\u0438 \u0441\u0442\u043E\u0432\u043F\u0435\u0446\u044C",
    "menu.array.delete columns": "\u0412\u0438\u0434\u0430\u043B\u0438\u0442\u0438 \u0432\u0438\u0431\u0440\u0430\u043D\u0456 \u0441\u0442\u043E\u0432\u043F\u0446\u0456",
    "submenu.array.insert separator": "\u0412\u0441\u0442\u0430\u0432\u0442\u0435 \u0440\u043E\u0437\u0434\u0456\u043B\u044C\u043D\u0438\u043A",
    "menu.insert table": "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u0438 \u0442\u0430\u0431\u043B\u0438\u0446\u044E",
    "submenu.table style": "\u0421\u0442\u0438\u043B\u044C \u0442\u0430\u0431\u043B\u0438\u0446\u0456"
  },
  vi: {
    "keyboard.tooltip.functions": "Ch\u1EE9c n\u0103ng",
    "keyboard.tooltip.symbols": "K\xFD hi\u1EC7u",
    "keyboard.tooltip.greek": "Ch\u1EEF Hy L\u1EA1p",
    "keyboard.tooltip.command": "Ch\u1EBF \u0111\u1ED9 l\u1EC7nh LaTeX",
    "keyboard.tooltip.numeric": "S\u1ED1",
    "keyboard.tooltip.roman": "Ch\u1EEF c\xE1i La m\xE3",
    "tooltip.copy to clipboard": "Sao ch\xE9p v\xE0o clipboard",
    "tooltip.redo": "L\xE0m l\u1EA1i",
    "tooltip.toggle virtual keyboard": "Chuy\u1EC3n \u0111\u1ED5i b\xE0n ph\xEDm \u1EA3o",
    "tooltip.undo": "Ho\xE0n t\xE1c",
    "menu.insert matrix": "Ch\xE8n ma tr\u1EADn",
    "menu.insert vector": "Insert Vector",
    "submenu.array.matrix delimiters": "D\u1EA5u ph\xE2n c\xE1ch ma tr\u1EADn",
    "menu.array.add row above": "Th\xEAm h\xE0ng sau",
    "menu.array.add row below": "Th\xEAm h\xE0ng tr\u01B0\u1EDBc",
    "menu.array.add column after": "Th\xEAm c\u1ED9t sau",
    "menu.array.add column before": "Th\xEAm c\u1ED9t tr\u01B0\u1EDBc",
    "menu.array.delete row": "X\xF3a h\xE0ng",
    "menu.array.delete rows": "X\xF3a h\xE0ng \u0111\xE3 ch\u1ECDn",
    "menu.array.delete column": "X\xF3a c\u1ED9t",
    "menu.array.delete columns": "X\xF3a c\xE1c c\u1ED9t \u0111\xE3 ch\u1ECDn",
    "submenu.array.insert separator": "Ch\xE8n d\u1EA5u ph\xE2n c\xE1ch",
    "menu.insert table": "Ch\xE8n b\u1EA3ng",
    "submenu.table style": "Ki\u1EC3u b\u1EA3ng"
  },
  zh_cn: {
    "keyboard.tooltip.functions": "\u804C\u80FD",
    "keyboard.tooltip.symbols": "\u7B26\u53F7",
    "keyboard.tooltip.greek": "\u5E0C\u814A\u5B57\u6BCD",
    "keyboard.tooltip.command": "\u4E73\u80F6 \u547D\u4EE4\u6A21\u5F0F",
    "keyboard.tooltip.numeric": "\u6570\u5B57",
    "keyboard.tooltip.roman": "\u7F57\u9A6C\u5B57\u6BCD",
    "tooltip.copy to clipboard": "\u590D\u5236\u5230\u526A\u8D34\u677F",
    "tooltip.redo": "\u91CD\u505A",
    "tooltip.toggle virtual keyboard": "\u5207\u6362\u865A\u62DF\u952E\u76D8",
    "tooltip.undo": "\u64A4\u6D88",
    "menu.insert matrix": "\u63D2\u5165\u77E9\u9635",
    "menu.insert vector": "\u63D2\u5165\u5411\u91CF",
    "submenu.array.matrix delimiters": "\u77E9\u9635\u5206\u9694\u7B26",
    "menu.array.add row above": "\u5728\u540E\u9762\u6DFB\u52A0\u884C",
    "menu.array.add row below": "\u5728\u524D\u9762\u6DFB\u52A0\u884C",
    "menu.array.add column after": "\u5728\u540E\u9762\u6DFB\u52A0\u5217r",
    "menu.array.add column before": "\u5728\u524D\u9762\u6DFB\u52A0\u5217",
    "menu.array.delete row": "\u5220\u9664\u884C",
    "menu.array.delete rows": "\u5220\u9664\u9009\u5B9A\u884C",
    "menu.array.delete column": "\u5220\u9664\u5217",
    "menu.array.delete columns": "\u5220\u9664\u9009\u5B9A\u7684\u5217",
    "submenu.array.insert separator": "\u63D2\u5165\u5206\u9694\u7B26",
    "menu.insert table": "\u63D2\u5165\u8868\u683C",
    "submenu.table style": "\u8868\u683C\u6837\u5F0F"
  },
  zh_tw: {
    "keyboard.tooltip.functions": "\u8077\u80FD",
    "keyboard.tooltip.symbols": "\u7B26\u865F",
    "keyboard.tooltip.greek": "\u5E0C\u81D8\u5B57\u6BCD",
    "keyboard.tooltip.command": "\u4E73\u81A0\u547D\u4EE4\u6A21\u5F0F",
    "keyboard.tooltip.numeric": "\u6578\u5B57",
    "keyboard.tooltip.roman": "\u7F85\u99AC\u5B57\u6BCD",
    "tooltip.copy to clipboard": "\u8907\u88FD\u5230\u526A\u8CBC\u677F",
    "tooltip.redo": "\u91CD\u505A",
    "tooltip.toggle virtual keyboard": "\u5207\u63DB\u865B\u64EC\u9375\u76E4",
    "tooltip.undo": "\u64A4\u6D88",
    "menu.insert matrix": "\u63D2\u5165\u77E9\u9663",
    "menu.insert vector": "\u63D2\u5165\u5411\u91CF",
    "submenu.array.matrix delimiters": "\u77E9\u9663\u5206\u9694\u7B26",
    "menu.array.add row above": "\u5728\u5F8C\u9762\u6DFB\u52A0\u884C",
    "menu.array.add row below": "\u5728\u524D\u9762\u6DFB\u52A0\u884C",
    "menu.array.add column after": "\u5728\u5F8C\u9762\u6DFB\u52A0\u5217",
    "menu.array.add column before": "\u5728\u524D\u9762\u6DFB\u52A0\u5217",
    "menu.array.delete row": "\u522A\u9664\u884C",
    "menu.array.delete rows": "\u522A\u9664\u9078\u5B9A\u884C",
    "menu.array.delete column": "\u522A\u9664\u5217",
    "menu.array.delete columns": "\u522A\u9664\u9078\u5B9A\u7684\u5217",
    "submenu.array.insert separator": "\u63D2\u5165\u5206\u9694\u7B26",
    "menu.insert table": "\u63D2\u5165\u8868\u683C",
    "submenu.table style": "\u8868\u683C\u6A23\u5F0F"
  }
};

// src/editor/l10n.ts
var l10n = {
  strings: STRINGS,
  _locale: "en",
  get locale() {
    if (!l10n._locale) {
      l10n._locale = (isBrowser() ? navigator.language.slice(0, 5) : null) ?? "en";
    }
    return l10n._locale;
  },
  set locale(value) {
    l10n._locale = value;
  },
  merge(locale, strings) {
    if (locale && strings) {
      const savedLocale = l10n._locale;
      l10n.locale = locale;
      l10n.strings[locale] = {
        ...l10n.strings[locale],
        ...strings
      };
      l10n.locale = savedLocale;
    } else if (locale && !strings) {
      for (const l3 of Object.keys(locale)) {
        l10n.merge(l3, locale[l3]);
      }
    }
  }
};
function localize(key) {
  if (key === void 0)
    return void 0;
  const language = l10n.locale.slice(0, 2);
  let result = "";
  if (l10n.strings[l10n.locale])
    result = l10n.strings[l10n.locale][key];
  if (!result && l10n.strings[language])
    result = l10n.strings[language][key];
  if (!result)
    result = l10n.strings.en[key];
  if (!result)
    return void 0;
  return result;
}

// src/editor-mathfield/utils.ts
function on(element, inSelectors, listener, options) {
  const selectors = inSelectors.split(" ");
  for (const sel of selectors) {
    const m3 = sel.match(/(.*):(.*)/);
    if (m3) {
      const options2 = options ?? {};
      if (m3[2] === "active") {
        options2.passive = false;
      } else {
        options2[m3[2]] = true;
      }
      element.addEventListener(m3[1], listener, options2);
    } else {
      element.addEventListener(sel, listener, options);
    }
  }
}
function off(element, inSelectors, listener, options) {
  const selectors = inSelectors.split(" ");
  for (const sel of selectors) {
    const m3 = sel.match(/(.*):(.*)/);
    if (m3) {
      const options2 = options ?? {};
      if (m3[2] === "active") {
        options2.passive = false;
      } else {
        options2[m3[2]] = true;
      }
      element.removeEventListener(m3[1], listener, options2);
    } else {
      element.removeEventListener(sel, listener, options);
    }
  }
}
function getSharedElement(id) {
  throwIfNotInBrowser();
  let result = document.getElementById(id);
  if (result) {
    result.dataset.refcount = Number(Number.parseInt(result.getAttribute("data-refcount") ?? "0") + 1).toString();
  } else {
    result = document.createElement("div");
    result.setAttribute("aria-hidden", "true");
    result.dataset.refcount = "1";
    result.id = id;
    document.body.append(result);
  }
  return result;
}
function releaseSharedElement(element) {
  if (!element)
    return;
  const refcount = Number.parseInt(element.getAttribute("data-refcount") ?? "0");
  if (refcount <= 1) {
    element.remove();
  } else {
    element.dataset.refcount = Number(refcount - 1).toString();
  }
}
function isValidMathfield(mf) {
  return mf.element !== void 0 && mf.element.mathfield === mf;
}
function findElementWithCaret(element) {
  return element.querySelector(".ML__caret") ?? element.querySelector(".ML__text-caret") ?? element.querySelector(".ML__latex-caret");
}
function getCaretPoint(element) {
  const caret = findElementWithCaret(element);
  if (!caret)
    return null;
  const bounds = caret.getBoundingClientRect();
  return {
    x: bounds.right,
    y: bounds.bottom,
    height: bounds.height
  };
}
function branchId(atom) {
  if (!atom.parent)
    return "root";
  let result = atom.parent.id ?? "";
  result += typeof atom.treeBranch === "string" ? "-" + atom.treeBranch : `-${atom.treeBranch[0]}/${atom.treeBranch[0]}`;
  return result;
}
function adjustForScrolling(mathfield, rect) {
  if (!rect)
    return null;
  const fieldRect = mathfield.field.getBoundingClientRect();
  const w3 = rect.right - rect.left;
  const h3 = rect.bottom - rect.top;
  const left = Math.ceil(rect.left - fieldRect.left + mathfield.field.scrollLeft);
  const top = Math.ceil(rect.top - fieldRect.top);
  return {
    left,
    right: left + w3,
    top,
    bottom: top + h3
  };
}
function getNodeBounds(node) {
  const bounds = node.getBoundingClientRect();
  const marginRight = parseInt(getComputedStyle(node).marginRight);
  const result = {
    top: bounds.top - 1,
    bottom: bounds.bottom,
    left: bounds.left,
    right: bounds.right - 1 + marginRight
  };
  if (node.children.length > 0 && node.tagName.toUpperCase() !== "SVG") {
    for (const child of node.children) {
      if (child.nodeType === 1) {
        if ("atom-id" in child.dataset && !child.classList.contains("pstrut")) {
          const r3 = getNodeBounds(child);
          result.left = Math.min(result.left, r3.left);
          result.right = Math.max(result.right, r3.right);
          result.top = Math.min(result.top, r3.top);
          result.bottom = Math.max(result.bottom, r3.bottom);
        }
      }
    }
  }
  return result;
}
function getAtomBounds(mathfield, atom) {
  if (!atom.id)
    return null;
  let result = mathfield._atomBoundsCache?.get(atom.id) ?? null;
  if (result !== null)
    return result;
  const node = mathfield.field.querySelector(`[data-atom-id="${atom.id}"]`);
  if (!node) {
    console.log(atom.id);
  }
  result = node ? getNodeBounds(node) : null;
  if (mathfield._atomBoundsCache) {
    if (result) {
      mathfield._atomBoundsCache.set(atom.id, result);
    } else {
      mathfield._atomBoundsCache.delete(atom.id);
    }
  }
  return result ?? null;
}
function getRangeBounds(mathfield, range2, options) {
  const rects = new Map();
  for (const atom of mathfield.model.getAtoms(range2, {
    includeChildren: true
  })) {
    if (options?.excludeAtomsWithBackground && atom.style.backgroundColor) {
      break;
    }
    const bounds = adjustForScrolling(mathfield, getAtomBounds(mathfield, atom));
    if (bounds) {
      const id = branchId(atom);
      if (rects.has(id)) {
        const r3 = rects.get(id);
        rects.set(id, {
          left: Math.min(r3.left, bounds.left),
          right: Math.max(r3.right, bounds.right),
          top: Math.min(r3.top, bounds.top),
          bottom: Math.max(r3.bottom, bounds.bottom)
        });
      } else {
        rects.set(id, bounds);
      }
    }
  }
  return [...rects.values()];
}
function getSelectionBounds(mathfield, options) {
  return mathfield.model.selection.ranges.reduce((acc, x3) => acc.concat(...getRangeBounds(mathfield, x3, options)), []);
}
function validateOrigin(origin, originValidator) {
  if (originValidator === "none") {
    return true;
  }
  if (originValidator === "same-origin") {
    return origin === window.origin;
  }
  if (typeof originValidator === "function") {
    return originValidator(origin);
  }
  return false;
}

// src/editor-mathfield/buttons.ts
function attachButtonHandlers(executeCommand, element, command) {
  if (typeof command === "object" && ("default" in command || "pressed" in command)) {
    if (command.default) {
      element.dataset.command = JSON.stringify(command.default);
    }
    if (command.alt) {
      element.dataset.commandAlt = JSON.stringify(command.alt);
    }
    if (command.altshift) {
      element.dataset.commandAltshift = JSON.stringify(command.altshift);
    }
    if (command.shift) {
      element.dataset.commandShift = JSON.stringify(command.shift);
    }
    if (command.pressed) {
      element.dataset.commandPressed = JSON.stringify(command.pressed);
    }
    if (command.pressAndHoldStart) {
      element.dataset.commandPressAndHoldStart = JSON.stringify(command.pressAndHoldStart);
    }
    if (command.pressAndHoldEnd) {
      element.dataset.commandPressAndHoldEnd = JSON.stringify(command.pressAndHoldEnd);
    }
  } else {
    element.dataset.command = JSON.stringify(command);
  }
  let pressHoldStart;
  let pressHoldElement;
  let touchID;
  let syntheticTarget;
  let pressAndHoldTimer;
  on(element, "mousedown touchstart:passive", (ev) => {
    if (ev.type !== "mousedown" || ev.buttons === 1) {
      ev.stopPropagation();
      if (ev.type !== "touchstart") {
        ev.preventDefault();
      }
      document.body.style["-webkit-user-select"] = "none";
      element.classList.add("is-pressed");
      pressHoldStart = Date.now();
      if (ev.type === "touchstart") {
        touchID = ev.changedTouches[0].identifier;
      }
      const command2 = element.getAttribute("data-command-pressed");
      if (command2) {
        executeCommand(JSON.parse(command2));
      }
      const pressAndHoldStartCommand = element.getAttribute("data-command-press-and-hold-start");
      if (pressAndHoldStartCommand) {
        pressHoldElement = element;
        if (pressAndHoldTimer) {
          clearTimeout(pressAndHoldTimer);
        }
        pressAndHoldTimer = setTimeout(() => {
          if (element.classList.contains("is-pressed")) {
            executeCommand(JSON.parse(pressAndHoldStartCommand));
          }
        }, 300);
      }
    }
  });
  on(element, "mouseleave touchcancel", () => {
    element.classList.remove("is-pressed");
  });
  on(element, "touchmove:passive", (ev) => {
    for (let i3 = 0; i3 < ev.changedTouches.length; i3++) {
      if (ev.changedTouches[i3].identifier === touchID) {
        const target = document.elementFromPoint(ev.changedTouches[i3].clientX, ev.changedTouches[i3].clientY);
        if (target !== syntheticTarget && syntheticTarget) {
          syntheticTarget.dispatchEvent(new MouseEvent("mouseleave"), {
            bubbles: true
          });
          syntheticTarget = null;
        }
        if (target) {
          syntheticTarget = target;
          target.dispatchEvent(new MouseEvent("mouseenter", {
            bubbles: true,
            buttons: 1
          }));
        }
      }
    }
  });
  on(element, "mouseenter", (ev) => {
    if (ev.buttons === 1) {
      element.classList.add("is-pressed");
    }
  });
  on(element, "mouseup touchend click", (ev) => {
    document.body.style["-webkit-user-select"] = "";
    if (syntheticTarget) {
      ev.stopPropagation();
      ev.preventDefault();
      const target = syntheticTarget;
      syntheticTarget = null;
      target.dispatchEvent(new MouseEvent("mouseup", {bubbles: true}));
      return;
    }
    element.classList.remove("is-pressed");
    element.classList.add("is-active");
    if (ev.type === "click" && ev.detail !== 0) {
      ev.stopPropagation();
      ev.preventDefault();
      return;
    }
    window.setTimeout(() => {
      element.classList.remove("is-active");
    }, 150);
    let command2 = element.getAttribute("data-command-press-and-hold-end");
    const now = Date.now();
    if (element !== pressHoldElement || now < pressHoldStart + 300) {
      command2 = null;
    }
    if (!command2 && ev.altKey && ev.shiftKey) {
      command2 = element.getAttribute("data-command-altshift");
    }
    if (!command2 && ev.altKey) {
      command2 = element.getAttribute("data-command-alt");
    }
    if (!command2 && ev.shiftKey) {
      command2 = element.getAttribute("data-command-shift");
    }
    if (!command2) {
      command2 = element.getAttribute("data-command");
    }
    if (command2) {
      executeCommand(JSON.parse(command2));
    }
    ev.stopPropagation();
    ev.preventDefault();
  });
}

// css/virtual-keyboard.less
var virtual_keyboard_default = `.ML__keyboard {
  --keyboard-background: rgba(209, 213, 217, 0.97);
  --keyboard-text: #000;
  --keyboard-text-active: var(--primary, hsl(var(--hue, 212), 40%, 50%));
  --keyboard-background-border: #ddd;
  --keycap-background: white;
  --keycap-background-active: #e5e5e5;
  --keycap-background-border: #e5e6e9;
  --keycap-background-border-bottom: #8d8f92;
  --keycap-text: #000;
  --keycap-text-active: #fff;
  --keycap-secondary-text: #000;
  --keycap-modifier-background: #b9bdc7;
  --keycap-modifier-border: #c5c9d0;
  --keycap-modifier-border-bottom: #989da6;
  --keyboard-alternate-background: #fff;
  --keyboard-alternate-background-active: var(--primary, hsl(var(--hue, 212), 40%, 50%));
  --keyboard-alternate-text: var(--keycap-text, #000);
  --keyboard-alternate-text-active: #fff;
  --keyboard-alternate-key-length: 70px;
  --keyboard-alternate-key-font-size: 30px;
  --keyboard-alternate-key-aside-font-size: 12px;
  --keyboard-height: 276px;
  --keycap-height: 52px;
  --keycap-font-size: 20px;
  --keycap-small-font-size: calc(var(--keycap-font-size) * 0.8);
  --keycap-extra-small-font-size: calc(var(--keycap-font-size) / 1.42);
  --keycap-tt-font-size: calc(var(--keycap-font-size) * 1.5);
  position: fixed;
  top: 0;
  height: 100%;
  width: 100%;
  z-index: var(--keyboard-zindex, 105);
  pointer-events: none;
  /* This is the element that displays alternate keys on press+hold */
}
.ML__keyboard.is-visible .ML__keyboard--plate {
  transform: translate(0, calc(-1 * var(--keyboard-height, 276px)));
  opacity: 1;
  visibility: visible;
  transition-timing-function: cubic-bezier(0.4, 0, 1, 1);
}
.ML__keyboard.alternate-keys {
  visibility: hidden;
  max-width: 286px;
  background-color: var(--keyboard-alternate-background);
  text-align: center;
  border-radius: 6px;
  position: fixed;
  bottom: auto;
  top: 0;
  box-sizing: content-box;
  transform: none;
  z-index: calc(var(--keyboard-zindex, 105) + 1);
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-content: center;
  box-shadow: 0 14px 28px rgba(0, 0, 0, 0.25), 0 10px 10px rgba(0, 0, 0, 0.22);
  transition: none;
}
@media only screen and (max-height: 412px) {
  .ML__keyboard.alternate-keys {
    max-width: 320px;
  }
}
.ML__keyboard.alternate-keys.is-visible {
  visibility: visible;
}
.ML__keyboard.alternate-keys.compact {
  --keyboard-alternate-key-length: 50px;
  --keyboard-alternate-key-font-size: 24px;
  --keyboard-alternate-key-aside-font-size: 10px;
}
.ML__keyboard.alternate-keys ul {
  list-style: none;
  margin: 3px;
  padding: 0;
  display: flex;
  flex-flow: row wrap-reverse;
  justify-content: center;
}
.ML__keyboard.alternate-keys ul > li {
  display: flex;
  flex-flow: column;
  align-items: center;
  justify-content: center;
  font-size: var(--keyboard-alternate-key-font-size);
  height: var(--keyboard-alternate-key-length);
  width: var(--keyboard-alternate-key-length);
  box-sizing: border-box;
  margin: 0;
  background: transparent;
  border: 1px solid transparent;
  border-radius: 5px;
  pointer-events: all;
  color: var(--keyboard-alternate-text);
  fill: currentColor;
}
@media only screen and (max-height: 412px) {
  .ML__keyboard.alternate-keys ul > li {
    font-size: 24px;
    height: 50px;
    width: 50px;
  }
}
.ML__keyboard.alternate-keys ul > li:hover,
.ML__keyboard.alternate-keys ul > li.is-pressed,
.ML__keyboard.alternate-keys ul > li.is-active {
  background: var(--keyboard-alternate-background-active);
  color: var(--keyboard-alternate-text-active);
}
.ML__keyboard.alternate-keys ul > li.small {
  font-size: var(--keycap-small-font-size, 16px);
}
.ML__keyboard.alternate-keys ul > li.small-button {
  width: 42px;
  height: 42px;
  margin: 2px;
  background: #fbfbfb;
}
.ML__keyboard.alternate-keys ul > li.small-button:hover {
  background: var(--keyboard-alternate-background-active);
}
.ML__keyboard.alternate-keys ul > li.box > div,
.ML__keyboard.alternate-keys ul > li.box > span {
  border: 1px dashed rgba(0, 0, 0, 0.24);
}
.ML__keyboard.alternate-keys ul > li .warning {
  min-height: 60px;
  min-width: 60px;
  background: #cd0030;
  color: white;
  padding: 5px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 5px;
}
.ML__keyboard.alternate-keys ul > li .warning:hover,
.ML__keyboard.alternate-keys ul > li .warning.is-pressed,
.ML__keyboard.alternate-keys ul > li .warning.is-active {
  background: red;
}
.ML__keyboard.alternate-keys ul > li .warning svg.svg-glyph {
  width: 50px;
  height: 50px;
}
.ML__keyboard.alternate-keys ul > li aside {
  font-size: var(--keyboard-alternate-key-aside-font-size);
  line-height: 12px;
  opacity: 0.78;
  padding-top: 2px;
}
.ML__keyboard .ML__keyboard--plate {
  position: absolute;
  left: 0;
  bottom: calc(-1 * var(--keyboard-height, 276px));
  width: 100%;
  padding-top: 5px;
  transform: translate(0, 0);
  opacity: 0;
  visibility: hidden;
  transition: 0.28s cubic-bezier(0, 0, 0.2, 1);
  transition-property: transform, opacity;
  backdrop-filter: grayscale(50%);
  background-color: var(--keyboard-background);
  border: 1px solid var(--keyboard-background-border);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
  font-size: 16px;
  /* Size of toolbar labels */
  font-weight: 400;
  margin: 0;
  text-shadow: none;
  box-sizing: border-box;
  touch-action: none;
  -webkit-user-select: none;
  user-select: none;
  cursor: pointer;
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16), 0 3px 6px rgba(0, 0, 0, 0.23);
  /* Keyboard layouts are made or rows of keys... */
}
.ML__keyboard .ML__keyboard--plate .tex {
  font-family: 'KaTeX_Math', KaTeX_Main, 'Cambria Math', 'Asana Math', OpenSymbol, Symbola, STIX, Times, serif !important;
}
.ML__keyboard .ML__keyboard--plate .tex-math {
  font-family: KaTeX_Math, 'Cambria Math', 'Asana Math', OpenSymbol, Symbola, STIX, Times, serif !important;
}
.ML__keyboard .ML__keyboard--plate .tt {
  font-family: 'IBM Plex Mono', 'Source Code Pro', Consolas, 'Roboto Mono', Menlo, 'Bitstream Vera Sans Mono', 'DejaVu Sans Mono', Monaco, Courier, monospace !important;
  font-size: var(--keycap-tt-font-size, 30px);
  font-weight: 400;
}
.ML__keyboard .ML__keyboard--plate > div.keyboard-layer {
  display: none;
  outline: none;
}
.ML__keyboard .ML__keyboard--plate > div.keyboard-layer.is-visible {
  display: flex;
  flex-flow: column;
}
.ML__keyboard .ML__keyboard--plate > div > div.keyboard-toolbar {
  align-self: center;
  display: flex;
  flex-flow: row;
  justify-content: space-between;
  width: 736px;
  /* Tablet */
  /* Phone */
  /* Icons for undo/redo, etc. */
}
@media only screen and (min-width: 768px) and (max-width: 1024px) {
  .ML__keyboard .ML__keyboard--plate > div > div.keyboard-toolbar {
    width: 556px;
  }
}
@media only screen and (max-width: 767px) {
  .ML__keyboard .ML__keyboard--plate > div > div.keyboard-toolbar {
    width: 365px;
    max-width: 100vw;
  }
}
.ML__keyboard .ML__keyboard--plate > div > div.keyboard-toolbar svg {
  height: 20px;
  width: 20px;
}
@media only screen and (max-width: 767px) {
  .ML__keyboard .ML__keyboard--plate > div > div.keyboard-toolbar svg {
    height: 13px;
    width: 17px;
  }
}
.ML__keyboard .ML__keyboard--plate > div > div.keyboard-toolbar > .left {
  position: relative;
  display: flex;
  justify-content: flex-start;
  flex-flow: row;
}
.ML__keyboard .ML__keyboard--plate > div > div.keyboard-toolbar > .right {
  display: flex;
  justify-content: flex-end;
  flex-flow: row;
}
.ML__keyboard .ML__keyboard--plate > div > div.keyboard-toolbar > div > div {
  /* "button" in the toolbar */
  display: flex;
  align-items: baseline;
  justify-content: center;
  pointer-events: all;
  color: var(--keyboard-text);
  fill: currentColor;
  background: 0;
  font-size: 110%;
  padding: 4px 15px;
  cursor: pointer;
  min-height: 0;
  border: none;
  padding-left: 10px;
  padding-right: 10px;
  margin-top: 7px;
  margin-bottom: 6px;
  margin-left: 4px;
  margin-right: 4px;
  box-shadow: none;
  border-bottom: 2px solid transparent;
  /* iPhone 5 */
  /* Phone */
}
.ML__keyboard .ML__keyboard--plate > div > div.keyboard-toolbar > div > div.disabled svg,
.ML__keyboard .ML__keyboard--plate > div > div.keyboard-toolbar > div > div.disabled:hover svg,
.ML__keyboard .ML__keyboard--plate > div > div.keyboard-toolbar > div > div.disabled.is-pressed svg {
  color: var(--keyboard-text);
  opacity: 0.2;
}
@media only screen and (max-width: 414px) {
  .ML__keyboard .ML__keyboard--plate > div > div.keyboard-toolbar > div > div {
    font-size: 100%;
    padding: 0 6px 0 0;
  }
}
@media only screen and (max-width: 767px) {
  .ML__keyboard .ML__keyboard--plate > div > div.keyboard-toolbar > div > div {
    padding-left: 4px;
    padding-right: 4px;
    font-size: 90%;
  }
}
.ML__keyboard .ML__keyboard--plate > div > div.keyboard-toolbar > div > div:hover,
.ML__keyboard .ML__keyboard--plate > div > div.keyboard-toolbar > div > div:active,
.ML__keyboard .ML__keyboard--plate > div > div.keyboard-toolbar > div > div.is-pressed,
.ML__keyboard .ML__keyboard--plate > div > div.keyboard-toolbar > div > div.is-active {
  color: var(--keyboard-text-active);
}
.ML__keyboard .ML__keyboard--plate > div > div.keyboard-toolbar > div > div.selected {
  color: var(--keyboard-text-active);
  border-bottom: 2px solid var(--keyboard-text-active);
  margin-bottom: 8px;
  padding-bottom: 0;
}
.ML__keyboard .ML__keyboard--plate div .rows {
  border: 0;
  border-collapse: separate;
  clear: both;
  margin: auto;
  display: flex;
  flex-flow: column;
  align-items: center;
  /* iPhone 5 */
  /* Pixel, iPhone 6,7,8+ */
  /* Tablet size */
  /* Desktop size */
}
.ML__keyboard .ML__keyboard--plate div .rows > ul {
  list-style: none;
  height: 40px;
  margin: 0 0 3px 0;
  padding: 0;
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li {
  /* Key widths. A standard key is 10 units wide (w10) */
  /* The formula for wn = n * w10 / 10 + (n -1) * margin-right */
  display: flex;
  flex-flow: column;
  align-items: center;
  justify-content: center;
  width: 34px;
  margin-right: 2px;
  height: 40px;
  box-sizing: border-box;
  padding: 8px 0;
  vertical-align: top;
  text-align: center;
  float: left;
  color: var(--keycap-text);
  fill: currentColor;
  font-size: var(--keycap-font-size, 20px);
  background: var(--keycap-background);
  border: 1px solid var(--keycap-background-border);
  border-bottom-color: var(--keycap-background-border-bottom);
  border-radius: 5px;
  pointer-events: all;
  /* Last key should be flush against the border */
  /* For the alignment of the text on some modifiers (e.g. shift) */
  /* Extra spacing between two adjacent keys */
  position: relative;
  overflow: hidden;
  -webkit-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li:last-child {
  margin-right: 0;
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.small {
  font-size: var(--keycap-small-font-size, 16px);
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.tt {
  color: var(--keyboard-text-active);
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.bottom {
  justify-content: flex-end;
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.left {
  align-items: flex-start;
  padding-left: 4px;
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.right {
  align-items: flex-end;
  padding-right: 4px;
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li svg.svg-glyph {
  width: 20px;
  height: 20px;
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li .warning {
  height: 25px;
  width: 25px;
  min-height: 25px;
  min-width: 25px;
  background: #cd0030;
  color: white;
  border-radius: 100%;
  padding: 5px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: -2px;
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li .warning svg.svg-glyph {
  width: 16px;
  height: 16px;
}
@media only screen and (max-width: 768px) {
  .ML__keyboard .ML__keyboard--plate div .rows > ul > li .warning {
    height: 16px;
    width: 16px;
    min-height: 16px;
    min-width: 16px;
  }
  .ML__keyboard .ML__keyboard--plate div .rows > ul > li .warning svg.svg-glyph {
    width: 14px;
    height: 14px;
  }
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li > .w0 {
  width: 0;
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li > .w5 {
  width: 16px;
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li > .w15 {
  width: 52px;
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li > .w20 {
  width: 70px;
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li > .w50 {
  width: 178px;
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.separator {
  background: transparent;
  border: none;
  pointer-events: none;
}
@media only screen and (max-width: 560px) {
  .ML__keyboard .ML__keyboard--plate div .rows > ul > li.if-wide {
    display: none;
  }
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.tex-math {
  font-size: 25px;
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li:hover,
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.is-pressed {
  background: var(--keycap-background-active);
  color: var(--keyboard-text-active);
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.keycap:active,
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.keycap.is-active,
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.action:active,
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.action.is-active {
  transform: translateY(calc(-0.2 * var(--keycap-height, 52px))) scale(1.4, 1.4);
  z-index: calc(var(--keyboard-zindex, 105) - 5);
  color: var(--keyboard-text-active);
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.modifier:active,
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.modifier.is-active {
  background: var(--keyboard-text-active);
  color: var(--keycap-text-active);
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.action.font-glyph,
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.modifier.font-glyph {
  font-size: 18px;
}
@media only screen and (max-width: 767px) {
  .ML__keyboard .ML__keyboard--plate div .rows > ul > li.action.font-glyph,
  .ML__keyboard .ML__keyboard--plate div .rows > ul > li.modifier.font-glyph {
    font-size: 16px;
  }
}
@media only screen and (max-width: 767px) {
  .ML__keyboard .ML__keyboard--plate div .rows > ul > li.fnbutton {
    font-size: 12px;
  }
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.bigfnbutton {
  font-size: var(--keycap-extra-small-font-size, 14px);
}
@media only screen and (max-width: 767px) {
  .ML__keyboard .ML__keyboard--plate div .rows > ul > li.bigfnbutton {
    font-size: calc(var(--keycap-extra-small-font-size, 14px) / 1.55);
  }
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.modifier,
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.action {
  background-color: var(--keycap-modifier-background);
  border-color: var(--keycap-modifier-border);
  border-bottom-color: var(--keycap-modifier-border-bottom);
  font-size: 65%;
  font-weight: 100;
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.modifier.selected,
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.action.selected {
  color: var(--keyboard-text-active);
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.modifier.selected:hover,
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.action.selected:hover,
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.modifier.selected:active,
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.action.selected:active,
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.modifier.selected.is-pressed,
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.action.selected.is-pressed,
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.modifier.selected.is-active,
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.action.selected.is-active {
  color: white;
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li.keycap.w50 {
  font-size: 80%;
  padding-top: 10px;
  font-weight: 100;
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li small {
  color: #555;
}
@media only screen and (max-width: 767px) {
  .ML__keyboard .ML__keyboard--plate div .rows > ul > li small {
    font-size: 9px;
  }
}
.ML__keyboard .ML__keyboard--plate div .rows > ul > li aside {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
  font-size: 10px;
  line-height: 10px;
  color: #666;
  /* On small screens, don't display */
}
@media only screen and (max-width: 767px) {
  .ML__keyboard .ML__keyboard--plate div .rows > ul > li aside {
    display: none;
  }
}
@media only screen and (max-width: 414px) {
  .ML__keyboard .ML__keyboard--plate div .rows > ul > li {
    width: calc(10vw - 2px);
    margin-right: 2px;
  }
  .ML__keyboard .ML__keyboard--plate div .rows > ul > .w5 {
    width: calc(5vw -2px);
  }
  .ML__keyboard .ML__keyboard--plate div .rows > ul > .w15 {
    width: calc(15vw - 2px);
  }
  .ML__keyboard .ML__keyboard--plate div .rows > ul > .w20 {
    width: calc(20vw - 2px);
  }
  .ML__keyboard .ML__keyboard--plate div .rows > ul > .w50 {
    width: calc(50vw - 2px);
  }
}
@media only screen and (min-width: 415px) and (max-width: 768px) {
  .ML__keyboard .ML__keyboard--plate div .rows > ul > li {
    width: 37px;
    margin-right: 3px;
  }
  .ML__keyboard .ML__keyboard--plate div .rows > ul > .w5 {
    width: 17px;
  }
  .ML__keyboard .ML__keyboard--plate div .rows > ul > .w15 {
    width: 57px;
  }
  .ML__keyboard .ML__keyboard--plate div .rows > ul > .w20 {
    width: 77px;
  }
  .ML__keyboard .ML__keyboard--plate div .rows > ul > .w50 {
    width: 197px;
  }
}
@media only screen and (min-width: 768px) and (max-width: 1024px) {
  .ML__keyboard .ML__keyboard--plate div .rows > ul {
    height: var(--keycap-height, 52px);
  }
  .ML__keyboard .ML__keyboard--plate div .rows > ul > li {
    height: var(--keycap-height, 52px);
    width: 51px;
    margin-right: 4px;
  }
  .ML__keyboard .ML__keyboard--plate div .rows > ul > .w5 {
    width: 23.5px;
  }
  .ML__keyboard .ML__keyboard--plate div .rows > ul > .w15 {
    width: 78.5px;
  }
  .ML__keyboard .ML__keyboard--plate div .rows > ul > .w20 {
    width: 106px;
  }
  .ML__keyboard .ML__keyboard--plate div .rows > ul > .w50 {
    width: 271px;
  }
}
@media only screen and (min-width: 1025px) {
  .ML__keyboard .ML__keyboard--plate div .rows > ul {
    height: var(--keycap-height, 52px);
  }
  .ML__keyboard .ML__keyboard--plate div .rows > ul > li {
    height: var(--keycap-height, 52px);
    width: 66px;
    margin-right: 6px;
  }
  .ML__keyboard .ML__keyboard--plate div .rows > ul > .modifier,
  .ML__keyboard .ML__keyboard--plate div .rows > ul > .action {
    font-size: 80%;
  }
  .ML__keyboard .ML__keyboard--plate div .rows > ul > .w5 {
    width: 30px;
  }
  .ML__keyboard .ML__keyboard--plate div .rows > ul > .w15 {
    width: 102px;
  }
  .ML__keyboard .ML__keyboard--plate div .rows > ul > .w20 {
    width: 138px;
  }
  .ML__keyboard .ML__keyboard--plate div .rows > ul > .w50 {
    width: 354px;
  }
}
@media (prefers-color-scheme: dark) {
  body:not([theme='light']) .ML__keyboard {
    --hue: 206;
    --keyboard-background: hsl(var(--hue, 212), 19%, 38%);
    --keyboard-text: #f0f0f0;
    --keyboard-text-active: hsl(var(--hue, 212), 100%, 60%);
    --keyboard-background-border: hsl(0, 0%, 20%);
    --keycap-background: hsl(var(--hue, 212), 25%, 39%);
    --keycap-background-active: hsl(var(--hue, 212), 35%, 42%);
    --keycap-background-border: hsl(var(--hue, 212), 25%, 35%);
    --keycap-background-border-bottom: hsl(206, 35%, 40%);
    --keycap-text: hsl(0, 0%, 81.6%);
    --keycap-text-active: #000;
    --keycap-secondary-text: #fff;
    --keycap-modifier-background: hsl(var(--hue, 212), 35%, 40%);
    --keycap-modifier-border: hsl(var(--hue, 212), 35%, 35%);
    --keycap-modifier-border-bottom: hsl(var(--hue, 212), 35%, 42%);
    --keyboard-alternate-background: hsl(var(--hue, 212), 19%, 38%);
  }
}
/* Same as the media query, but with a class */
body[theme='dark'] .ML__keyboard {
  --hue: 206;
  --keyboard-background: hsl(var(--hue, 212), 19%, 38%);
  --keyboard-text: #f0f0f0;
  --keyboard-text-active: hsl(var(--hue, 212), 100%, 60%);
  --keyboard-background-border: hsl(0, 0%, 20%);
  --keycap-background: hsl(var(--hue, 212), 25%, 39%);
  --keycap-background-active: hsl(var(--hue, 212), 35%, 42%);
  --keycap-background-border: hsl(var(--hue, 212), 25%, 35%);
  --keycap-background-border-bottom: hsl(206, 35%, 40%);
  --keycap-text: hsl(0, 0%, 81.6%);
  --keycap-text-active: #000;
  --keycap-secondary-text: #fff;
  --keycap-modifier-background: hsl(var(--hue, 212), 35%, 40%);
  --keycap-modifier-border: hsl(var(--hue, 212), 35%, 35%);
  --keycap-modifier-border-bottom: hsl(var(--hue, 212), 35%, 42%);
  --keyboard-alternate-background: hsl(var(--hue, 212), 19%, 38%);
}
/* The 'material' theme for the virtual keyboard */
div.ML__keyboard.material {
  --keyboard-background: rgba(209, 213, 217, 0.9);
  --keyboard-background-border: #ddd;
  --keycap-background: transparent;
  --keycap-background-active: #cccfd1;
  --keycap-background-border: transparent;
  --keyboard-alternate-background: #efefef;
  --keyboard-alternate-text: #000;
  font-family: Roboto, sans-serif;
}
div.ML__keyboard.material.alternate-keys {
  background: var(--keyboard-alternate-background);
  border: 1px solid transparent;
  border-radius: 5px;
  box-shadow: 0 14px 28px rgba(0, 0, 0, 0.25), 0 10px 10px rgba(0, 0, 0, 0.22);
}
div.ML__keyboard.material.alternate-keys ul li:hover,
div.ML__keyboard.material.alternate-keys ul li:active,
div.ML__keyboard.material.alternate-keys ul li.is-active,
div.ML__keyboard.material.alternate-keys ul li.is-pressed {
  border: 1px solid transparent;
  background: #5f97fc;
  color: white;
  fill: currentColor;
}
div.ML__keyboard.material .ML__keyboard__plate .keyboard-toolbar > div > div {
  font-size: 16px;
}
div.ML__keyboard.material .ML__keyboard__plate .keyboard-toolbar div div:hover,
div.ML__keyboard.material .ML__keyboard__plate .keyboard-toolbar div div:active,
div.ML__keyboard.material .ML__keyboard__plate .keyboard-toolbar div.div.is-active,
div.ML__keyboard.material .ML__keyboard__plate .keyboard-toolbar div.div.is-pressed {
  color: #5f97fc;
  fill: currentColor;
}
div.ML__keyboard.material .ML__keyboard__plate .keyboard-toolbar > div > .selected {
  color: #5f97fc;
  fill: currentColor;
  border-bottom: 2px solid #5f97fc;
  margin-bottom: 8px;
  padding-bottom: 0;
}
div.ML__keyboard.material .ML__keyboard__plate div > .rows > ul > .keycap {
  background: transparent;
  border: 1px solid transparent;
  border-radius: 5px;
  color: var(--keycap-text);
  fill: currentColor;
  transition: none;
}
div.ML__keyboard.material .ML__keyboard__plate div > .rows > ul > .keycap.tt {
  color: #5f97fc;
}
div.ML__keyboard.material .ML__keyboard__plate div > .rows > ul > .keycap[data-key=' '] {
  margin-top: 10px;
  margin-bottom: 10px;
  height: 20px;
  background: #e0e0e0;
}
div.ML__keyboard.material .ML__keyboard__plate div > .rows > ul > .keycap[data-key=' ']:hover,
div.ML__keyboard.material .ML__keyboard__plate div > .rows > ul > .keycap[data-key=' ']:active,
div.ML__keyboard.material .ML__keyboard__plate div > .rows > ul > .keycap[data-key=' '].is-active,
div.ML__keyboard.material .ML__keyboard__plate div > .rows > ul > .keycap[data-key=' '].is-pressed {
  background: #d0d0d0;
  box-shadow: none;
  transform: none;
}
div.ML__keyboard.material .ML__keyboard__plate div > .rows > ul > .keycap:not([data-key=' ']):hover {
  border: 1px solid transparent;
  background: var(--keycap-background-active);
  box-shadow: none;
}
div.ML__keyboard.material .ML__keyboard__plate div > .rows > ul > .keycap:not([data-key=' ']).is-pressed,
div.ML__keyboard.material .ML__keyboard__plate div > .rows > ul > .keycap:not([data-key=' ']).is-active,
div.ML__keyboard.material .ML__keyboard__plate div > .rows > ul > .keycap:not([data-key=' ']):active {
  background: var(--keyboard-alternate-background);
  color: var(--keyboard-alternate-text);
  box-shadow: 0 10px 20px rgba(0, 0, 0, 0.19), 0 6px 6px rgba(0, 0, 0, 0.23);
}
@media only screen and (max-width: 767px) {
  div.ML__keyboard.material .ML__keyboard__plate div > .rows > ul > .keycap:not([data-key=' ']).is-pressed,
  div.ML__keyboard.material .ML__keyboard__plate div > .rows > ul > .keycap:not([data-key=' ']).is-active,
  div.ML__keyboard.material .ML__keyboard__plate div > .rows > ul > .keycap:not([data-key=' ']):active {
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.19), 0 6px 6px rgba(0, 0, 0, 0.23);
    font-size: 10px;
    vertical-align: top;
    width: 19.5px;
    margin-right: 10px;
    margin-left: 10px;
    transform: translateY(-10px) scale(2, 2);
    transition: none;
    justify-content: flex-start;
    padding: 2px 0 0 0;
    z-index: calc(var(--ML_keyboard-zindex, 105) - 5);
  }
}
@media only screen and (max-width: 414px) {
  div.ML__keyboard.material .ML__keyboard__plate div > .rows > ul > .keycap:not([data-key=' ']).is-pressed,
  div.ML__keyboard.material .ML__keyboard__plate div > .rows > ul > .keycap:not([data-key=' ']).is-active,
  div.ML__keyboard.material .ML__keyboard__plate div > .rows > ul > .keycap:not([data-key=' ']):active {
    width: 16.5px;
  }
}
@media only screen and (max-width: 767px) {
  div.ML__keyboard.material .ML__keyboard__plate div > .rows > ul > .keycap:last-child:active,
  div.ML__keyboard.material .ML__keyboard__plate div > .rows > ul > .keycap:last-child.is-active {
    margin-right: 0;
    margin-left: 14px;
  }
}
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.modifier,
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.action {
  background: transparent;
  border: 0;
  color: #869096;
  fill: currentColor;
  font-size: 16px;
  transition: none;
}
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.modifier.selected,
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.action.selected {
  color: #5f97fc;
  border-radius: 0;
  border-bottom: 2px solid #5f97fc;
}
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.modifier:hover,
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.action:hover,
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.modifier:active,
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.action:active,
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.modifier.is-active,
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.action.is-active,
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.modifier.is-pressed,
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.action.is-pressed {
  border: 0;
  color: var(--keycap-text);
  background: var(--keycap-background-active);
  box-shadow: none;
}
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.fnbutton,
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.bigfnbutton {
  background: transparent;
  border: 0;
}
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.fnbutton.selected,
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.bigfnbutton.selected,
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.fnbutton.selected,
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.bigfnbutton.selected {
  color: #5f97fc;
  fill: currentColor;
  border-radius: 0;
  border-bottom: 2px solid #5f97fc;
}
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.fnbutton:hover,
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.bigfnbutton:hover,
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.fnbutton:active,
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.bigfnbutton:active,
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.fnbutton.is-pressed,
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.bigfnbutton.is-pressed,
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.fnbutton.is-active,
div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.bigfnbutton.is-active {
  border: 0;
  color: #5f97fc;
  fill: currentColor;
  background: var(--keycap-background-active);
  box-shadow: none;
}
@media (prefers-color-scheme: dark) {
  body:not([theme='light']) div.ML__keyboard.material {
    --hue: 198;
    --keyboard-background: hsl(var(--hue, 212), 19%, 18%);
    --keyboard-text: #d4d6d7;
    --keyboard-text-active: #5f97fc;
    --keyboard-background-border: hsl(0, 0%, 20%);
    --keycap-background: hsl(var(--hue, 212), 25%, 39%);
    --keycap-background-active: #5f97fc;
    --keycap-background-border: transparent;
    --keycap-background-border-bottom: transparent;
    --keycap-text: hsl(0, 0%, 81.6%);
    --keycap-text-active: #d4d6d7;
    --keycap-secondary-text: #5f97fc;
    --keycap-modifier-background: hsl(var(--hue, 212), 35%, 40%);
    --keycap-modifier-border: hsl(var(--hue, 212), 35%, 35%);
    --keycap-modifier-border-bottom: hsl(var(--hue, 212), 35%, 42%);
    --keyboard-alternate-background: hsl(var(--hue, 212), 8%, 2%);
    --keyboard-alternate-background-active: hsl(var(--hue, 212), 35%, 42%);
    --keyboard-alternate-text: hsl(0, 0%, 82%);
  }
}
body[theme='dark'] div.ML__keyboard.material {
  --hue: 198;
  --keyboard-background: hsl(var(--hue, 212), 19%, 18%);
  --keyboard-text: #d4d6d7;
  --keyboard-text-active: #5f97fc;
  --keyboard-background-border: hsl(0, 0%, 20%);
  --keycap-background: hsl(var(--hue, 212), 25%, 39%);
  --keycap-background-active: #5f97fc;
  --keycap-background-border: transparent;
  --keycap-background-border-bottom: transparent;
  --keycap-text: hsl(0, 0%, 81.6%);
  --keycap-text-active: #d4d6d7;
  --keycap-secondary-text: #5f97fc;
  --keycap-modifier-background: hsl(var(--hue, 212), 35%, 40%);
  --keycap-modifier-border: hsl(var(--hue, 212), 35%, 35%);
  --keycap-modifier-border-bottom: hsl(var(--hue, 212), 35%, 42%);
  --keyboard-alternate-background: hsl(var(--hue, 212), 8%, 2%);
  --keyboard-alternate-background-active: hsl(var(--hue, 212), 35%, 42%);
  --keyboard-alternate-text: hsl(0, 0%, 82%);
}
`;

// src/core/modes-math.ts
var VARIANTS = {
  "main": ["Main-Regular", "ML__cmr"],
  "main-italic": ["Main-Italic", "ML__cmr ML__it"],
  "main-bold": ["Main-Bold", "ML__cmr ML__bold"],
  "main-bolditalic": ["Main-BoldItalic", "ML__cmr ML__bold ML__it"],
  "normal": ["Main-Regular", "ML__cmr"],
  "normal-bold": ["Main-Bold", "ML__mathbf"],
  "normal-italic": ["Math-Italic", "ML__mathit"],
  "normal-bolditalic": ["Math-BoldItalic", "ML__mathbfit"],
  "ams": ["AMS-Regular", "ML__ams"],
  "ams-bold": ["AMS-Regular", "ML__ams"],
  "ams-italic": ["AMS-Regular", "ML__ams"],
  "ams-bolditalic": ["AMS-Regular", "ML__ams"],
  "sans-serif": ["SansSerif-Regular", "ML__sans"],
  "sans-serif-bold": ["SansSerif-Regular", "ML__sans ML__bold"],
  "sans-serif-italic": ["SansSerif-Regular", "ML__sans"],
  "sans-serif-bolditalic": ["SansSerif-Regular", "ML__sans"],
  "calligraphic": ["Caligraphic-Regular", "ML__cal"],
  "calligraphic-bold": ["Caligraphic-Regular", "ML__cal ML__bold"],
  "calligraphic-italic": ["Caligraphic-Regular", "ML__cal ML__it"],
  "calligraphic-bolditalic": ["Caligraphic-Regular", "ML__cal ML__bold ML__it"],
  "script": ["Script-Regular", "ML__script"],
  "script-bold": ["Script-Regular", "ML__script ML__bold"],
  "script-italic": ["Script-Regular", "ML__script ML__it"],
  "script-bolditalic": ["Script-Regular", "ML__script ML__bold ML__it"],
  "fraktur": ["Fraktur-Regular", "ML__frak"],
  "fraktur-bold": ["Fraktur-Regular", "ML__frak"],
  "fraktur-italic": ["Fraktur-Regular", "ML__frak"],
  "fraktur-bolditalic": ["Fraktur-Regular", "ML__frak"],
  "monospace": ["Typewriter-Regular", "ML__tt"],
  "monospace-bold": ["Typewriter-Regular", "ML__tt ML__bold"],
  "monospace-italic": ["Typewriter-Regular", "ML__tt ML__it"],
  "monospace-bolditalic": ["Typewriter-Regular", "ML__tt ML__bold ML__it"],
  "double-struck": ["AMS-Regular", "ML__bb"],
  "double-struck-bold": ["AMS-Regular", "ML__bb"],
  "double-struck-italic": ["AMS-Regular", "ML__bb"],
  "double-struck-bolditalic": ["AMS-Regular", "ML__bb"]
};
var VARIANT_REPERTOIRE = {
  "double-struck": /^[A-Z ]$/,
  "script": /^[A-Z ]$/,
  "calligraphic": /^[\dA-Z ]$/,
  "fraktur": /^[\dA-Za-z ]$|^[!"#$%&'()*+,\-./:;=?[]^]$/,
  "monospace": /^[\dA-Za-z ]$|^[!"&'()*+,\-./:;=?@[\]^_~\u0131\u0237\u0393\u0394\u0398\u039B\u039E\u03A0\u03A3\u03A5\u03A8\u03A9]$/,
  "sans-serif": /^[\dA-Za-z ]$|^[!"&'()*+,\-./:;=?@[\]^_~\u0131\u0237\u0393\u0394\u0398\u039B\u039E\u03A0\u03A3\u03A5\u03A8\u03A9]$/
};
var GREEK_LOWERCASE = /^[\u03B1-\u03C9]|\u03D1|\u03D5|\u03D6|\u03F1|\u03F5]$/;
var GREEK_UPPERCASE = /^[\u0393|\u0394\u0398\u039B\u039E\u03A0\u03A3\u03A5\u03A6\u03A8\u03A9]$/;
var LETTER_SHAPE_RANGES = [
  /^[a-z]$/,
  /^[A-Z]$/,
  GREEK_LOWERCASE,
  GREEK_UPPERCASE
];
var LETTER_SHAPE_MODIFIER = {
  iso: ["it", "it", "it", "it"],
  tex: ["it", "it", "it", "up"],
  french: ["it", "up", "up", "up"],
  upright: ["up", "up", "up", "up"]
};
var MathMode = class extends Mode {
  constructor() {
    super("math");
  }
  createAtom(command, style) {
    const info = getInfo(command, "math");
    const result = new Atom(info?.type ?? "mord", {
      mode: "math",
      command,
      value: info?.codepoint ? String.fromCodePoint(info?.codepoint) : command,
      style
    });
    if (info?.isFunction ?? false) {
      result.isFunction = true;
    }
    if (command.startsWith("\\")) {
      result.verbatimLatex = command;
    }
    return result;
  }
  serialize(run, options) {
    const {parent} = run[0];
    const contextFontsize = parent?.computedStyle.fontSize;
    return joinLatex(getPropertyRuns(run, "fontSize").map((x3) => {
      const result = this.emitBackgroundColorRun(x3, options);
      const fontsize = x3[0].computedStyle.fontSize;
      if (fontsize && (!parent || contextFontsize !== fontsize)) {
        return "\\" + [
          "",
          "tiny",
          "scriptsize",
          "footnotesize",
          "small",
          "normalsize",
          "large",
          "Large",
          "LARGE",
          "huge",
          "Huge"
        ][fontsize] + " " + result;
      }
      return result;
    }));
  }
  emitBackgroundColorRun(run, options) {
    const {parent} = run[0];
    const parentColor = parent?.computedStyle.backgroundColor;
    return joinLatex(getPropertyRuns(run, "backgroundColor").map((x3) => {
      let result = this.emitColorRun(x3, options);
      const style = x3[0].computedStyle;
      if (style.backgroundColor && (!parent || parentColor !== style.backgroundColor) && (x3.length > 0 || !(x3[0] instanceof BoxAtom))) {
        if (options.defaultMode === "inline-math") {
          result = `\\( ${result} \\)`;
        } else {
          result = `\\[ ${result} \\]`;
        }
        result = `\\colorbox{${style.verbatimBackgroundColor ?? style.backgroundColor}}{${result}}`;
      }
      return result;
    }));
  }
  emitColorRun(run, options) {
    const {parent} = run[0];
    const parentMode = parent?.mode ?? "math";
    const contextVariant = variantString(parent);
    const contextColor = parent?.computedStyle.color;
    return joinLatex(getPropertyRuns(run, "color").map((x3) => {
      const result = joinLatex(getPropertyRuns(x3, "variant").map((x4) => {
        const variant = variantString(x4[0]);
        if (x4.every((x5) => {
          const info = getInfo(x5.command, parentMode);
          if (!info || !info.variant)
            return false;
          return variantString(x5) === variant;
        })) {
          return joinLatex(x4.map((x5) => Atom.serialize(x5, options)));
        }
        let command = "";
        if (variant && variant !== contextVariant) {
          command = {
            "calligraphic": "\\mathcal{",
            "fraktur": "\\mathfrak{",
            "double-struck": "\\mathbb{",
            "script": "\\mathscr{",
            "monospace": "\\mathtt{",
            "sans-serif": "\\mathsf{",
            "normal": "\\mathrm{",
            "normal-italic": "\\mathit{",
            "normal-bold": "\\mathbf{",
            "normal-bolditalic": "\\mathbfit{",
            "ams": "",
            "ams-italic": "\\mathit{",
            "ams-bold": "\\mathbf{",
            "ams-bolditalic": "\\mathbfit{",
            "main": "",
            "main-italic": "\\mathit{",
            "main-bold": "\\mathbf{",
            "main-bolditalic": "\\mathbfit{"
          }[variant];
          console.assert(command !== void 0);
        }
        return joinLatex([
          command,
          ...x4.map((x5) => Atom.serialize(x5, options))
        ]) + (command ? "}" : "");
      }));
      const style = x3[0].computedStyle;
      if (style.color && (!parent || contextColor !== style.color)) {
        return "\\textcolor{" + (style.verbatimColor ?? style.color) + "}{" + result + "}";
      }
      return result;
    }));
  }
  applyStyle(box, style) {
    if (style.variant === void 0)
      return "";
    const letterShapeStyle = style.letterShapeStyle === "auto" || !style.letterShapeStyle ? "tex" : style.letterShapeStyle;
    let {variant} = style;
    let {variantStyle} = style;
    if (variant === "normal" && !variantStyle && /[\u00A3\u0131\u0237]/.test(box.value)) {
      variant = "main";
      variantStyle = "italic";
    }
    if (variant === "normal" && !variantStyle && box.value.length === 1) {
      LETTER_SHAPE_RANGES.forEach((x3, i3) => {
        if (x3.test(box.value) && LETTER_SHAPE_MODIFIER[letterShapeStyle][i3] === "it") {
          variantStyle = "italic";
        }
      });
    }
    if (variantStyle === "up") {
      variantStyle = void 0;
    }
    const styledVariant = variantStyle ? variant + "-" + variantStyle : variant;
    console.assert(VARIANTS[styledVariant] !== void 0);
    const [fontName, classes] = VARIANTS[styledVariant];
    if (VARIANT_REPERTOIRE[variant] && !VARIANT_REPERTOIRE[variant].test(box.value)) {
      box.value = mathVariantToUnicode(box.value, variant, variantStyle);
      return null;
    }
    if (GREEK_LOWERCASE.test(box.value)) {
      box.classes += " lcGreek";
    }
    if (classes) {
      box.classes += " " + classes;
    }
    return fontName;
  }
};
function variantString(atom) {
  if (!atom)
    return "";
  const {style} = atom;
  if (style.variant === void 0)
    return "";
  let result = style.variant;
  if (style.variantStyle && style.variantStyle !== "up") {
    result += "-" + style.variantStyle;
  }
  return result;
}
new MathMode();

// src/core/modes-text.ts
function emitStringTextRun(run, options) {
  return joinLatex(run.map((x3) => Atom.serialize(x3, options)));
}
function emitFontShapeTextRun(run, options) {
  return joinLatex(getPropertyRuns(run, "fontShape").map((x3) => {
    const result = emitStringTextRun(x3, options);
    const {fontShape} = x3[0].style;
    if (fontShape === "it") {
      return "\\textit{" + result + "}";
    }
    if (fontShape === "sl") {
      return "\\textsl{" + result + "}";
    }
    if (fontShape === "sc") {
      return "\\textsc{" + result + "}";
    }
    if (fontShape === "n") {
      return "\\textup{" + result + "}";
    }
    if (fontShape) {
      return "\\fontshape{" + x3[0].style.fontShape + "}" + result;
    }
    return result;
  }));
}
function emitFontSeriesTextRun(run, options) {
  return joinLatex(getPropertyRuns(run, "fontSeries").map((x3) => {
    const result = emitFontShapeTextRun(x3, options);
    const {fontSeries} = x3[0].style;
    if (fontSeries === "b") {
      return "\\textbf{" + result + "}";
    }
    if (fontSeries === "l") {
      return "\\textlf{" + result + "}";
    }
    if (fontSeries === "m") {
      return "\\textmd{" + result + "}";
    }
    if (fontSeries) {
      return "\\fontseries{" + fontSeries + "}" + result;
    }
    return result;
  }));
}
function emitSizeTextRun(run, options) {
  return joinLatex(getPropertyRuns(run, "fontSize").map((x3) => {
    const result = emitFontSeriesTextRun(x3, options);
    const command = [
      "",
      "tiny",
      "scriptsize",
      "footnotesize",
      "small",
      "normalsize",
      "large",
      "Large",
      "LARGE",
      "huge",
      "Huge"
    ][x3[0].style.fontSize ?? ""] ?? "";
    if (command) {
      return `\\${command} ${result}`;
    }
    return result;
  }));
}
function emitFontFamilyTextRun(run, options) {
  return joinLatex(getPropertyRuns(run, "fontFamily").map((x3) => {
    const result = emitSizeTextRun(x3, options);
    const command = {
      "roman": "textrm",
      "monospace": "texttt",
      "sans-serif": "textsf"
    }[x3[0].style.fontFamily ?? ""] ?? "";
    if (command)
      return `\\${command}{${result}}`;
    if (x3[0].style.fontFamily) {
      return "\\fontfamily{" + x3[0].style.fontFamily + "}" + result;
    }
    return result;
  }));
}
function emitStyledTextRun(run, options) {
  return emitFontFamilyTextRun(run, options);
}
function emitBackgroundColorRun(run, options) {
  const {parent} = run[0];
  const parentColor = parent?.computedStyle.backgroundColor;
  return joinLatex(getPropertyRuns(run, "backgroundColor").map((x3) => {
    let result = emitColorRun(x3, options);
    const style = x3[0].computedStyle;
    if (style.backgroundColor && (!parent || parentColor !== style.backgroundColor) && (x3.length > 0 || !(x3[0] instanceof BoxAtom))) {
      result = `\\colorbox{${style.verbatimBackgroundColor ?? style.backgroundColor}}{${result}}`;
    }
    return result;
  }));
}
function emitColorRun(run, options) {
  if (!run || run.length === 0)
    return "";
  const parentColor = run[0].parent?.style.color;
  return joinLatex(getPropertyRuns(run, "color").map((x3) => {
    const result = emitStyledTextRun(x3, options);
    if (x3[0].style.color && x3[0].style.color !== "none" && parentColor !== x3[0].style.color) {
      return "\\textcolor{" + (x3[0].style.verbatimColor ?? x3[0].style.color) + "}{" + result + "}";
    }
    return result;
  }));
}
var TEXT_FONT_CLASS = {
  "roman": "",
  "sans-serif": "ML__sans",
  "monospace": "ML__tt"
};
var TextMode = class extends Mode {
  constructor() {
    super("text");
  }
  createAtom(command, style) {
    const info = getInfo(command, "text");
    return new TextAtom(command, info?.codepoint ? String.fromCodePoint(info?.codepoint) : command, style);
  }
  serialize(inRun, options) {
    const run = [...inRun];
    let prefix = "";
    while (run[0]?.changeMode ?? false) {
      prefix += emitBackgroundColorRun([run[0]], options);
      run.shift();
    }
    let suffix = "";
    if (run.length > 0) {
      suffix += emitBackgroundColorRun(run, options);
    }
    if (options.skipModeCommand ?? false)
      return prefix + suffix;
    if (suffix) {
      const allAtomsHaveShapeOrSeriesOrFontFamily = run.every((x3) => x3.style.fontSeries !== void 0 || x3.style.fontShape !== void 0 || x3.style.fontFamily !== void 0);
      if (!allAtomsHaveShapeOrSeriesOrFontFamily) {
        suffix = `\\text{${suffix}}`;
      }
    }
    return prefix + suffix;
  }
  applyStyle(box, style) {
    const {fontFamily} = style;
    if (TEXT_FONT_CLASS[fontFamily]) {
      box.classes += " " + TEXT_FONT_CLASS[fontFamily];
    } else if (fontFamily) {
      box.setStyle("font-family", fontFamily);
    }
    if (style.fontShape) {
      box.classes += " ";
      box.classes += {
        it: "ML__it",
        sl: "ML__shape_sl",
        sc: "ML__shape_sc",
        ol: "ML__shape_ol"
      }[style.fontShape] ?? "";
    }
    if (style.fontSeries) {
      const m3 = style.fontSeries.match(/(.?[lbm])?(.?[cx])?/);
      if (m3) {
        box.classes += " ";
        box.classes += {
          ul: "ML__series_ul",
          el: "ML__series_el",
          l: "ML__series_l",
          sl: "ML__series_sl",
          m: "",
          sb: "ML__series_sb",
          b: "ML__bold",
          eb: "ML__series_eb",
          ub: "ML__series_ub"
        }[m3[1] ?? ""] ?? "";
        box.classes += " ";
        box.classes += {
          uc: "ML__series_uc",
          ec: "ML__series_ec",
          c: "ML__series_c",
          sc: "ML__series_sc",
          n: "",
          sx: "ML__series_sx",
          x: "ML__series_x",
          ex: "ML__series_ex",
          ux: "ML__series_ux"
        }[m3[2] ?? ""] ?? "";
      }
    }
    return "Main-Regular";
  }
  parse(tokens, error, options) {
    let result = [];
    let atom;
    while (tokens.length > 0) {
      const token = tokens.shift();
      if (token === "<space>") {
        result.push(new TextAtom(" ", " ", options.style));
      } else if (!!token && token.startsWith("\\")) {
        tokens.unshift(token);
        let atoms;
        [atoms, tokens] = options.parse("text", tokens, options);
        result = [...result, ...atoms];
      } else if (token === "<$>" || token === "<$$>") {
        const subtokens = tokens.slice(0, tokens.findIndex((x3) => x3 === token));
        tokens = tokens.slice(subtokens.length + 1);
        const [atoms] = options.parse("math", subtokens, options);
        result = [...result, ...atoms];
      } else if (token === "<{>" || token === "<}>") {
      } else if (token) {
        const info = getInfo(token, "text", options.macros);
        if (!info || info.ifMode && !info.ifMode.includes("text")) {
          error({code: "unexpected-token"});
        } else if (info.codepoint) {
          atom = new TextAtom(token, String.fromCodePoint(info.codepoint), options.style);
          atom.verbatimLatex = charToLatex("text", token.codePointAt(0));
          result.push(atom);
        }
      }
    }
    return [result, tokens];
  }
};
new TextMode();

// src/core-atoms/latex.ts
var LatexAtom = class extends Atom {
  constructor(value, options) {
    super("latex", {value, mode: "latex"});
    this.isSuggestion = options?.isSuggestion ?? false;
    this.isError = false;
    this.verbatimLatex = value;
  }
  get computedStyle() {
    return {};
  }
  render(context) {
    const result = new Box(this.value, {
      classes: this.isSuggestion ? "ML__suggestion" : this.isError ? "ML__error" : "",
      type: "latex",
      maxFontSize: 1
    });
    if (!result)
      return null;
    if (this.caret)
      result.caret = this.caret;
    return this.bind(context, result);
  }
};
var LatexGroupAtom = class extends Atom {
  constructor(latex) {
    super("group", {mode: "latex"});
    this.body = [...latex].map((x3) => new LatexAtom(x3));
    this.skipBoundary = false;
  }
  render(context) {
    const box = Atom.createBox(context, this.body, {newList: true});
    if (!box)
      return null;
    if (this.caret)
      box.caret = this.caret;
    return this.bind(context, box);
  }
  serialize(_options) {
    return this.body?.map((x3) => x3.value).join("") ?? "";
  }
};

// src/core/modes-latex.ts
var LatexMode = class extends Mode {
  constructor() {
    super("latex");
  }
  createAtom(command, _style) {
    return new LatexAtom(command);
  }
  serialize(run, _options) {
    return run.filter((x3) => x3 instanceof LatexAtom && !x3.isSuggestion).map((x3) => x3.value).join("");
  }
};
new LatexMode();

// src/core/registers.ts
var DEFAULT_DIMENSION_REGISTERS = {
  "p@": "1pt ",
  "z@": "0pt",
  "maxdimen": "16383.99999pt",
  "hfuzz": "0.1pt",
  "vfuzz": "0.1pt",
  "overfullrule": "5pt",
  "hsize": "6.5in",
  "vsize": "8.9in",
  "parindent": "20pt",
  "maxdepth": "4pt",
  "splitmaxdepth": "\\maxdimen",
  "boxmaxdepth": "\\maxdimen",
  "delimitershortfall": "5pt",
  "nulldelimiterspace": "1.2pt",
  "scriptspace": "0.5pt",
  "topskip": "10pt",
  "splittopskip": "10pt",
  "normalbaselineskip": "12pt",
  "normallineskip": "1pt",
  "normallineskiplimit": "0pt",
  "jot": "3pt",
  "doublerulesep": "2pt",
  "arrayrulewidth": "0.4pt",
  "arraycolsep": "5pt",
  "fboxsep": "3pt",
  "fboxrule": "0.4pt"
};
var DEFAULT_GLUE_REGISTERS = {
  "z@skip": "0pt plust0pt minus0pt",
  "hideskip": "-1000pt plust 1fill",
  "@flushglue": "0pt plust 1fill",
  "parskip": "0pt plus 1pt",
  "abovedisplayskip": "12pt plus 3pt minus 9pt",
  "abovedisplayshortskip": "0pt plus 3pt",
  "belowdisplayskip": "12pt plus 3pt minus 9pt",
  "belowdisplayshortskip": "7pt plus 3pt minus 4pt",
  "parfillskip": "0pt plus 1fil",
  "thinmuskip": "3mu",
  "medmuskip": "4mu plus 2mu minus 4mu",
  "thickmuskip": "5mu plus 5mu",
  "smallskipamount": "3pt plus1pt minus1pt",
  "medskipamount": "6pt plus2pt minus2pt",
  "bigskipamount": "12pt plus4pt minus4pt"
};
var DEFAULT_NUMBER_REGISTERS = {
  pretolerance: 100,
  tolerance: 200,
  hbadness: 1e3,
  vbadness: 1e3,
  linepenalty: 10,
  hyphenpenalty: 50,
  exhyphenpenalty: 50,
  binoppenalty: 700,
  relpenalty: 500,
  clubpenalty: 150,
  widowpenalty: 150,
  displaywidowpenalty: 50,
  brokenpenalty: 100,
  predisplaypenalty: 1e4,
  doublehyphendemerits: 1e4,
  finalhyphendemerits: 5e3,
  adjdemerits: 1e4,
  tracinglostchars: 1,
  uchyph: 1,
  delimiterfactor: 901,
  defaulthyphenchar: "\\-",
  defaultskewchar: -1,
  newlinechar: -1,
  showboxbreadth: 5,
  showboxdepth: 3,
  errorcontextlines: 5,
  interdisplaylinepenalty: 100,
  interfootnotelinepenalty: 100,
  baselineSkip: 1.2,
  arraystretch: "",
  month: new Date().getMonth() + 1,
  day: new Date().getDate(),
  year: new Date().getFullYear()
};
var _DEFAULT_REGISTERS;
function getDefaultRegisters() {
  if (_DEFAULT_REGISTERS)
    return _DEFAULT_REGISTERS;
  _DEFAULT_REGISTERS = {
    ...DEFAULT_NUMBER_REGISTERS
  };
  for (const reg of Object.keys(DEFAULT_DIMENSION_REGISTERS)) {
    _DEFAULT_REGISTERS[reg] = convertToDimension(DEFAULT_DIMENSION_REGISTERS[reg], _DEFAULT_REGISTERS) ?? 0;
  }
  for (const reg of Object.keys(DEFAULT_GLUE_REGISTERS)) {
    _DEFAULT_REGISTERS[reg] = convertToGlue(DEFAULT_GLUE_REGISTERS[reg], _DEFAULT_REGISTERS) ?? 0;
  }
  return _DEFAULT_REGISTERS;
}

// src/core/typeset.ts
function typesetRecursive(atoms, _options) {
  return atoms;
}
function typeset(atoms, options) {
  return typesetRecursive(atoms, {
    registers: options?.registers ? options.registers : getDefaultRegisters()
  });
}

// css/popover.less
var popover_default = `/* The element that display info while in latex mode */
#mathlive-popover-panel {
  visibility: hidden;
  min-width: 160px;
  background-color: rgba(97, 97, 97, 0.95);
  color: #fff;
  text-align: center;
  border-radius: 6px;
  position: fixed;
  z-index: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  box-shadow: 0 14px 28px rgba(0, 0, 0, 0.25), 0 10px 10px rgba(0, 0, 0, 0.22);
  transition: all 0.2s cubic-bezier(0.64, 0.09, 0.08, 1);
  /* The 'tip' of the popover panel */
}
#mathlive-popover-panel::after {
  content: '';
  position: absolute;
  top: -5px;
  left: calc(50% - 3px);
  width: 0;
  height: 0;
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  font-size: 1rem;
  border-bottom: 5px solid rgba(97, 97, 97, 0.9);
}
.ML__popover--reverse-direction::after {
  top: auto;
  bottom: -5px;
  border-top: 5px solid rgba(97, 97, 97, 0.9);
  border-bottom: 0;
}
#mathlive-popover-panel.is-visible {
  visibility: inherit;
  animation: ML__fade-in cubic-bezier(0, 0, 0.2, 1) 0.15s;
}
@keyframes ML__fade-in {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
/* The wrapper class for the entire content of the popover panel */
.ML__popover__content {
  border-radius: 6px;
  padding: 2px;
  cursor: pointer;
  min-height: 100px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  margin-left: 8px;
  margin-right: 8px;
  /* Since the content can be clicked on, provide feedback on hover */
}
.ML__popover__content a {
  color: #5ea6fd;
  padding-top: 0.3em;
  margin-top: 0.4em;
  display: block;
}
.ML__popover__content a:hover {
  color: #5ea6fd;
  text-decoration: underline;
}
.ML__popover__content:hover,
.ML__popover__content.is-pressed,
.ML__popover__content.is-active {
  background: rgba(255, 255, 255, 0.1);
}
/* The command inside a popover (inside a #mathlive-popover-panel) */
.ML__popover__command {
  font-size: 1.6rem;
  font-family: KaTeX_Main;
}
.ML__popover__prev-shortcut {
  height: 31px;
  opacity: 0.1;
  cursor: pointer;
  margin-left: 8px;
  margin-right: 8px;
  padding-top: 4px;
  padding-bottom: 2px;
}
.ML__popover__prev-shortcut:hover,
.ML__popover__next-shortcut:hover {
  opacity: 0.3;
}
.ML__popover__prev-shortcut.is-pressed,
.ML__popover__next-shortcut.is-pressed {
  opacity: 1;
}
.ML__popover__prev-shortcut.is-active,
.ML__popover__next-shortcut.is-active {
  opacity: 1;
}
.ML__popover__prev-shortcut > span,
.ML__popover__next-shortcut > span {
  padding: 5px;
  border-radius: 8px;
  width: 20px;
  height: 20px;
  display: inline-block;
}
.ML__popover__prev-shortcut > span > span {
  margin-top: -2px;
  display: block;
}
.ML__popover__next-shortcut > span > span {
  margin-top: 2px;
  display: block;
}
.ML__popover__prev-shortcut:hover > span,
.ML__popover__next-shortcut:hover > span {
  background: rgba(255, 255, 255, 0.1);
}
.ML__popover__next-shortcut {
  height: 34px;
  opacity: 0.1;
  cursor: pointer;
  margin-left: 8px;
  margin-right: 8px;
  padding-top: 2px;
  padding-bottom: 4px;
}
/* The keyboard shortcuts for a symbol as displayed in the popover */
.ML__popover__shortcut {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
  font-size: 0.8em;
  opacity: 0.7;
  margin-top: 0.25em;
  padding-top: 0.25em;
}
/* The field in a popover that provides some info about the symbol */
.ML__popover__note {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
  font-size: 0.8rem;
  opacity: 0.7;
  line-height: 1em;
  padding-left: 0.5em;
  padding-right: 0.5em;
  padding-top: 0.25em;
}
/* Style for the character that joins the modifiers of a keyboard shortcut 
(usually a "+" sign)*/
.ML__shortcut-join {
  opacity: 0.5;
}
`;

// src/editor/popover.ts
var POPOVER_STYLESHEET_HASH = void 0;
var gPopoverStylesheet = null;
var gCoreStylesheet = null;
var NOTES = {
  "\\text": "roman text",
  "\\textrm": "roman text",
  "\\textnormal": "roman text",
  "\\textit": "italic text",
  "\\textbf": "bold text",
  "\\texttt": "monospaced text",
  "\\textsf": "sans-serif text",
  "\\mathrm": ["roman", "(upright)"],
  "\\mathbf": "bold",
  "\\bf": "bold",
  "\\bold": "bold",
  "\\mathit": "italic",
  "\\mathbb": "blackboard",
  "\\mathscr": "script",
  "\\mathtt": ["typewriter", "(monospaced)"],
  "\\mathsf": "sans-serif",
  "\\mathcal": "caligraphic",
  "\\frak": ["fraktur", "(gothic)"],
  "\\mathfrak": ["fraktur", "(gothic)"],
  "\\textcolor": "text color",
  "\\color": "color",
  "\\forall": "for all",
  "\\exists": "there exists",
  "\\nexists": "there does not exist",
  "\\frac": "fraction",
  "\\dfrac": "display fraction",
  "\\cfrac": "continuous fraction",
  "\\tfrac": "text fraction",
  "\\binom": "binomial coefficient",
  "\\dbinom": "display binomial coefficient",
  "\\tbinom": "text binomial coefficient",
  "\\pdiff": "partial differential",
  "\\vec": "vector",
  "\\check": "caron",
  "\\acute": "acute",
  "\\breve": "breve",
  "\\tilde": "tilde",
  "\\dot": "dot",
  "\\hat": ["hat", "circumflex"],
  "\\ddot": "double dot",
  "\\bar": "bar",
  "\\prime": "prime",
  "\\doubleprime": "double prime",
  "\\varnothing": "empty set",
  "\\emptyset": "empty set",
  "\\subseteq": "subset of or <br>equal to",
  "\\supseteq": "superset of or <br>equal to",
  "\\supset": "superset of",
  "\\subset": "subset of",
  "\\partial": "partial derivative",
  "\\bigcup": "union",
  "\\bigcap": "intersection",
  "\\approx": "approximately equal to",
  "\\notin": "not an element of",
  "\\in": ["element of", "included in"],
  "\\infty": "infinity",
  "\\land": "logical and",
  "\\sqrt": "square root",
  "\\prod": "product",
  "\\sum": "summation",
  "\\amalg": ["amalgamation", "coproduct", "free product", "disjoint union"],
  "\\cup": "union with",
  "\\cap": "intersection with",
  "\\int": "integral",
  "\\iint": "surface integral",
  "\\oint": "curve integral",
  "\\iiint": "volume integral",
  "\\iff": "if and only if",
  "\\ln": "natural logarithm",
  "\\boldsymbol": "bold",
  "\\setminus": "set subtraction",
  "\\stackrel": "relation with symbol above",
  "\\stackbin": "operator with symbol above",
  "\\underset": "symbol with annotation below",
  "\\overset": "symbol with annotation above",
  "\\hslash": ["h-bar", "Planck constant"],
  "\\gtrsim": "greater than or <br>similar to",
  "\\propto": "proportional to",
  "\\equiv": "equivalent to",
  "\\!": ["negative thin space", "(-3 mu)"],
  "\\ ": ["space", "(6 mu)"],
  "\\,": ["thin space", "(3 mu)"],
  "\\:": ["medium space", "(4 mu)"],
  "\\;": ["thick space", "(5 mu)"],
  "\\quad": ["1 em space", "(18 mu)"],
  "\\qquad": ["2 em space", "(36 mu)"],
  "\\enskip": ["&#189; em space", "(9 mu)"],
  "\\mp": "minus or plus",
  "\\pm": "plus or minus",
  "\\Im": "Imaginary part of",
  "\\Re": "Real part of",
  "\\gothicCapitalR": "Real part of",
  "\\gothicCapitalI": "Imaginary part part of",
  "\\differentialD": "differential d",
  "\\aleph": [
    "aleph",
    "infinite cardinal",
    '<a target="_blank" href="https://en.wikipedia.org/wiki/Cardinal_number">Wikipedia <big>&#x203A;</big></a>'
  ],
  "\\beth": [
    "beth",
    "beth number",
    '<a target="_blank" href="https://en.wikipedia.org/wiki/Beth_number">Wikipedia <big>&#x203A;</big></a>'
  ],
  "\\gimel": [
    "gimel",
    "gimel function",
    '<a target="_blank" href="https://en.wikipedia.org/wiki/Gimel_function">Wikipedia <big>&#x203A;</big></a>'
  ],
  "\\O": "empty set",
  "\\N": "set of <br>natural numbers",
  "\\Z": "set of <br>integers",
  "\\Q": "set of <br>rational numbers",
  "\\C": "set of <br>complex numbers",
  "\\R": "set of <br>real numbers",
  "\\P": "set of <br>prime numbers",
  "\\lesseqqgtr": "less than, equal to or<br> greater than",
  "\\gnapprox": "greater than and <br>not approximately",
  "\\lnapprox": "lesser than and <br>not approximately",
  "\\j": "dotless j",
  "\\i": "dotless i",
  "\\cdot": "centered dot",
  "\\lmoustache": "left moustache",
  "\\rmoustache": "right moustache",
  "\\nabla": ["nabla", "del", "differential vector operator"],
  "\\square": [
    "square",
    "d\u2019Alembert operator",
    '<a target="_blank" href="https://en.wikipedia.org/wiki/D%27Alembert_operator">Wikipedia <big>&#x203A;</big></a>'
  ],
  "\\blacksquare": [
    "black square",
    "end of proof",
    "tombstone",
    "Halmos symbol"
  ],
  "\\Box": "end of proof",
  "\\colon": ["such that", "ratio"],
  "\\coloneq": ["is defined by", "is assigned"],
  "\\Colon": ["is defined by", "as"],
  "\\_": ["underbar", "underscore"],
  "\\ll": "much less than",
  "\\gg": "much greater than",
  "\\doteq": "approximately equal to",
  "\\Doteq": "approximately equal to",
  "\\doteqdot": "approximately equal to",
  "\\cong": ["isomorphism of", "(for algebras, modules...)"],
  "\\det": ["determinant of", "(of a matrix)"],
  "\\dotplus": "Cartesian product algebra",
  "\\otimes": [
    "tensor product",
    "(of algebras)",
    "Kronecker product",
    "(of matrices)"
  ],
  "\\oplus": ["direct sum", "(of modules)"],
  "\\lb": "base-2 logarithm",
  "\\lg": "base-10 logarithm",
  "\\wp": [
    "Weierstrass P",
    '<a target="_blank" href="https://en.wikipedia.org/wiki/Weierstrass%27s_elliptic_functions">Wikipedia <big>&#x203A;</big></a>'
  ],
  "\\wr": [
    "wreath product",
    '<a target="_blank" href="https://en.wikipedia.org/wiki/Wreath_product">Wikipedia <big>&#x203A;</big></a>'
  ],
  "\\top": ["tautology", "Proposition P is universally true"],
  "\\bot": ["contradiction", "Proposition P is contradictory"],
  "\\mid": ["probability", "of event A given B"],
  "\\mho": [
    "Siemens",
    "electrical conductance in SI unit",
    '<a target="_blank" href="https://en.wikipedia.org/wiki/Siemens_(unit)">Wikipedia <big>&#x203A;</big></a>'
  ],
  "\\Longrightarrow": "implies",
  "\\Longleftrightarrow": "if, and only if,",
  "\\prec": "precedes",
  "\\preceq": "precedes or is equal to",
  "\\succ": "succeedes",
  "\\succeq": "succeedes or is equal to",
  "\\perp": ["is perpendicular to", "is independent of"],
  "\\models": [
    "entails",
    "double-turnstyle, models",
    "is a semantic consequence of",
    '<a target="_blank" href="https://en.wikipedia.org/wiki/Double_turnstile">Wikipedia <big>&#x203A;</big></a>'
  ],
  "\\vdash": [
    "satisfies",
    "turnstyle, assertion sign",
    "syntactic inference",
    '<a target="_blank" href="https://en.wikipedia.org/wiki/Turnstile_(symbol)">Wikipedia <big>&#x203A;</big></a>'
  ],
  "\\implies": ["implies", "logical consequence"],
  "\\impliedby": ["implied by", "logical consequence"],
  "\\surd": ["surd", "root of", "checkmark"],
  "\\ltimes": [
    "semi direct product",
    '<a target="_blank" href="https://en.wikipedia.org/wiki/Semidirect_product">Wikipedia <big>&#x203A;</big></a>'
  ],
  "\\rtimes": [
    "semi direct product",
    '<a target="_blank" href="https://en.wikipedia.org/wiki/Semidirect_product">Wikipedia <big>&#x203A;</big></a>'
  ],
  "\\leftthreetimes": [
    "semi direct product",
    '<a target="_blank" href="https://en.wikipedia.org/wiki/Semidirect_product">Wikipedia <big>&#x203A;</big></a>'
  ],
  "\\rightthreetimes": [
    "semi direct product",
    '<a target="_blank" href="https://en.wikipedia.org/wiki/Semidirect_product">Wikipedia <big>&#x203A;</big></a>'
  ],
  "\\divideontimes": ["divide on times"],
  "\\curlywedge": "nor",
  "\\curlyvee": "nand",
  "\\simeq": "is group isomorphic with",
  "\\vartriangleleft": ["is a normal subgroup of", "is an ideal ring of"],
  "\\circ": ["circle", "ring", "function composition"],
  "\\rlap": ["overlap right", "\\rlap{x}o"],
  "\\llap": ["overlap left", "o\\llap{/}"],
  "\\colorbox": ["color box", "\\colorbox{#fbc0bd}{...}"],
  "\\ast": ["asterisk", "reflexive closure (as a superscript)"],
  "\\bullet": "bullet",
  "\\lim": "limit"
};
function getNote(symbol) {
  let result = NOTES[symbol] ?? "";
  if (isArray(result)) {
    result = result.join("<br>");
  }
  return result;
}
function latexToMarkup(latex) {
  const root = new Atom("root", {mode: "math"});
  root.body = typeset(parseLatex(latex, {
    parseMode: "math",
    macros: getMacros(),
    registers: getDefaultRegisters()
  }));
  const box = coalesce(adjustInterAtomSpacing(new Box(root.render(new Context({
    macros: getMacros(),
    registers: getDefaultRegisters(),
    smartFence: false
  }, {
    fontSize: DEFAULT_FONT_SIZE
  }, "displaystyle")), {classes: "ML__base"})));
  return makeStruts(box, {classes: "ML__mathlive"}).toMarkup();
}
function showPopoverWithLatex(mf, latex, displayArrows) {
  if (!latex || latex.length === 0) {
    hidePopover(mf);
    return;
  }
  const command = latex;
  const commandMarkup = latexToMarkup(latex);
  const commandNote = getNote(command);
  const keybinding = getKeybindingsForCommand(mf.keybindings, command).join("<br>");
  let template = displayArrows ? '<div class="ML__popover__prev-shortcut" role="button" aria-label="Previous suggestion"><span><span>&#x25B2;</span></span></div>' : "";
  template += '<span class="ML__popover__content" role="button">';
  template += '<div class="ML__popover__command">' + commandMarkup + "</div>";
  if (commandNote) {
    template += '<div class="ML__popover__note">' + commandNote + "</div>";
  }
  if (keybinding) {
    template += '<div class="ML__popover__shortcut">' + keybinding + "</div>";
  }
  template += "</span>";
  template += displayArrows ? '<div class="ML__popover__next-shortcut" role="button" aria-label="Next suggestion"><span><span>&#x25BC;</span></span></div>' : "";
  mf.popover = createPopover(mf, template);
  let element = mf.popover.querySelectorAll(".ML__popover__content");
  if (element && element.length > 0) {
    attachButtonHandlers((command2) => mf.executeCommand(command2), element[0], {
      default: ["complete", "accept-suggestion"]
    });
  }
  element = mf.popover.querySelectorAll(".ML__popover__prev-shortcut");
  if (element && element.length > 0) {
    attachButtonHandlers((command2) => mf.executeCommand(command2), element[0], "previousSuggestion");
  }
  element = mf.popover.querySelectorAll(".ML__popover__next-shortcut");
  if (element && element.length > 0) {
    attachButtonHandlers((command2) => mf.executeCommand(command2), element[0], "nextSuggestion");
  }
  setTimeout(() => {
    const caretPoint = getCaretPoint(mf.field);
    if (caretPoint)
      setPopoverPosition(mf, caretPoint);
    if (mf.popover) {
      mf.popover.classList.add("is-visible");
      mf.popoverVisible = true;
    }
  }, 32);
}
function updatePopoverPosition(mf, options) {
  if (!mf.element || mf.element.mathfield !== mf)
    return;
  if (!mf.popover || !mf.popoverVisible)
    return;
  if (options?.deferred) {
    setTimeout(() => updatePopoverPosition(mf), 100);
    return;
  }
  if (mf.model.at(mf.model.position)?.type !== "latex") {
    hidePopover(mf);
  } else {
    const caretPoint = getCaretPoint(mf.field);
    if (caretPoint)
      setPopoverPosition(mf, caretPoint);
  }
}
function setPopoverPosition(mf, position) {
  throwIfNotInBrowser();
  if (!mf.popover || !mf.popoverVisible)
    return;
  const screenHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
  const screenWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
  const scrollbarHeight = window.innerHeight - document.documentElement.clientHeight;
  const virtualkeyboardHeight = mf.virtualKeyboard.height;
  if (position.x + mf.popover.offsetWidth / 2 > screenWidth - scrollbarWidth) {
    mf.popover.style.left = `${screenWidth - mf.popover.offsetWidth - scrollbarWidth}px`;
  } else if (position.x - mf.popover.offsetWidth / 2 < 0) {
    mf.popover.style.left = "0";
  } else {
    mf.popover.style.left = `${position.x - mf.popover.offsetWidth / 2}px`;
  }
  if (position.y + mf.popover.offsetHeight + 5 > screenHeight - scrollbarHeight - virtualkeyboardHeight) {
    mf.popover.classList.add("ML__popover--reverse-direction");
    mf.popover.style.top = `${position.y - position.height - mf.popover.offsetHeight - 5}px`;
  } else {
    mf.popover.classList.remove("ML__popover--reverse-direction");
    mf.popover.style.top = `${position.y + 5}px`;
  }
}
function hidePopover(mf) {
  mf.suggestionIndex = 0;
  mf.popoverVisible = false;
  if (mf.popover) {
    mf.popover.classList.remove("is-visible");
    mf.popover.innerHTML = "";
  }
}
function createPopover(mf, html) {
  if (mf.popover) {
    mf.popover.innerHTML = mf.options.createHTML(html);
    return mf.popover;
  }
  mf.popover = getSharedElement("mathlive-popover-panel");
  if (POPOVER_STYLESHEET_HASH === void 0) {
    POPOVER_STYLESHEET_HASH = hashCode(popover_default).toString(36);
  }
  gPopoverStylesheet = inject(null, popover_default, POPOVER_STYLESHEET_HASH);
  gCoreStylesheet = inject(null, core_default, hashCode(core_default).toString(36));
  mf.popover.innerHTML = mf.options.createHTML(html);
  return mf.popover;
}
function disposePopover(mf) {
  releaseSharedElement(mf.popover);
  if (gPopoverStylesheet)
    gPopoverStylesheet.release();
  if (gCoreStylesheet)
    gCoreStylesheet.release();
  delete mf.popover;
}

// src/editor-mathfield/render.ts
function hash(latex) {
  let result = 0;
  for (let i3 = 0; i3 < latex.length; i3++) {
    result = result * 31 + latex.charCodeAt(i3);
    result = result | 0;
  }
  return Math.abs(result);
}
function requestUpdate(mathfield, options) {
  if (!mathfield.dirty) {
    mathfield.dirty = true;
    requestAnimationFrame(() => {
      if (isValidMathfield(mathfield) && mathfield.dirty) {
        mathfield._atomBoundsCache = new Map();
        render(mathfield, options);
        mathfield._atomBoundsCache = void 0;
      }
    });
  }
}
function render(mathfield, renderOptions) {
  throwIfNotInBrowser();
  if (!isValidMathfield(mathfield))
    return;
  renderOptions = renderOptions ?? {};
  mathfield.dirty = false;
  const {model} = mathfield;
  if (window.mathlive === void 0) {
    window.mathlive = {};
  }
  model.root.caret = "";
  model.root.isSelected = false;
  model.root.containsCaret = true;
  for (const atom of model.atoms) {
    atom.caret = "";
    atom.isSelected = false;
    atom.containsCaret = false;
  }
  const hasFocus = mathfield.hasFocus() && !mathfield.options.readOnly;
  if (model.selectionIsCollapsed) {
    model.at(model.position).caret = hasFocus ? mathfield.mode : "";
  } else {
    for (const atom of model.getAtoms(model.selection, {
      includeChildren: true
    })) {
      atom.isSelected = true;
    }
  }
  if (hasFocus) {
    let ancestor = model.at(model.position).parent;
    while (ancestor) {
      ancestor.containsCaret = true;
      ancestor = ancestor.parent;
    }
  }
  const base = model.root.render(new Context({
    macros: mathfield.options.macros,
    registers: mathfield.options.registers,
    atomIdsSettings: {
      seed: hash(Atom.serialize(model.root, {
        expandMacro: false,
        defaultMode: mathfield.options.defaultMode
      })),
      groupNumbers: renderOptions.forHighlighting ?? false
    },
    smartFence: mathfield.options.smartFence,
    renderPlaceholder: mathfield.options.readOnly ? (context, p3) => {
      if (p3.placeholderId) {
        const field2 = mathfield.getPlaceholderField(p3.placeholderId);
        return p3.createMathfieldBox(context, {
          placeholderId: p3.placeholderId,
          element: field2
        });
      }
      return p3.createBox(context);
    } : void 0,
    isSelected: model.root.isSelected
  }, {
    fontSize: DEFAULT_FONT_SIZE,
    letterShapeStyle: mathfield.options.letterShapeStyle
  }, mathfield.options.defaultMode === "inline-math" ? "textstyle" : "displaystyle"));
  const wrapper = makeStruts(adjustInterAtomSpacing(base, mathfield.options.horizontalSpacingScale), {
    classes: "ML__mathlive",
    attributes: {
      "translate": "no",
      "aria-hidden": "true"
    }
  });
  const field = mathfield.field;
  const isFocused = field.classList.contains("ML__focused");
  if (isFocused && !hasFocus) {
    field.classList.remove("ML__focused");
  } else if (!isFocused && hasFocus) {
    field.classList.add("ML__focused");
  }
  field.innerHTML = mathfield.options.createHTML(wrapper.toMarkup());
  mathfield.fieldContent = field.querySelector(".ML__mathlive");
  mathfield.accessibleNode.innerHTML = mathfield.options.createHTML('<math xmlns="http://www.w3.org/1998/Math/MathML">' + atomsToMathML(model.root, mathfield.options) + "</math>");
  renderSelection(mathfield);
  if (mathfield.options.readOnly) {
    mathfield.attachNestedMathfield();
  }
  if (!(renderOptions.interactive ?? false)) {
    setTimeout(() => renderSelection(mathfield), 32);
  }
}
function renderSelection(mathfield) {
  throwIfNotInBrowser();
  if (!mathfield.field)
    return;
  for (const element of mathfield.field.querySelectorAll(".ML__selection, .ML__contains-highlight")) {
    element.remove();
  }
  if (!mathfield.hasFocus())
    return;
  const model = mathfield.model;
  if (model.selectionIsCollapsed) {
    setTimeout(() => updatePopoverPosition(mathfield), 32);
    let atom = model.at(model.position);
    while (atom && !(atom.containsCaret && atom.displayContainsHighlight)) {
      atom = atom.parent;
    }
    if (atom?.containsCaret && atom.displayContainsHighlight) {
      const bounds = adjustForScrolling(mathfield, getAtomBounds(mathfield, atom));
      if (bounds) {
        const element = document.createElement("div");
        element.classList.add("ML__contains-highlight");
        element.style.position = "absolute";
        element.style.left = `${bounds.left}px`;
        element.style.top = `${bounds.top}px`;
        element.style.width = `${Math.ceil(bounds.right - bounds.left)}px`;
        element.style.height = `${Math.ceil(bounds.bottom - bounds.top - 1)}px`;
        mathfield.field.insertBefore(element, mathfield.field.childNodes[0]);
      }
    }
    return;
  }
  for (const x3 of unionRects(getSelectionBounds(mathfield, {excludeAtomsWithBackground: true}))) {
    const selectionElement = document.createElement("div");
    selectionElement.classList.add("ML__selection");
    selectionElement.style.position = "absolute";
    selectionElement.style.left = `${x3.left}px`;
    selectionElement.style.top = `${x3.top}px`;
    selectionElement.style.width = `${Math.ceil(x3.right - x3.left)}px`;
    selectionElement.style.height = `${Math.ceil(x3.bottom - x3.top - 1)}px`;
    mathfield.field.insertBefore(selectionElement, mathfield.field.childNodes[0]);
  }
}
function unionRects(rects) {
  const result = [];
  for (const rect of rects) {
    let found = false;
    for (const rect2 of result) {
      if (rect.left === rect2.left && rect.right === rect2.right && rect.top === rect2.top && rect.bottom === rect2.bottom) {
        found = true;
        break;
      }
    }
    if (!found)
      result.push(rect);
  }
  for (const rect of rects) {
    let count = 0;
    for (const rect2 of rects) {
      if (rect.left >= rect2.left && rect.right <= rect2.right && rect.top >= rect2.top && rect.bottom <= rect2.bottom) {
        count += 1;
        if (count > 1)
          break;
      }
    }
    if (count === 1)
      result.push(rect);
  }
  return result;
}

// src/editor-model/selection-utils.ts
function compareSelection(a3, b3) {
  if (a3.direction === b3.direction) {
    const l3 = a3.ranges.length;
    if (b3.ranges.length === l3) {
      let i3 = 0;
      while (i3 < l3 && compareRange(a3.ranges[i3], b3.ranges[i3]) === "equal") {
        i3++;
      }
      return i3 === l3 ? "equal" : "different";
    }
  }
  return "different";
}
function compareRange(a3, b3) {
  if (a3[0] === b3[0] && a3[1] === b3[1])
    return "equal";
  return "different";
}
function range(selection) {
  let first = Infinity;
  let last = -Infinity;
  for (const range2 of selection.ranges) {
    first = Math.min(first, range2[0], range2[1]);
    last = Math.max(last, range2[0], range2[1]);
  }
  return [first, last];
}

// src/editor-mathfield/mode-editor.ts
var CLIPBOARD_LATEX_BEGIN = "\\begin{equation*}";
var CLIPBOARD_LATEX_END = "\\end{equation*}";
var defaultExportHook = (_from, latex, _range) => {
  if (!MODE_SHIFT_COMMANDS.some((x3) => latex.startsWith(x3[0]) && latex.endsWith(x3[1]))) {
    latex = `${CLIPBOARD_LATEX_BEGIN} ${latex} ${CLIPBOARD_LATEX_END}`;
  }
  return latex;
};
var _ModeEditor = class {
  constructor(name) {
    _ModeEditor._registry[name] = this;
  }
  static onPaste(mode, mathfield, ev) {
    return _ModeEditor._registry[mode].onPaste(mathfield, ev);
  }
  static onCopy(mathfield, ev) {
    if (!ev.clipboardData)
      return;
    const model = mathfield.model;
    const exportRange = model.selectionIsCollapsed ? [0, model.lastOffset] : range(model.selection);
    const atoms = model.getAtoms(exportRange);
    if (atoms.every((x3) => x3.mode === "text" || !x3.mode)) {
      ev.clipboardData.setData("text/plain", atoms.filter((x3) => x3 instanceof TextAtom).map((x3) => x3.value).join(""));
    } else if (atoms.every((x3) => x3.mode === "latex")) {
      ev.clipboardData.setData("text/plain", model.getAtoms(exportRange, {includeChildren: true}).map((x3) => x3.value ?? "").join(""));
    } else {
      let latex = "";
      if (atoms.length === 1 && atoms[0].verbatimLatex) {
        latex = atoms[0].verbatimLatex;
      }
      if (!latex) {
        latex = model.getValue(exportRange, "latex-expanded");
      }
      ev.clipboardData.setData("application/x-latex", latex);
      ev.clipboardData.setData("text/plain", mathfield.options.onExport(mathfield, latex, exportRange));
      const mathJson = model.getValue(exportRange, "math-json");
      if (mathJson) {
        ev.clipboardData.setData("application/json", mathJson);
      }
      const mathMl = model.getValue(exportRange, "math-ml");
      if (mathMl) {
        ev.clipboardData.setData("application/mathml+xml", mathMl);
      }
    }
    ev.preventDefault();
  }
  static insert(mode, model, text, options = {}) {
    return _ModeEditor._registry[mode].insert(model, text, options);
  }
  onPaste(_mathfield, _ev) {
    return false;
  }
  insert(_model, _text, _options) {
    return false;
  }
};
var ModeEditor = _ModeEditor;
ModeEditor._registry = {};

// src/editor-model/listeners.ts
function selectionDidChange(model) {
  if (typeof model.listeners?.onSelectionDidChange === "function" && !model.suppressChangeNotifications) {
    model.suppressChangeNotifications = true;
    model.listeners.onSelectionDidChange(model);
    model.suppressChangeNotifications = false;
  }
}
function contentDidChange(model) {
  if (typeof model.listeners?.onContentDidChange === "function" && !model.suppressChangeNotifications) {
    model.suppressChangeNotifications = true;
    model.listeners.onContentDidChange(model);
    model.suppressChangeNotifications = false;
  }
}
function placeholderDidChange(model, placeholderId) {
  if (typeof model.listeners?.onPlaceholderDidChange === "function" && !model.suppressChangeNotifications) {
    model.suppressChangeNotifications = true;
    model.listeners.onPlaceholderDidChange(model, placeholderId);
    model.suppressChangeNotifications = false;
  }
}

// src/editor-mathfield/mode-editor-latex.ts
var LatexModeEditor = class extends ModeEditor {
  constructor() {
    super("latex");
  }
  createAtom(command, _style) {
    return new LatexAtom(command);
  }
  onPaste(mathfield, ev) {
    if (!ev.clipboardData)
      return false;
    const text = ev.clipboardData.getData("text/plain");
    if (text) {
      mathfield.snapshot();
      if (this.insert(mathfield.model, text)) {
        requestUpdate(mathfield);
      }
      ev.preventDefault();
      ev.stopPropagation();
      return true;
    }
    return false;
  }
  insert(model, text, options) {
    if (!options)
      options = {};
    if (!options.insertionMode)
      options.insertionMode = "replaceSelection";
    if (!options.selectionMode)
      options.selectionMode = "placeholder";
    const {suppressChangeNotifications} = model;
    if (options.suppressChangeNotifications) {
      model.suppressChangeNotifications = true;
    }
    const savedSuppressChangeNotifications = model.suppressChangeNotifications;
    model.suppressChangeNotifications = true;
    if (options.insertionMode === "replaceSelection" && !model.selectionIsCollapsed) {
      model.position = model.deleteAtoms(range(model.selection));
    } else if (options.insertionMode === "replaceAll") {
      model.root.setChildren([], "body");
      model.position = 0;
    } else if (options.insertionMode === "insertBefore") {
      model.collapseSelection("backward");
    } else if (options.insertionMode === "insertAfter") {
      model.collapseSelection("forward");
    }
    const newAtoms = [];
    for (const c3 of text) {
      if (COMMAND_MODE_CHARACTERS.test(c3)) {
        newAtoms.push(new LatexAtom(c3));
      }
    }
    let cursor = model.at(model.position);
    if (cursor instanceof LatexGroupAtom)
      cursor = cursor.lastChild;
    const lastNewAtom = cursor.parent.addChildrenAfter(newAtoms, cursor);
    model.suppressChangeNotifications = savedSuppressChangeNotifications;
    if (options.selectionMode === "before") {
    } else if (options.selectionMode === "item") {
      model.setSelection(model.anchor, model.offsetOf(lastNewAtom));
    } else if (lastNewAtom) {
      model.position = model.offsetOf(lastNewAtom);
    }
    contentDidChange(model);
    model.suppressChangeNotifications = suppressChangeNotifications;
    return true;
  }
};
function getLatexGroup(model) {
  return model.atoms.find((x3) => x3 instanceof LatexGroupAtom);
}
function getLatexGroupBody(model) {
  const atom = model.atoms.find((x3) => x3 instanceof LatexGroupAtom);
  if (!atom)
    return [];
  return atom.body?.filter((x3) => x3 instanceof LatexAtom) ?? [];
}
function getCommandSuggestionRange(model, options) {
  let start = 0;
  let found = false;
  const last = Number.isFinite(options?.before) ? options?.before ?? 0 : model.lastOffset;
  while (start <= last && !found) {
    const atom = model.at(start);
    found = atom instanceof LatexAtom && atom.isSuggestion;
    if (!found)
      start++;
  }
  if (!found)
    return [void 0, void 0];
  let end = start;
  let done = false;
  while (end <= last && !done) {
    const atom = model.at(end);
    done = !(atom instanceof LatexAtom && atom.isSuggestion);
    if (!done)
      end++;
  }
  return [start - 1, end - 1];
}
new LatexModeEditor();

// src/editor-mathfield/autocomplete.ts
function updateAutocomplete(mathfield, options) {
  const {model} = mathfield;
  for (const atom2 of getLatexGroupBody(model)) {
    if (atom2.isSuggestion) {
      atom2.parent.removeChild(atom2);
    } else {
      atom2.isError = false;
    }
  }
  if (!model.selectionIsCollapsed) {
    hidePopover(mathfield);
    return;
  }
  const command = [];
  let atom = model.at(model.position);
  while (atom && atom instanceof LatexAtom && /[a-zA-Z*]$/.test(atom.value)) {
    command.unshift(atom);
    atom = atom.leftSibling;
  }
  const leftSibling = atom?.leftSibling;
  if (atom && atom instanceof LatexAtom && atom.value === "\\" && !(leftSibling instanceof LatexAtom && atom.value === "\\")) {
    command.unshift(atom);
    atom = model.at(model.position).rightSibling;
    while (atom && atom instanceof LatexAtom && /[a-zA-Z*]$/.test(atom.value)) {
      command.push(atom);
      atom = atom.rightSibling;
    }
  }
  const commandString = command.map((x3) => x3.value).join("");
  const suggestions = commandString ? suggest(commandString) : [];
  if (suggestions.length === 0) {
    if (/^\\[a-zA-Z\*]+$/.test(commandString)) {
      command.forEach((x3) => {
        x3.isError = true;
      });
    }
    hidePopover(mathfield);
    return;
  }
  mathfield.suggestionIndex = options?.atIndex ?? 0;
  if (mathfield.suggestionIndex < 0) {
    mathfield.suggestionIndex = suggestions.length - 1;
  }
  const suggestion = suggestions[mathfield.suggestionIndex % suggestions.length].match;
  if (suggestion !== commandString) {
    const lastAtom = command[command.length - 1];
    lastAtom.parent.addChildrenAfter([...suggestion.slice(commandString.length - suggestion.length)].map((x3) => new LatexAtom(x3, {isSuggestion: true})), lastAtom);
    requestUpdate(mathfield);
  }
  showPopoverWithLatex(mathfield, suggestion, suggestions.length > 1);
}
function acceptCommandSuggestion(model) {
  const [from, to] = getCommandSuggestionRange(model, {
    before: model.position
  });
  if (from === void 0 || to === void 0)
    return false;
  let result = false;
  model.getAtoms([from, to]).forEach((x3) => {
    if (x3.isSuggestion) {
      x3.isSuggestion = false;
      result = true;
    }
  });
  return result;
}
function complete(mathfield, completion = "accept", options) {
  hidePopover(mathfield);
  const latexGroup = getLatexGroup(mathfield.model);
  if (!latexGroup)
    return false;
  if (completion === "accept-suggestion") {
    const suggestions = getLatexGroupBody(mathfield.model).filter((x3) => x3.isSuggestion);
    if (suggestions.length === 0)
      return false;
    for (const suggestion of suggestions)
      suggestion.isSuggestion = false;
    mathfield.model.position = mathfield.model.offsetOf(suggestions[suggestions.length - 1]);
    return true;
  }
  const body = getLatexGroupBody(mathfield.model).filter((x3) => !x3.isSuggestion);
  const latex = body.map((x3) => x3.value).join("");
  const newPos = latexGroup.leftSibling;
  latexGroup.parent.removeChild(latexGroup);
  mathfield.model.position = mathfield.model.offsetOf(newPos);
  mathfield.mode = options?.mode ?? "math";
  if (completion === "reject")
    return true;
  ModeEditor.insert("math", mathfield.model, latex, {
    macros: mathfield.options.macros,
    selectionMode: options?.selectItem ?? false ? "item" : "placeholder",
    format: "latex"
  });
  mathfield.snapshot();
  mathfield.model.announce("replacement");
  return true;
}

// src/editor/commands.ts
var HAPTIC_FEEDBACK_DURATION = 3;
var COMMANDS = {};
function register2(commands, options) {
  options = options ?? {target: "mathfield", canUndo: false};
  for (const selector of Object.keys(commands)) {
    console.assert(!COMMANDS[selector], "Selector already defined: ", selector);
    COMMANDS[selector] = {...options, fn: commands[selector]};
  }
}
function getCommandTarget(command) {
  let selector;
  selector = isArray(command) ? command[0] : command;
  selector = selector.replace(/-\w/g, (m3) => m3[1].toUpperCase());
  return COMMANDS[selector]?.target;
}
function perform(mathfield, command) {
  if (!command) {
    return false;
  }
  let selector;
  let args = [];
  let handled = false;
  let dirty = false;
  if (isArray(command)) {
    selector = command[0];
    args = command.slice(1);
  } else {
    selector = command;
  }
  selector = selector.replace(/-\w/g, (m3) => m3[1].toUpperCase());
  const commandTarget = COMMANDS[selector]?.target;
  if (commandTarget === "model") {
    if (mathfield.options.readOnly && /^(paste|cut|insert|delete|transpose|add)/.test(selector)) {
      mathfield.model.announce("plonk");
      return false;
    }
    if (/^(delete|transpose|add)/.test(selector)) {
      if (selector !== "deleteBackward") {
        mathfield.resetKeystrokeBuffer();
      }
    }
    if (/^(delete|transpose|add)/.test(selector) && mathfield.mode !== "latex") {
      mathfield.popUndoStack();
      mathfield.snapshot();
    }
    COMMANDS[selector].fn(mathfield.model, ...args);
    if (/^(delete|transpose|add)/.test(selector) && mathfield.mode !== "latex") {
      mathfield.snapshot();
    }
    if (mathfield.mode === "latex") {
      updateAutocomplete(mathfield);
    }
    dirty = true;
    handled = true;
  } else if (commandTarget === "virtual-keyboard") {
    dirty = mathfield.virtualKeyboard?.executeCommand(command) ?? false;
    handled = true;
  } else if (COMMANDS[selector]) {
    dirty = COMMANDS[selector].fn(mathfield, ...args);
    handled = true;
  } else {
    throw new Error('Unknown command "' + selector + '"');
  }
  if (commandTarget !== "virtual-keyboard") {
    if (!mathfield.model.selectionIsCollapsed || /^(transpose|paste|complete|((moveToNextChar|moveToPreviousChar|extend).*))_$/.test(selector)) {
      mathfield.resetKeystrokeBuffer();
      mathfield.style = {};
    }
  }
  if (dirty) {
    requestUpdate(mathfield);
  }
  return handled;
}
function performWithFeedback(mathfield, selector) {
  mathfield.focus();
  if (mathfield.options.keypressVibration && canVibrate()) {
    navigator.vibrate(HAPTIC_FEEDBACK_DURATION);
  }
  selector = selector.replace(/-\w/g, (m3) => m3[1].toUpperCase());
  if (selector === "moveToNextPlaceholder" || selector === "moveToPreviousPlaceholder" || selector === "complete") {
    mathfield.returnKeypressSound?.play().catch(console.warn);
  } else if (selector === "deleteBackward" || selector === "deleteForward" || selector === "deletePreviousWord" || selector === "deleteNextWord" || selector === "deleteToGroupStart" || selector === "deleteToGroupEnd" || selector === "deleteToMathFieldStart" || selector === "deleteToMathFieldEnd") {
    mathfield.deleteKeypressSound?.play().catch(console.warn);
  } else {
    mathfield.keypressSound?.play().catch(console.warn);
  }
  const result = mathfield.executeCommand(selector);
  mathfield.scrollIntoView();
  return result;
}
register2({
  performWithFeedback: (mathfield, command) => performWithFeedback(mathfield, command)
});
function nextSuggestion(mathfield) {
  updateAutocomplete(mathfield, {atIndex: mathfield.suggestionIndex + 1});
  return false;
}
function previousSuggestion(mathfield) {
  updateAutocomplete(mathfield, {atIndex: mathfield.suggestionIndex - 1});
  return false;
}
register2({
  complete,
  nextSuggestion,
  previousSuggestion
}, {target: "mathfield", category: "autocomplete"});

// src/editor/scrim.ts
var Scrim = class {
  constructor(options) {
    this.preventOverlayClose = options?.preventOverlayClose ?? false;
    this.translucent = options?.translucent ?? false;
    this.state = "closed";
  }
  get element() {
    if (this._element)
      return this._element;
    const element = document.createElement("div");
    element.setAttribute("role", "presentation");
    element.style.position = "fixed";
    element.style["contain"] = "content";
    element.style.top = "0";
    element.style.left = "0";
    element.style.right = "0";
    element.style.bottom = "0";
    element.style.zIndex = "var(--scrim-zindex, 10099)";
    element.style.outline = "none";
    if (this.translucent) {
      element.style.background = "rgba(255, 255, 255, .2)";
      element.style["backdropFilter"] = "contrast(40%)";
    } else {
      element.style.background = "transparent";
    }
    this._element = element;
    return element;
  }
  open(options) {
    if (this.state !== "closed")
      return;
    this.state = "opening";
    this.savedActiveElement = deepActiveElement();
    const {element} = this;
    (options?.root ?? document.body).appendChild(element);
    element.addEventListener("click", this);
    document.addEventListener("touchmove", this, false);
    document.addEventListener("scroll", this, false);
    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    this.savedMarginRight = document.body.style.marginRight;
    this.savedOverflow = document.body.style.overflow;
    document.body.style.overflow = "hidden";
    const marginRight = Number.parseFloat(getComputedStyle(document.body).marginRight);
    document.body.style.marginRight = `${marginRight + scrollbarWidth}px`;
    if (options?.child) {
      element.append(options.child);
    }
    this.state = "open";
  }
  close() {
    if (this.state !== "open")
      return;
    this.state = "closing";
    if (typeof this.onClose === "function")
      this.onClose();
    const {element} = this;
    element.removeEventListener("click", this);
    document.removeEventListener("touchmove", this, false);
    document.removeEventListener("scroll", this, false);
    element.remove();
    document.body.style.overflow = this.savedOverflow ?? "";
    document.body.style.marginRight = this.savedMarginRight ?? "";
    if (document.activeElement !== this.savedActiveElement) {
      this.savedActiveElement?.focus?.();
    }
    element.innerHTML = "";
    this.state = "closed";
  }
  handleEvent(ev) {
    if (!this.preventOverlayClose) {
      if (ev.target === this._element && ev.type === "click") {
        this.close();
        ev.preventDefault();
        ev.stopPropagation();
      } else if (ev.target === document && (ev.type === "touchmove" || ev.type === "scroll")) {
        this.close();
        ev.preventDefault();
        ev.stopPropagation();
      }
    }
  }
};
function deepActiveElement() {
  let a3 = document.activeElement;
  while (a3?.shadowRoot?.activeElement) {
    a3 = a3.shadowRoot.activeElement;
  }
  return a3;
}

// src/editor/virtual-keyboard-utils.ts
var gScrim = null;
var VIRTUAL_KEYBOARD_STYLESHEET_HASH = void 0;
function showAlternateKeys(keyboard, altKeysetId) {
  throwIfNotInBrowser();
  const altKeys = ALT_KEYS[altKeysetId];
  const altContainer = document.createElement("div");
  altContainer.setAttribute("aria-hidden", "true");
  altContainer.className = "ML__keyboard alternate-keys" + (keyboard.element.classList.contains("material") ? " material" : "");
  altContainer.id = "mathlive-alternate-keys-panel";
  if (altKeys.length >= 14) {
    altContainer.style.width = "236px";
  } else if (altKeys.length >= 7) {
    altContainer.style.width = "286px";
  } else if (altKeys.length === 4 || altKeys.length === 2) {
    altContainer.style.width = "146px";
  } else if (altKeys.length === 1) {
    altContainer.style.width = "86px";
  } else {
    altContainer.style.width = "146px";
  }
  altContainer.style.height = "auto";
  let markup = "";
  for (const altKey of altKeys) {
    markup += "<li";
    if (typeof altKey === "string") {
      markup += ' data-latex="' + altKey.replace(/"/g, "&quot;") + '"';
    } else {
      if (altKey.latex) {
        markup += ' data-latex="' + altKey.latex.replace(/"/g, "&quot;") + '"';
      }
      if (altKey.content) {
        markup += ' data-content="' + altKey.content.replace(/"/g, "&quot;") + '"';
      }
      if (altKey.insert) {
        markup += ' data-insert="' + altKey.insert.replace(/"/g, "&quot;") + '"';
      }
      if (altKey.command) {
        if (typeof altKey.command === "string") {
          markup += ` data-command="${altKey.command.replace(/"/g, "&quot;")}"`;
        } else {
          markup += " data-command='" + JSON.stringify(altKey.command).replace(/"/g, "&quot;") + "'";
        }
      }
      if (altKey.aside) {
        markup += ` data-aside="${altKey.aside.replace(/"/g, "&quot;")}"`;
      }
      if (altKey.class) {
        markup += ` data-classes="${altKey.class}"`;
      }
    }
    markup += ">";
    markup += typeof altKey === "string" ? altKey : altKey.label ?? "";
    markup += "</li>";
  }
  markup = "<ul>" + markup + "</ul>";
  altContainer.innerHTML = keyboard.options.createHTML(markup);
  makeKeycap(keyboard, [...altContainer.querySelectorAll("li")], "performAlternateKeys");
  if (gScrim === null)
    gScrim = new Scrim();
  gScrim.open({
    root: keyboard.options.virtualKeyboardContainer,
    child: altContainer
  });
  const keycapElement = keyboard?.element.querySelector('div.keyboard-layer.is-visible div.rows ul li[data-alt-keys="' + altKeysetId + '"]');
  const position = keycapElement?.getBoundingClientRect();
  if (position) {
    if (position.top - altContainer.clientHeight < 0) {
      altContainer.style.width = "auto";
      if (altKeys.length <= 6) {
        altContainer.style.height = "56px";
      } else if (altKeys.length <= 12) {
        altContainer.style.height = "108px";
      } else if (altKeys.length <= 18) {
        altContainer.style.height = "205px";
      } else {
        altContainer.classList.add("compact");
      }
    }
    const top = (position.top - altContainer.clientHeight + 5).toString() + "px";
    const left = Math.max(0, Math.min(window.innerWidth - altContainer.offsetWidth, (position.left + position.right - altContainer.offsetWidth) / 2)) + "px";
    altContainer.style.transform = "translate(" + left + "," + top + ")";
    altContainer.classList.add("is-visible");
  }
  return false;
}
function hideAlternateKeys() {
  throwIfNotInBrowser();
  const altContainer = document.querySelector("#mathlive-alternate-keys-panel");
  if (altContainer) {
    altContainer.classList.remove("is-visible");
    altContainer.innerHTML = "";
  }
  gScrim?.close();
  return false;
}
var VirtualKeyboard = class {
  constructor(options, mathfield) {
    this.options = options;
    this.visible = false;
    this._mathfield = mathfield;
    this.coreStylesheet = null;
    this.virtualKeyboardStylesheet = null;
  }
  setOptions(options) {
    this.visible = false;
    this._element?.remove();
    this._element = void 0;
    this.options = options;
  }
  get element() {
    return this._element;
  }
  set element(val) {
    this._element?.remove();
    this._element = val;
  }
  get visible() {
    return this._visible;
  }
  set visible(val) {
    this._visible = val;
  }
  get height() {
    return this.element?.offsetHeight ?? 0;
  }
  handleEvent(evt) {
    if (!this.element) {
      return;
    }
    switch (evt.type) {
      case "mouseup":
      case "blur":
      case "touchend":
      case "touchcancel":
        document.body.style.userSelect = "";
        unshiftKeyboardLayer(this);
        break;
    }
  }
  focusMathfield() {
    this._mathfield?.focus?.();
  }
  blurMathfield() {
    this._mathfield?.blur?.();
  }
  stateChanged() {
    this._mathfield?.element?.dispatchEvent(new Event("virtual-keyboard-toggle", {
      bubbles: true,
      cancelable: false,
      composed: true
    }));
  }
  executeCommand(command) {
    let selector;
    let args = [];
    if (isArray(command)) {
      selector = command[0];
      args = command.slice(1);
    } else {
      selector = command;
    }
    selector = selector.replace(/-\w/g, (m3) => m3[1].toUpperCase());
    if (COMMANDS[selector]?.target === "virtual-keyboard") {
      return COMMANDS[selector].fn(this, ...args);
    }
    return this._mathfield?.executeCommand(command) ?? false;
  }
  create() {
    if (!VIRTUAL_KEYBOARD_STYLESHEET_HASH) {
      VIRTUAL_KEYBOARD_STYLESHEET_HASH = hashCode(virtual_keyboard_default).toString(36);
    }
    this.virtualKeyboardStylesheet = this.virtualKeyboardStylesheet = inject(null, virtual_keyboard_default, VIRTUAL_KEYBOARD_STYLESHEET_HASH);
    this.coreStylesheet = inject(null, core_default, hashCode(core_default).toString(36));
    void loadFonts(this.options.fontsDirectory);
  }
  enable() {
    window.addEventListener("mouseup", this);
    window.addEventListener("blur", this);
    window.addEventListener("touchend", this);
    window.addEventListener("touchcancel", this);
  }
  disable() {
    window.removeEventListener("mouseup", this);
    window.removeEventListener("blur", this);
    window.removeEventListener("touchend", this);
    window.removeEventListener("touchcancel", this);
    hideAlternateKeys();
    this.visible = false;
    this.coreStylesheet?.release();
    this.coreStylesheet = null;
    this.virtualKeyboardStylesheet?.release();
    this.virtualKeyboardStylesheet = null;
    this._element?.remove();
    this._element = void 0;
  }
  dispose() {
  }
};
var KEYBOARDS = {
  numeric: {
    tooltip: "keyboard.tooltip.numeric",
    layer: "math",
    label: "123",
    layers: ["math"]
  },
  roman: {
    tooltip: "keyboard.tooltip.roman",
    layer: "lower-roman",
    label: "ABC",
    layers: ["lower-roman", "upper-roman"]
  },
  greek: {
    tooltip: "keyboard.tooltip.greek",
    layer: "lower-greek",
    label: "&alpha;&beta;&gamma;",
    classes: "tex-math",
    layers: ["lower-greek", "upper-greek"]
  },
  functions: {
    tooltip: "keyboard.tooltip.functions",
    layer: "functions",
    label: "<i>f</i>&thinsp;()",
    classes: "tex",
    layers: ["functions"]
  },
  symbols: {
    tooltip: "keyboard.tooltip.symbols",
    layer: "symbols",
    label: "&infin;\u2260\u2208",
    classes: "tex",
    layers: ["symbols"]
  },
  latex: {
    tooltip: "keyboard.tooltip.command",
    command: ["switchMode", "latex"],
    label: `<svg class="svg-glyph"><use xlink:href='#svg-command' /></svg>`,
    layers: ["latex-lower", "latex-upper", "latex-symbols"]
  },
  style: {
    tooltip: "keyboard.tooltip.style",
    layer: "style",
    label: "<b>b</b><i>i</i>\u{1D539}"
  }
};
var SHIFTED_KEYS = {
  "\\varphi ": ["&Phi;", "\\Phi "],
  "\\varsigma ": ["&Sigma;", "\\Sigma "],
  "\\epsilon ": ["&#x0190;", '{\\char"0190}'],
  "\\rho ": ["&#x3A1", '{\\char"3A1}'],
  "\\tau ": ["&#x3A4;", '{\\char"3A4}'],
  "\\upsilon ": ["&Upsilon;", "\\Upsilon "],
  "\\theta ": ["&Theta;", "\\Theta "],
  "\\iota ": ["&Iota;", '{\\char"399}'],
  "\\omicron ": ["&#x039F;", '{\\char"39F}'],
  "\\pi ": ["&Pi;", "\\Pi "],
  "\\alpha ": ["&Alpha;", '{\\char"391}'],
  "\\sigma ": ["&Sigma;", "\\Sigma "],
  "\\delta ": ["&Delta;", "\\Delta "],
  "\\phi ": ["&#x03a6;", "\\Phi "],
  "\\gamma ": ["&Gamma;", "\\Gamma "],
  "\\eta ": ["&Eta;", '{\\char"397}'],
  "\\xi ": ["&Xi;", "\\Xi "],
  "\\kappa ": ["&Kappa;", '{\\char"39A}'],
  "\\lambda ": ["&Lambda;", "\\Lambda "],
  "\\zeta ": ["&Zeta;", '{\\char"396}'],
  "\\chi ": ["&Chi;", '{\\char"3A7}'],
  "\\psi ": ["&Psi;", "\\Psi "],
  "\\omega ": ["&Omega;", "\\Omega "],
  "\\beta ": ["&Beta;", '{\\char"392}'],
  "\\nu ": ["&Nu;", '{\\char"39D}'],
  "\\mu ": ["&Mu;", '{\\char"39C}']
};
var ALT_KEYS_BASE = {
  "0": [
    "\\emptyset",
    "\\varnothing",
    "\\infty",
    {latex: "#?_0", insert: "#@_0"},
    "\\circ",
    "\\bigcirc",
    "\\bullet"
  ],
  "2": ["\\frac{1}{2}", {latex: "#?^2", insert: "#@^2"}],
  "3": ["\\frac{1}{3}", {latex: "#?^3", insert: "#@^3"}],
  ".": [
    ",",
    ";",
    "\\colon",
    {latex: ":", aside: "ratio"},
    {latex: "\\cdotp", aside: "center dot", class: "box"},
    {latex: "\\cdots", aside: "center ellipsis", class: "box"},
    {latex: "\\ldotp", aside: "low dot", class: "box"},
    {latex: "\\ldots", aside: "low ellipsis", class: "box"},
    {latex: "\\vdots", aside: "", class: "box"},
    {latex: "\\ddots", aside: "", class: "box"},
    "\\odot",
    "\\oslash",
    "\\circledcirc"
  ],
  "*": [
    "\\cdot",
    "\\ast",
    "\\star",
    "\\bigstar",
    "\\ltimes",
    "\\rtimes",
    "\\rightthreetimes",
    "\\leftthreetimes",
    "\\intercal",
    "\\prod",
    {latex: "\\prod_{n\\mathop=0}^{\\infty}", class: "small"}
  ],
  "+": [
    "\\pm",
    "\\mp",
    "\\sum",
    {latex: "\\sum_{n\\mathop=0}^{\\infty}", class: "small"},
    "\\dotplus",
    "\\oplus"
  ],
  "-": ["\\pm", "\\mp", "\\ominus", "\\vert #0  \\vert"],
  "/": ["\\divideontimes", "/", "\\div", "\\%"],
  "(": [
    "\\left( #0\\right)",
    "\\left[ #0\\right]",
    "\\left\\{ #0\\right\\}",
    "\\left\\langle #0\\right\\rangle",
    "\\lfloor",
    "\\llcorner",
    "(",
    "\\lbrack",
    "\\lvert",
    "\\lVert",
    "\\lgroup",
    "\\langle",
    "\\lceil",
    "\\ulcorner",
    "\\lmoustache",
    "\\lbrace"
  ],
  ")": [
    "\\rfloor",
    "\\lrcorner",
    ")",
    "\\rbrack",
    "\\rvert",
    "\\rVert",
    "\\rgroup",
    "\\rangle",
    "\\rceil",
    "\\urcorner",
    "\\rmoustache",
    "\\rbrace"
  ],
  "=": [
    "\\cong",
    "\\asymp",
    "\\equiv",
    "\\differencedelta",
    "\\varpropto",
    "\\thickapprox",
    "\\approxeq",
    "\\thicksim",
    "\\backsim",
    "\\eqsim",
    "\\simeq",
    "\\Bumpeq",
    "\\bumpeq",
    "\\doteq",
    "\\Doteq",
    "\\fallingdotseq",
    "\\risingdotseq",
    "\\coloneq",
    "\\eqcirc",
    "\\circeq",
    "\\triangleq",
    "\\between"
  ],
  "!=": ["\\neq", "\\ncong", "", "\\nsim"],
  "<": [
    "\\leq",
    "\\leqq",
    "\\lneqq",
    "\\ll",
    "\\lessgtr",
    "\\nless",
    "\\nleq",
    "\\lesssim",
    "\\precsim",
    "\\prec",
    "\\nprec",
    "\\preccurlyeq",
    "\\lessdot"
  ],
  ">": [
    "\\geq",
    "\\geqq",
    "\\gneqq",
    "\\gg",
    "\\gtrless",
    "\\ngtr",
    "\\ngeq",
    "\\gtrsim",
    "\\succsim",
    "\\succ",
    "\\nsucc",
    "\\succcurlyeq",
    "\\gtrdot"
  ],
  "in": ["\\owns"],
  "!in": ["\\backepsilon"],
  "subset": ["\\subseteq", "\\nsubset", "\\nsubseteq"],
  "superset": ["\\supseteq", "\\nsupset", "\\nsupseteq"],
  "infinity": ["\\aleph_0", "\\aleph_1", "\\omega", "\\mathfrak{m}"],
  "numeric-pi": ["\\prod", "\\theta", "\\rho", "\\sin", "\\cos", "\\tan"],
  "ee": ["\\times 10^{#?}", "\\ln", "\\ln_{10}", "\\log"],
  "^": ["_{#?}"],
  "int": [
    {latex: "\\int_{#?}^{#?}", class: "small"},
    {latex: "\\int", class: "small"},
    {latex: "\\smallint", class: "small"},
    {latex: "\\iint", class: "small"},
    {latex: "\\iiint", class: "small"},
    {latex: "\\oint", class: "small"},
    {latex: "\\dfrac{\\rd}{\\rd x}", class: "small"},
    {latex: "\\frac{\\partial}{\\partial x}", class: "small"},
    "\\capitalDifferentialD",
    "\\rd",
    "\\partial"
  ],
  "nabla": ["\\nabla\\times", "\\nabla\\cdot", "\\nabla^{2}"],
  "!": ["!!", "\\Gamma", "\\Pi"],
  "accents": [
    "\\bar{#@}",
    "\\vec{#@}",
    "\\hat{#@}",
    "\\check{#@}",
    "\\dot{#@}",
    "\\ddot{#@}",
    "\\mathring{#@}",
    "\\breve{#@}",
    "\\acute{#@}",
    "\\tilde{#@}",
    "\\grave{#@}"
  ],
  "underline": [
    "\\underbrace{#@}",
    "\\underlinesegment{#@}",
    "\\underleftrightarrow{#@}",
    "\\underrightarrow{#@}",
    "\\underleftarrow{#@}",
    "\\undergroup{#@}"
  ],
  "overline": [
    "\\overbrace{#@}",
    "\\overlinesegment{#@}",
    "\\overleftrightarrow{#@}",
    "\\overrightarrow{#@}",
    "\\overleftarrow{#@}",
    "\\overgroup{#@}"
  ],
  "xleftarrows": [
    "\\xlongequal{}",
    "\\xleftrightarrow{}",
    "\\xLeftrightarrow{}",
    "\\xleftrightharpoons{}",
    "\\xLeftarrow{}",
    "\\xleftharpoonup{}",
    "\\xleftharpoondown{}",
    "\\xtwoheadleftarrow{}",
    "\\xhookleftarrow{}",
    "\\xtofrom{}",
    "\\xleftequilibrium{}",
    "\\xrightleftarrows{}"
  ],
  "xrightarrows": [
    "\\xlongequal{}",
    "\\xleftrightarrow{}",
    "\\xLeftrightarrow{}",
    "\\xleftrightharpoons{}",
    "\\xRightarrow{}",
    "\\xrightharpoonup{}",
    "\\xrightharpoondown{}",
    "\\xtwoheadrightarrow{}",
    "\\xrightleftharpoons{}",
    "\\xhookrightarrow{}",
    "\\xmapsto{}",
    "\\xrightequilibrium{}",
    "\\xrightleftarrows{}"
  ],
  "A": [
    {latex: "\\aleph", aside: "aleph"},
    {latex: "\\forall", aside: "for all"}
  ],
  "a": [
    {latex: "\\aleph", aside: "aleph"},
    {latex: "\\forall", aside: "for all"}
  ],
  "b": [{latex: "\\beth", aside: "beth"}],
  "B": [{latex: "\\beth", aside: "beth"}],
  "c": [{latex: "\\C", aside: "set of complex numbers"}],
  "d": [{latex: "\\daleth", aside: "daleth"}],
  "D": [{latex: "\\daleth", aside: "daleth"}],
  "e": [
    {latex: "\\exponentialE", aside: "exponential e"},
    {latex: "\\exists", aside: "there is"},
    {latex: "\\nexists", aside: "there isn\u2019t"}
  ],
  "g": [{latex: "\\gimel", aside: "gimel"}],
  "G": [{latex: "\\gimel", aside: "gimel"}],
  "h": [
    {latex: "\\hbar", aside: "h bar"},
    {latex: "\\hslash", aside: "h slash"}
  ],
  "i": [{latex: "\\imaginaryI", aside: "imaginary i"}],
  "j": [{latex: "\\imaginaryJ", aside: "imaginary j"}],
  "l": [{latex: "\\ell", aside: "ell"}],
  "n": [{latex: "\\N", aside: "set of natural numbers"}],
  "p": [{latex: "\\P", aside: "set of primes"}],
  "q": [{latex: "\\Q", aside: "set of rational numbers"}],
  "r": [{latex: "\\R", aside: "set of real numbers"}],
  "z": [{latex: "\\Z", aside: "set of integers"}],
  "x-var": [
    "y",
    "z",
    "t",
    "r",
    {latex: "f(#?)", class: "small"},
    {latex: "g(#?)", class: "small"},
    "x^2",
    "x^n",
    "x_n",
    "x_{n+1}",
    "x_i",
    "x_{i+1}"
  ],
  "n-var": ["i", "j", "p", "k", "a", "u"],
  "ii": ["\\Re", "\\Im", "\\imaginaryJ", "\\Vert #0 \\Vert"],
  "logic": [
    {latex: "\\exists", aside: "there is"},
    {latex: "\\nexists", aside: "there isn\u2019t"},
    {latex: "\\ni", aside: "such that"},
    {latex: "\\Colon", aside: "such that"},
    {latex: "\\implies", aside: "implies"},
    {latex: "\\impliedby", aside: "implied by"},
    {latex: "\\iff", aside: "if and only if"},
    {latex: "\\land", aside: "and"},
    {latex: "\\lor", aside: "or"},
    {latex: "\\oplus", aside: "xor"},
    {latex: "\\lnot", aside: "not"},
    {latex: "\\downarrow", aside: "nor"},
    {latex: "\\uparrow", aside: "nand"},
    {latex: "\\curlywedge", aside: "nor"},
    {latex: "\\bar\\curlywedge", aside: "nand"},
    {latex: "\\therefore", aside: "therefore"},
    {latex: "\\because", aside: "because"},
    {latex: "^\\biconditional", aside: "biconditional"},
    "\\leftrightarrow",
    "\\Leftrightarrow",
    "\\to",
    "\\models",
    "\\vdash",
    "\\gets",
    "\\dashv",
    "\\roundimplies"
  ],
  "set-operators": [
    "\\cap",
    "\\cup",
    "\\setminus",
    "\\smallsetminus",
    "\\complement"
  ],
  "set-relations": [
    "\\in",
    "\\notin",
    "\\ni",
    "\\owns",
    "\\subset",
    "\\supset",
    "\\subseteq",
    "\\supseteq",
    "\\subsetneq",
    "\\supsetneq",
    "\\varsubsetneq",
    "\\subsetneqq",
    "\\nsubset",
    "\\nsupset",
    "\\nsubseteq",
    "\\nsupseteq"
  ],
  "space": [
    {
      latex: '\\char"203A\\!\\char"2039',
      insert: "\\!",
      aside: "negative thin space<br>\u207B\xB3\u29F8\u2081\u2088 em"
    },
    {
      latex: '\\unicode{"203A}\\,\\unicode{"2039}',
      insert: "\\,",
      aside: "thin space<br>\xB3\u29F8\u2081\u2088 em"
    },
    {
      latex: '\\unicode{"203A}\\:\\unicode{"2039}',
      insert: "\\:",
      aside: "medium space<br>\u2074\u29F8\u2081\u2088 em"
    },
    {
      latex: '\\unicode{"203A}\\;\\unicode{"2039}',
      insert: "\\;",
      aside: "thick space<br>\u2075\u29F8\u2081\u2088 em"
    },
    {
      latex: '\\unicode{"203A}\\ \\unicode{"2039}',
      insert: "\\ ",
      aside: "\u2153 em"
    },
    {
      latex: '\\unicode{"203A}\\enspace\\unicode{"2039}',
      insert: "\\enspace",
      aside: "\xBD em"
    },
    {
      latex: '\\unicode{"203A}\\quad\\unicode{"2039}',
      insert: "\\quad",
      aside: "1 em"
    },
    {
      latex: '\\unicode{"203A}\\qquad\\unicode{"2039}',
      insert: "\\qquad",
      aside: "2 em"
    }
  ],
  "delete": [
    {
      label: '<span class="warning"><svg class="svg-glyph"><use xlink:href="#svg-trash" /></svg></span>',
      command: "deleteAll"
    }
  ],
  "->|": []
};
var ALT_KEYS = {};
var LAYERS = {
  "math": `
        <div class='rows'>
            <ul>
                <li class='keycap tex' data-alt-keys='x-var'><i>x</i></li>
                <li class='keycap tex' data-alt-keys='n-var'><i>n</i></li>
                <li class='separator w5'></li>
                <row name='numpad-1'/>
                <li class='separator w5'></li>
                <li class='keycap tex' data-latex='\\exponentialE' data-alt-keys='ee'>e</li>
                <li class='keycap tex' data-latex='\\imaginaryI' data-alt-keys='ii'>i</li>
                <li class='keycap tex' data-latex='\\pi' data-alt-keys='numeric-pi'></li>
            </ul>
            <ul>
                <li class='keycap tex' data-key='<' data-alt-keys='<'>&lt;</li>
                <li class='keycap tex' data-key='>' data-alt-keys='>'>&gt;</li>
                <li class='separator w5'></li>
                <row name='numpad-2'/>
                <li class='separator w5'></li>
                <li class='keycap tex' data-latex='#@^{2}' data-latex='x^2'></li>
                <li class='keycap tex' data-alt-keys='^' data-insert='#@^{#?}' data-latex='x^\\placeholder'></li>
                <li class='keycap tex small' data-insert='\\sqrt{#0}' data-latex='\\sqrt{#0}'></li>
            </ul>
            <ul>
                <li class='keycap tex' data-alt-keys='(' >(</li>
                <li class='keycap tex' data-alt-keys=')' >)</li>
                <li class='separator w5'></li>
                <row name='numpad-3'/>
                <li class='separator w5'></li>
                <li class='keycap small' data-alt-keys='int' data-latex='\\int_0^\\infty'></li>
                <li class='keycap' data-latex='\\forall' data-alt-keys='logic' ></li>
                <li class='action font-glyph bottom right' data-alt-keys='delete' data-command='["performWithFeedback","deleteBackward"]'>&#x232b;</li></ul>
            </ul>
            <ul>
                <li class='keycap' data-alt-keys='foreground-color' data-command='["applyStyle",{"color":"red"}]'><span style='border-radius: 50%;width:22px;height:22px; border: 3px solid #cc2428; box-sizing: border-box'></span></li>
                <li class='keycap' data-alt-keys='background-color' data-command='["applyStyle",{"backgroundColor":"yellow"}]'><span style='border-radius: 50%;width:22px;height:22px; background:#fff590; box-sizing: border-box'></span></li>
                <li class='separator w5'></li>
                <row name='numpad-4'/>
                <li class='separator w5'></li>
                <arrows/>
            </ul>
        </div>
    `,
  "lower-roman": `
        <div class='rows'>
            <ul>
                <row name='numpad-1' class='if-wide'/>
                <row name='lower-1' shift-layer='upper-roman'/>
            </ul>
            <ul>
                <row name='numpad-2' class='if-wide'/>
                <row name='lower-2'  shift-layer='upper-roman''/>
            </ul>
            <ul>
                <row name='numpad-3' class='if-wide'/>
                <row name='lower-3'  shift-layer='upper-roman''/>
            </ul>
            <ul>
                <row name='numpad-4' class='if-wide'/>
                <li class='keycap' >;</li>
                <li class='keycap' >,</li>
                <li class='keycap w50' data-key=' ' data-alt-keys='space'>&nbsp;</li>
                <arrows/>
            </ul>
        </div>`,
  "upper-roman": `
        <div class='rows'>
            <ul>
                <row name='numpad-1' class='if-wide'/>
                <row name='upper-1'  shift-layer='lower-roman'/>
            </ul>
            <ul>
                <row name='numpad-2' class='if-wide'/>
                <row name='upper-2' shift-layer='lower-roman'/>
            </ul>
            <ul>
                <row name='numpad-3' class='if-wide'/>
                <row name='upper-3' shift-layer='lower-roman'/>
            </ul>
            <ul>
                <row name='numpad-4' class='if-wide'/>
                <li class='keycap' >;</li>
                <li class='keycap' data-alt-keys='.'>;</li>
                <li class='keycap w50' data-key=' '>&nbsp;</li>
                <arrows/>
            </ul>
        </div>`,
  "symbols": `
        <div class='rows'>
            <ul>
                <row name='numpad-1' class='if-wide'/>
                <li class='keycap tex' data-alt-keys='(' data-insert='\\lbrace '>{</li>
                <li class='keycap tex' data-alt-keys=')' data-insert='\\rbrace '>}</li>
                <li class='separator w5'></li>
                <li class='keycap tex' data-alt-keys='in' data-insert='\\in '>&#x2208;</li>
                <li class='keycap tex' data-alt-keys='!in' data-insert='\\notin '>&#x2209;</li>
                <li class='keycap tex' data-insert='\\Re '>&#x211c;<aside>Real</aside></li>
                <li class='keycap tex' data-insert='\\Im '>&#x2111;<aside>Imaginary</aside></li>
                <li class='keycap w15' data-insert='\\ulcorner#0\\urcorner '><span><sup>&#x250c;</sup><span><span style='color:#ddd'>o</span><sup>&#x2510;</sup></span><aside>ceil</aside></li>
                <li class='keycap tex' data-alt-keys='nabla' data-insert='\\nabla '>&#x2207;<aside>nabla</aside></li>
                <li class='keycap tex' data-alt-keys='infinity' data-insert='\\infty '>&#x221e;</li>

            </ul>
            <ul>
                <row name='numpad-2' class='if-wide'/>
                <li class='keycap tex' data-alt-keys='(' data-insert='\\lbrack '>[</li>
                <li class='keycap tex' data-alt-keys=')' data-insert='\\rbrack '>]</li>
                <li class='separator w5'></li>
                <li class='keycap tex' data-alt-keys='subset' data-insert='\\subset '>&#x2282;</li>
                <li class='keycap tex' data-alt-keys='superset' data-insert='\\supset '>&#x2283;</li>
                <li class='keycap tex' data-key='!' data-alt-keys='!'>!<aside>factorial</aside></li>
                <li class='keycap' data-latex='^{\\prime} '><span><sup><span><span style='color:#ddd'>o</span>&#x2032</sup></span><aside>prime</aside></li>
                <li class='keycap w15' data-insert='\\llcorner#0\\lrcorner '><span><sub>&#x2514;</sub><span style='color:#ddd'>o</span><sub>&#x2518;</sub></span><aside>floor</aside></li>
                <li class='keycap tex' data-insert='\\partial '>&#x2202;<aside>partial<br>derivative</aside></li>
                <li class='keycap tex' data-insert='\\emptyset '>&#x2205;<aside>empty set</aside></li>

            </ul>
            <ul>
                <row name='numpad-3' class='if-wide'/>
                <li class='keycap tex' data-alt-keys='(' data-insert='\\langle '>&#x27e8;</li>
                <li class='keycap tex' data-alt-keys=')' data-insert='\\rangle '>&#x27e9;</li>
                <li class='separator w5'></li>
                <li class='keycap tex' data-alt-keys='overline' data-latex='\\overline{#?}' data-aside='overline'></li>
                <li class='keycap tex' data-alt-keys='underline' data-latex='\\underline{#?}' data-aside='underline'></li>
                <li class='keycap tex' data-alt-keys='accents' data-insert='\\vec{#@}' data-latex='\\vec{#?}' data-aside='vector'></li>
                <li class='keycap tex small' data-alt-keys='xleftarrows' data-latex='\\xleftarrow{}' ></li>
                <li class='keycap tex small' data-alt-keys='xrightarrows' data-latex='\\xrightarrow{}' ></li>
                <li class='keycap tex' data-alt-keys='absnorm' data-insert='\\left| #0 \\right|' data-latex='\\left| #? \\right|' data-aside='abs'></li>

                <li class='action font-glyph bottom right w15'
                    data-shifted='<span class="warning"><svg class="svg-glyph"><use xlink:href="#svg-trash" /></svg></span>'
                    data-shifted-command='"deleteAll"'
                    data-alt-keys='delete' data-command='["performWithFeedback","deleteBackward"]'
                >&#x232b;</li>
            </ul>
            <ul>
                <row name='numpad-4' class='if-wide'/>
                <li class='keycap tex' data-insert=','>,</li>
                <li class='keycap tex' data-insert='\\cdot '>&#x22c5;<aside>centered dot</aside></li>
                <li class='keycap tex' data-insert='\\colon '>:<aside>colon</aside></li>
                <li class='keycap tex' data-insert='\\circ '>&#x2218;<aside>circle</aside></li>
                <li class='keycap tex' data-insert='\\approx '>&#x2248;<aside>approx.</aside></li>
                <li class='keycap tex' data-insert='\\ne '>&#x2260;</li>
                <li class='keycap tex' data-insert='\\pm '>&#x00b1;</li>
                <arrows/>
            </ul>
        </div>`,
  "lower-greek": `
        <div class='rows'>
            <ul><li class='keycap tex' data-insert='\\varphi '><i>&#x03c6;</i><aside>phi var.</aside></li>
                <li class='keycap tex' data-insert='\\varsigma '><i>&#x03c2;</i><aside>sigma var.</aside></li>
                <li class='keycap tex' data-insert='\\epsilon '><i>&#x03f5;</i></li>
                <li class='keycap tex' data-insert='\\rho '><i>&rho;</i></li>
                <li class='keycap tex' data-insert='\\tau '><i>&tau;</i></li>
                <li class='keycap tex' data-insert='\\upsilon '><i>&upsilon;</i></li>
                <li class='keycap tex' data-insert='\\theta '><i>&theta;</i></li>
                <li class='keycap tex' data-insert='\\iota '><i>&iota;</i></li>
                <li class='keycap tex' data-insert='\\omicron '>&omicron;</i></li>
                <li class='keycap tex' data-insert='\\pi '><i>&pi;</i></li>
            </ul>
            <ul><li class='keycap tex' data-insert='\\alpha ' data-shifted='&Alpha;' data-shifted-command='["insert","{\\\\char\\"391}"]'><i>&alpha;</i></li>
                <li class='keycap tex' data-insert='\\sigma '><i>&sigma;</i></li>
                <li class='keycap tex' data-insert='\\delta '><i>&delta;</i></li>
                <li class='keycap tex' data-insert='\\phi '><i>&#x03d5;</i></i></li>
                <li class='keycap tex' data-insert='\\gamma '><i>&gamma;</i></li>
                <li class='keycap tex' data-insert='\\eta '><i>&eta;</i></li>
                <li class='keycap tex' data-insert='\\xi '><i>&xi;</i></li>
                <li class='keycap tex' data-insert='\\kappa '><i>&kappa;</i></li>
                <li class='keycap tex' data-insert='\\lambda '><i>&lambda;</i></li>
            </ul>
            <ul><li class='shift modifier font-glyph bottom left w15 layer-switch' data-layer='upper-greek'>&#x21e7;</li>
                <li class='keycap tex' data-insert='\\zeta '><i>&zeta;</i></li>
                <li class='keycap tex' data-insert='\\chi '><i>&chi;</i></li>
                <li class='keycap tex' data-insert='\\psi '><i>&psi;</i></li>
                <li class='keycap tex' data-insert='\\omega '><i>&omega;</i></li>
                <li class='keycap tex' data-insert='\\beta '><i>&beta;</i></li>
                <li class='keycap tex' data-insert='\\nu '><i>&nu;</i></li>
                <li class='keycap tex' data-insert='\\mu '><i>&mu;</i></li>
                <li class='action font-glyph bottom right w15'
                    data-shifted='<span class="warning"><svg class="svg-glyph"><use xlink:href="#svg-trash" /></svg></span>'
                    data-shifted-command='"deleteAll"'
                    data-alt-keys='delete' data-command='["performWithFeedback","deleteBackward"]'
                >&#x232b;</li>
            </ul>
            <ul>
                <li class='keycap ' data-key=' '>&nbsp;</li>
                <li class='keycap'>,</li>
                <li class='keycap tex' data-insert='\\varepsilon '><i>&#x03b5;</i><aside>epsilon var.</aside></li>
                <li class='keycap tex' data-insert='\\vartheta '><i>&#x03d1;</i><aside>theta var.</aside></li>
                <li class='keycap tex' data-insert='\\varkappa '><i>&#x3f0;</i><aside>kappa var.</aside></li>
                <li class='keycap tex' data-insert='\\varpi '><i>&#x03d6;<aside>pi var.</aside></i></li>
                <li class='keycap tex' data-insert='\\varrho '><i>&#x03f1;</i><aside>rho var.</aside></li>
                <arrows/>
            </ul>
        </div>`,
  "upper-greek": `
        <div class='rows'>
            <ul><li class='keycap tex' data-insert='\\Phi '>&Phi;<aside>phi</aside></li>
                <li class='keycap tex' data-insert='\\Sigma '>&Sigma;<aside>sigma</aside></li>
                <li class='keycap tex' data-insert='{\\char"0190}'>&#x0190;<aside>epsilon</aside></li>
                <li class='keycap tex' data-insert='{\\char"3A1}'>&#x3A1;<aside>rho</aside></li>
                <li class='keycap tex' data-insert='{\\char"3A4}'>&#x3A4;<aside>tau</aside></li>
                <li class='keycap tex' data-insert='\\Upsilon '>&Upsilon;<aside>upsilon</aside></li>
                <li class='keycap tex' data-insert='\\Theta '>&Theta;<aside>theta</aside></li>
                <li class='keycap tex' data-insert='{\\char"399}'>&Iota;<aside>iota</aside></li>
                <li class='keycap tex' data-insert='{\\char"39F}'>&#x039F;<aside>omicron</aside></li>
                <li class='keycap tex' data-insert='\\Pi '>&Pi;<aside>pi</aside></li></ul>
            <ul><li class='keycap tex' data-insert='{\\char"391}'>&#x391;<aside>alpha</aside></li>
                <li class='keycap tex' data-insert='\\Sigma '>&Sigma;<aside>sigma</aside></li>
                <li class='keycap tex' data-insert='\\Delta '>&Delta;<aside>delta</aside></li>
                <li class='keycap tex' data-insert='\\Phi '>&#x03a6;<aside>phi</aside></li>
                <li class='keycap tex' data-insert='\\Gamma '>&Gamma;<aside>gamma</aside></li>
                <li class='keycap tex' data-insert='{\\char"397}'>&Eta;<aside>eta</aside></li>
                <li class='keycap tex' data-insert='\\Xi '>&Xi;<aside>xi</aside></li>
                <li class='keycap tex' data-insert='{\\char"39A}'>&Kappa;<aside>kappa</aside></li>
                <li class='keycap tex' data-insert='\\Lambda '>&Lambda;<aside>lambda</aside></li></ul>
            <ul><li class='shift modifier font-glyph bottom left selected w15 layer-switch' data-layer='lower-greek'>&#x21e7;</li>
                <li class='keycap tex' data-insert='{\\char"396}'>&Zeta;<aside>zeta</aside></li>
                <li class='keycap tex' data-insert='{\\char"3A7}'>&Chi;<aside>chi</aside></li>
                <li class='keycap tex' data-insert='\\Psi '>&Psi;<aside>psi</aside></li>
                <li class='keycap tex' data-insert='\\Omega '>&Omega;<aside>omega</aside></li>
                <li class='keycap tex' data-insert='{\\char"392}'>&Beta;<aside>beta</aside></li>
                <li class='keycap tex' data-insert='{\\char"39D}'>&Nu;<aside>nu</aside></li>
                <li class='keycap tex' data-insert='{\\char"39C}'>&Mu;<aside>mu</aside></li>
                <li class='action font-glyph bottom right w15' data-command='["performWithFeedback","deleteBackward"]'>&#x232b;</li></ul>
            <ul>
                <li class='separator w10'>&nbsp;</li>
                <li class='keycap'>.</li>
                <li class='keycap w50' data-key=' '>&nbsp;</li>
                <arrows/>
            </ul>
        </div>`,
  "latex-lower": `
        <div class='rows'>
            <ul><row name='lower-1' class='tt' shift-layer='latex-upper'/></ul>
            <ul><row name='lower-2' class='tt' shift-layer='latex-upper'/></ul>
            <ul><row name='lower-3' class='tt' shift-layer='latex-upper'/></ul>
            <ul>
                <li class='layer-switch font-glyph modifier bottom left' data-layer='latex-symbols'>01#</li>
                <li class='keycap tt' data-shifted='[' data-shifted-command='["insertAndUnshiftKeyboardLayer", "["]'>{</li>
                <li class='keycap tt' data-shifted=']' data-shifted-command='["insertAndUnshiftKeyboardLayer", "]"]'>}</li>
                <li class='keycap tt' data-shifted='(' data-shifted-command='["insertAndUnshiftKeyboardLayer", "("]'>^</li>
                <li class='keycap tt' data-shifted=')' data-shifted-command='["insertAndUnshiftKeyboardLayer", ")"]'>_</li>
                <li class='keycap w20' data-key=' '>&nbsp;</li>
                <arrows/>
            </ul>
        </div>`,
  "latex-upper": `
        <div class='rows'>
            <ul><row name='upper-1' class='tt' shift-layer='latex-lower'/></ul>
            <ul><row name='upper-2' class='tt' shift-layer='latex-lower'/></ul>
            <ul><row name='upper-3' class='tt' shift-layer='latex-lower'/></ul>
            <ul>
                <li class='layer-switch font-glyph modifier bottom left' data-layer='latex-symbols'01#</li>
                <li class='keycap tt'>[</li>
                <li class='keycap tt'>]</li>
                <li class='keycap tt'>(</li>
                <li class='keycap tt'>)</li>
                <li class='keycap w20' data-key=' '>&nbsp;</li>
                <arrows/>
            </ul>
        </div>`,
  "latex-symbols": `
        <div class='rows'>
            <ul><li class='keycap tt'>1</li><li class='keycap tt'>2</li><li class='keycap tt'>3</li><li class='keycap tt'>4</li><li class='keycap tt'>5</li><li class='keycap tt'>6</li><li class='keycap tt'>7</li><li class='keycap tt'>8</li><li class='keycap tt'>9</li><li class='keycap tt'>0</li></ul>
            <ul><li class='keycap tt'>!</li><li class='keycap tt'>@</li><li class='keycap tt'>#</li><li class='keycap tt'>$</li><li class='keycap tt'>%</li><li class='keycap tt'>^</li><li class='keycap tt'>&</li><li class='keycap tt'>*</li><li class='keycap tt'>+</li><li class='keycap tt'>=</li></ul>
            <ul>
                <li class='keycap tt'>\\</li>
                <li class='keycap tt'>|</li>
                <li class='keycap tt'>/</li>
                <li class='keycap tt'>\`</li>
                <li class='keycap tt'>;</li>
                <li class='keycap tt'>:</li>
                <li class='keycap tt'>?</li>
                <li class='keycap tt'>'</li>
                <li class='keycap tt'>"</li>
                <li class='action font-glyph bottom right'
                    data-shifted='<span class="warning"><svg class="svg-glyph"><use xlink:href="#svg-trash" /></svg></span>'
                    data-shifted-command='"deleteAll"'
                    data-alt-keys='delete' data-command='["performWithFeedback","deleteBackward"]'
                >&#x232b;</li>
            </ul>
            <ul>
                <li class='layer-switch font-glyph modifier bottom left' data-layer='latex-lower'>abc</li>
                <li class='keycap tt'>&lt;</li>
                <li class='keycap tt'>&gt;</li>
                <li class='keycap tt'>~</li>
                <li class='keycap tt'>,</li>
                <li class='keycap tt'>.</li>
                <li class='keycap' data-key=' '>&nbsp;</li>
                <arrows/>
            </ul>
        </div>`,
  "functions": `
        <div class='rows'>
            <ul><li class='separator'></li>
                <li class='fnbutton' data-insert='\\sin'></li>
                <li class='fnbutton' data-insert='\\sin^{-1}'></li>
                <li class='fnbutton' data-insert='\\ln'></li>
                <li class='fnbutton' data-insert='\\exponentialE^{#?}'></li>
                <li class='bigfnbutton' data-insert='\\operatorname{lcm}(#?)' data-latex='\\operatorname{lcm}()'></li>
                <li class='bigfnbutton' data-insert='\\operatorname{ceil}(#?)' data-latex='\\operatorname{ceil}()'></li>
                <li class='bigfnbutton' data-insert='\\lim_{n\\to\\infty}'></li>
                <li class='bigfnbutton' data-insert='\\int'></li>
                <li class='bigfnbutton' data-insert='\\operatorname{abs}(#?)' data-latex='\\operatorname{abs}()'></li>
            </ul>
            <ul><li class='separator'></li>
                <li class='fnbutton' data-latex='\\cos'></li>
                <li class='fnbutton' data-latex='\\cos^{-1}'></li>
                <li class='fnbutton' data-latex='\\ln_{10}'></li>
                <li class='fnbutton' data-latex='10^{#?}'></li>
                <li class='bigfnbutton' data-latex='\\operatorname{gcd}(#?)' data-latex='\\operatorname{gcd}()'></li>
                <li class='bigfnbutton' data-latex='\\operatorname{floor}(#?)' data-latex='\\operatorname{floor}()'></li>
                <li class='bigfnbutton' data-latex='\\sum_{n\\mathop=0}^{\\infty}'></li>
                <li class='bigfnbutton' data-latex='\\int_{0}^{\\infty}'></li>
                <li class='bigfnbutton' data-latex='\\operatorname{sign}(#?)' data-latex='\\operatorname{sign}()'></li>
            </ul>
            <ul><li class='separator'></li>
                <li class='fnbutton' data-latex='\\tan'></li>
                <li class='fnbutton' data-latex='\\tan^{-1}'></li>
                <li class='fnbutton' data-latex='\\log_{#?}'></li>
                <li class='fnbutton' data-latex='\\sqrt[#?]{#0}'></li>
                <li class='bigfnbutton' data-insert='#0 \\mod' data-latex='\\mod'></li>
                <li class='bigfnbutton' data-insert='\\operatorname{round}(#?) ' data-latex='\\operatorname{round}()'></li>
                <li class='bigfnbutton' data-insert='\\prod_{n\\mathop=0}^{\\infty}' data-latex='{\\scriptstyle \\prod_{n=0}^{\\infty}}'></li>
                <li class='bigfnbutton' data-insert='\\frac{\\differentialD #0}{\\differentialD x}'></li>
                <li class='action font-glyph bottom right' data-command='["performWithFeedback","deleteBackward"]'>&#x232b;</li></ul>
            <ul><li class='separator'></li>
                <li class='fnbutton'>(</li>
                <li class='fnbutton'>)</li>
                <li class='fnbutton' data-insert='^{#?}' data-latex='x^{#?}'></li>
                <li class='fnbutton' data-insert='_{#?}' data-latex='x_{#?}'></li>
                <li class='keycap w20 ' data-key=' '>&nbsp;</li>
                <arrows/>
            </ul>
        </div>`,
  "style": `
        <div class='rows'>
            <ul>
                <li class='keycap' data-alt-keys='foreground-color' data-command='["applyStyle",{"color":"red"}]'><span style='border-radius: 50%;width:22px;height:22px; border: 3px solid #cc2428'></span></li>
                <li class='keycap' data-alt-keys='background-color' data-command='["applyStyle",{"backgroundColor":"yellow"}]'><span style='border-radius: 50%;width:22px;height:22px; background:#fff590'></span></li>
                <li class='separator w5'></li>
                <li class='keycap' data-command='["applyStyle",{"size":"3"}]' data-latex='\\scriptsize\\text{small}'></li>
                <li class='keycap' data-command='["applyStyle",{"size":"5"}]' data-latex='\\scriptsize\\text{normal}'></li>
                <li class='keycap' data-command='["applyStyle",{"size":"9"}]' data-latex='\\huge\\text{big}'></li>
                <li class='separator w5'></li>
                <li class='keycap' data-latex='\\langle' data-command='["insert", "\\\\langle", {"smartFence":true}]'></li>
            </ul>
            <ul>
                <li class='keycap' data-command='["applyStyle",{"series":"l"}]' data-latex='\\fontseries{l}\\text{Ab}'></li>
                <li class='keycap' data-command='["applyStyle",{"series":"m"}]' data-latex='\\fontseries{m}\\text{Ab}'></li>
                <li class='keycap' data-command='["applyStyle",{"series":"b"}]' data-latex='\\fontseries{b}\\text{Ab}'></li>
                <li class='keycap' data-command='["applyStyle",{"series":"bx"}]' data-latex='\\fontseries{bx}\\text{Ab}'></li>
                <li class='keycap' data-command='["applyStyle",{"series":"sb"}]' data-latex='\\fontseries{sb}\\text{Ab}'></li>
                <li class='keycap' data-command='["applyStyle",{"series":"c"}]' data-latex='\\fontseries{c}\\text{Ab}'></li>
            </ul>
            <ul>
                <li class='keycap' data-command='["applyStyle",{"shape":"up"}]' data-latex='\\textup{Ab}'></li>
                <li class='keycap' data-command='["applyStyle",{"shape":"it"}]' data-latex='\\textit{Ab}'></li>
                <li class='keycap' data-command='["applyStyle",{"shape":"sl"}]' data-latex='\\textsl{Ab}'></li>
                <li class='keycap' data-command='["applyStyle",{"shape":"sc"}]' data-latex='\\textsc{Ab}'></li>
                <li class='separator w5'></li>
                <li class='keycap' data-insert='\\emph{#?} ' data-latex='\\text{\\emph{emph}}'></li>
            </ul>
            <ul>
                <li class='keycap' data-command='["applyStyle",{"fontFamily":"cmr"}]' data-latex='\\textrm{Az}'></li>
                <li class='keycap' data-command='["applyStyle",{"fontFamily":"cmtt"}]' data-latex='\\texttt{Az}'></li>
                <li class='keycap' data-command='["applyStyle",{"fontFamily":"cmss"}]' data-latex='\\textsf{Az}'></li>

                <li class='keycap' data-command='["applyStyle",{"fontFamily":"bb"}]'  data-latex='\\mathbb{AZ}'></li>
                <li class='keycap' data-command='["applyStyle",{"fontFamily":"scr"}]'  data-latex='\\mathscr{AZ}'></li>
                <li class='keycap' data-command='["applyStyle",{"fontFamily":"cal"}]' data-latex='\\mathcal{A1}'></li>
                <li class='keycap' data-command='["applyStyle",{"fontFamily":"frak"}]' data-latex='\\mathfrak{Az}'></li>
            </ul>
        </div>`
};
function latexToMarkup2(latex, arg) {
  latex = latex.replace(/(^|[^\\])#@/g, "$1#?");
  const root = new Atom("root", {mode: "math"});
  root.body = typeset(parseLatex(latex, {
    parseMode: "math",
    args: arg,
    macros: getMacros(),
    registers: getDefaultRegisters()
  }));
  const box = coalesce(adjustInterAtomSpacing(new Box(root.render(new Context({
    macros: getMacros(),
    registers: getDefaultRegisters(),
    smartFence: false
  }, {
    fontSize: DEFAULT_FONT_SIZE
  }, "displaystyle")), {classes: "ML__base"})));
  return makeStruts(box, {classes: "ML__mathlive"}).toMarkup();
}
function makeKeyboardToolbar(options, keyboardIDs, currentKeyboard) {
  let result = "<div class='left'>";
  const keyboardList = keyboardIDs.replace(/\s+/g, " ").split(" ");
  if (keyboardList.length > 1) {
    const keyboards = {
      ...KEYBOARDS,
      ...options.customVirtualKeyboards ?? {}
    };
    for (const keyboard of keyboardList) {
      if (!keyboards[keyboard]) {
        console.error('Unknown virtual keyboard "', keyboard, '"');
        break;
      }
      result += "<div class='";
      if (keyboard === currentKeyboard) {
        result += "selected ";
      } else if (keyboards[keyboard].command) {
        result += "action ";
      } else {
        result += "layer-switch ";
      }
      result += (keyboards[keyboard].classes ?? "") + "'";
      if (keyboards[keyboard].tooltip) {
        result += "data-ML__tooltip='" + (localize(keyboards[keyboard].tooltip) ?? keyboards[keyboard].tooltip) + "' ";
        result += "data-placement='top' data-delay='1s'";
      }
      if (keyboard !== currentKeyboard) {
        if (typeof keyboards[keyboard].command === "string") {
          result += `data-command='"${keyboards[keyboard].command}"'`;
        } else if (Array.isArray(keyboards[keyboard].command)) {
          result += `data-command='"${keyboards[keyboard].command.join("")}"'`;
        }
        if (keyboards[keyboard].layer) {
          result += "data-layer='" + keyboards[keyboard].layer + "'";
        }
      }
      result += ">" + keyboards[keyboard].label + "</div>";
    }
  }
  result += "</div>";
  const toolbarOptions = options.virtualKeyboardToolbar;
  const availableActions = toolbarOptions === "default" ? ["copyToClipboard", "undo", "redo"] : [];
  const actionsMarkup = {
    copyToClipboard: `
            <div class='action'
                data-command='"copyToClipboard"'
                data-ML__tooltip='${localize("tooltip.copy to clipboard")}' data-placement='top' data-delay='1s'>
                <svg><use xlink:href='#svg-copy' /></svg>
            </div>
        `,
    undo: `
            <div class='action disabled'
                data-command='"undo"'
                data-ML__tooltip='${localize("tooltip.undo")}' data-placement='top' data-delay='1s'>
                <svg><use xlink:href='#svg-undo' /></svg>
            </div>
        `,
    redo: `
            <div class='action disabled'
                data-command='"redo"'
                data-ML__tooltip='${localize("tooltip.redo")}' data-placement='top' data-delay='1s'>
                <svg><use xlink:href='#svg-redo' /></svg>
            </div>
        `
  };
  if (availableActions.length > 0) {
    result += `
            <div class='right'>
                ${availableActions.map((action) => actionsMarkup[action]).join("")}
            </div>
        `;
  }
  return "<div class='keyboard-toolbar' role='toolbar'>" + result + "</div>";
}
function makeKeycap(keyboard, elementList, chainedCommand) {
  for (const element of elementList) {
    let html = void 0;
    if (element.getAttribute("data-latex")) {
      html = latexToMarkup2(element.getAttribute("data-latex").replace(/&quot;/g, '"'), () => "\\placeholder{}");
    } else if (element.getAttribute("data-insert") && element.innerHTML === "") {
      html = latexToMarkup2(element.getAttribute("data-insert").replace(/&quot;/g, '"'), () => "\\placeholder{}");
    } else if (element.getAttribute("data-content")) {
      html = element.getAttribute("data-content").replace(/&quot;/g, '"');
    }
    if (element.getAttribute("data-aside")) {
      html = (html ?? "") + "<aside>" + element.getAttribute("data-aside").replace(/&quot;/g, '"') + "</aside>";
    }
    if (html !== void 0) {
      element.innerHTML = keyboard.options.createHTML(html);
    }
    if (element.getAttribute("data-classes")) {
      element.classList.add(element.getAttribute("data-classes"));
    }
    const key = element.getAttribute("data-insert")?.replace(/&quot;/g, '"');
    if (key && SHIFTED_KEYS[key]) {
      element.dataset.shifted = SHIFTED_KEYS[key][0];
      element.dataset.shiftedCommand = JSON.stringify([
        "insertAndUnshiftKeyboardLayer",
        SHIFTED_KEYS[key][1]
      ]);
    }
    let selector;
    if (element.getAttribute("data-command")) {
      selector = JSON.parse(element.getAttribute("data-command"));
    } else if (element.getAttribute("data-insert")) {
      selector = [
        "insert",
        element.getAttribute("data-insert"),
        {
          focus: true,
          feedback: true,
          scrollIntoView: true,
          mode: "math",
          format: "latex",
          resetStyle: true
        }
      ];
    } else if (element.getAttribute("data-latex")) {
      selector = [
        "insert",
        element.getAttribute("data-latex"),
        {
          focus: true,
          feedback: true,
          scrollIntoView: true,
          mode: "math",
          format: "latex",
          resetStyle: true
        }
      ];
    } else {
      selector = [
        "typedText",
        element.getAttribute("data-key") ?? element.textContent,
        {focus: true, feedback: true, simulateKeystroke: true}
      ];
    }
    if (chainedCommand) {
      selector = [chainedCommand, selector];
    }
    let handlers = selector;
    const altKeysetId = element.getAttribute("data-alt-keys");
    if (altKeysetId) {
      const altKeys = ALT_KEYS[altKeysetId];
      if (altKeys) {
        handlers = {
          default: selector,
          pressAndHoldStart: ["showAlternateKeys", altKeysetId],
          pressAndHoldEnd: "hideAlternateKeys"
        };
      }
    }
    attachButtonHandlers((command) => keyboard.executeCommand(command), element, handlers);
  }
}
function expandLayerMarkup(options, layer) {
  const ROWS = {
    qwerty: {
      "lower-1": "qwertyuiop",
      "lower-2": " asdfghjkl ",
      "lower-3": "^zxcvbnm~",
      "upper-1": "QWERTYUIOP",
      "upper-2": " ASDFGHJKL ",
      "upper-3": "^ZXCVBNM~",
      "numpad-1": "789/",
      "numpad-2": "456*",
      "numpad-3": "123-",
      "numpad-4": "0.=+"
    },
    azerty: {
      "lower-1": "azertyuiop",
      "lower-2": "qsdfghjklm",
      "lower-3": "^ wxcvbn ~",
      "upper-1": "AZERTYUIOP",
      "upper-2": "QSDFGHJKLM",
      "upper-3": "^ WXCVBN ~"
    },
    qwertz: {
      "lower-1": "qwertzuiop",
      "lower-2": " asdfghjkl ",
      "lower-3": "^yxcvbnm~",
      "upper-1": "QWERTZUIOP",
      "upper-2": " ASDFGHJKL",
      "upper-3": "^YXCVBNM~"
    },
    dvorak: {
      "lower-1": "^  pyfgcrl ",
      "lower-2": "aoeuidhtns",
      "lower-3": "qjkxbmwvz~",
      "upper-1": "^  PYFGCRL ",
      "upper-2": "AOEUIDHTNS",
      "upper-3": "QJKXBMWVZ~"
    },
    colemak: {
      "lower-1": " qwfpgjluy ",
      "lower-2": "arstdhneio",
      "lower-3": "^zxcvbkm~",
      "upper-1": " QWFPGNLUY ",
      "upper-2": "ARSTDHNEIO",
      "upper-3": "^ZXCVBKM~"
    }
  };
  let layoutName = options.virtualKeyboardLayout;
  if (layoutName === "auto") {
    const activeLayout = getActiveKeyboardLayout();
    if (activeLayout) {
      layoutName = activeLayout.virtualLayout;
    }
    if (!layoutName || layoutName === "auto") {
      layoutName = {
        fr: "azerty",
        be: "azerty",
        al: "qwertz",
        ba: "qwertz",
        cz: "qwertz",
        de: "qwertz",
        hu: "qwertz",
        sk: "qwertz",
        ch: "qwertz"
      }[l10n.locale.slice(0, 2)] ?? "qwerty";
    }
  }
  const layout = ROWS[layoutName] ?? ROWS.qwerty;
  let result = layer;
  let row;
  result = result.replace(/<arrows\/>/g, `
        <li class='action' data-command='["performWithFeedback","moveToPreviousChar"]'
            data-shifted='<svg class="svg-glyph"><use xlink:href="#svg-angle-double-left" /></svg>'
            data-shifted-command='["performWithFeedback","extendToPreviousChar"]'>
            <svg class="svg-glyph"><use xlink:href='#svg-arrow-left' /></svg>
        </li>
        <li class='action' data-command='["performWithFeedback","moveToNextChar"]'
            data-shifted='<svg class="svg-glyph"><use xlink:href="#svg-angle-double-right" /></svg>'
            data-shifted-command='["performWithFeedback","extendToNextChar"]'>
            <svg class="svg-glyph"><use xlink:href='#svg-arrow-right' /></svg>
        </li>
        <li class='action' data-command='["performWithFeedback","moveToNextPlaceholder"]'>
        <svg class="svg-glyph"><use xlink:href='#svg-tab' /></svg></li>`);
  let m3 = result.match(/(<row\s+)(.*)((?:<\/row|\/)>)/);
  while (m3) {
    row = "";
    const attributesArray = m3[2].match(/[a-zA-Z][a-zA-Z\d-]*=(['"])(.*?)\1/g);
    const attributes = {};
    if (attributesArray) {
      for (const attribute of attributesArray) {
        const m22 = attribute.match(/([a-zA-Z][a-zA-Z\d-]*)=(['"])(.*?)\2/);
        if (m22) {
          attributes[m22[1]] = m22[3];
        }
      }
    }
    let keys = layout[attributes.name];
    if (!keys)
      keys = ROWS.qwerty[attributes.name];
    if (!keys) {
      console.warn("Unknown roman keyboard row:", attributes.name);
    } else {
      for (const c3 of keys) {
        let cls = attributes.class ?? "";
        if (cls)
          cls = ` ${cls}`;
        if (c3 === "~") {
          row += `<li class='action font-glyph bottom right `;
          row += keys.length - (keys.match(/ /g) || []).length / 2 === 10 ? "w10" : "w15";
          row += `' data-shifted='<span class="warning"><svg class="svg-glyph"><use xlink:href="#svg-trash" /></svg></span>'
                        data-shifted-command='"deleteAll"'
                        data-alt-keys='delete' data-command='["performWithFeedback","deleteBackward"]'
                        >&#x232b;</li>`;
        } else if (c3 === " ") {
          row += "<li class='separator w5'></li>";
        } else if (c3 === "^") {
          row += `<li class='shift modifier font-glyph bottom left w15 layer-switch' data-layer='` + attributes["shift-layer"] + `'>&#x21e7;</li>`;
        } else if (c3 === "/") {
          row += "<li class='keycap" + cls + "' data-alt-keys='/' data-insert='\\frac{#@}{#?}'>&divide;</li>";
        } else if (c3 === "*") {
          row += "<li class='keycap" + cls + "' data-alt-keys='*' data-insert='\\times '>&times;</li>";
        } else if (c3 === "-") {
          row += "<li class='keycap" + cls + "' data-alt-keys='-' data-key='-' data-alt-keys='-'>&#x2212;</li>";
        } else if (cls.includes("tt")) {
          row += `<li class='keycap${cls}' data-alt-keys='${c3}' data-command='["typedText","${c3}",{"mode":"command", "focus":true, "feedback":true}]'>${c3}</li>`;
        } else {
          row += "<li class='keycap" + cls + "' data-alt-keys='" + c3 + "'>" + c3 + "</li>";
        }
      }
    }
    result = result.replace(new RegExp(m3[1] + m3[2] + m3[3]), row);
    m3 = result.match(/(<row\s+)(.*)((?:<\/row|\/)>)/);
  }
  return result;
}
function makeKeyboardElement(keyboard, theme) {
  throwIfNotInBrowser();
  const svgIcons = `<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">

            <symbol id="svg-command" viewBox="0 0 640 512">
                <path d="M34.495 36.465l211.051 211.05c4.686 4.686 4.686 12.284 0 16.971L34.495 475.535c-4.686 4.686-12.284 4.686-16.97 0l-7.071-7.07c-4.686-4.686-4.686-12.284 0-16.971L205.947 256 10.454 60.506c-4.686-4.686-4.686-12.284 0-16.971l7.071-7.07c4.686-4.687 12.284-4.687 16.97 0zM640 468v-10c0-6.627-5.373-12-12-12H300c-6.627 0-12 5.373-12 12v10c0 6.627 5.373 12 12 12h328c6.627 0 12-5.373 12-12z"/>
            </symbol>

            <symbol id="svg-undo" viewBox="0 0 512 512">
                <path d="M20 8h10c6.627 0 12 5.373 12 12v110.625C85.196 57.047 165.239 7.715 256.793 8.001 393.18 8.428 504.213 120.009 504 256.396 503.786 393.181 392.834 504 256 504c-63.926 0-122.202-24.187-166.178-63.908-5.113-4.618-5.354-12.561-.482-17.433l7.069-7.069c4.503-4.503 11.749-4.714 16.482-.454C150.782 449.238 200.935 470 256 470c117.744 0 214-95.331 214-214 0-117.744-95.331-214-214-214-82.862 0-154.737 47.077-190.289 116H180c6.627 0 12 5.373 12 12v10c0 6.627-5.373 12-12 12H20c-6.627 0-12-5.373-12-12V20c0-6.627 5.373-12 12-12z"/>
            </symbol>
            <symbol id="svg-redo" viewBox="0 0 512 512">
                <path d="M492 8h-10c-6.627 0-12 5.373-12 12v110.625C426.804 57.047 346.761 7.715 255.207 8.001 118.82 8.428 7.787 120.009 8 256.396 8.214 393.181 119.166 504 256 504c63.926 0 122.202-24.187 166.178-63.908 5.113-4.618 5.354-12.561.482-17.433l-7.069-7.069c-4.503-4.503-11.749-4.714-16.482-.454C361.218 449.238 311.065 470 256 470c-117.744 0-214-95.331-214-214 0-117.744 95.331-214 214-214 82.862 0 154.737 47.077 190.289 116H332c-6.627 0-12 5.373-12 12v10c0 6.627 5.373 12 12 12h160c6.627 0 12-5.373 12-12V20c0-6.627-5.373-12-12-12z"/>
            </symbol>
            <symbol id="svg-arrow-left" viewBox="0 0 192 512">
                <path d="M25.1 247.5l117.8-116c4.7-4.7 12.3-4.7 17 0l7.1 7.1c4.7 4.7 4.7 12.3 0 17L64.7 256l102.2 100.4c4.7 4.7 4.7 12.3 0 17l-7.1 7.1c-4.7 4.7-12.3 4.7-17 0L25 264.5c-4.6-4.7-4.6-12.3.1-17z"/>
            </symbol>
            <symbol id="svg-arrow-right" viewBox="0 0 192 512">
                    <path d="M166.9 264.5l-117.8 116c-4.7 4.7-12.3 4.7-17 0l-7.1-7.1c-4.7-4.7-4.7-12.3 0-17L127.3 256 25.1 155.6c-4.7-4.7-4.7-12.3 0-17l7.1-7.1c4.7-4.7 12.3-4.7 17 0l117.8 116c4.6 4.7 4.6 12.3-.1 17z"/>
            </symbol>
            <symbol id="svg-tab" viewBox="0 0 448 512">
                    <path d="M32 217.1c0-8.8 7.2-16 16-16h144v-93.9c0-7.1 8.6-10.7 13.6-5.7l143.5 143.1c6.3 6.3 6.3 16.4 0 22.7L205.6 410.4c-5 5-13.6 1.5-13.6-5.7v-93.9H48c-8.8 0-16-7.2-16-16v-77.7m-32 0v77.7c0 26.5 21.5 48 48 48h112v61.9c0 35.5 43 53.5 68.2 28.3l143.6-143c18.8-18.8 18.8-49.2 0-68L228.2 78.9c-25.1-25.1-68.2-7.3-68.2 28.3v61.9H48c-26.5 0-48 21.6-48 48zM436 64h-8c-6.6 0-12 5.4-12 12v360c0 6.6 5.4 12 12 12h8c6.6 0 12-5.4 12-12V76c0-6.6-5.4-12-12-12z"/>
            </symbol>
            <symbol id="svg-copy" viewBox="0 0 448 512">
                <path d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM352 32.491a15.88 15.88 0 0 1 7.431 4.195l51.882 51.883A15.885 15.885 0 0 1 415.508 96H352V32.491zM288 464c0 8.822-7.178 16-16 16H48c-8.822 0-16-7.178-16-16V144c0-8.822 7.178-16 16-16h80v240c0 26.51 21.49 48 48 48h112v48zm128-96c0 8.822-7.178 16-16 16H176c-8.822 0-16-7.178-16-16V48c0-8.822 7.178-16 16-16h144v72c0 13.2 10.8 24 24 24h72v240z"/>
            </symbol>
            <symbol id="svg-angle-double-right" viewBox="0 0 320 512">
                <path d="M166.9 264.5l-117.8 116c-4.7 4.7-12.3 4.7-17 0l-7.1-7.1c-4.7-4.7-4.7-12.3 0-17L127.3 256 25.1 155.6c-4.7-4.7-4.7-12.3 0-17l7.1-7.1c4.7-4.7 12.3-4.7 17 0l117.8 116c4.6 4.7 4.6 12.3-.1 17zm128-17l-117.8-116c-4.7-4.7-12.3-4.7-17 0l-7.1 7.1c-4.7 4.7-4.7 12.3 0 17L255.3 256 153.1 356.4c-4.7 4.7-4.7 12.3 0 17l7.1 7.1c4.7 4.7 12.3 4.7 17 0l117.8-116c4.6-4.7 4.6-12.3-.1-17z"/>
            </symbol>
            <symbol id="svg-angle-double-left" viewBox="0 0 320 512">
                <path d="M153.1 247.5l117.8-116c4.7-4.7 12.3-4.7 17 0l7.1 7.1c4.7 4.7 4.7 12.3 0 17L192.7 256l102.2 100.4c4.7 4.7 4.7 12.3 0 17l-7.1 7.1c-4.7 4.7-12.3 4.7-17 0L153 264.5c-4.6-4.7-4.6-12.3.1-17zm-128 17l117.8 116c4.7 4.7 12.3 4.7 17 0l7.1-7.1c4.7-4.7 4.7-12.3 0-17L64.7 256l102.2-100.4c4.7-4.7 4.7-12.3 0-17l-7.1-7.1c-4.7-4.7-12.3-4.7-17 0L25 247.5c-4.6 4.7-4.6 12.3.1 17z"/>
            </symbol>
            <symbol id="svg-trash" viewBox="0 0 448 512">
                <path d="M336 64l-33.6-44.8C293.3 7.1 279.1 0 264 0h-80c-15.1 0-29.3 7.1-38.4 19.2L112 64H24C10.7 64 0 74.7 0 88v2c0 3.3 2.7 6 6 6h26v368c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V96h26c3.3 0 6-2.7 6-6v-2c0-13.3-10.7-24-24-24h-88zM184 32h80c5 0 9.8 2.4 12.8 6.4L296 64H152l19.2-25.6c3-4 7.8-6.4 12.8-6.4zm200 432c0 8.8-7.2 16-16 16H80c-8.8 0-16-7.2-16-16V96h320v368zm-176-44V156c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v264c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12zm-80 0V156c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v264c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12zm160 0V156c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v264c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12z"/>
            </symbol>
        </svg>
        `;
  let markup = svgIcons;
  keyboard.create();
  ALT_KEYS_BASE["foreground-color"] = [];
  for (const color of Object.keys(FOREGROUND_COLORS)) {
    ALT_KEYS_BASE["foreground-color"].push({
      class: "small-button",
      content: '<span style="border-radius:50%;width:32px;height:32px; box-sizing: border-box; border: 3px solid ' + FOREGROUND_COLORS[color] + '"></span>',
      command: ["applyStyle", {color}]
    });
  }
  ALT_KEYS_BASE["background-color"] = [];
  for (const color of Object.keys(BACKGROUND_COLORS)) {
    ALT_KEYS_BASE["background-color"].push({
      class: "small-button",
      content: '<span style="border-radius:50%;width:32px;height:32px; background:' + BACKGROUND_COLORS[color] + '"></span>',
      command: ["applyStyle", {backgroundColor: color}]
    });
  }
  ALT_KEYS = {...ALT_KEYS_BASE};
  for (const key of Object.keys(ALT_KEYS)) {
    ALT_KEYS[key] = ALT_KEYS[key].slice();
  }
  const UPPER_ALPHA = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  const LOWER_ALPHA = "abcdefghijklmnopqrstuvwxyz";
  const DIGITS = "0123456789";
  for (let i3 = 0; i3 < 26; i3++) {
    const key = UPPER_ALPHA[i3];
    if (!ALT_KEYS[key])
      ALT_KEYS[key] = [];
    ALT_KEYS[key].unshift({
      latex: "\\mathbb{" + key + "}",
      aside: "blackboard",
      insert: "\\mathbb{" + key + "}"
    });
    ALT_KEYS[key].unshift({
      latex: "\\mathbf{" + key + "}",
      aside: "bold",
      insert: "\\mathbf{" + key + "}"
    });
    ALT_KEYS[key].unshift({
      latex: "\\mathsf{" + key + "}",
      aside: "sans",
      insert: "\\mathsf{" + key + "}"
    });
    ALT_KEYS[key].unshift({
      latex: "\\mathtt{" + key + "}",
      aside: "monospace",
      insert: "\\mathtt{" + key + "}"
    });
    ALT_KEYS[key].unshift({
      latex: "\\mathcal{" + key + "}",
      aside: "calligraphy",
      insert: "\\mathcal{" + key + "}"
    });
    ALT_KEYS[key].unshift({
      latex: "\\mathfrak{" + key + "}",
      aside: "fraktur",
      insert: "\\mathfrak{" + key + "}"
    });
  }
  for (let i3 = 0; i3 <= 26; i3++) {
    const key = LOWER_ALPHA[i3];
    if (!ALT_KEYS[key])
      ALT_KEYS[key] = [];
    ALT_KEYS[key].unshift({
      latex: "\\mathsf{" + key + "}",
      aside: "sans",
      insert: "\\mathsf{" + key + "}"
    });
    ALT_KEYS[key].unshift({
      latex: "\\mathbf{" + key + "}",
      aside: "bold",
      insert: "\\mathbf{" + key + "}"
    });
    ALT_KEYS[key].unshift({
      latex: "\\mathtt{" + key + "}",
      aside: "monospace",
      insert: "\\mathtt{" + key + "}"
    });
    ALT_KEYS[key].unshift({
      latex: "\\mathfrak{" + key + "}",
      aside: "fraktur",
      insert: "\\mathfrak{" + key + "}"
    });
  }
  for (let i3 = 0; i3 < 10; i3++) {
    const key = DIGITS[i3];
    if (!ALT_KEYS[key])
      ALT_KEYS[key] = [];
    ALT_KEYS[key].unshift({
      latex: "\\mathbf{" + key + "}",
      aside: "bold",
      insert: "\\mathbf{" + key + "}"
    });
    ALT_KEYS[key].unshift({
      latex: "\\mathsf{" + key + "}",
      aside: "sans",
      insert: "\\mathsf{" + key + "}"
    });
    ALT_KEYS[key].unshift({
      latex: "\\mathtt{" + key + "}",
      aside: "monospace",
      insert: "\\mathtt{" + key + "}"
    });
    ALT_KEYS[key].unshift({
      latex: "\\mathcal{" + key + "}",
      aside: "script",
      insert: "\\mathcal{" + key + "}"
    });
    ALT_KEYS[key].unshift({
      latex: "\\mathfrak{" + key + "}",
      aside: "fraktur",
      insert: "\\mathfrak{" + key + "}"
    });
  }
  let keyboardIDs = keyboard.options.virtualKeyboards;
  if (!keyboardIDs) {
    keyboardIDs = "all";
  }
  keyboardIDs = keyboardIDs.replace(/\ball\b/i, "numeric functions symbols roman  greek");
  const layers = {
    ...LAYERS,
    ...keyboard.options.customVirtualKeyboardLayers ?? {}
  };
  const keyboards = {
    ...KEYBOARDS,
    ...keyboard.options.customVirtualKeyboards ?? {}
  };
  const keyboardList = keyboardIDs.replace(/\s+/g, " ").split(" ");
  for (const keyboardName of keyboardList) {
    if (!keyboards[keyboardName]) {
      console.error('Unknown virtual keyboard "' + keyboardName + '"');
      continue;
    }
    let keyboardLayers = keyboards[keyboardName].layers ?? [];
    if (keyboards[keyboardName].layer) {
      keyboardLayers.push(keyboards[keyboardName].layer);
    }
    keyboardLayers = [...new Set(keyboardLayers)];
    for (const layerName of keyboardLayers) {
      if (!layers[layerName]) {
        console.error('Unknown virtual keyboard layer: "', layerName, '"');
        break;
      }
      if (typeof layers[layerName] === "object") {
        const layer = layers[layerName];
        let layerMarkup2 = "";
        if (layer.styles) {
          layerMarkup2 += `<style>${layer.styles}</style>`;
        }
        if (layer.backdrop) {
          layerMarkup2 += `<div class='${layer.backdrop}'>`;
        }
        if (layer.container) {
          layerMarkup2 += `<div class='${layer.container}'>`;
        }
        if (layer.rows) {
          layerMarkup2 += `<div class='rows'>`;
          for (const row of layer.rows) {
            layerMarkup2 += `<ul>`;
            for (const keycap of row) {
              layerMarkup2 += `<li`;
              if (keycap.class && /separator/.test(keycap.class)) {
                layerMarkup2 += ` class="${keycap.class}"`;
              } else if (keycap.class) {
                layerMarkup2 += ` class="keycap ${keycap.class}"`;
              } else {
                layerMarkup2 += ` class="keycap"`;
              }
              if (keycap.key) {
                layerMarkup2 += ` data-key="${keycap.key}"`;
              }
              if (keycap.command) {
                if (typeof keycap.command === "string") {
                  layerMarkup2 += ` data-command='"${keycap.command}"'`;
                } else {
                  layerMarkup2 += ` data-command='`;
                  layerMarkup2 += JSON.stringify(keycap.command);
                  layerMarkup2 += `'`;
                }
              }
              if (keycap.insert) {
                layerMarkup2 += ` data-insert="${keycap.insert}"`;
              }
              if (keycap.latex) {
                layerMarkup2 += ` data-latex="${keycap.latex}"`;
              }
              if (keycap.aside) {
                layerMarkup2 += ` data-aside="${keycap.aside}"`;
              }
              if (keycap.variants) {
                const keysetId = Date.now().toString(36).slice(-2) + Math.floor(Math.random() * 1e5).toString(36);
                ALT_KEYS[keysetId] = keycap.variants;
                layerMarkup2 += ` data-alt-keys="${keysetId}"`;
              }
              if (keycap.shifted) {
                layerMarkup2 += ` data-shifted="${keycap.shifted}"`;
              }
              if (keycap.shiftedCommand) {
                layerMarkup2 += ` data-shifted-command="${keycap.shiftedCommand}"`;
              }
              layerMarkup2 += `>${keycap.label ? keycap.label : ""}</li>`;
            }
            layerMarkup2 += `</ul>`;
          }
          layerMarkup2 += `</div>`;
        }
        if (layer.container) {
          layerMarkup2 += "</div>";
        }
        if (layer.backdrop) {
          layerMarkup2 += "</div>";
        }
        layers[layerName] = layerMarkup2;
      }
      markup += `<div tabindex="-1" class='keyboard-layer' data-layer='${layerName}'>`;
      markup += makeKeyboardToolbar(keyboard.options, keyboardIDs, keyboardName);
      const layerMarkup = layers[layerName];
      markup += expandLayerMarkup(keyboard.options, layerMarkup);
      markup += "</div>";
    }
  }
  const result = document.createElement("div");
  result.className = "ML__keyboard";
  if (theme) {
    result.classList.add(theme);
  } else if (keyboard.options.virtualKeyboardTheme) {
    result.classList.add(keyboard.options.virtualKeyboardTheme);
  }
  const plate = document.createElement("div");
  plate.className = "ML__keyboard--plate";
  plate.innerHTML = keyboard.options.createHTML(markup);
  result.appendChild(plate);
  const keycaps = result.querySelectorAll(".keycap, .action, .fnbutton, .bigfnbutton");
  for (const keycap of keycaps) {
    keycap.id = "ML__k" + Date.now().toString(36).slice(-2) + Math.floor(Math.random() * 1e5).toString(36);
  }
  makeKeycap(keyboard, [...keycaps]);
  const elementList = result.querySelectorAll(".layer-switch");
  for (const element of elementList) {
    if (element.classList.contains("shift")) {
      attachButtonHandlers((command) => keyboard.executeCommand(command), element, {
        pressed: "shiftKeyboardLayer",
        default: ["switchKeyboardLayer", element.getAttribute("data-layer")],
        pressAndHoldEnd: "unshiftKeyboardLayer"
      });
    } else {
      attachButtonHandlers((command) => keyboard.executeCommand(command), element, {
        default: ["switchKeyboardLayer", element.getAttribute("data-layer")]
      });
    }
  }
  const layerElements = result.querySelectorAll(".keyboard-layer");
  for (const x3 of layerElements) {
    x3.addEventListener("mousedown", (evt) => {
      evt.preventDefault();
      evt.stopPropagation();
    });
    x3.addEventListener("touchstart", (evt) => {
      evt.preventDefault();
      evt.stopPropagation();
    }, {passive: false});
  }
  console.assert(layerElements.length > 0, "No virtual keyboards available");
  layerElements[0]?.classList.add("is-visible");
  return result;
}
function unshiftKeyboardLayer(keyboard) {
  hideAlternateKeys();
  const keycaps = keyboard.element.querySelectorAll("div.keyboard-layer.is-visible .rows .keycap, div.keyboard-layer.is-visible .rows .action");
  if (keycaps) {
    for (const keycap of keycaps) {
      const content = keycap.getAttribute("data-unshifted-content");
      if (content) {
        keycap.innerHTML = keyboard.options.createHTML(content);
      }
      const command = keycap.getAttribute("data-unshifted-command");
      if (command) {
        keycap.dataset.command = command;
      }
    }
  }
  return false;
}
function onUndoStateChanged(keyboard, canUndoState, canRedoState) {
  const toolbar = keyboard.element?.querySelector(".keyboard-toolbar");
  if (!toolbar)
    return false;
  const undoButton = toolbar.querySelector(`[data-command='"undo"']`);
  const redoButton = toolbar.querySelector(`[data-command='"redo"']`);
  if (redoButton) {
    if (canRedoState) {
      redoButton.classList.remove("disabled");
    } else {
      redoButton.classList.add("disabled");
    }
  }
  if (undoButton) {
    if (canUndoState) {
      undoButton.classList.remove("disabled");
    } else {
      undoButton.classList.add("disabled");
    }
  }
  return false;
}

// src/editor/virtual-keyboard-commands.ts
register2({
  showAlternateKeys
}, {target: "virtual-keyboard"});
function switchKeyboardLayer(keyboard, layer) {
  if (keyboard.options.virtualKeyboardMode !== "off") {
    if (layer !== "lower-command" && layer !== "upper-command" && layer !== "symbols-command") {
      keyboard.executeCommand("complete");
    }
    showVirtualKeyboard(keyboard);
    hideAlternateKeys();
    unshiftKeyboardLayer(keyboard);
    const layers = keyboard?.element.querySelectorAll(".keyboard-layer");
    let found = false;
    for (const layer_ of layers) {
      if (layer_.dataset.layer === layer) {
        found = true;
        break;
      }
    }
    if (found) {
      for (const layer_ of layers) {
        if (layer_.dataset.layer === layer) {
          layer_.classList.add("is-visible");
        } else {
          layer_.classList.remove("is-visible");
        }
      }
    }
    keyboard.focusMathfield();
  }
  return true;
}
function shiftKeyboardLayer(keyboard) {
  const keycaps = keyboard?.element.querySelectorAll("div.keyboard-layer.is-visible .rows .keycap, div.keyboard-layer.is-visible .rows .action");
  if (keycaps) {
    for (const keycap of keycaps) {
      let shiftedContent = keycap.getAttribute("data-shifted");
      if (shiftedContent || /^[a-z]$/.test(keycap.innerHTML)) {
        keycap.dataset.unshiftedContent = keycap.innerHTML;
        if (!shiftedContent) {
          shiftedContent = keycap.innerHTML.toUpperCase();
        }
        keycap.innerHTML = keyboard.options.createHTML(shiftedContent);
        const command = keycap.getAttribute("data-command");
        if (command) {
          keycap.dataset.unshiftedCommand = command;
          const shifteCommand = keycap.getAttribute("data-shifted-command");
          if (shifteCommand) {
            keycap.dataset.command = shifteCommand;
          } else {
            const commandObject = JSON.parse(command);
            if (isArray(commandObject)) {
              commandObject[1] = commandObject[1].toUpperCase();
            }
            keycap.dataset.command = JSON.stringify(commandObject);
          }
        }
      }
    }
  }
  return false;
}
register2({
  shiftKeyboardLayer
}, {target: "virtual-keyboard"});
function performAlternateKeys(keyboard, command) {
  hideAlternateKeys();
  return keyboard.executeCommand(command);
}
function insertAndUnshiftKeyboardLayer(keyboard, c3) {
  keyboard.executeCommand(["insert", c3]);
  unshiftKeyboardLayer(keyboard);
  return true;
}
register2({
  hideAlternateKeys: () => hideAlternateKeys(),
  performAlternateKeys,
  switchKeyboardLayer: (keyboard, layer) => switchKeyboardLayer(keyboard, layer),
  unshiftKeyboardLayer: (keyboard) => unshiftKeyboardLayer(keyboard),
  insertAndUnshiftKeyboardLayer
}, {target: "virtual-keyboard"});
function toggleVirtualKeyboardAlt(keyboard) {
  let hadAltTheme = false;
  if (keyboard?.element) {
    hadAltTheme = keyboard?.element.classList.contains("material");
    keyboard.disable();
  }
  showVirtualKeyboard(keyboard, hadAltTheme ? "" : "material");
  return false;
}
function toggleVirtualKeyboardShift(keyboard) {
  keyboard.options.virtualKeyboardLayout = {
    qwerty: "azerty",
    azerty: "qwertz",
    qwertz: "dvorak",
    dvorak: "colemak",
    colemak: "qwerty"
  }[keyboard.options.virtualKeyboardLayout];
  const layer = keyboard?.element.querySelector("div.keyboard-layer.is-visible")?.id ?? "";
  if (keyboard) {
    keyboard.disable();
  }
  showVirtualKeyboard(keyboard);
  if (layer) {
    switchKeyboardLayer(keyboard, layer);
  }
  return false;
}
register2({
  toggleVirtualKeyboardAlt,
  toggleVirtualKeyboardShift
}, {target: "virtual-keyboard"});
function showVirtualKeyboard(keyboard, theme = "") {
  keyboard.visible = false;
  toggleVirtualKeyboard(keyboard, theme);
  return false;
}
function hideVirtualKeyboard(keyboard) {
  keyboard.visible = true;
  toggleVirtualKeyboard(keyboard);
  return false;
}
function toggleVirtualKeyboard(keyboard, theme) {
  if (!keyboard.options.virtualKeyboardContainer)
    return false;
  keyboard.visible = !keyboard.visible;
  if (keyboard.visible) {
    keyboard.focusMathfield();
    if (keyboard.element) {
      keyboard.element.classList.add("is-visible");
    } else {
      keyboard.element = makeKeyboardElement(keyboard, theme ?? "");
      on(keyboard.element, "touchstart:passive mousedown", () => keyboard.focusMathfield());
      keyboard.options.virtualKeyboardContainer.appendChild(keyboard.element);
    }
    window.setTimeout(() => {
      keyboard?.element?.classList.add("is-visible");
    }, 1);
  } else if (keyboard.element) {
    keyboard.disable();
  }
  keyboard.stateChanged();
  return false;
}
register2({
  toggleVirtualKeyboard: (keyboard, theme) => toggleVirtualKeyboard(keyboard, theme),
  hideVirtualKeyboard: (keyboard) => hideVirtualKeyboard(keyboard),
  showVirtualKeyboard: (keyboard, theme) => showVirtualKeyboard(keyboard, theme),
  onUndoStateChanged: (keyboard, canUndoState, canRedoState) => onUndoStateChanged(keyboard, canUndoState, canRedoState)
}, {target: "virtual-keyboard"});

// src/editor/speech.ts
function speakableText(speechOptions, prefix, atoms) {
  const options = {
    ...speechOptions,
    textToSpeechMarkup: "",
    textToSpeechRulesOptions: {
      ...speechOptions.textToSpeechRulesOptions,
      markup: "none"
    }
  };
  return prefix + atomToSpeakableText(atoms, options);
}
register2({
  speak: (mathfield, scope, options) => {
    return speak(mathfield, scope, options);
  }
}, {target: "mathfield", category: "speech"});
function speak(mathfield, scope, speakOptions) {
  speakOptions = speakOptions ?? {withHighlighting: false};
  const {model} = mathfield;
  function getAtoms(scope2) {
    let result = null;
    switch (scope2) {
      case "all":
        result = model.root;
        break;
      case "selection":
        result = model.getAtoms(model.selection);
        break;
      case "left": {
        result = model.getAtoms(model.offsetOf(model.at(model.position).leftSibling), model.position);
        break;
      }
      case "right": {
        result = model.getAtoms(model.position, model.offsetOf(model.at(model.position).rightSibling));
        break;
      }
      case "group":
        result = model.getAtoms(model.getSiblingsRange(model.position));
        break;
      case "parent": {
        const {parent} = model.at(model.position);
        if (parent && parent.type !== "root") {
          result = parent;
        } else {
          result = model.root;
        }
        break;
      }
      default:
        result = model.root;
    }
    return result;
  }
  function getFailedSpeech(scope2) {
    let result = "";
    switch (scope2) {
      case "all":
        console.log("Internal failure: speak all failed");
        break;
      case "selection":
        result = "no selection";
        break;
      case "left":
        result = "at start";
        break;
      case "right":
        result = "at end";
        break;
      case "group":
        console.log("Internal failure: speak group failed");
        break;
      case "parent":
        result = "no parent";
        break;
      default:
        console.log('unknown speak_ param value: "' + scope2 + '"');
        break;
    }
    return result;
  }
  const atoms = getAtoms(scope);
  if (atoms === null) {
    mathfield.options.speakHook?.(getFailedSpeech(scope), mathfield.options);
    return false;
  }
  const options = {...mathfield.options};
  if (speakOptions.withHighlighting || options.speechEngine === "amazon") {
    options.textToSpeechMarkup = window.sre && options.textToSpeechRules === "sre" ? "ssml_step" : "ssml";
  }
  const text = atomToSpeakableText(atoms, options);
  if (speakOptions.withHighlighting) {
    window.mathlive.readAloudMathField = mathfield;
    render(mathfield, {forHighlighting: true});
    if (mathfield.options.readAloudHook) {
      mathfield.options.readAloudHook(mathfield.field, text, mathfield.options);
    }
  } else if (mathfield.options.speakHook) {
    mathfield.options.speakHook(text, options);
  }
  return false;
}
function defaultSpeakHook(text, config) {
  if (!config && window?.mathlive) {
    config = window.mathlive.config;
  }
  config = config ?? {};
  if (!config.speechEngine || config.speechEngine === "local") {
    const utterance = new SpeechSynthesisUtterance(text);
    if (window) {
      window.speechSynthesis.speak(utterance);
    } else {
      console.log("Speak:", text);
    }
  } else if (config.speechEngine === "amazon") {
    if (!window || !window.AWS) {
      console.warn("AWS SDK not loaded. See https://www.npmjs.com/package/aws-sdk");
    } else {
      const polly = new window.AWS.Polly({apiVersion: "2016-06-10"});
      const parameters = {
        OutputFormat: "mp3",
        VoiceId: config.speechEngineVoice ?? "Joanna",
        Engine: [
          "Amy",
          "Emma",
          "Brian",
          "Ivy",
          "Joanna",
          "Kendra",
          "Kimberly",
          "Salli",
          "Joey",
          "Justin",
          "Matthew"
        ].includes(config.speechEngineVoice ?? "Joanna") ? "neural" : "standard",
        Text: text,
        TextType: "ssml"
      };
      polly.synthesizeSpeech(parameters, (err, data) => {
        if (err) {
          console.warn("polly.synthesizeSpeech() error:", err, err.stack);
        } else if (data?.AudioStream) {
          const uInt8Array = new Uint8Array(data.AudioStream);
          const blob = new Blob([uInt8Array.buffer], {
            type: "audio/mpeg"
          });
          const url = URL.createObjectURL(blob);
          const audioElement = new Audio(url);
          audioElement.play().catch((error) => console.log(error));
        } else {
          console.log("polly.synthesizeSpeech():", data);
        }
      });
    }
  } else if (config.speechEngine === "google") {
    console.warn("The Google speech engine is not supported yet. Please come again.");
  }
}

// src/editor/a11y.ts
function relationName(atom) {
  let result = void 0;
  if (atom.treeBranch === "body") {
    result = {
      enclose: "cross out",
      leftright: "fence",
      surd: "square root",
      root: "math field",
      mop: "operator"
    }[atom.parent.type];
  } else if (atom.parent.type === "genfrac") {
    if (atom.treeBranch === "above") {
      return "numerator";
    }
    if (atom.treeBranch === "below") {
      return "denominator";
    }
  } else if (atom.parent.type === "surd") {
    if (atom.treeBranch === "above") {
      result = "index";
    }
  } else if (atom.treeBranch === "superscript") {
    result = "superscript";
  } else if (atom.treeBranch === "subscript") {
    result = "subscript";
  }
  if (!result) {
    console.log("unknown relationship");
  }
  return result ?? "parent";
}
function defaultAnnounceHook(mathfield, action, previousPosition, atoms) {
  let liveText = "";
  if (action === "plonk") {
    mathfield.plonkSound?.play().catch((error) => console.warn(error));
    mathfield.resetKeystrokeBuffer();
  } else if (action === "delete") {
    liveText = speakableText(mathfield.options, "deleted: ", atoms);
  } else if (action === "focus" || action.includes("move")) {
    liveText = getRelationshipAsSpokenText(mathfield.model, previousPosition) + (mathfield.model.selectionIsCollapsed ? "" : "selected: ") + getNextAtomAsSpokenText(mathfield.model, mathfield.options);
  } else if (action === "replacement") {
    liveText = speakableText(mathfield.options, "", mathfield.model.at(mathfield.model.position));
  } else if (action === "line") {
    liveText = speakableText(mathfield.options, "", mathfield.model.root);
    mathfield.keyboardDelegate.setAriaLabel("after: " + liveText);
  } else {
    liveText = atoms ? speakableText(mathfield.options, action + " ", atoms) : action;
  }
  const ariaLiveChangeHack = mathfield.ariaLiveText.textContent.includes("\xA0") ? " \u202F " : " \xA0 ";
  mathfield.ariaLiveText.textContent = liveText + ariaLiveChangeHack;
}
function getRelationshipAsSpokenText(model, previousOffset) {
  if (Number.isNaN(previousOffset))
    return "";
  const previous = model.at(previousOffset);
  if (!previous)
    return "";
  if (previous.treeDepth <= model.at(model.position).treeDepth) {
    return "";
  }
  let result = "";
  let ancestor = previous.parent;
  const newParent = model.at(model.position).parent;
  while (ancestor !== model.root && ancestor !== newParent) {
    result += `out of ${relationName(ancestor)};`;
    ancestor = ancestor.parent;
  }
  return result;
}
function getNextAtomAsSpokenText(model, options) {
  if (!model.selectionIsCollapsed) {
    return speakableText(options, "", model.getAtoms(model.selection));
  }
  let result = "";
  const cursor = model.at(model.position);
  const relation = relationName(cursor);
  if (cursor.isFirstSibling) {
    result = (relation ? "start of " + relation : "unknown") + ": ";
  }
  if (cursor.isLastSibling) {
    if (!cursor.isFirstSibling) {
      result += relation ? "end of " + relation : "unknown";
    }
  } else {
    result += speakableText(options, "", cursor);
  }
  return result;
}

// src/editor/speech-read-aloud.ts
function removeHighlight(element) {
  element.classList.remove("ML__highlight");
  if (element.children) {
    for (const child of element.children) {
      removeHighlight(child);
    }
  }
}
function highlightAtomID(element, atomID) {
  if (!atomID || element.dataset?.atomId === atomID) {
    element.classList.add("ML__highlight");
    if (element.children && element.children.length > 0) {
      [...element.children].forEach((x3) => {
        if (x3 instanceof HTMLElement) {
          highlightAtomID(x3);
        }
      });
    }
  } else {
    element.classList.remove("ML__highlight");
    if (element.children && element.children.length > 0) {
      [...element.children].forEach((x3) => {
        if (x3 instanceof HTMLElement) {
          highlightAtomID(x3, atomID);
        }
      });
    }
  }
}
function defaultReadAloudHook(element, text, config) {
  if (typeof window === "undefined") {
    return;
  }
  if (!config && window.mathlive) {
    config = window.mathlive.config;
  }
  if (config.speechEngine !== "amazon") {
    console.warn("Use Amazon TTS Engine for synchronized highlighting");
    if (config.speakHook)
      config.speakHook(text, config);
    return;
  }
  if (!window.AWS) {
    console.warn("AWS SDK not loaded. See https://www.npmjs.com/package/aws-sdk");
    return;
  }
  const polly = new window.AWS.Polly({apiVersion: "2016-06-10"});
  const parameters = {
    OutputFormat: "json",
    VoiceId: config.speechEngineVoice ?? "Joanna",
    Engine: "standard",
    Text: text,
    TextType: "ssml",
    SpeechMarkTypes: ["ssml"]
  };
  window.mathlive = window.mathlive ?? {};
  window.mathlive.readAloudElement = element;
  const statusHook = config.onReadAloudStatus ?? window.mathlive.onReadAloudStatus;
  polly.synthesizeSpeech(parameters, (err, data) => {
    if (err) {
      console.warn("polly.synthesizeSpeech() error:", err, err.stack);
      return;
    }
    if (!data || !data.AudioStream) {
      console.log("polly.synthesizeSpeech():", data);
      return;
    }
    const response = new TextDecoder("utf-8").decode(new Uint8Array(data.AudioStream));
    window.mathlive.readAloudMarks = response.split("\n").map((x3) => x3 ? JSON.parse(x3) : {});
    window.mathlive.readAloudTokens = [];
    for (const mark of window.mathlive.readAloudMarks) {
      if (mark.value) {
        window.mathlive.readAloudTokens.push(mark.value);
      }
    }
    window.mathlive.readAloudCurrentMark = "";
    parameters.OutputFormat = "mp3";
    parameters.SpeechMarkTypes = [];
    polly.synthesizeSpeech(parameters, (err2, data2) => {
      if (err2) {
        console.warn("polly.synthesizeSpeech(", text, ") error:", err2, err2.stack);
        return;
      }
      if (!data2 || !data2.AudioStream) {
        return;
      }
      const uInt8Array = new Uint8Array(data2.AudioStream);
      const blob = new Blob([uInt8Array.buffer], {
        type: "audio/mpeg"
      });
      const url = URL.createObjectURL(blob);
      if (!window.mathlive.readAloudAudio) {
        window.mathlive.readAloudAudio = new Audio();
        window.mathlive.readAloudAudio.addEventListener("ended", () => {
          const mathfield = window.mathlive.readAloudMathField;
          if (statusHook) {
            statusHook(mathfield, "ended");
          }
          if (mathfield) {
            render(mathfield);
            window.mathlive.readAloudElement = null;
            window.mathlive.readAloudMathField = null;
            window.mathlive.readAloudTokens = [];
            window.mathlive.readAloudMarks = [];
            window.mathlive.readAloudCurrentMark = "";
          } else {
            removeHighlight(window.mathlive.readAloudElement);
          }
        });
        window.mathlive.readAloudAudio.addEventListener("timeupdate", () => {
          let value = "";
          const target = window.mathlive.readAloudAudio.currentTime * 1e3 + 100;
          for (const mark of window.mathlive.readAloudMarks) {
            if (mark.time < target) {
              value = mark.value;
            }
          }
          if (window.mathlive.readAloudCurrentMark !== value) {
            window.mathlive.readAloudCurrentToken = value;
            if (value && value === window.mathlive.readAloudFinalToken) {
              window.mathlive.readAloudAudio.pause();
            } else {
              window.mathlive.readAloudCurrentMark = value;
              highlightAtomID(window.mathlive.readAloudElement, window.mathlive.readAloudCurrentMark);
            }
          }
        });
      } else {
        window.mathlive.readAloudAudio.pause();
      }
      window.mathlive.readAloudAudio.src = url;
      if (statusHook) {
        statusHook(window.mathlive.readAloudMathField, "playing");
      }
      window.mathlive.readAloudAudio.play();
    });
  });
}

// src/editor/options.ts
var AUDIO_FEEDBACK_VOLUME = 0.5;
var NO_OP_LISTENER = () => {
};
function loadSound(soundDirectory, sound) {
  if (sound === null || sound === void 0 || sound === "none" || sound === "null") {
    return null;
  }
  if (sound instanceof HTMLAudioElement) {
    sound.load();
    return sound;
  }
  sound = sound.trim();
  if (sound.length === 0)
    return null;
  const url = resolveRelativeUrl((soundDirectory === void 0 || soundDirectory.length === 0 ? "./sounds" : soundDirectory) + "/" + sound).toString();
  const result = new Audio();
  result.src = url;
  result.volume = AUDIO_FEEDBACK_VOLUME;
  result.load();
  return result;
}
function unloadSound(sound) {
  if (sound instanceof HTMLAudioElement) {
    sound.pause();
    sound.removeAttribute("src");
    sound.load();
  }
}
function update(current, updates) {
  const soundsDirectory = updates.soundsDirectory ?? current.soundsDirectory ?? "./sounds";
  const result = get(current, Object.keys(current));
  for (const key of Object.keys(updates)) {
    switch (key) {
      case "scriptDepth":
        if (isArray(updates.scriptDepth)) {
          result.scriptDepth = [updates.scriptDepth[0], updates.scriptDepth[1]];
        } else if (typeof updates.scriptDepth === "number") {
          result.scriptDepth = [updates.scriptDepth, updates.scriptDepth];
        } else {
          throw new TypeError("Unexpected value for scriptDepth");
        }
        break;
      case "locale":
        result.locale = updates.locale === "auto" ? (isBrowser() ? navigator.language.slice(0, 5) : null) ?? "en" : updates.locale;
        l10n.locale = result.locale;
        break;
      case "strings":
        l10n.merge(updates.strings);
        result.strings = l10n.strings;
        break;
      case "virtualKeyboardLayout":
        result.virtualKeyboardLayout = updates.virtualKeyboardLayout;
        break;
      case "virtualKeyboardMode":
        if (updates.virtualKeyboardMode === "auto") {
          result.virtualKeyboardMode = isTouchCapable() ? "onfocus" : "off";
        } else {
          result.virtualKeyboardMode = updates.virtualKeyboardMode;
        }
        break;
      case "customVirtualKeyboardLayers":
        result.customVirtualKeyboardLayers = {
          ...result.customVirtualKeyboardLayers,
          ...updates.customVirtualKeyboardLayers
        };
        break;
      case "customVirtualKeyboards":
        result.customVirtualKeyboards = {
          ...result.customVirtualKeyboards,
          ...updates.customVirtualKeyboards
        };
        break;
      case "letterShapeStyle":
        if (updates.letterShapeStyle === "auto") {
          if (l10n.locale.startsWith("fr")) {
            result.letterShapeStyle = "french";
          } else {
            result.letterShapeStyle = "tex";
          }
        } else {
          result.letterShapeStyle = updates.letterShapeStyle;
        }
        break;
      case "plonkSound":
        unloadSound(result.plonkSound);
        result.plonkSound = loadSound(soundsDirectory, updates.plonkSound);
        break;
      case "keypressSound":
        if (typeof result.keypressSound === "object" && result.keypressSound !== null && "default" in result.keypressSound) {
          unloadSound(result.keypressSound.default);
          unloadSound(result.keypressSound.delete);
          unloadSound(result.keypressSound.return);
          unloadSound(result.keypressSound.spacebar);
        }
        if (updates.keypressSound === null) {
          result.keypressSound = {
            default: null,
            delete: null,
            return: null,
            spacebar: null
          };
        } else if (typeof updates.keypressSound === "string") {
          const sound = loadSound(soundsDirectory, updates.keypressSound);
          result.keypressSound = {
            delete: sound,
            return: sound,
            spacebar: sound,
            default: sound
          };
        } else if (updates.keypressSound instanceof HTMLAudioElement) {
          result.keypressSound = {
            delete: updates.keypressSound,
            return: updates.keypressSound,
            spacebar: updates.keypressSound,
            default: updates.keypressSound
          };
        } else if (typeof updates.keypressSound === "object" && "default" in updates.keypressSound) {
          result.keypressSound = {...updates.keypressSound};
          result.keypressSound.default = loadSound(soundsDirectory, result.keypressSound.default);
          result.keypressSound.delete = loadSound(soundsDirectory, result.keypressSound.delete) ?? updates.keypressSound.default;
          result.keypressSound.return = loadSound(soundsDirectory, result.keypressSound.return) ?? updates.keypressSound.default;
          result.keypressSound.spacebar = loadSound(soundsDirectory, result.keypressSound.spacebar) ?? updates.keypressSound.default;
        }
        break;
      case "virtualKeyboardContainer":
        result.virtualKeyboardContainer = updates.virtualKeyboardContainer;
        break;
      case "macros":
        result.macros = normalizeMacroDictionary(updates.macros) ?? {};
        break;
      case "onBlur":
      case "onFocus":
      case "onContentWillChange":
      case "onContentDidChange":
      case "onSelectionWillChange":
      case "onSelectionDidChange":
      case "onUndoStateWillChange":
      case "onUndoStateDidChange":
      case "onModeChange":
      case "onCommit":
      case "onReadAloudStatus":
      case "onError":
        if (updates[key] === null) {
          result[key] = NO_OP_LISTENER;
        } else if (typeof updates[key] !== "function") {
          throw new TypeError(key + " must be a function or null");
        }
        result[key] = updates[key];
        break;
      default:
        if (isArray(updates[key])) {
          result[key] = [...updates[key]];
        } else if (typeof updates[key] === "object") {
          result[key] = {...updates[key]};
        } else {
          result[key] = updates[key];
        }
    }
  }
  return result;
}
function get(config, keys) {
  let resolvedKeys;
  if (typeof keys === "string") {
    resolvedKeys = [keys];
  } else if (keys === void 0) {
    resolvedKeys = Object.keys(config);
  } else {
    resolvedKeys = keys;
  }
  const result = {};
  for (const x3 of resolvedKeys) {
    if (isArray(config[x3])) {
      result[x3] = [...config[x3]];
    } else if (config[x3] instanceof HTMLElement) {
      result[x3] = config[x3];
    } else if (config[x3] === null) {
      result[x3] = null;
    } else if (typeof config[x3] === "object") {
      result[x3] = {...config[x3]};
    } else {
      result[x3] = config[x3];
    }
  }
  if (typeof keys === "string") {
    return result[keys];
  }
  return result;
}
var DEFAULT_KEYBOARD_TOGGLE_GLYPH = `<span style="width: 21px; margin-top: 4px;"><svg style="width: 21px;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M528 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h480c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm16 336c0 8.823-7.177 16-16 16H48c-8.823 0-16-7.177-16-16V112c0-8.823 7.177-16 16-16h480c8.823 0 16 7.177 16 16v288zM168 268v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm-336 80v-24c0-6.627-5.373-12-12-12H84c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm384 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zM120 188v-24c0-6.627-5.373-12-12-12H84c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm-96 152v-8c0-6.627-5.373-12-12-12H180c-6.627 0-12 5.373-12 12v8c0 6.627 5.373 12 12 12h216c6.627 0 12-5.373 12-12z"/></svg></span>`;
function getDefault() {
  return {
    readOnly: false,
    createHTML: (s3) => s3,
    fontsDirectory: "./fonts",
    soundsDirectory: "./sounds",
    defaultMode: "math",
    macros: getMacros(),
    registers: {...getDefaultRegisters()},
    colorMap: defaultColorMap,
    backgroundColorMap: defaultBackgroundColorMap,
    horizontalSpacingScale: 1,
    letterShapeStyle: l10n.locale.startsWith("fr") ? "french" : "tex",
    smartMode: false,
    smartFence: true,
    smartSuperscript: true,
    scriptDepth: [Infinity, Infinity],
    removeExtraneousParentheses: true,
    mathModeSpace: "",
    locale: l10n.locale ?? "en",
    strings: l10n.strings,
    keybindings: DEFAULT_KEYBINDINGS,
    inlineShortcuts: INLINE_SHORTCUTS,
    inlineShortcutTimeout: 0,
    virtualKeyboardToggleGlyph: DEFAULT_KEYBOARD_TOGGLE_GLYPH,
    virtualKeyboardMode: "auto",
    virtualKeyboards: "all",
    virtualKeyboardLayout: "auto",
    customVirtualKeyboardLayers: {},
    customVirtualKeyboards: {},
    virtualKeyboardTheme: isBrowser() && /android|cros/i.test(navigator.userAgent) ? "material" : "apple",
    keypressVibration: true,
    keypressSound: null,
    plonkSound: null,
    virtualKeyboardToolbar: "default",
    virtualKeyboardContainer: globalThis.document?.body ?? null,
    useSharedVirtualKeyboard: false,
    sharedVirtualKeyboardTargetOrigin: globalThis.window?.origin,
    originValidator: "same-origin",
    textToSpeechRules: "mathlive",
    textToSpeechMarkup: "",
    textToSpeechRulesOptions: {},
    speechEngine: "local",
    speechEngineVoice: "Joanna",
    speechEngineRate: "100%",
    speakHook: defaultSpeakHook,
    readAloudHook: defaultReadAloudHook,
    onAnnounce: defaultAnnounceHook,
    onKeystroke: () => true,
    onMoveOutOf: () => true,
    onTabOutOf: () => true,
    onPlaceholderDidChange: () => {
    },
    onBlur: NO_OP_LISTENER,
    onFocus: NO_OP_LISTENER,
    onContentWillChange: NO_OP_LISTENER,
    onContentDidChange: NO_OP_LISTENER,
    onSelectionWillChange: NO_OP_LISTENER,
    onSelectionDidChange: NO_OP_LISTENER,
    onUndoStateWillChange: NO_OP_LISTENER,
    onUndoStateDidChange: NO_OP_LISTENER,
    onModeChange: NO_OP_LISTENER,
    onReadAloudStatus: NO_OP_LISTENER,
    onCommit: NO_OP_LISTENER,
    onExport: defaultExportHook,
    onError: () => {
    },
    value: ""
  };
}
function effectiveMode(options) {
  if (options.defaultMode === "inline-math")
    return "math";
  return options.defaultMode;
}

// src/editor-mathfield/remote-virtual-keyboard.ts
var POST_MESSAGE_TYPE = "ml#systemPostMessage";
var VirtualKeyboardDelegate = class {
  constructor(options) {
    this.targetOrigin = options.targetOrigin ?? window.origin;
    this.originValidator = options.originValidator ?? "same-origin";
    this._mathfield = options.mathfield;
    this.enable();
  }
  setOptions(_options) {
  }
  create() {
  }
  dispose() {
    this.disable();
  }
  enable() {
    if (!this.enabled) {
      this.enabled = true;
      window.addEventListener("message", this);
    }
  }
  disable() {
    if (this.enabled) {
      window.removeEventListener("message", this);
      this.enabled = false;
    }
  }
  executeCommand(command) {
    if (getCommandTarget(command) === "virtual-keyboard") {
      this.sendMessage("executeCommand", {command});
      return false;
    }
    return this._mathfield?.executeCommand(command);
  }
  focusMathfield() {
  }
  blurMathfield() {
  }
  stateChanged() {
  }
  handleEvent(event) {
    if (event.type === "message" && event.data && event.data.type === POST_MESSAGE_TYPE) {
      if (!validateOrigin(event.origin, this.originValidator)) {
        throw new Error(`Message from unknown origin (${event.origin}) cannot be handled`);
      }
      const {action} = event.data;
      if (action === "executeCommand") {
        this.executeCommand(event.data.command);
      } else if (action === "updateState") {
        this.visible = event.data.state.visible;
        this.height = event.data.state.height;
      } else if (action === "focus") {
        this._mathfield?.focus?.();
      } else if (action === "blur") {
        this._mathfield?.blur?.();
      }
    }
  }
  sendMessage(action, payload = {}) {
    if (window.parent) {
      window.parent.postMessage({
        type: POST_MESSAGE_TYPE,
        action,
        ...payload
      }, this.targetOrigin);
      return true;
    }
    return false;
  }
};
var RemoteVirtualKeyboard = class extends VirtualKeyboard {
  constructor(options) {
    super({
      ...RemoteVirtualKeyboard.defaultOptions,
      ...options ?? {}
    });
    window.addEventListener("message", this);
  }
  static get defaultOptions() {
    return {
      createHTML: (s3) => s3,
      fontsDirectory: "./fonts",
      soundsDirectory: "./sounds",
      targetOrigin: window.origin,
      originValidator: "same-origin",
      virtualKeyboards: "all",
      virtualKeyboardLayout: "auto",
      customVirtualKeyboardLayers: {},
      customVirtualKeyboards: {},
      virtualKeyboardTheme: /macos|ios/.test(osPlatform()) ? "apple" : "material",
      keypressVibration: true,
      keypressSound: null,
      plonkSound: null,
      virtualKeyboardToolbar: "default",
      virtualKeyboardToggleGlyph: DEFAULT_KEYBOARD_TOGGLE_GLYPH,
      virtualKeyboardMode: "auto",
      virtualKeyboardContainer: globalThis.document?.body ?? null
    };
  }
  handleEvent(event) {
    if (event.type === "message" && event.data && event.data.type === POST_MESSAGE_TYPE) {
      if (!validateOrigin(event.origin, this.options.originValidator)) {
        throw new Error(`Can not handle message from unknown origin (${event.origin}).`);
      }
      const {action} = event.data;
      if (action === "executeCommand") {
        const {command} = event.data;
        this.sourceFrame = event.source;
        this.executeCommand(command);
      }
    }
  }
  stateChanged() {
    this.sendMessage("stateChanged", {
      state: {
        visible: this.visible,
        height: this.element?.offsetHeight ?? 0
      }
    });
  }
  executeCommand(command) {
    const commandTarget = getCommandTarget(command);
    if (commandTarget === "virtual-keyboard") {
      return super.executeCommand(command);
    }
    this.sendMessage("executeCommand", {command});
    return false;
  }
  focus() {
    this.sendMessage("focus");
  }
  blur() {
    this.sendMessage("blur");
  }
  canUndo() {
    return this.canUndoState;
  }
  canRedo() {
    return this.canRedoState;
  }
  dispose() {
    window.removeEventListener("message", this);
  }
  sendMessage(action, payload = {}) {
    this.sourceFrame?.postMessage({
      type: POST_MESSAGE_TYPE,
      action,
      ...payload
    }, this.options.targetOrigin);
  }
};

// src/editor-model/utils.ts
function isOffset(value) {
  return typeof value === "number" && !Number.isNaN(value);
}
function isRange(value) {
  return Array.isArray(value) && value.length === 2;
}
function isSelection(value) {
  return value !== void 0 && value !== null && typeof value === "object" && "ranges" in value && Array.isArray(value.ranges);
}

// node_modules/@cortex-js/compute-engine/dist/math-json.min.esm.js
var e = [127462, 127487];
function i(e3) {
  return e3 === 8205 || e3 === 65038 || e3 === 65039 || e3 >= 127995 && e3 <= 128e3 || e3 >= 129456 && e3 <= 129460 || e3 >= 917536 && e3 <= 917632;
}
function t(i3) {
  return i3 >= e[0] && i3 <= e[1];
}
var r = class {
  constructor(e3) {
    this.obeyspaces = false, this.s = function(e4) {
      if (/^[\u0020-\u00FF]*$/.test(e4))
        return e4;
      const r3 = [], n3 = function(e5) {
        const i3 = [];
        for (let t3 = 0; t3 < e5.length; t3++) {
          let r4 = e5.charCodeAt(t3);
          if (r4 >= 55296 && r4 <= 56319) {
            const i4 = e5.charCodeAt(t3 + 1);
            i4 >= 56320 && i4 <= 57343 && (r4 = 65536 + 1024 * (r4 - 55296) + (i4 - 56320), t3++);
          }
          i3.push(r4);
        }
        return i3;
      }(e4);
      let s3 = 0;
      for (; s3 < n3.length; ) {
        const e5 = n3[s3++], a3 = n3[s3];
        if (a3 === 8205) {
          const e6 = s3 - 1;
          for (s3 += 2; n3[s3] === 8205; )
            s3 += 2;
          r3.push(String.fromCodePoint(...n3.slice(e6, 2 * s3 - e6 + 1)));
        } else if (i(a3)) {
          const e6 = s3 - 1;
          for (; i(n3[s3]); )
            s3 += n3[s3] === 8205 ? 2 : 1;
          r3.push(String.fromCodePoint(...n3.slice(e6, 2 * s3 - e6 - 1)));
        } else
          t(e5) ? (s3 += 1, r3.push(String.fromCodePoint(...n3.slice(s3 - 2, 2)))) : r3.push(String.fromCodePoint(e5));
      }
      return r3;
    }(e3), this.pos = 0;
  }
  end() {
    return this.pos >= this.s.length;
  }
  get() {
    return this.pos < this.s.length ? this.s[this.pos++] : "";
  }
  peek() {
    return this.s[this.pos];
  }
  match(e3) {
    let i3;
    return i3 = typeof this.s == "string" ? e3.exec(this.s.slice(this.pos)) : e3.exec(this.s.slice(this.pos).join("")), (i3 == null ? void 0 : i3[0]) ? (this.pos += i3[0].length, i3[0]) : null;
  }
  next() {
    if (this.end())
      return null;
    if (!this.obeyspaces && this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]+/))
      return "<space>";
    if (this.obeyspaces && this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]/))
      return "<space>";
    const e3 = this.get();
    if (e3 === "\\") {
      if (!this.end()) {
        let e4 = this.match(/^[a-zA-Z*]+/);
        if (e4)
          this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]*/);
        else if (e4 = this.get(), e4 === " ")
          return "<space>";
        return "\\" + e4;
      }
    } else {
      if (e3 === "{")
        return "<{>";
      if (e3 === "}")
        return "<}>";
      if (e3 === "^") {
        if (this.peek() === "^") {
          this.get();
          const e4 = this.match(/^(\^(\^(\^(\^[0-9a-f])?[0-9a-f])?[0-9a-f])?[0-9a-f])?[0-9a-f][0-9a-f]/);
          if (e4)
            return String.fromCodePoint(parseInt(e4.slice(e4.lastIndexOf("^") + 1), 16));
        }
        return e3;
      }
      if (e3 === "#") {
        if (!this.end()) {
          let e4 = false;
          if (/[0-9?]/.test(this.peek()) && (e4 = true, this.pos + 1 < this.s.length)) {
            const i3 = this.s[this.pos + 1];
            e4 = /[^0-9A-Za-z]/.test(i3);
          }
          return e4 ? "#" + this.get() : "#";
        }
      } else if (e3 === "$")
        return this.peek() === "$" ? (this.get(), "<$$>") : "<$>";
    }
    return e3;
  }
};
function n(e3, i3) {
  var t3, r3, n3, a3;
  let o3 = [], l3 = e3.next();
  if (l3)
    if (l3 === "\\relax")
      ;
    else if (l3 === "\\noexpand")
      l3 = e3.next(), l3 && o3.push(l3);
    else if (l3 === "\\obeyspaces")
      e3.obeyspaces = true;
    else if (l3 === "\\space" || l3 === "~")
      o3.push("<space>");
    else if (l3 === "\\bgroup")
      o3.push("<{>");
    else if (l3 === "\\egroup")
      o3.push("<}>");
    else if (l3 === "\\string")
      l3 = e3.next(), l3 && (l3[0] === "\\" ? Array.from(l3).forEach((e4) => o3.push(e4 === "\\" ? "\\backslash" : e4)) : l3 === "<{>" ? o3.push("\\{") : l3 === "<space>" ? o3.push("~") : l3 === "<}>" && o3.push("\\}"));
    else if (l3 === "\\csname") {
      for (; e3.peek() === "<space>"; )
        e3.next();
      let n4 = "", a4 = false, u3 = [];
      do {
        if (u3.length === 0)
          if (/^#[0-9?]$/.test(e3.peek())) {
            const n5 = e3.get().slice(1);
            u3 = s((r3 = (t3 = i3 == null ? void 0 : i3[n5]) !== null && t3 !== void 0 ? t3 : i3 == null ? void 0 : i3["?"]) !== null && r3 !== void 0 ? r3 : "\\placeholder{}", i3), l3 = u3[0];
          } else
            l3 = e3.next(), u3 = l3 ? [l3] : [];
        a4 = u3.length === 0, a4 || l3 !== "\\endcsname" || (a4 = true, u3.shift()), a4 || (a4 = l3 === "<$>" || l3 === "<$$>" || l3 === "<{>" || l3 === "<}>" || !!l3 && l3.length > 1 && l3[0] === "\\"), a4 || (n4 += u3.shift());
      } while (!a4);
      n4 && o3.push("\\" + n4), o3 = o3.concat(u3);
    } else if (l3 === "\\endcsname")
      ;
    else if (l3.length > 1 && l3[0] === "#") {
      const e4 = l3.slice(1);
      o3 = o3.concat(s((a3 = (n3 = i3 == null ? void 0 : i3[e4]) !== null && n3 !== void 0 ? n3 : i3 == null ? void 0 : i3["?"]) !== null && a3 !== void 0 ? a3 : "\\placeholder{}", i3));
    } else
      o3.push(l3);
  return o3;
}
function s(e3, i3) {
  const t3 = e3.toString().split(/\r?\n/);
  let s3 = "", a3 = "";
  for (const e4 of t3) {
    s3 += a3, a3 = " ";
    const i4 = e4.match(/((?:\\%)|[^%])*/);
    i4 !== null && (s3 += i4[0]);
  }
  const o3 = new r(s3);
  let l3 = [];
  do {
    l3 = l3.concat(n(o3, i3));
  } while (!o3.end());
  return l3;
}
function a(e3) {
  let i3 = "", t3 = "";
  for (const r3 of e3)
    r3 && (/[a-zA-Z*]/.test(r3[0]) && (t3 += i3), i3 = /\\[a-zA-Z]+\*?$/.test(r3) ? " " : "", t3 += r3);
  return t3;
}
function o(e3) {
  let i3 = [];
  if (Array.isArray(e3))
    for (const t3 of e3)
      Array.isArray(t3) ? i3 = [...i3, ...t3] : i3.push(t3);
  else
    i3 = [e3];
  return a(i3.map((e4) => {
    var i4;
    return (i4 = {"<space>": " ", "<$$>": "$$", "<$>": "$", "<{>": "{", "<}>": "}"}[e4]) !== null && i4 !== void 0 ? i4 : e4;
  }));
}
var l;
var u = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
var c = {exports: {}};
l = c, function(e3) {
  var i3, t3, r3, n3, s3 = 9e15, a3 = 1e9, o3 = "0123456789abcdef", u3 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", c3 = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", h3 = {precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -s3, maxE: s3, crypto: false}, g3 = true, p3 = "[DecimalError] ", f3 = p3 + "Invalid argument: ", m3 = p3 + "Precision limit exceeded", d3 = p3 + "crypto unavailable", v3 = Math.floor, x3 = Math.pow, y3 = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, b3 = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, w3 = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, N3 = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, q3 = 1e7, E3 = u3.length - 1, M25 = c3.length - 1, S4 = {name: "[object Decimal]"};
  function A3(e4) {
    var i4, t4, r4, n4 = e4.length - 1, s4 = "", a4 = e4[0];
    if (n4 > 0) {
      for (s4 += a4, i4 = 1; i4 < n4; i4++)
        (t4 = 7 - (r4 = e4[i4] + "").length) && (s4 += R3(t4)), s4 += r4;
      (t4 = 7 - (r4 = (a4 = e4[i4]) + "").length) && (s4 += R3(t4));
    } else if (a4 === 0)
      return "0";
    for (; a4 % 10 == 0; )
      a4 /= 10;
    return s4 + a4;
  }
  function z3(e4, i4, t4) {
    if (e4 !== ~~e4 || e4 < i4 || e4 > t4)
      throw Error(f3 + e4);
  }
  function k3(e4, i4, t4, r4) {
    var n4, s4, a4, o4;
    for (s4 = e4[0]; s4 >= 10; s4 /= 10)
      --i4;
    return --i4 < 0 ? (i4 += 7, n4 = 0) : (n4 = Math.ceil((i4 + 1) / 7), i4 %= 7), s4 = x3(10, 7 - i4), o4 = e4[n4] % s4 | 0, r4 == null ? i4 < 3 ? (i4 == 0 ? o4 = o4 / 100 | 0 : i4 == 1 && (o4 = o4 / 10 | 0), a4 = t4 < 4 && o4 == 99999 || t4 > 3 && o4 == 49999 || o4 == 5e4 || o4 == 0) : a4 = (t4 < 4 && o4 + 1 == s4 || t4 > 3 && o4 + 1 == s4 / 2) && (e4[n4 + 1] / s4 / 100 | 0) == x3(10, i4 - 2) - 1 || (o4 == s4 / 2 || o4 == 0) && (e4[n4 + 1] / s4 / 100 | 0) == 0 : i4 < 4 ? (i4 == 0 ? o4 = o4 / 1e3 | 0 : i4 == 1 ? o4 = o4 / 100 | 0 : i4 == 2 && (o4 = o4 / 10 | 0), a4 = (r4 || t4 < 4) && o4 == 9999 || !r4 && t4 > 3 && o4 == 4999) : a4 = ((r4 || t4 < 4) && o4 + 1 == s4 || !r4 && t4 > 3 && o4 + 1 == s4 / 2) && (e4[n4 + 1] / s4 / 1e3 | 0) == x3(10, i4 - 3) - 1, a4;
  }
  function I3(e4, i4, t4) {
    for (var r4, n4, s4 = [0], a4 = 0, l3 = e4.length; a4 < l3; ) {
      for (n4 = s4.length; n4--; )
        s4[n4] *= i4;
      for (s4[0] += o3.indexOf(e4.charAt(a4++)), r4 = 0; r4 < s4.length; r4++)
        s4[r4] > t4 - 1 && (s4[r4 + 1] === void 0 && (s4[r4 + 1] = 0), s4[r4 + 1] += s4[r4] / t4 | 0, s4[r4] %= t4);
    }
    return s4.reverse();
  }
  S4.absoluteValue = S4.abs = function() {
    var e4 = new this.constructor(this);
    return e4.s < 0 && (e4.s = 1), L3(e4);
  }, S4.ceil = function() {
    return L3(new this.constructor(this), this.e + 1, 2);
  }, S4.comparedTo = S4.cmp = function(e4) {
    var i4, t4, r4, n4, s4 = this, a4 = s4.d, o4 = (e4 = new s4.constructor(e4)).d, l3 = s4.s, u4 = e4.s;
    if (!a4 || !o4)
      return l3 && u4 ? l3 !== u4 ? l3 : a4 === o4 ? 0 : !a4 ^ l3 < 0 ? 1 : -1 : NaN;
    if (!a4[0] || !o4[0])
      return a4[0] ? l3 : o4[0] ? -u4 : 0;
    if (l3 !== u4)
      return l3;
    if (s4.e !== e4.e)
      return s4.e > e4.e ^ l3 < 0 ? 1 : -1;
    for (i4 = 0, t4 = (r4 = a4.length) < (n4 = o4.length) ? r4 : n4; i4 < t4; ++i4)
      if (a4[i4] !== o4[i4])
        return a4[i4] > o4[i4] ^ l3 < 0 ? 1 : -1;
    return r4 === n4 ? 0 : r4 > n4 ^ l3 < 0 ? 1 : -1;
  }, S4.cosine = S4.cos = function() {
    var e4, i4, t4 = this, r4 = t4.constructor;
    return t4.d ? t4.d[0] ? (e4 = r4.precision, i4 = r4.rounding, r4.precision = e4 + Math.max(t4.e, t4.sd()) + 7, r4.rounding = 1, t4 = function(e5, i5) {
      var t5, r5, n4 = i5.d.length;
      n4 < 32 ? r5 = (1 / V3(4, t5 = Math.ceil(n4 / 3))).toString() : (t5 = 16, r5 = "2.3283064365386962890625e-10"), e5.precision += t5, i5 = W3(e5, 1, i5.times(r5), new e5(1));
      for (var s4 = t5; s4--; ) {
        var a4 = i5.times(i5);
        i5 = a4.times(a4).minus(a4).times(8).plus(1);
      }
      return e5.precision -= t5, i5;
    }(r4, Q3(r4, t4)), r4.precision = e4, r4.rounding = i4, L3(n3 == 2 || n3 == 3 ? t4.neg() : t4, e4, i4, true)) : new r4(1) : new r4(NaN);
  }, S4.cubeRoot = S4.cbrt = function() {
    var e4, i4, t4, r4, n4, s4, a4, o4, l3, u4, c4 = this, h4 = c4.constructor;
    if (!c4.isFinite() || c4.isZero())
      return new h4(c4);
    for (g3 = false, (s4 = c4.s * x3(c4.s * c4, 1 / 3)) && Math.abs(s4) != 1 / 0 ? r4 = new h4(s4.toString()) : (t4 = A3(c4.d), (s4 = ((e4 = c4.e) - t4.length + 1) % 3) && (t4 += s4 == 1 || s4 == -2 ? "0" : "00"), s4 = x3(t4, 1 / 3), e4 = v3((e4 + 1) / 3) - (e4 % 3 == (e4 < 0 ? -1 : 2)), (r4 = new h4(t4 = s4 == 1 / 0 ? "5e" + e4 : (t4 = s4.toExponential()).slice(0, t4.indexOf("e") + 1) + e4)).s = c4.s), a4 = (e4 = h4.precision) + 3; ; )
      if (u4 = (l3 = (o4 = r4).times(o4).times(o4)).plus(c4), r4 = O3(u4.plus(c4).times(o4), u4.plus(l3), a4 + 2, 1), A3(o4.d).slice(0, a4) === (t4 = A3(r4.d)).slice(0, a4)) {
        if ((t4 = t4.slice(a4 - 3, a4 + 1)) != "9999" && (n4 || t4 != "4999")) {
          +t4 && (+t4.slice(1) || t4.charAt(0) != "5") || (L3(r4, e4 + 1, 1), i4 = !r4.times(r4).times(r4).eq(c4));
          break;
        }
        if (!n4 && (L3(o4, e4 + 1, 0), o4.times(o4).times(o4).eq(c4))) {
          r4 = o4;
          break;
        }
        a4 += 4, n4 = 1;
      }
    return g3 = true, L3(r4, e4, h4.rounding, i4);
  }, S4.decimalPlaces = S4.dp = function() {
    var e4, i4 = this.d, t4 = NaN;
    if (i4) {
      if (t4 = 7 * ((e4 = i4.length - 1) - v3(this.e / 7)), e4 = i4[e4])
        for (; e4 % 10 == 0; e4 /= 10)
          t4--;
      t4 < 0 && (t4 = 0);
    }
    return t4;
  }, S4.dividedBy = S4.div = function(e4) {
    return O3(this, new this.constructor(e4));
  }, S4.dividedToIntegerBy = S4.divToInt = function(e4) {
    var i4 = this.constructor;
    return L3(O3(this, new i4(e4), 0, 1, 1), i4.precision, i4.rounding);
  }, S4.equals = S4.eq = function(e4) {
    return this.cmp(e4) === 0;
  }, S4.floor = function() {
    return L3(new this.constructor(this), this.e + 1, 3);
  }, S4.greaterThan = S4.gt = function(e4) {
    return this.cmp(e4) > 0;
  }, S4.greaterThanOrEqualTo = S4.gte = function(e4) {
    var i4 = this.cmp(e4);
    return i4 == 1 || i4 === 0;
  }, S4.hyperbolicCosine = S4.cosh = function() {
    var e4, i4, t4, r4, n4, s4 = this, a4 = s4.constructor, o4 = new a4(1);
    if (!s4.isFinite())
      return new a4(s4.s ? 1 / 0 : NaN);
    if (s4.isZero())
      return o4;
    t4 = a4.precision, r4 = a4.rounding, a4.precision = t4 + Math.max(s4.e, s4.sd()) + 4, a4.rounding = 1, (n4 = s4.d.length) < 32 ? i4 = (1 / V3(4, e4 = Math.ceil(n4 / 3))).toString() : (e4 = 16, i4 = "2.3283064365386962890625e-10"), s4 = W3(a4, 1, s4.times(i4), new a4(1), true);
    for (var l3, u4 = e4, c4 = new a4(8); u4--; )
      l3 = s4.times(s4), s4 = o4.minus(l3.times(c4.minus(l3.times(c4))));
    return L3(s4, a4.precision = t4, a4.rounding = r4, true);
  }, S4.hyperbolicSine = S4.sinh = function() {
    var e4, i4, t4, r4, n4 = this, s4 = n4.constructor;
    if (!n4.isFinite() || n4.isZero())
      return new s4(n4);
    if (i4 = s4.precision, t4 = s4.rounding, s4.precision = i4 + Math.max(n4.e, n4.sd()) + 4, s4.rounding = 1, (r4 = n4.d.length) < 3)
      n4 = W3(s4, 2, n4, n4, true);
    else {
      e4 = (e4 = 1.4 * Math.sqrt(r4)) > 16 ? 16 : 0 | e4, n4 = W3(s4, 2, n4 = n4.times(1 / V3(5, e4)), n4, true);
      for (var a4, o4 = new s4(5), l3 = new s4(16), u4 = new s4(20); e4--; )
        a4 = n4.times(n4), n4 = n4.times(o4.plus(a4.times(l3.times(a4).plus(u4))));
    }
    return s4.precision = i4, s4.rounding = t4, L3(n4, i4, t4, true);
  }, S4.hyperbolicTangent = S4.tanh = function() {
    var e4, i4, t4 = this, r4 = t4.constructor;
    return t4.isFinite() ? t4.isZero() ? new r4(t4) : (e4 = r4.precision, i4 = r4.rounding, r4.precision = e4 + 7, r4.rounding = 1, O3(t4.sinh(), t4.cosh(), r4.precision = e4, r4.rounding = i4)) : new r4(t4.s);
  }, S4.inverseCosine = S4.acos = function() {
    var e4, i4 = this, t4 = i4.constructor, r4 = i4.abs().cmp(1), n4 = t4.precision, s4 = t4.rounding;
    return r4 !== -1 ? r4 === 0 ? i4.isNeg() ? T4(t4, n4, s4) : new t4(0) : new t4(NaN) : i4.isZero() ? T4(t4, n4 + 4, s4).times(0.5) : (t4.precision = n4 + 6, t4.rounding = 1, i4 = i4.asin(), e4 = T4(t4, n4 + 4, s4).times(0.5), t4.precision = n4, t4.rounding = s4, e4.minus(i4));
  }, S4.inverseHyperbolicCosine = S4.acosh = function() {
    var e4, i4, t4 = this, r4 = t4.constructor;
    return t4.lte(1) ? new r4(t4.eq(1) ? 0 : NaN) : t4.isFinite() ? (e4 = r4.precision, i4 = r4.rounding, r4.precision = e4 + Math.max(Math.abs(t4.e), t4.sd()) + 4, r4.rounding = 1, g3 = false, t4 = t4.times(t4).minus(1).sqrt().plus(t4), g3 = true, r4.precision = e4, r4.rounding = i4, t4.ln()) : new r4(t4);
  }, S4.inverseHyperbolicSine = S4.asinh = function() {
    var e4, i4, t4 = this, r4 = t4.constructor;
    return !t4.isFinite() || t4.isZero() ? new r4(t4) : (e4 = r4.precision, i4 = r4.rounding, r4.precision = e4 + 2 * Math.max(Math.abs(t4.e), t4.sd()) + 6, r4.rounding = 1, g3 = false, t4 = t4.times(t4).plus(1).sqrt().plus(t4), g3 = true, r4.precision = e4, r4.rounding = i4, t4.ln());
  }, S4.inverseHyperbolicTangent = S4.atanh = function() {
    var e4, i4, t4, r4, n4 = this, s4 = n4.constructor;
    return n4.isFinite() ? n4.e >= 0 ? new s4(n4.abs().eq(1) ? n4.s / 0 : n4.isZero() ? n4 : NaN) : (e4 = s4.precision, i4 = s4.rounding, r4 = n4.sd(), Math.max(r4, e4) < 2 * -n4.e - 1 ? L3(new s4(n4), e4, i4, true) : (s4.precision = t4 = r4 - n4.e, n4 = O3(n4.plus(1), new s4(1).minus(n4), t4 + e4, 1), s4.precision = e4 + 4, s4.rounding = 1, n4 = n4.ln(), s4.precision = e4, s4.rounding = i4, n4.times(0.5))) : new s4(NaN);
  }, S4.inverseSine = S4.asin = function() {
    var e4, i4, t4, r4, n4 = this, s4 = n4.constructor;
    return n4.isZero() ? new s4(n4) : (i4 = n4.abs().cmp(1), t4 = s4.precision, r4 = s4.rounding, i4 !== -1 ? i4 === 0 ? ((e4 = T4(s4, t4 + 4, r4).times(0.5)).s = n4.s, e4) : new s4(NaN) : (s4.precision = t4 + 6, s4.rounding = 1, n4 = n4.div(new s4(1).minus(n4.times(n4)).sqrt().plus(1)).atan(), s4.precision = t4, s4.rounding = r4, n4.times(2)));
  }, S4.inverseTangent = S4.atan = function() {
    var e4, i4, t4, r4, n4, s4, a4, o4, l3, u4 = this, c4 = u4.constructor, h4 = c4.precision, p4 = c4.rounding;
    if (u4.isFinite()) {
      if (u4.isZero())
        return new c4(u4);
      if (u4.abs().eq(1) && h4 + 4 <= M25)
        return (a4 = T4(c4, h4 + 4, p4).times(0.25)).s = u4.s, a4;
    } else {
      if (!u4.s)
        return new c4(NaN);
      if (h4 + 4 <= M25)
        return (a4 = T4(c4, h4 + 4, p4).times(0.5)).s = u4.s, a4;
    }
    for (c4.precision = o4 = h4 + 10, c4.rounding = 1, e4 = t4 = Math.min(28, o4 / 7 + 2 | 0); e4; --e4)
      u4 = u4.div(u4.times(u4).plus(1).sqrt().plus(1));
    for (g3 = false, i4 = Math.ceil(o4 / 7), r4 = 1, l3 = u4.times(u4), a4 = new c4(u4), n4 = u4; e4 !== -1; )
      if (n4 = n4.times(l3), s4 = a4.minus(n4.div(r4 += 2)), n4 = n4.times(l3), (a4 = s4.plus(n4.div(r4 += 2))).d[i4] !== void 0)
        for (e4 = i4; a4.d[e4] === s4.d[e4] && e4--; )
          ;
    return t4 && (a4 = a4.times(2 << t4 - 1)), g3 = true, L3(a4, c4.precision = h4, c4.rounding = p4, true);
  }, S4.isFinite = function() {
    return !!this.d;
  }, S4.isInteger = S4.isInt = function() {
    return !!this.d && v3(this.e / 7) > this.d.length - 2;
  }, S4.isNaN = function() {
    return !this.s;
  }, S4.isNegative = S4.isNeg = function() {
    return this.s < 0;
  }, S4.isPositive = S4.isPos = function() {
    return this.s > 0;
  }, S4.isZero = function() {
    return !!this.d && this.d[0] === 0;
  }, S4.lessThan = S4.lt = function(e4) {
    return this.cmp(e4) < 0;
  }, S4.lessThanOrEqualTo = S4.lte = function(e4) {
    return this.cmp(e4) < 1;
  }, S4.logarithm = S4.log = function(e4) {
    var i4, t4, r4, n4, s4, a4, o4, l3, u4 = this, c4 = u4.constructor, h4 = c4.precision, p4 = c4.rounding;
    if (e4 == null)
      e4 = new c4(10), i4 = true;
    else {
      if (t4 = (e4 = new c4(e4)).d, e4.s < 0 || !t4 || !t4[0] || e4.eq(1))
        return new c4(NaN);
      i4 = e4.eq(10);
    }
    if (t4 = u4.d, u4.s < 0 || !t4 || !t4[0] || u4.eq(1))
      return new c4(t4 && !t4[0] ? -1 / 0 : u4.s != 1 ? NaN : t4 ? 0 : 1 / 0);
    if (i4)
      if (t4.length > 1)
        s4 = true;
      else {
        for (n4 = t4[0]; n4 % 10 == 0; )
          n4 /= 10;
        s4 = n4 !== 1;
      }
    if (g3 = false, a4 = U2(u4, o4 = h4 + 5), r4 = i4 ? F3(c4, o4 + 10) : U2(e4, o4), k3((l3 = O3(a4, r4, o4, 1)).d, n4 = h4, p4))
      do {
        if (a4 = U2(u4, o4 += 10), r4 = i4 ? F3(c4, o4 + 10) : U2(e4, o4), l3 = O3(a4, r4, o4, 1), !s4) {
          +A3(l3.d).slice(n4 + 1, n4 + 15) + 1 == 1e14 && (l3 = L3(l3, h4 + 1, 0));
          break;
        }
      } while (k3(l3.d, n4 += 10, p4));
    return g3 = true, L3(l3, h4, p4);
  }, S4.minus = S4.sub = function(e4) {
    var i4, t4, r4, n4, s4, a4, o4, l3, u4, c4, h4, p4, f4 = this, m4 = f4.constructor;
    if (e4 = new m4(e4), !f4.d || !e4.d)
      return f4.s && e4.s ? f4.d ? e4.s = -e4.s : e4 = new m4(e4.d || f4.s !== e4.s ? f4 : NaN) : e4 = new m4(NaN), e4;
    if (f4.s != e4.s)
      return e4.s = -e4.s, f4.plus(e4);
    if (u4 = f4.d, p4 = e4.d, o4 = m4.precision, l3 = m4.rounding, !u4[0] || !p4[0]) {
      if (p4[0])
        e4.s = -e4.s;
      else {
        if (!u4[0])
          return new m4(l3 === 3 ? -0 : 0);
        e4 = new m4(f4);
      }
      return g3 ? L3(e4, o4, l3) : e4;
    }
    if (t4 = v3(e4.e / 7), c4 = v3(f4.e / 7), u4 = u4.slice(), s4 = c4 - t4) {
      for ((h4 = s4 < 0) ? (i4 = u4, s4 = -s4, a4 = p4.length) : (i4 = p4, t4 = c4, a4 = u4.length), s4 > (r4 = Math.max(Math.ceil(o4 / 7), a4) + 2) && (s4 = r4, i4.length = 1), i4.reverse(), r4 = s4; r4--; )
        i4.push(0);
      i4.reverse();
    } else {
      for ((h4 = (r4 = u4.length) < (a4 = p4.length)) && (a4 = r4), r4 = 0; r4 < a4; r4++)
        if (u4[r4] != p4[r4]) {
          h4 = u4[r4] < p4[r4];
          break;
        }
      s4 = 0;
    }
    for (h4 && (i4 = u4, u4 = p4, p4 = i4, e4.s = -e4.s), a4 = u4.length, r4 = p4.length - a4; r4 > 0; --r4)
      u4[a4++] = 0;
    for (r4 = p4.length; r4 > s4; ) {
      if (u4[--r4] < p4[r4]) {
        for (n4 = r4; n4 && u4[--n4] === 0; )
          u4[n4] = q3 - 1;
        --u4[n4], u4[r4] += q3;
      }
      u4[r4] -= p4[r4];
    }
    for (; u4[--a4] === 0; )
      u4.pop();
    for (; u4[0] === 0; u4.shift())
      --t4;
    return u4[0] ? (e4.d = u4, e4.e = D4(u4, t4), g3 ? L3(e4, o4, l3) : e4) : new m4(l3 === 3 ? -0 : 0);
  }, S4.modulo = S4.mod = function(e4) {
    var i4, t4 = this, r4 = t4.constructor;
    return e4 = new r4(e4), !t4.d || !e4.s || e4.d && !e4.d[0] ? new r4(NaN) : !e4.d || t4.d && !t4.d[0] ? L3(new r4(t4), r4.precision, r4.rounding) : (g3 = false, r4.modulo == 9 ? (i4 = O3(t4, e4.abs(), 0, 3, 1)).s *= e4.s : i4 = O3(t4, e4, 0, r4.modulo, 1), i4 = i4.times(e4), g3 = true, t4.minus(i4));
  }, S4.naturalExponential = S4.exp = function() {
    return _3(this);
  }, S4.naturalLogarithm = S4.ln = function() {
    return U2(this);
  }, S4.negated = S4.neg = function() {
    var e4 = new this.constructor(this);
    return e4.s = -e4.s, L3(e4);
  }, S4.plus = S4.add = function(e4) {
    var i4, t4, r4, n4, s4, a4, o4, l3, u4, c4, h4 = this, p4 = h4.constructor;
    if (e4 = new p4(e4), !h4.d || !e4.d)
      return h4.s && e4.s ? h4.d || (e4 = new p4(e4.d || h4.s === e4.s ? h4 : NaN)) : e4 = new p4(NaN), e4;
    if (h4.s != e4.s)
      return e4.s = -e4.s, h4.minus(e4);
    if (u4 = h4.d, c4 = e4.d, o4 = p4.precision, l3 = p4.rounding, !u4[0] || !c4[0])
      return c4[0] || (e4 = new p4(h4)), g3 ? L3(e4, o4, l3) : e4;
    if (s4 = v3(h4.e / 7), r4 = v3(e4.e / 7), u4 = u4.slice(), n4 = s4 - r4) {
      for (n4 < 0 ? (t4 = u4, n4 = -n4, a4 = c4.length) : (t4 = c4, r4 = s4, a4 = u4.length), n4 > (a4 = (s4 = Math.ceil(o4 / 7)) > a4 ? s4 + 1 : a4 + 1) && (n4 = a4, t4.length = 1), t4.reverse(); n4--; )
        t4.push(0);
      t4.reverse();
    }
    for ((a4 = u4.length) - (n4 = c4.length) < 0 && (n4 = a4, t4 = c4, c4 = u4, u4 = t4), i4 = 0; n4; )
      i4 = (u4[--n4] = u4[n4] + c4[n4] + i4) / q3 | 0, u4[n4] %= q3;
    for (i4 && (u4.unshift(i4), ++r4), a4 = u4.length; u4[--a4] == 0; )
      u4.pop();
    return e4.d = u4, e4.e = D4(u4, r4), g3 ? L3(e4, o4, l3) : e4;
  }, S4.precision = S4.sd = function(e4) {
    var i4, t4 = this;
    if (e4 !== void 0 && e4 !== !!e4 && e4 !== 1 && e4 !== 0)
      throw Error(f3 + e4);
    return t4.d ? (i4 = C3(t4.d), e4 && t4.e + 1 > i4 && (i4 = t4.e + 1)) : i4 = NaN, i4;
  }, S4.round = function() {
    var e4 = this, i4 = e4.constructor;
    return L3(new i4(e4), e4.e + 1, i4.rounding);
  }, S4.sine = S4.sin = function() {
    var e4, i4, t4 = this, r4 = t4.constructor;
    return t4.isFinite() ? t4.isZero() ? new r4(t4) : (e4 = r4.precision, i4 = r4.rounding, r4.precision = e4 + Math.max(t4.e, t4.sd()) + 7, r4.rounding = 1, t4 = function(e5, i5) {
      var t5, r5 = i5.d.length;
      if (r5 < 3)
        return W3(e5, 2, i5, i5);
      t5 = (t5 = 1.4 * Math.sqrt(r5)) > 16 ? 16 : 0 | t5, i5 = W3(e5, 2, i5 = i5.times(1 / V3(5, t5)), i5);
      for (var n4, s4 = new e5(5), a4 = new e5(16), o4 = new e5(20); t5--; )
        n4 = i5.times(i5), i5 = i5.times(s4.plus(n4.times(a4.times(n4).minus(o4))));
      return i5;
    }(r4, Q3(r4, t4)), r4.precision = e4, r4.rounding = i4, L3(n3 > 2 ? t4.neg() : t4, e4, i4, true)) : new r4(NaN);
  }, S4.squareRoot = S4.sqrt = function() {
    var e4, i4, t4, r4, n4, s4, a4 = this, o4 = a4.d, l3 = a4.e, u4 = a4.s, c4 = a4.constructor;
    if (u4 !== 1 || !o4 || !o4[0])
      return new c4(!u4 || u4 < 0 && (!o4 || o4[0]) ? NaN : o4 ? a4 : 1 / 0);
    for (g3 = false, (u4 = Math.sqrt(+a4)) == 0 || u4 == 1 / 0 ? (((i4 = A3(o4)).length + l3) % 2 == 0 && (i4 += "0"), u4 = Math.sqrt(i4), l3 = v3((l3 + 1) / 2) - (l3 < 0 || l3 % 2), r4 = new c4(i4 = u4 == 1 / 0 ? "5e" + l3 : (i4 = u4.toExponential()).slice(0, i4.indexOf("e") + 1) + l3)) : r4 = new c4(u4.toString()), t4 = (l3 = c4.precision) + 3; ; )
      if (r4 = (s4 = r4).plus(O3(a4, s4, t4 + 2, 1)).times(0.5), A3(s4.d).slice(0, t4) === (i4 = A3(r4.d)).slice(0, t4)) {
        if ((i4 = i4.slice(t4 - 3, t4 + 1)) != "9999" && (n4 || i4 != "4999")) {
          +i4 && (+i4.slice(1) || i4.charAt(0) != "5") || (L3(r4, l3 + 1, 1), e4 = !r4.times(r4).eq(a4));
          break;
        }
        if (!n4 && (L3(s4, l3 + 1, 0), s4.times(s4).eq(a4))) {
          r4 = s4;
          break;
        }
        t4 += 4, n4 = 1;
      }
    return g3 = true, L3(r4, l3, c4.rounding, e4);
  }, S4.tangent = S4.tan = function() {
    var e4, i4, t4 = this, r4 = t4.constructor;
    return t4.isFinite() ? t4.isZero() ? new r4(t4) : (e4 = r4.precision, i4 = r4.rounding, r4.precision = e4 + 10, r4.rounding = 1, (t4 = t4.sin()).s = 1, t4 = O3(t4, new r4(1).minus(t4.times(t4)).sqrt(), e4 + 10, 0), r4.precision = e4, r4.rounding = i4, L3(n3 == 2 || n3 == 4 ? t4.neg() : t4, e4, i4, true)) : new r4(NaN);
  }, S4.times = S4.mul = function(e4) {
    var i4, t4, r4, n4, s4, a4, o4, l3, u4, c4 = this, h4 = c4.constructor, p4 = c4.d, f4 = (e4 = new h4(e4)).d;
    if (e4.s *= c4.s, !(p4 && p4[0] && f4 && f4[0]))
      return new h4(!e4.s || p4 && !p4[0] && !f4 || f4 && !f4[0] && !p4 ? NaN : p4 && f4 ? 0 * e4.s : e4.s / 0);
    for (t4 = v3(c4.e / 7) + v3(e4.e / 7), (l3 = p4.length) < (u4 = f4.length) && (s4 = p4, p4 = f4, f4 = s4, a4 = l3, l3 = u4, u4 = a4), s4 = [], r4 = a4 = l3 + u4; r4--; )
      s4.push(0);
    for (r4 = u4; --r4 >= 0; ) {
      for (i4 = 0, n4 = l3 + r4; n4 > r4; )
        o4 = s4[n4] + f4[r4] * p4[n4 - r4 - 1] + i4, s4[n4--] = o4 % q3 | 0, i4 = o4 / q3 | 0;
      s4[n4] = (s4[n4] + i4) % q3 | 0;
    }
    for (; !s4[--a4]; )
      s4.pop();
    return i4 ? ++t4 : s4.shift(), e4.d = s4, e4.e = D4(s4, t4), g3 ? L3(e4, h4.precision, h4.rounding) : e4;
  }, S4.toBinary = function(e4, i4) {
    return Y3(this, 2, e4, i4);
  }, S4.toDecimalPlaces = S4.toDP = function(e4, i4) {
    var t4 = this, r4 = t4.constructor;
    return t4 = new r4(t4), e4 === void 0 ? t4 : (z3(e4, 0, a3), i4 === void 0 ? i4 = r4.rounding : z3(i4, 0, 8), L3(t4, e4 + t4.e + 1, i4));
  }, S4.toExponential = function(e4, i4) {
    var t4, r4 = this, n4 = r4.constructor;
    return e4 === void 0 ? t4 = P3(r4, true) : (z3(e4, 0, a3), i4 === void 0 ? i4 = n4.rounding : z3(i4, 0, 8), t4 = P3(r4 = L3(new n4(r4), e4 + 1, i4), true, e4 + 1)), r4.isNeg() && !r4.isZero() ? "-" + t4 : t4;
  }, S4.toFixed = function(e4, i4) {
    var t4, r4, n4 = this, s4 = n4.constructor;
    return e4 === void 0 ? t4 = P3(n4) : (z3(e4, 0, a3), i4 === void 0 ? i4 = s4.rounding : z3(i4, 0, 8), t4 = P3(r4 = L3(new s4(n4), e4 + n4.e + 1, i4), false, e4 + r4.e + 1)), n4.isNeg() && !n4.isZero() ? "-" + t4 : t4;
  }, S4.toFraction = function(e4) {
    var i4, t4, r4, n4, s4, a4, o4, l3, u4, c4, h4, p4, m4 = this, d4 = m4.d, v4 = m4.constructor;
    if (!d4)
      return new v4(m4);
    if (u4 = t4 = new v4(1), r4 = l3 = new v4(0), a4 = (s4 = (i4 = new v4(r4)).e = C3(d4) - m4.e - 1) % 7, i4.d[0] = x3(10, a4 < 0 ? 7 + a4 : a4), e4 == null)
      e4 = s4 > 0 ? i4 : u4;
    else {
      if (!(o4 = new v4(e4)).isInt() || o4.lt(u4))
        throw Error(f3 + o4);
      e4 = o4.gt(i4) ? s4 > 0 ? i4 : u4 : o4;
    }
    for (g3 = false, o4 = new v4(A3(d4)), c4 = v4.precision, v4.precision = s4 = 7 * d4.length * 2; h4 = O3(o4, i4, 0, 1, 1), (n4 = t4.plus(h4.times(r4))).cmp(e4) != 1; )
      t4 = r4, r4 = n4, n4 = u4, u4 = l3.plus(h4.times(n4)), l3 = n4, n4 = i4, i4 = o4.minus(h4.times(n4)), o4 = n4;
    return n4 = O3(e4.minus(t4), r4, 0, 1, 1), l3 = l3.plus(n4.times(u4)), t4 = t4.plus(n4.times(r4)), l3.s = u4.s = m4.s, p4 = O3(u4, r4, s4, 1).minus(m4).abs().cmp(O3(l3, t4, s4, 1).minus(m4).abs()) < 1 ? [u4, r4] : [l3, t4], v4.precision = c4, g3 = true, p4;
  }, S4.toHexadecimal = S4.toHex = function(e4, i4) {
    return Y3(this, 16, e4, i4);
  }, S4.toNearest = function(e4, i4) {
    var t4 = this, r4 = t4.constructor;
    if (t4 = new r4(t4), e4 == null) {
      if (!t4.d)
        return t4;
      e4 = new r4(1), i4 = r4.rounding;
    } else {
      if (e4 = new r4(e4), i4 === void 0 ? i4 = r4.rounding : z3(i4, 0, 8), !t4.d)
        return e4.s ? t4 : e4;
      if (!e4.d)
        return e4.s && (e4.s = t4.s), e4;
    }
    return e4.d[0] ? (g3 = false, t4 = O3(t4, e4, 0, i4, 1).times(e4), g3 = true, L3(t4)) : (e4.s = t4.s, t4 = e4), t4;
  }, S4.toNumber = function() {
    return +this;
  }, S4.toOctal = function(e4, i4) {
    return Y3(this, 8, e4, i4);
  }, S4.toPower = S4.pow = function(e4) {
    var i4, t4, r4, n4, s4, a4, o4 = this, l3 = o4.constructor, u4 = +(e4 = new l3(e4));
    if (!(o4.d && e4.d && o4.d[0] && e4.d[0]))
      return new l3(x3(+o4, u4));
    if ((o4 = new l3(o4)).eq(1))
      return o4;
    if (r4 = l3.precision, s4 = l3.rounding, e4.eq(1))
      return L3(o4, r4, s4);
    if ((i4 = v3(e4.e / 7)) >= e4.d.length - 1 && (t4 = u4 < 0 ? -u4 : u4) <= 9007199254740991)
      return n4 = $3(l3, o4, t4, r4), e4.s < 0 ? new l3(1).div(n4) : L3(n4, r4, s4);
    if ((a4 = o4.s) < 0) {
      if (i4 < e4.d.length - 1)
        return new l3(NaN);
      if ((1 & e4.d[i4]) == 0 && (a4 = 1), o4.e == 0 && o4.d[0] == 1 && o4.d.length == 1)
        return o4.s = a4, o4;
    }
    return (i4 = (t4 = x3(+o4, u4)) != 0 && isFinite(t4) ? new l3(t4 + "").e : v3(u4 * (Math.log("0." + A3(o4.d)) / Math.LN10 + o4.e + 1))) > l3.maxE + 1 || i4 < l3.minE - 1 ? new l3(i4 > 0 ? a4 / 0 : 0) : (g3 = false, l3.rounding = o4.s = 1, t4 = Math.min(12, (i4 + "").length), (n4 = _3(e4.times(U2(o4, r4 + t4)), r4)).d && k3((n4 = L3(n4, r4 + 5, 1)).d, r4, s4) && (i4 = r4 + 10, +A3((n4 = L3(_3(e4.times(U2(o4, i4 + t4)), i4), i4 + 5, 1)).d).slice(r4 + 1, r4 + 15) + 1 == 1e14 && (n4 = L3(n4, r4 + 1, 0))), n4.s = a4, g3 = true, l3.rounding = s4, L3(n4, r4, s4));
  }, S4.toPrecision = function(e4, i4) {
    var t4, r4 = this, n4 = r4.constructor;
    return e4 === void 0 ? t4 = P3(r4, r4.e <= n4.toExpNeg || r4.e >= n4.toExpPos) : (z3(e4, 1, a3), i4 === void 0 ? i4 = n4.rounding : z3(i4, 0, 8), t4 = P3(r4 = L3(new n4(r4), e4, i4), e4 <= r4.e || r4.e <= n4.toExpNeg, e4)), r4.isNeg() && !r4.isZero() ? "-" + t4 : t4;
  }, S4.toSignificantDigits = S4.toSD = function(e4, i4) {
    var t4 = this.constructor;
    return e4 === void 0 ? (e4 = t4.precision, i4 = t4.rounding) : (z3(e4, 1, a3), i4 === void 0 ? i4 = t4.rounding : z3(i4, 0, 8)), L3(new t4(this), e4, i4);
  }, S4.toString = function() {
    var e4 = this, i4 = e4.constructor, t4 = P3(e4, e4.e <= i4.toExpNeg || e4.e >= i4.toExpPos);
    return e4.isNeg() && !e4.isZero() ? "-" + t4 : t4;
  }, S4.truncated = S4.trunc = function() {
    return L3(new this.constructor(this), this.e + 1, 1);
  }, S4.valueOf = S4.toJSON = function() {
    var e4 = this, i4 = e4.constructor, t4 = P3(e4, e4.e <= i4.toExpNeg || e4.e >= i4.toExpPos);
    return e4.isNeg() ? "-" + t4 : t4;
  };
  var O3 = function() {
    function e4(e5, i5, t4) {
      var r5, n4 = 0, s4 = e5.length;
      for (e5 = e5.slice(); s4--; )
        r5 = e5[s4] * i5 + n4, e5[s4] = r5 % t4 | 0, n4 = r5 / t4 | 0;
      return n4 && e5.unshift(n4), e5;
    }
    function i4(e5, i5, t4, r5) {
      var n4, s4;
      if (t4 != r5)
        s4 = t4 > r5 ? 1 : -1;
      else
        for (n4 = s4 = 0; n4 < t4; n4++)
          if (e5[n4] != i5[n4]) {
            s4 = e5[n4] > i5[n4] ? 1 : -1;
            break;
          }
      return s4;
    }
    function r4(e5, i5, t4, r5) {
      for (var n4 = 0; t4--; )
        e5[t4] -= n4, n4 = e5[t4] < i5[t4] ? 1 : 0, e5[t4] = n4 * r5 + e5[t4] - i5[t4];
      for (; !e5[0] && e5.length > 1; )
        e5.shift();
    }
    return function(n4, s4, a4, o4, l3, u4) {
      var c4, h4, g4, p4, f4, m4, d4, x4, y4, b4, w4, N4, E4, M26, S5, A4, z4, k4, I4, O4, P4 = n4.constructor, D5 = n4.s == s4.s ? 1 : -1, F4 = n4.d, T5 = s4.d;
      if (!(F4 && F4[0] && T5 && T5[0]))
        return new P4(n4.s && s4.s && (F4 ? !T5 || F4[0] != T5[0] : T5) ? F4 && F4[0] == 0 || !T5 ? 0 * D5 : D5 / 0 : NaN);
      for (u4 ? (f4 = 1, h4 = n4.e - s4.e) : (u4 = q3, f4 = 7, h4 = v3(n4.e / f4) - v3(s4.e / f4)), I4 = T5.length, z4 = F4.length, b4 = (y4 = new P4(D5)).d = [], g4 = 0; T5[g4] == (F4[g4] || 0); g4++)
        ;
      if (T5[g4] > (F4[g4] || 0) && h4--, a4 == null ? (M26 = a4 = P4.precision, o4 = P4.rounding) : M26 = l3 ? a4 + (n4.e - s4.e) + 1 : a4, M26 < 0)
        b4.push(1), m4 = true;
      else {
        if (M26 = M26 / f4 + 2 | 0, g4 = 0, I4 == 1) {
          for (p4 = 0, T5 = T5[0], M26++; (g4 < z4 || p4) && M26--; g4++)
            S5 = p4 * u4 + (F4[g4] || 0), b4[g4] = S5 / T5 | 0, p4 = S5 % T5 | 0;
          m4 = p4 || g4 < z4;
        } else {
          for ((p4 = u4 / (T5[0] + 1) | 0) > 1 && (T5 = e4(T5, p4, u4), F4 = e4(F4, p4, u4), I4 = T5.length, z4 = F4.length), A4 = I4, N4 = (w4 = F4.slice(0, I4)).length; N4 < I4; )
            w4[N4++] = 0;
          (O4 = T5.slice()).unshift(0), k4 = T5[0], T5[1] >= u4 / 2 && ++k4;
          do {
            p4 = 0, (c4 = i4(T5, w4, I4, N4)) < 0 ? (E4 = w4[0], I4 != N4 && (E4 = E4 * u4 + (w4[1] || 0)), (p4 = E4 / k4 | 0) > 1 ? (p4 >= u4 && (p4 = u4 - 1), (c4 = i4(d4 = e4(T5, p4, u4), w4, x4 = d4.length, N4 = w4.length)) == 1 && (p4--, r4(d4, I4 < x4 ? O4 : T5, x4, u4))) : (p4 == 0 && (c4 = p4 = 1), d4 = T5.slice()), (x4 = d4.length) < N4 && d4.unshift(0), r4(w4, d4, N4, u4), c4 == -1 && (c4 = i4(T5, w4, I4, N4 = w4.length)) < 1 && (p4++, r4(w4, I4 < N4 ? O4 : T5, N4, u4)), N4 = w4.length) : c4 === 0 && (p4++, w4 = [0]), b4[g4++] = p4, c4 && w4[0] ? w4[N4++] = F4[A4] || 0 : (w4 = [F4[A4]], N4 = 1);
          } while ((A4++ < z4 || w4[0] !== void 0) && M26--);
          m4 = w4[0] !== void 0;
        }
        b4[0] || b4.shift();
      }
      if (f4 == 1)
        y4.e = h4, t3 = m4;
      else {
        for (g4 = 1, p4 = b4[0]; p4 >= 10; p4 /= 10)
          g4++;
        y4.e = g4 + h4 * f4 - 1, L3(y4, l3 ? a4 + y4.e + 1 : a4, o4, m4);
      }
      return y4;
    };
  }();
  function L3(e4, i4, t4, r4) {
    var n4, s4, a4, o4, l3, u4, c4, h4, p4, f4 = e4.constructor;
    e:
      if (i4 != null) {
        if (!(h4 = e4.d))
          return e4;
        for (n4 = 1, o4 = h4[0]; o4 >= 10; o4 /= 10)
          n4++;
        if ((s4 = i4 - n4) < 0)
          s4 += 7, a4 = i4, l3 = (c4 = h4[p4 = 0]) / x3(10, n4 - a4 - 1) % 10 | 0;
        else if ((p4 = Math.ceil((s4 + 1) / 7)) >= (o4 = h4.length)) {
          if (!r4)
            break e;
          for (; o4++ <= p4; )
            h4.push(0);
          c4 = l3 = 0, n4 = 1, a4 = (s4 %= 7) - 7 + 1;
        } else {
          for (c4 = o4 = h4[p4], n4 = 1; o4 >= 10; o4 /= 10)
            n4++;
          l3 = (a4 = (s4 %= 7) - 7 + n4) < 0 ? 0 : c4 / x3(10, n4 - a4 - 1) % 10 | 0;
        }
        if (r4 = r4 || i4 < 0 || h4[p4 + 1] !== void 0 || (a4 < 0 ? c4 : c4 % x3(10, n4 - a4 - 1)), u4 = t4 < 4 ? (l3 || r4) && (t4 == 0 || t4 == (e4.s < 0 ? 3 : 2)) : l3 > 5 || l3 == 5 && (t4 == 4 || r4 || t4 == 6 && (s4 > 0 ? a4 > 0 ? c4 / x3(10, n4 - a4) : 0 : h4[p4 - 1]) % 10 & 1 || t4 == (e4.s < 0 ? 8 : 7)), i4 < 1 || !h4[0])
          return h4.length = 0, u4 ? (i4 -= e4.e + 1, h4[0] = x3(10, (7 - i4 % 7) % 7), e4.e = -i4 || 0) : h4[0] = e4.e = 0, e4;
        if (s4 == 0 ? (h4.length = p4, o4 = 1, p4--) : (h4.length = p4 + 1, o4 = x3(10, 7 - s4), h4[p4] = a4 > 0 ? (c4 / x3(10, n4 - a4) % x3(10, a4) | 0) * o4 : 0), u4)
          for (; ; ) {
            if (p4 == 0) {
              for (s4 = 1, a4 = h4[0]; a4 >= 10; a4 /= 10)
                s4++;
              for (a4 = h4[0] += o4, o4 = 1; a4 >= 10; a4 /= 10)
                o4++;
              s4 != o4 && (e4.e++, h4[0] == q3 && (h4[0] = 1));
              break;
            }
            if (h4[p4] += o4, h4[p4] != q3)
              break;
            h4[p4--] = 0, o4 = 1;
          }
        for (s4 = h4.length; h4[--s4] === 0; )
          h4.pop();
      }
    return g3 && (e4.e > f4.maxE ? (e4.d = null, e4.e = NaN) : e4.e < f4.minE && (e4.e = 0, e4.d = [0])), e4;
  }
  function P3(e4, i4, t4) {
    if (!e4.isFinite())
      return j2(e4);
    var r4, n4 = e4.e, s4 = A3(e4.d), a4 = s4.length;
    return i4 ? (t4 && (r4 = t4 - a4) > 0 ? s4 = s4.charAt(0) + "." + s4.slice(1) + R3(r4) : a4 > 1 && (s4 = s4.charAt(0) + "." + s4.slice(1)), s4 = s4 + (e4.e < 0 ? "e" : "e+") + e4.e) : n4 < 0 ? (s4 = "0." + R3(-n4 - 1) + s4, t4 && (r4 = t4 - a4) > 0 && (s4 += R3(r4))) : n4 >= a4 ? (s4 += R3(n4 + 1 - a4), t4 && (r4 = t4 - n4 - 1) > 0 && (s4 = s4 + "." + R3(r4))) : ((r4 = n4 + 1) < a4 && (s4 = s4.slice(0, r4) + "." + s4.slice(r4)), t4 && (r4 = t4 - a4) > 0 && (n4 + 1 === a4 && (s4 += "."), s4 += R3(r4))), s4;
  }
  function D4(e4, i4) {
    var t4 = e4[0];
    for (i4 *= 7; t4 >= 10; t4 /= 10)
      i4++;
    return i4;
  }
  function F3(e4, i4, t4) {
    if (i4 > E3)
      throw g3 = true, t4 && (e4.precision = t4), Error(m3);
    return L3(new e4(u3), i4, 1, true);
  }
  function T4(e4, i4, t4) {
    if (i4 > M25)
      throw Error(m3);
    return L3(new e4(c3), i4, t4, true);
  }
  function C3(e4) {
    var i4 = e4.length - 1, t4 = 7 * i4 + 1;
    if (i4 = e4[i4]) {
      for (; i4 % 10 == 0; i4 /= 10)
        t4--;
      for (i4 = e4[0]; i4 >= 10; i4 /= 10)
        t4++;
    }
    return t4;
  }
  function R3(e4) {
    for (var i4 = ""; e4--; )
      i4 += "0";
    return i4;
  }
  function $3(e4, i4, t4, r4) {
    var n4, s4 = new e4(1), a4 = Math.ceil(r4 / 7 + 4);
    for (g3 = false; ; ) {
      if (t4 % 2 && J3((s4 = s4.times(i4)).d, a4) && (n4 = true), (t4 = v3(t4 / 2)) === 0) {
        t4 = s4.d.length - 1, n4 && s4.d[t4] === 0 && ++s4.d[t4];
        break;
      }
      J3((i4 = i4.times(i4)).d, a4);
    }
    return g3 = true, s4;
  }
  function Z3(e4) {
    return 1 & e4.d[e4.d.length - 1];
  }
  function B3(e4, i4, t4) {
    for (var r4, n4 = new e4(i4[0]), s4 = 0; ++s4 < i4.length; ) {
      if (!(r4 = new e4(i4[s4])).s) {
        n4 = r4;
        break;
      }
      n4[t4](r4) && (n4 = r4);
    }
    return n4;
  }
  function _3(e4, i4) {
    var t4, r4, n4, s4, a4, o4, l3, u4 = 0, c4 = 0, h4 = 0, p4 = e4.constructor, f4 = p4.rounding, m4 = p4.precision;
    if (!e4.d || !e4.d[0] || e4.e > 17)
      return new p4(e4.d ? e4.d[0] ? e4.s < 0 ? 0 : 1 / 0 : 1 : e4.s ? e4.s < 0 ? 0 : e4 : NaN);
    for (i4 == null ? (g3 = false, l3 = m4) : l3 = i4, o4 = new p4(0.03125); e4.e > -2; )
      e4 = e4.times(o4), h4 += 5;
    for (l3 += r4 = Math.log(x3(2, h4)) / Math.LN10 * 2 + 5 | 0, t4 = s4 = a4 = new p4(1), p4.precision = l3; ; ) {
      if (s4 = L3(s4.times(e4), l3, 1), t4 = t4.times(++c4), A3((o4 = a4.plus(O3(s4, t4, l3, 1))).d).slice(0, l3) === A3(a4.d).slice(0, l3)) {
        for (n4 = h4; n4--; )
          a4 = L3(a4.times(a4), l3, 1);
        if (i4 != null)
          return p4.precision = m4, a4;
        if (!(u4 < 3 && k3(a4.d, l3 - r4, f4, u4)))
          return L3(a4, p4.precision = m4, f4, g3 = true);
        p4.precision = l3 += 10, t4 = s4 = o4 = new p4(1), c4 = 0, u4++;
      }
      a4 = o4;
    }
  }
  function U2(e4, i4) {
    var t4, r4, n4, s4, a4, o4, l3, u4, c4, h4, p4, f4 = 1, m4 = e4, d4 = m4.d, v4 = m4.constructor, x4 = v4.rounding, y4 = v4.precision;
    if (m4.s < 0 || !d4 || !d4[0] || !m4.e && d4[0] == 1 && d4.length == 1)
      return new v4(d4 && !d4[0] ? -1 / 0 : m4.s != 1 ? NaN : d4 ? 0 : m4);
    if (i4 == null ? (g3 = false, c4 = y4) : c4 = i4, v4.precision = c4 += 10, r4 = (t4 = A3(d4)).charAt(0), !(Math.abs(s4 = m4.e) < 15e14))
      return u4 = F3(v4, c4 + 2, y4).times(s4 + ""), m4 = U2(new v4(r4 + "." + t4.slice(1)), c4 - 10).plus(u4), v4.precision = y4, i4 == null ? L3(m4, y4, x4, g3 = true) : m4;
    for (; r4 < 7 && r4 != 1 || r4 == 1 && t4.charAt(1) > 3; )
      r4 = (t4 = A3((m4 = m4.times(e4)).d)).charAt(0), f4++;
    for (s4 = m4.e, r4 > 1 ? (m4 = new v4("0." + t4), s4++) : m4 = new v4(r4 + "." + t4.slice(1)), h4 = m4, l3 = a4 = m4 = O3(m4.minus(1), m4.plus(1), c4, 1), p4 = L3(m4.times(m4), c4, 1), n4 = 3; ; ) {
      if (a4 = L3(a4.times(p4), c4, 1), A3((u4 = l3.plus(O3(a4, new v4(n4), c4, 1))).d).slice(0, c4) === A3(l3.d).slice(0, c4)) {
        if (l3 = l3.times(2), s4 !== 0 && (l3 = l3.plus(F3(v4, c4 + 2, y4).times(s4 + ""))), l3 = O3(l3, new v4(f4), c4, 1), i4 != null)
          return v4.precision = y4, l3;
        if (!k3(l3.d, c4 - 10, x4, o4))
          return L3(l3, v4.precision = y4, x4, g3 = true);
        v4.precision = c4 += 10, u4 = a4 = m4 = O3(h4.minus(1), h4.plus(1), c4, 1), p4 = L3(m4.times(m4), c4, 1), n4 = o4 = 1;
      }
      l3 = u4, n4 += 2;
    }
  }
  function j2(e4) {
    return String(e4.s * e4.s / 0);
  }
  function H3(e4, i4) {
    var t4, r4, n4;
    for ((t4 = i4.indexOf(".")) > -1 && (i4 = i4.replace(".", "")), (r4 = i4.search(/e/i)) > 0 ? (t4 < 0 && (t4 = r4), t4 += +i4.slice(r4 + 1), i4 = i4.substring(0, r4)) : t4 < 0 && (t4 = i4.length), r4 = 0; i4.charCodeAt(r4) === 48; r4++)
      ;
    for (n4 = i4.length; i4.charCodeAt(n4 - 1) === 48; --n4)
      ;
    if (i4 = i4.slice(r4, n4)) {
      if (n4 -= r4, e4.e = t4 = t4 - r4 - 1, e4.d = [], r4 = (t4 + 1) % 7, t4 < 0 && (r4 += 7), r4 < n4) {
        for (r4 && e4.d.push(+i4.slice(0, r4)), n4 -= 7; r4 < n4; )
          e4.d.push(+i4.slice(r4, r4 += 7));
        r4 = 7 - (i4 = i4.slice(r4)).length;
      } else
        r4 -= n4;
      for (; r4--; )
        i4 += "0";
      e4.d.push(+i4), g3 && (e4.e > e4.constructor.maxE ? (e4.d = null, e4.e = NaN) : e4.e < e4.constructor.minE && (e4.e = 0, e4.d = [0]));
    } else
      e4.e = 0, e4.d = [0];
    return e4;
  }
  function G3(e4, t4) {
    var r4, n4, s4, a4, o4, l3, u4, c4, h4;
    if (t4 === "Infinity" || t4 === "NaN")
      return +t4 || (e4.s = NaN), e4.e = NaN, e4.d = null, e4;
    if (b3.test(t4))
      r4 = 16, t4 = t4.toLowerCase();
    else if (y3.test(t4))
      r4 = 2;
    else {
      if (!w3.test(t4))
        throw Error(f3 + t4);
      r4 = 8;
    }
    for ((a4 = t4.search(/p/i)) > 0 ? (u4 = +t4.slice(a4 + 1), t4 = t4.substring(2, a4)) : t4 = t4.slice(2), o4 = (a4 = t4.indexOf(".")) >= 0, n4 = e4.constructor, o4 && (a4 = (l3 = (t4 = t4.replace(".", "")).length) - a4, s4 = $3(n4, new n4(r4), a4, 2 * a4)), a4 = h4 = (c4 = I3(t4, r4, q3)).length - 1; c4[a4] === 0; --a4)
      c4.pop();
    return a4 < 0 ? new n4(0 * e4.s) : (e4.e = D4(c4, h4), e4.d = c4, g3 = false, o4 && (e4 = O3(e4, s4, 4 * l3)), u4 && (e4 = e4.times(Math.abs(u4) < 54 ? x3(2, u4) : i3.pow(2, u4))), g3 = true, e4);
  }
  function W3(e4, i4, t4, r4, n4) {
    var s4, a4, o4, l3, u4 = e4.precision, c4 = Math.ceil(u4 / 7);
    for (g3 = false, l3 = t4.times(t4), o4 = new e4(r4); ; ) {
      if (a4 = O3(o4.times(l3), new e4(i4++ * i4++), u4, 1), o4 = n4 ? r4.plus(a4) : r4.minus(a4), r4 = O3(a4.times(l3), new e4(i4++ * i4++), u4, 1), (a4 = o4.plus(r4)).d[c4] !== void 0) {
        for (s4 = c4; a4.d[s4] === o4.d[s4] && s4--; )
          ;
        if (s4 == -1)
          break;
      }
      s4 = o4, o4 = r4, r4 = a4, a4 = s4;
    }
    return g3 = true, a4.d.length = c4 + 1, a4;
  }
  function V3(e4, i4) {
    for (var t4 = e4; --i4; )
      t4 *= e4;
    return t4;
  }
  function Q3(e4, i4) {
    var t4, r4 = i4.s < 0, s4 = T4(e4, e4.precision, 1), a4 = s4.times(0.5);
    if ((i4 = i4.abs()).lte(a4))
      return n3 = r4 ? 4 : 1, i4;
    if ((t4 = i4.divToInt(s4)).isZero())
      n3 = r4 ? 3 : 2;
    else {
      if ((i4 = i4.minus(t4.times(s4))).lte(a4))
        return n3 = Z3(t4) ? r4 ? 2 : 3 : r4 ? 4 : 1, i4;
      n3 = Z3(t4) ? r4 ? 1 : 4 : r4 ? 3 : 2;
    }
    return i4.minus(s4).abs();
  }
  function Y3(e4, i4, r4, n4) {
    var s4, l3, u4, c4, h4, g4, p4, f4, m4, d4 = e4.constructor, v4 = r4 !== void 0;
    if (v4 ? (z3(r4, 1, a3), n4 === void 0 ? n4 = d4.rounding : z3(n4, 0, 8)) : (r4 = d4.precision, n4 = d4.rounding), e4.isFinite()) {
      for (v4 ? (s4 = 2, i4 == 16 ? r4 = 4 * r4 - 3 : i4 == 8 && (r4 = 3 * r4 - 2)) : s4 = i4, (u4 = (p4 = P3(e4)).indexOf(".")) >= 0 && (p4 = p4.replace(".", ""), (m4 = new d4(1)).e = p4.length - u4, m4.d = I3(P3(m4), 10, s4), m4.e = m4.d.length), l3 = h4 = (f4 = I3(p4, 10, s4)).length; f4[--h4] == 0; )
        f4.pop();
      if (f4[0]) {
        if (u4 < 0 ? l3-- : ((e4 = new d4(e4)).d = f4, e4.e = l3, f4 = (e4 = O3(e4, m4, r4, n4, 0, s4)).d, l3 = e4.e, g4 = t3), u4 = f4[r4], c4 = s4 / 2, g4 = g4 || f4[r4 + 1] !== void 0, g4 = n4 < 4 ? (u4 !== void 0 || g4) && (n4 === 0 || n4 === (e4.s < 0 ? 3 : 2)) : u4 > c4 || u4 === c4 && (n4 === 4 || g4 || n4 === 6 && 1 & f4[r4 - 1] || n4 === (e4.s < 0 ? 8 : 7)), f4.length = r4, g4)
          for (; ++f4[--r4] > s4 - 1; )
            f4[r4] = 0, r4 || (++l3, f4.unshift(1));
        for (h4 = f4.length; !f4[h4 - 1]; --h4)
          ;
        for (u4 = 0, p4 = ""; u4 < h4; u4++)
          p4 += o3.charAt(f4[u4]);
        if (v4) {
          if (h4 > 1)
            if (i4 == 16 || i4 == 8) {
              for (u4 = i4 == 16 ? 4 : 3, --h4; h4 % u4; h4++)
                p4 += "0";
              for (h4 = (f4 = I3(p4, s4, i4)).length; !f4[h4 - 1]; --h4)
                ;
              for (u4 = 1, p4 = "1."; u4 < h4; u4++)
                p4 += o3.charAt(f4[u4]);
            } else
              p4 = p4.charAt(0) + "." + p4.slice(1);
          p4 = p4 + (l3 < 0 ? "p" : "p+") + l3;
        } else if (l3 < 0) {
          for (; ++l3; )
            p4 = "0" + p4;
          p4 = "0." + p4;
        } else if (++l3 > h4)
          for (l3 -= h4; l3--; )
            p4 += "0";
        else
          l3 < h4 && (p4 = p4.slice(0, l3) + "." + p4.slice(l3));
      } else
        p4 = v4 ? "0p+0" : "0";
      p4 = (i4 == 16 ? "0x" : i4 == 2 ? "0b" : i4 == 8 ? "0o" : "") + p4;
    } else
      p4 = j2(e4);
    return e4.s < 0 ? "-" + p4 : p4;
  }
  function J3(e4, i4) {
    if (e4.length > i4)
      return e4.length = i4, true;
  }
  function K2(e4) {
    return new this(e4).abs();
  }
  function X3(e4) {
    return new this(e4).acos();
  }
  function ee2(e4) {
    return new this(e4).acosh();
  }
  function ie3(e4, i4) {
    return new this(e4).plus(i4);
  }
  function te3(e4) {
    return new this(e4).asin();
  }
  function re3(e4) {
    return new this(e4).asinh();
  }
  function ne3(e4) {
    return new this(e4).atan();
  }
  function se3(e4) {
    return new this(e4).atanh();
  }
  function ae3(e4, i4) {
    e4 = new this(e4), i4 = new this(i4);
    var t4, r4 = this.precision, n4 = this.rounding, s4 = r4 + 4;
    return e4.s && i4.s ? e4.d || i4.d ? !i4.d || e4.isZero() ? (t4 = i4.s < 0 ? T4(this, r4, n4) : new this(0)).s = e4.s : !e4.d || i4.isZero() ? (t4 = T4(this, s4, 1).times(0.5)).s = e4.s : i4.s < 0 ? (this.precision = s4, this.rounding = 1, t4 = this.atan(O3(e4, i4, s4, 1)), i4 = T4(this, s4, 1), this.precision = r4, this.rounding = n4, t4 = e4.s < 0 ? t4.minus(i4) : t4.plus(i4)) : t4 = this.atan(O3(e4, i4, s4, 1)) : (t4 = T4(this, s4, 1).times(i4.s > 0 ? 0.25 : 0.75)).s = e4.s : t4 = new this(NaN), t4;
  }
  function oe3(e4) {
    return new this(e4).cbrt();
  }
  function le2(e4) {
    return L3(e4 = new this(e4), e4.e + 1, 2);
  }
  function ue2(e4) {
    if (!e4 || typeof e4 != "object")
      throw Error(p3 + "Object expected");
    var i4, t4, r4, n4 = e4.defaults === true, o4 = ["precision", 1, a3, "rounding", 0, 8, "toExpNeg", -s3, 0, "toExpPos", 0, s3, "maxE", 0, s3, "minE", -s3, 0, "modulo", 0, 9];
    for (i4 = 0; i4 < o4.length; i4 += 3)
      if (t4 = o4[i4], n4 && (this[t4] = h3[t4]), (r4 = e4[t4]) !== void 0) {
        if (!(v3(r4) === r4 && r4 >= o4[i4 + 1] && r4 <= o4[i4 + 2]))
          throw Error(f3 + t4 + ": " + r4);
        this[t4] = r4;
      }
    if (t4 = "crypto", n4 && (this[t4] = h3[t4]), (r4 = e4[t4]) !== void 0) {
      if (r4 !== true && r4 !== false && r4 !== 0 && r4 !== 1)
        throw Error(f3 + t4 + ": " + r4);
      if (r4) {
        if (typeof crypto == "undefined" || !crypto || !crypto.getRandomValues && !crypto.randomBytes)
          throw Error(d3);
        this[t4] = true;
      } else
        this[t4] = false;
    }
    return this;
  }
  function ce2(e4) {
    return new this(e4).cos();
  }
  function he2(e4) {
    return new this(e4).cosh();
  }
  function ge2(e4, i4) {
    return new this(e4).div(i4);
  }
  function pe2(e4) {
    return new this(e4).exp();
  }
  function fe2(e4) {
    return L3(e4 = new this(e4), e4.e + 1, 3);
  }
  function me() {
    var e4, i4, t4 = new this(0);
    for (g3 = false, e4 = 0; e4 < arguments.length; )
      if ((i4 = new this(arguments[e4++])).d)
        t4.d && (t4 = t4.plus(i4.times(i4)));
      else {
        if (i4.s)
          return g3 = true, new this(1 / 0);
        t4 = i4;
      }
    return g3 = true, t4.sqrt();
  }
  function de2(e4) {
    return e4 instanceof i3 || e4 && e4.name === "[object Decimal]" || false;
  }
  function ve2(e4) {
    return new this(e4).ln();
  }
  function xe2(e4, i4) {
    return new this(e4).log(i4);
  }
  function ye2(e4) {
    return new this(e4).log(2);
  }
  function be2(e4) {
    return new this(e4).log(10);
  }
  function we2() {
    return B3(this, arguments, "lt");
  }
  function Ne2() {
    return B3(this, arguments, "gt");
  }
  function qe(e4, i4) {
    return new this(e4).mod(i4);
  }
  function Ee2(e4, i4) {
    return new this(e4).mul(i4);
  }
  function Me(e4, i4) {
    return new this(e4).pow(i4);
  }
  function Se2(e4) {
    var i4, t4, r4, n4, s4 = 0, o4 = new this(1), l3 = [];
    if (e4 === void 0 ? e4 = this.precision : z3(e4, 1, a3), r4 = Math.ceil(e4 / 7), this.crypto)
      if (crypto.getRandomValues)
        for (i4 = crypto.getRandomValues(new Uint32Array(r4)); s4 < r4; )
          (n4 = i4[s4]) >= 429e7 ? i4[s4] = crypto.getRandomValues(new Uint32Array(1))[0] : l3[s4++] = n4 % 1e7;
      else {
        if (!crypto.randomBytes)
          throw Error(d3);
        for (i4 = crypto.randomBytes(r4 *= 4); s4 < r4; )
          (n4 = i4[s4] + (i4[s4 + 1] << 8) + (i4[s4 + 2] << 16) + ((127 & i4[s4 + 3]) << 24)) >= 214e7 ? crypto.randomBytes(4).copy(i4, s4) : (l3.push(n4 % 1e7), s4 += 4);
        s4 = r4 / 4;
      }
    else
      for (; s4 < r4; )
        l3[s4++] = 1e7 * Math.random() | 0;
    for (e4 %= 7, (r4 = l3[--s4]) && e4 && (n4 = x3(10, 7 - e4), l3[s4] = (r4 / n4 | 0) * n4); l3[s4] === 0; s4--)
      l3.pop();
    if (s4 < 0)
      t4 = 0, l3 = [0];
    else {
      for (t4 = -1; l3[0] === 0; t4 -= 7)
        l3.shift();
      for (r4 = 1, n4 = l3[0]; n4 >= 10; n4 /= 10)
        r4++;
      r4 < 7 && (t4 -= 7 - r4);
    }
    return o4.e = t4, o4.d = l3, o4;
  }
  function Ae2(e4) {
    return L3(e4 = new this(e4), e4.e + 1, this.rounding);
  }
  function ze2(e4) {
    return (e4 = new this(e4)).d ? e4.d[0] ? e4.s : 0 * e4.s : e4.s || NaN;
  }
  function ke2(e4) {
    return new this(e4).sin();
  }
  function Ie2(e4) {
    return new this(e4).sinh();
  }
  function Oe2(e4) {
    return new this(e4).sqrt();
  }
  function Le2(e4, i4) {
    return new this(e4).sub(i4);
  }
  function Pe2(e4) {
    return new this(e4).tan();
  }
  function De2(e4) {
    return new this(e4).tanh();
  }
  function Fe2(e4) {
    return L3(e4 = new this(e4), e4.e + 1, 1);
  }
  (i3 = function e4(i4) {
    var t4, r4, n4;
    function s4(e5) {
      var i5, t5, r5, n5 = this;
      if (!(n5 instanceof s4))
        return new s4(e5);
      if (n5.constructor = s4, e5 instanceof s4)
        return n5.s = e5.s, void (g3 ? !e5.d || e5.e > s4.maxE ? (n5.e = NaN, n5.d = null) : e5.e < s4.minE ? (n5.e = 0, n5.d = [0]) : (n5.e = e5.e, n5.d = e5.d.slice()) : (n5.e = e5.e, n5.d = e5.d ? e5.d.slice() : e5.d));
      if ((r5 = typeof e5) == "number") {
        if (e5 === 0)
          return n5.s = 1 / e5 < 0 ? -1 : 1, n5.e = 0, void (n5.d = [0]);
        if (e5 < 0 ? (e5 = -e5, n5.s = -1) : n5.s = 1, e5 === ~~e5 && e5 < 1e7) {
          for (i5 = 0, t5 = e5; t5 >= 10; t5 /= 10)
            i5++;
          return void (g3 ? i5 > s4.maxE ? (n5.e = NaN, n5.d = null) : i5 < s4.minE ? (n5.e = 0, n5.d = [0]) : (n5.e = i5, n5.d = [e5]) : (n5.e = i5, n5.d = [e5]));
        }
        return 0 * e5 != 0 ? (e5 || (n5.s = NaN), n5.e = NaN, void (n5.d = null)) : H3(n5, e5.toString());
      }
      if (r5 !== "string")
        throw Error(f3 + e5);
      return (t5 = e5.charCodeAt(0)) === 45 ? (e5 = e5.slice(1), n5.s = -1) : (t5 === 43 && (e5 = e5.slice(1)), n5.s = 1), N3.test(e5) ? H3(n5, e5) : G3(n5, e5);
    }
    if (s4.prototype = S4, s4.ROUND_UP = 0, s4.ROUND_DOWN = 1, s4.ROUND_CEIL = 2, s4.ROUND_FLOOR = 3, s4.ROUND_HALF_UP = 4, s4.ROUND_HALF_DOWN = 5, s4.ROUND_HALF_EVEN = 6, s4.ROUND_HALF_CEIL = 7, s4.ROUND_HALF_FLOOR = 8, s4.EUCLID = 9, s4.config = s4.set = ue2, s4.clone = e4, s4.isDecimal = de2, s4.abs = K2, s4.acos = X3, s4.acosh = ee2, s4.add = ie3, s4.asin = te3, s4.asinh = re3, s4.atan = ne3, s4.atanh = se3, s4.atan2 = ae3, s4.cbrt = oe3, s4.ceil = le2, s4.cos = ce2, s4.cosh = he2, s4.div = ge2, s4.exp = pe2, s4.floor = fe2, s4.hypot = me, s4.ln = ve2, s4.log = xe2, s4.log10 = be2, s4.log2 = ye2, s4.max = we2, s4.min = Ne2, s4.mod = qe, s4.mul = Ee2, s4.pow = Me, s4.random = Se2, s4.round = Ae2, s4.sign = ze2, s4.sin = ke2, s4.sinh = Ie2, s4.sqrt = Oe2, s4.sub = Le2, s4.tan = Pe2, s4.tanh = De2, s4.trunc = Fe2, i4 === void 0 && (i4 = {}), i4 && i4.defaults !== true)
      for (n4 = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], t4 = 0; t4 < n4.length; )
        i4.hasOwnProperty(r4 = n4[t4++]) || (i4[r4] = this[r4]);
    return s4.config(i4), s4;
  }(h3)).default = i3.Decimal = i3, u3 = new i3(u3), c3 = new i3(c3), l.exports ? (typeof Symbol == "function" && typeof Symbol.iterator == "symbol" && (S4[Symbol.for("nodejs.util.inspect.custom")] = S4.toString, S4[Symbol.toStringTag] = "Decimal"), l.exports = i3) : (e3 || (e3 = typeof self != "undefined" && self && self.self == self ? self : window), r3 = e3.Decimal, i3.noConflict = function() {
    return e3.Decimal = r3, i3;
  }, e3.Decimal = i3);
}(u);
var h = {exports: {}};
!function(e3, i3) {
  !function(i4) {
    var t3 = function(e4) {
      return 0.5 * (Math.exp(e4) + Math.exp(-e4));
    }, r3 = function(e4) {
      return 0.5 * (Math.exp(e4) - Math.exp(-e4));
    }, n3 = function() {
      throw SyntaxError("Invalid Param");
    };
    function s3(e4, i5) {
      var t4 = Math.abs(e4), r4 = Math.abs(i5);
      return e4 === 0 ? Math.log(r4) : i5 === 0 ? Math.log(t4) : t4 < 3e3 && r4 < 3e3 ? 0.5 * Math.log(e4 * e4 + i5 * i5) : Math.log(e4 / Math.cos(Math.atan2(i5, e4)));
    }
    function a3(e4, i5) {
      if (!(this instanceof a3))
        return new a3(e4, i5);
      var t4 = function(e5, i6) {
        var t5 = {re: 0, im: 0};
        if (e5 == null)
          t5.re = t5.im = 0;
        else if (i6 !== void 0)
          t5.re = e5, t5.im = i6;
        else
          switch (typeof e5) {
            case "object":
              if ("im" in e5 && "re" in e5)
                t5.re = e5.re, t5.im = e5.im;
              else if ("abs" in e5 && "arg" in e5) {
                if (!Number.isFinite(e5.abs) && Number.isFinite(e5.arg))
                  return a3.INFINITY;
                t5.re = e5.abs * Math.cos(e5.arg), t5.im = e5.abs * Math.sin(e5.arg);
              } else if ("r" in e5 && "phi" in e5) {
                if (!Number.isFinite(e5.r) && Number.isFinite(e5.phi))
                  return a3.INFINITY;
                t5.re = e5.r * Math.cos(e5.phi), t5.im = e5.r * Math.sin(e5.phi);
              } else
                e5.length === 2 ? (t5.re = e5[0], t5.im = e5[1]) : n3();
              break;
            case "string":
              t5.im = t5.re = 0;
              var r4 = e5.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g), s4 = 1, o3 = 0;
              r4 === null && n3();
              for (var l3 = 0; l3 < r4.length; l3++) {
                var u3 = r4[l3];
                u3 === " " || u3 === "	" || u3 === "\n" || (u3 === "+" ? s4++ : u3 === "-" ? o3++ : u3 === "i" || u3 === "I" ? (s4 + o3 === 0 && n3(), r4[l3 + 1] === " " || isNaN(r4[l3 + 1]) ? t5.im += parseFloat((o3 % 2 ? "-" : "") + "1") : (t5.im += parseFloat((o3 % 2 ? "-" : "") + r4[l3 + 1]), l3++), s4 = o3 = 0) : ((s4 + o3 === 0 || isNaN(u3)) && n3(), r4[l3 + 1] === "i" || r4[l3 + 1] === "I" ? (t5.im += parseFloat((o3 % 2 ? "-" : "") + u3), l3++) : t5.re += parseFloat((o3 % 2 ? "-" : "") + u3), s4 = o3 = 0));
              }
              s4 + o3 > 0 && n3();
              break;
            case "number":
              t5.im = 0, t5.re = e5;
              break;
            default:
              n3();
          }
        return isNaN(t5.re) || isNaN(t5.im), t5;
      }(e4, i5);
      this.re = t4.re, this.im = t4.im;
    }
    a3.prototype = {re: 0, im: 0, sign: function() {
      var e4 = this.abs();
      return new a3(this.re / e4, this.im / e4);
    }, add: function(e4, i5) {
      var t4 = new a3(e4, i5);
      return this.isInfinite() && t4.isInfinite() ? a3.NAN : this.isInfinite() || t4.isInfinite() ? a3.INFINITY : new a3(this.re + t4.re, this.im + t4.im);
    }, sub: function(e4, i5) {
      var t4 = new a3(e4, i5);
      return this.isInfinite() && t4.isInfinite() ? a3.NAN : this.isInfinite() || t4.isInfinite() ? a3.INFINITY : new a3(this.re - t4.re, this.im - t4.im);
    }, mul: function(e4, i5) {
      var t4 = new a3(e4, i5);
      return this.isInfinite() && t4.isZero() || this.isZero() && t4.isInfinite() ? a3.NAN : this.isInfinite() || t4.isInfinite() ? a3.INFINITY : t4.im === 0 && this.im === 0 ? new a3(this.re * t4.re, 0) : new a3(this.re * t4.re - this.im * t4.im, this.re * t4.im + this.im * t4.re);
    }, div: function(e4, i5) {
      var t4 = new a3(e4, i5);
      if (this.isZero() && t4.isZero() || this.isInfinite() && t4.isInfinite())
        return a3.NAN;
      if (this.isInfinite() || t4.isZero())
        return a3.INFINITY;
      if (this.isZero() || t4.isInfinite())
        return a3.ZERO;
      e4 = this.re, i5 = this.im;
      var r4, n4, s4 = t4.re, o3 = t4.im;
      return o3 === 0 ? new a3(e4 / s4, i5 / s4) : Math.abs(s4) < Math.abs(o3) ? new a3((e4 * (n4 = s4 / o3) + i5) / (r4 = s4 * n4 + o3), (i5 * n4 - e4) / r4) : new a3((e4 + i5 * (n4 = o3 / s4)) / (r4 = o3 * n4 + s4), (i5 - e4 * n4) / r4);
    }, pow: function(e4, i5) {
      var t4 = new a3(e4, i5);
      if (e4 = this.re, i5 = this.im, t4.isZero())
        return a3.ONE;
      if (t4.im === 0) {
        if (i5 === 0 && e4 > 0)
          return new a3(Math.pow(e4, t4.re), 0);
        if (e4 === 0)
          switch ((t4.re % 4 + 4) % 4) {
            case 0:
              return new a3(Math.pow(i5, t4.re), 0);
            case 1:
              return new a3(0, Math.pow(i5, t4.re));
            case 2:
              return new a3(-Math.pow(i5, t4.re), 0);
            case 3:
              return new a3(0, -Math.pow(i5, t4.re));
          }
      }
      if (e4 === 0 && i5 === 0 && t4.re > 0 && t4.im >= 0)
        return a3.ZERO;
      var r4 = Math.atan2(i5, e4), n4 = s3(e4, i5);
      return e4 = Math.exp(t4.re * n4 - t4.im * r4), i5 = t4.im * n4 + t4.re * r4, new a3(e4 * Math.cos(i5), e4 * Math.sin(i5));
    }, sqrt: function() {
      var e4, i5, t4 = this.re, r4 = this.im, n4 = this.abs();
      if (t4 >= 0) {
        if (r4 === 0)
          return new a3(Math.sqrt(t4), 0);
        e4 = 0.5 * Math.sqrt(2 * (n4 + t4));
      } else
        e4 = Math.abs(r4) / Math.sqrt(2 * (n4 - t4));
      return i5 = t4 <= 0 ? 0.5 * Math.sqrt(2 * (n4 - t4)) : Math.abs(r4) / Math.sqrt(2 * (n4 + t4)), new a3(e4, r4 < 0 ? -i5 : i5);
    }, exp: function() {
      var e4 = Math.exp(this.re);
      return this.im, new a3(e4 * Math.cos(this.im), e4 * Math.sin(this.im));
    }, expm1: function() {
      var e4 = this.re, i5 = this.im;
      return new a3(Math.expm1(e4) * Math.cos(i5) + function(e5) {
        var i6 = Math.PI / 4;
        if (e5 < -i6 || e5 > i6)
          return Math.cos(e5) - 1;
        var t4 = e5 * e5;
        return t4 * (t4 * (1 / 24 + t4 * (-1 / 720 + t4 * (1 / 40320 + t4 * (-1 / 3628800 + t4 * (1 / 4790014600 + t4 * (-1 / 87178291200 + t4 * (1 / 20922789888e3))))))) - 0.5);
      }(i5), Math.exp(e4) * Math.sin(i5));
    }, log: function() {
      var e4 = this.re, i5 = this.im;
      return new a3(s3(e4, i5), Math.atan2(i5, e4));
    }, abs: function() {
      return e4 = this.re, i5 = this.im, t4 = Math.abs(e4), r4 = Math.abs(i5), t4 < 3e3 && r4 < 3e3 ? Math.sqrt(t4 * t4 + r4 * r4) : (t4 < r4 ? (t4 = r4, r4 = e4 / i5) : r4 = i5 / e4, t4 * Math.sqrt(1 + r4 * r4));
      var e4, i5, t4, r4;
    }, arg: function() {
      return Math.atan2(this.im, this.re);
    }, sin: function() {
      var e4 = this.re, i5 = this.im;
      return new a3(Math.sin(e4) * t3(i5), Math.cos(e4) * r3(i5));
    }, cos: function() {
      var e4 = this.re, i5 = this.im;
      return new a3(Math.cos(e4) * t3(i5), -Math.sin(e4) * r3(i5));
    }, tan: function() {
      var e4 = 2 * this.re, i5 = 2 * this.im, n4 = Math.cos(e4) + t3(i5);
      return new a3(Math.sin(e4) / n4, r3(i5) / n4);
    }, cot: function() {
      var e4 = 2 * this.re, i5 = 2 * this.im, n4 = Math.cos(e4) - t3(i5);
      return new a3(-Math.sin(e4) / n4, r3(i5) / n4);
    }, sec: function() {
      var e4 = this.re, i5 = this.im, n4 = 0.5 * t3(2 * i5) + 0.5 * Math.cos(2 * e4);
      return new a3(Math.cos(e4) * t3(i5) / n4, Math.sin(e4) * r3(i5) / n4);
    }, csc: function() {
      var e4 = this.re, i5 = this.im, n4 = 0.5 * t3(2 * i5) - 0.5 * Math.cos(2 * e4);
      return new a3(Math.sin(e4) * t3(i5) / n4, -Math.cos(e4) * r3(i5) / n4);
    }, asin: function() {
      var e4 = this.re, i5 = this.im, t4 = new a3(i5 * i5 - e4 * e4 + 1, -2 * e4 * i5).sqrt(), r4 = new a3(t4.re - i5, t4.im + e4).log();
      return new a3(r4.im, -r4.re);
    }, acos: function() {
      var e4 = this.re, i5 = this.im, t4 = new a3(i5 * i5 - e4 * e4 + 1, -2 * e4 * i5).sqrt(), r4 = new a3(t4.re - i5, t4.im + e4).log();
      return new a3(Math.PI / 2 - r4.im, r4.re);
    }, atan: function() {
      var e4 = this.re, i5 = this.im;
      if (e4 === 0) {
        if (i5 === 1)
          return new a3(0, 1 / 0);
        if (i5 === -1)
          return new a3(0, -1 / 0);
      }
      var t4 = e4 * e4 + (1 - i5) * (1 - i5), r4 = new a3((1 - i5 * i5 - e4 * e4) / t4, -2 * e4 / t4).log();
      return new a3(-0.5 * r4.im, 0.5 * r4.re);
    }, acot: function() {
      var e4 = this.re, i5 = this.im;
      if (i5 === 0)
        return new a3(Math.atan2(1, e4), 0);
      var t4 = e4 * e4 + i5 * i5;
      return t4 !== 0 ? new a3(e4 / t4, -i5 / t4).atan() : new a3(e4 !== 0 ? e4 / 0 : 0, i5 !== 0 ? -i5 / 0 : 0).atan();
    }, asec: function() {
      var e4 = this.re, i5 = this.im;
      if (e4 === 0 && i5 === 0)
        return new a3(0, 1 / 0);
      var t4 = e4 * e4 + i5 * i5;
      return t4 !== 0 ? new a3(e4 / t4, -i5 / t4).acos() : new a3(e4 !== 0 ? e4 / 0 : 0, i5 !== 0 ? -i5 / 0 : 0).acos();
    }, acsc: function() {
      var e4 = this.re, i5 = this.im;
      if (e4 === 0 && i5 === 0)
        return new a3(Math.PI / 2, 1 / 0);
      var t4 = e4 * e4 + i5 * i5;
      return t4 !== 0 ? new a3(e4 / t4, -i5 / t4).asin() : new a3(e4 !== 0 ? e4 / 0 : 0, i5 !== 0 ? -i5 / 0 : 0).asin();
    }, sinh: function() {
      var e4 = this.re, i5 = this.im;
      return new a3(r3(e4) * Math.cos(i5), t3(e4) * Math.sin(i5));
    }, cosh: function() {
      var e4 = this.re, i5 = this.im;
      return new a3(t3(e4) * Math.cos(i5), r3(e4) * Math.sin(i5));
    }, tanh: function() {
      var e4 = 2 * this.re, i5 = 2 * this.im, n4 = t3(e4) + Math.cos(i5);
      return new a3(r3(e4) / n4, Math.sin(i5) / n4);
    }, coth: function() {
      var e4 = 2 * this.re, i5 = 2 * this.im, n4 = t3(e4) - Math.cos(i5);
      return new a3(r3(e4) / n4, -Math.sin(i5) / n4);
    }, csch: function() {
      var e4 = this.re, i5 = this.im, n4 = Math.cos(2 * i5) - t3(2 * e4);
      return new a3(-2 * r3(e4) * Math.cos(i5) / n4, 2 * t3(e4) * Math.sin(i5) / n4);
    }, sech: function() {
      var e4 = this.re, i5 = this.im, n4 = Math.cos(2 * i5) + t3(2 * e4);
      return new a3(2 * t3(e4) * Math.cos(i5) / n4, -2 * r3(e4) * Math.sin(i5) / n4);
    }, asinh: function() {
      var e4 = this.im;
      this.im = -this.re, this.re = e4;
      var i5 = this.asin();
      return this.re = -this.im, this.im = e4, e4 = i5.re, i5.re = -i5.im, i5.im = e4, i5;
    }, acosh: function() {
      var e4 = this.acos();
      if (e4.im <= 0) {
        var i5 = e4.re;
        e4.re = -e4.im, e4.im = i5;
      } else
        i5 = e4.im, e4.im = -e4.re, e4.re = i5;
      return e4;
    }, atanh: function() {
      var e4 = this.re, i5 = this.im, t4 = e4 > 1 && i5 === 0, r4 = 1 - e4, n4 = 1 + e4, o3 = r4 * r4 + i5 * i5, l3 = o3 !== 0 ? new a3((n4 * r4 - i5 * i5) / o3, (i5 * r4 + n4 * i5) / o3) : new a3(e4 !== -1 ? e4 / 0 : 0, i5 !== 0 ? i5 / 0 : 0), u3 = l3.re;
      return l3.re = s3(l3.re, l3.im) / 2, l3.im = Math.atan2(l3.im, u3) / 2, t4 && (l3.im = -l3.im), l3;
    }, acoth: function() {
      var e4 = this.re, i5 = this.im;
      if (e4 === 0 && i5 === 0)
        return new a3(0, Math.PI / 2);
      var t4 = e4 * e4 + i5 * i5;
      return t4 !== 0 ? new a3(e4 / t4, -i5 / t4).atanh() : new a3(e4 !== 0 ? e4 / 0 : 0, i5 !== 0 ? -i5 / 0 : 0).atanh();
    }, acsch: function() {
      var e4 = this.re, i5 = this.im;
      if (i5 === 0)
        return new a3(e4 !== 0 ? Math.log(e4 + Math.sqrt(e4 * e4 + 1)) : 1 / 0, 0);
      var t4 = e4 * e4 + i5 * i5;
      return t4 !== 0 ? new a3(e4 / t4, -i5 / t4).asinh() : new a3(e4 !== 0 ? e4 / 0 : 0, i5 !== 0 ? -i5 / 0 : 0).asinh();
    }, asech: function() {
      var e4 = this.re, i5 = this.im;
      if (this.isZero())
        return a3.INFINITY;
      var t4 = e4 * e4 + i5 * i5;
      return t4 !== 0 ? new a3(e4 / t4, -i5 / t4).acosh() : new a3(e4 !== 0 ? e4 / 0 : 0, i5 !== 0 ? -i5 / 0 : 0).acosh();
    }, inverse: function() {
      if (this.isZero())
        return a3.INFINITY;
      if (this.isInfinite())
        return a3.ZERO;
      var e4 = this.re, i5 = this.im, t4 = e4 * e4 + i5 * i5;
      return new a3(e4 / t4, -i5 / t4);
    }, conjugate: function() {
      return new a3(this.re, -this.im);
    }, neg: function() {
      return new a3(-this.re, -this.im);
    }, ceil: function(e4) {
      return e4 = Math.pow(10, e4 || 0), new a3(Math.ceil(this.re * e4) / e4, Math.ceil(this.im * e4) / e4);
    }, floor: function(e4) {
      return e4 = Math.pow(10, e4 || 0), new a3(Math.floor(this.re * e4) / e4, Math.floor(this.im * e4) / e4);
    }, round: function(e4) {
      return e4 = Math.pow(10, e4 || 0), new a3(Math.round(this.re * e4) / e4, Math.round(this.im * e4) / e4);
    }, equals: function(e4, i5) {
      var t4 = new a3(e4, i5);
      return Math.abs(t4.re - this.re) <= a3.EPSILON && Math.abs(t4.im - this.im) <= a3.EPSILON;
    }, clone: function() {
      return new a3(this.re, this.im);
    }, toString: function() {
      var e4 = this.re, i5 = this.im, t4 = "";
      return this.isNaN() ? "NaN" : this.isInfinite() ? "Infinity" : (Math.abs(e4) < a3.EPSILON && (e4 = 0), Math.abs(i5) < a3.EPSILON && (i5 = 0), i5 === 0 ? t4 + e4 : (e4 !== 0 ? (t4 += e4, t4 += " ", i5 < 0 ? (i5 = -i5, t4 += "-") : t4 += "+", t4 += " ") : i5 < 0 && (i5 = -i5, t4 += "-"), i5 !== 1 && (t4 += i5), t4 + "i"));
    }, toVector: function() {
      return [this.re, this.im];
    }, valueOf: function() {
      return this.im === 0 ? this.re : null;
    }, isNaN: function() {
      return isNaN(this.re) || isNaN(this.im);
    }, isZero: function() {
      return this.im === 0 && this.re === 0;
    }, isFinite: function() {
      return isFinite(this.re) && isFinite(this.im);
    }, isInfinite: function() {
      return !(this.isNaN() || this.isFinite());
    }}, a3.ZERO = new a3(0, 0), a3.ONE = new a3(1, 0), a3.I = new a3(0, 1), a3.PI = new a3(Math.PI, 0), a3.E = new a3(Math.E, 0), a3.INFINITY = new a3(1 / 0, 1 / 0), a3.NAN = new a3(NaN, NaN), a3.EPSILON = 1e-15, Object.defineProperty(a3, "__esModule", {value: true}), a3.default = a3, a3.Complex = a3, e3.exports = a3;
  }();
}(h), new c.exports.Decimal(0), new c.exports.Decimal(1), new c.exports.Decimal(-1), new c.exports.Decimal(NaN), new c.exports.Decimal(1 / 0), new c.exports.Decimal(-1 / 0), [0.9999999999998099, 676.5203681218851, -1259.1392167224028, 771.3234287776531, -176.6150291621406, 12.507343278686905, -0.13857109526572012, 9984369578019572e-21, 15056327351493116e-23].map((e3) => new c.exports.Decimal(e3)), new c.exports.Decimal(607).div(128), [0.9999999999999971, 57.15623566586292, -59.59796035547549, 14.136097974741746, -0.4919138160976202, 3399464998481189e-20, 4652362892704858e-20, -9837447530487956e-20, 1580887032249125e-19, -21026444172410488e-20, 21743961811521265e-20, -1643181065367639e-19, 8441822398385275e-20, -26190838401581408e-21, 36899182659531625e-22].map((e3) => new c.exports.Decimal(e3));
var g = "List";
var p = "Missing";
var f = "Nothing";
var m = "Add";
var d = "Divide";
var v = "Multiply";
var x = "Power";
function y(e3) {
  return e3 !== null && typeof e3 == "object" && "num" in e3;
}
function b(e3) {
  return e3 !== null && typeof e3 == "object" && "sym" in e3;
}
function w(e3) {
  return e3 !== null && typeof e3 == "object" && "fn" in e3;
}
function N(e3) {
  if (typeof e3 == "number")
    return e3;
  if (e3 === null)
    return null;
  if (y(e3))
    return e3.num.endsWith("d") || e3.num.endsWith("n") ? null : parseFloat(e3.num);
  const i3 = z(e3);
  return i3 === null ? null : i3 === "NaN" ? NaN : i3 === "+Infinity" ? 1 / 0 : i3 === "-Infinity" ? -1 / 0 : A(e3) === "Complex" && N(O(e3, 2)) === 0 ? N(O(e3, 1)) : null;
}
function q(e3) {
  return e3 === null ? null : typeof e3 == "object" && "str" in e3 ? e3.str : typeof e3 != "string" || e3.length < 2 || e3[0] !== "'" || e3[e3.length - 1] !== "'" ? null : e3.substring(1, e3.length - 1);
}
function E(e3) {
  var i3, t3, r3, n3, s3, a3;
  const o3 = z(e3);
  if (o3 === "ThreeQuarter")
    return [3, 4];
  if (o3 === "TwoThird")
    return [2, 3];
  if (o3 === "Half")
    return [1, 2];
  if (o3 === "Third")
    return [1, 3];
  if (o3 === "Quarter")
    return [1, 4];
  if (S2(e3))
    return [null, null];
  const l3 = A(e3);
  if (!l3)
    return [null, null];
  let u3 = null, c3 = null;
  if (l3 === x) {
    const r4 = N(O(e3, 2));
    r4 === 1 ? (u3 = (i3 = N(O(e3, 1))) !== null && i3 !== void 0 ? i3 : null, c3 = 1) : r4 === -1 && (u3 = 1, c3 = (t3 = N(O(e3, 1))) !== null && t3 !== void 0 ? t3 : null);
  }
  return l3 === d && (u3 = (r3 = N(O(e3, 1))) !== null && r3 !== void 0 ? r3 : null, c3 = (n3 = N(O(e3, 2))) !== null && n3 !== void 0 ? n3 : null), l3 === v && A(O(e3, 2)) === x && N(O(O(e3, 2), 2)) === -1 && (u3 = (s3 = N(O(e3, 1))) !== null && s3 !== void 0 ? s3 : null, c3 = (a3 = N(O(O(e3, 2), 1))) !== null && a3 !== void 0 ? a3 : null), u3 === null || c3 === null ? [null, null] : Number.isInteger(u3) && Number.isInteger(c3) ? [u3, c3] : [null, null];
}
function M(e3) {
  return e3 === null ? null : Array.isArray(e3) ? e3[0] : w(e3) ? e3.fn[0] : null;
}
function S2(e3) {
  return e3 === null || !Array.isArray(e3) && (typeof e3 != "object" || !("fn" in e3 || "dic" in e3));
}
function A(e3) {
  if (e3 === null)
    return "";
  const i3 = M(e3);
  return typeof i3 == "string" ? i3 : "";
}
function z(e3) {
  return e3 === null ? null : typeof e3 == "string" ? e3.length >= 2 && e3[0] === "'" && e3[e3.length - 1] === "'" ? null : e3 : b(e3) ? e3.sym : null;
}
function k(e3) {
  return Array.isArray(e3) ? e3.slice(1) : w(e3) ? e3.fn.slice(1) : [];
}
function I(e3, i3) {
  let t3 = null;
  if (Array.isArray(e3) && (t3 = e3), w(e3) && (t3 = e3.fn), t3 === null)
    return [];
  let r3 = 1;
  const n3 = [];
  for (; r3 < t3.length; )
    n3.push(i3(t3[r3])), r3 += 1;
  return n3;
}
function O(e3, i3) {
  var t3, r3;
  return e3 === null ? null : Array.isArray(e3) ? (t3 = e3[i3]) !== null && t3 !== void 0 ? t3 : null : w(e3) && (r3 = e3.fn[i3]) !== null && r3 !== void 0 ? r3 : null;
}
function L(e3) {
  return Array.isArray(e3) ? Math.max(0, e3.length - 1) : w(e3) ? Math.max(0, e3.fn.length - 1) : 0;
}
function P(e3) {
  return typeof e3 == "object" && "dict" in e3 ? e3.dict : null;
}
var D2 = [{name: "Overscript", trigger: {infix: "\\overset"}, precedence: 700}, {name: "Underscript", trigger: {infix: "\\underset"}, precedence: 700}, {name: "Increment", trigger: {postfix: ["+", "+"]}, precedence: 880}, {name: "Decrement", trigger: {postfix: ["-", "-"]}, precedence: 880}, {name: "PreIncrement", trigger: {prefix: ["+", "+"]}, precedence: 880}, {name: "PreDecrement", trigger: {prefix: ["-", "-"]}, precedence: 880}, {name: "Ring", trigger: {infix: "\\circ"}, precedence: 265}, {name: "Transpose", trigger: {superfix: "T"}}, {name: "ConjugateTranspose", trigger: {superfix: "H"}}, {name: "StringJoin", trigger: {infix: ["\\lt", "\\gt"]}, precedence: 780}, {name: "Starstar", trigger: {infix: ["\\star", "\\star"]}, precedence: 780}, {name: "PartialDerivative", trigger: {prefix: "\\partial"}, parse: (e3, i3, t3) => {
  var r3, n3;
  let s3 = false, a3 = f, o3 = f;
  for (; !s3; )
    i3.skipSpace(), i3.match("_") ? o3 = i3.matchRequiredLatexArgument() : i3.match("^") ? a3 = i3.matchRequiredLatexArgument() : s3 = true;
  if (A(o3) === "Sequence" && (o3 = [g, ...k(o3)]), !o3 || !a3)
    return [e3, null];
  let l3 = (r3 = i3.matchRequiredLatexArgument()) !== null && r3 !== void 0 ? r3 : f;
  return l3 !== f && (l3 = [l3, ...(n3 = i3.matchArguments("group")) !== null && n3 !== void 0 ? n3 : f]), [null, ["PartialDerivative", l3, o3, a3]];
}, serialize: (e3, i3) => {
  let t3 = "\\partial";
  const r3 = O(i3, 1), n3 = O(i3, 2), s3 = O(i3, 3);
  return n3 !== null && n3 !== f && (M(n3) === g ? t3 += "_{" + e3.serialize(["Sequence", ...k(n3)]) + "}" : t3 += "_{" + e3.serialize(n3) + "}"), s3 !== null && s3 !== f && (t3 += "^{" + e3.serialize(s3) + "}"), r3 !== null && r3 !== f && (t3 += e3.serialize(r3)), t3;
}, precedence: 740}, {name: "OverBar", trigger: {symbol: "\\overline"}, requiredLatexArg: 1}, {name: "UnderBar", trigger: {symbol: "\\underline"}, requiredLatexArg: 1}, {name: "OverVector", trigger: {symbol: "\\vec"}, requiredLatexArg: 1}, {name: "OverTile", trigger: {symbol: "\\tilde"}, requiredLatexArg: 1}, {name: "OverHat", trigger: {symbol: "\\hat"}, requiredLatexArg: 1}, {name: "OverHat", trigger: {symbol: "\\hat"}, requiredLatexArg: 1}, {name: "OverRightArrow", trigger: {symbol: "\\overrightarrow"}, requiredLatexArg: 1}, {name: "OverLeftArrow", trigger: {symbol: "\\overleftarrow"}, requiredLatexArg: 1}, {name: "OverRightDoubleArrow", trigger: {symbol: "\\Overrightarrow"}, requiredLatexArg: 1}, {name: "OverLeftHarpoon", trigger: {symbol: "\\overleftharpoon"}, requiredLatexArg: 1}, {name: "OverRightHarpoon", trigger: {symbol: "\\overrightharpoon"}, requiredLatexArg: 1}, {name: "OverLeftRightArrow", trigger: {symbol: "\\overleftrightarrow"}, requiredLatexArg: 1}, {name: "OverBrace", trigger: {symbol: "\\overbrace"}, requiredLatexArg: 1}, {name: "OverLineSegment", trigger: {symbol: "\\overlinesegment"}, requiredLatexArg: 1}, {name: "OverGroup", trigger: {symbol: "\\overgroup"}, requiredLatexArg: 1}];
function F(e3, i3) {
  return i3 > 2 ? "solidus" : "radical";
}
function T2(e3) {
  return e3 === "<space>" || e3 === "\\qquad" || e3 === "\\quad" || e3 === "\\enskip" || e3 === "\\;" || e3 === "\\," || e3 === "\\ " || e3 === "~";
}
function C(e3, i3, t3) {
  return (r3, n3, s3) => {
    if (s3 >= i3)
      return [r3, null];
    n3.skipSpace(), n3.match(t3), r3 === "Missing" && (r3 = f);
    const a3 = [e3, r3 != null ? r3 : f];
    let o3 = false;
    for (; !o3; ) {
      for (o3 = true, n3.skipSpace(); n3.match(t3); )
        a3.push(f), n3.skipSpace();
      if (n3.atEnd)
        a3.push(f);
      else {
        const e4 = n3.matchExpression(i3);
        a3.push(e4 != null ? e4 : f), o3 = e4 === null;
      }
      o3 || (n3.skipSpace(), o3 = !n3.match(t3));
    }
    return [null, a3];
  };
}
function R(e3) {
  return (i3, t3) => k(t3).map((e4) => i3.serialize(e4)).join(e3);
}
var $ = [{name: "LatexTokens", serialize: function(e3, i3) {
  return k(i3).map((i4) => {
    const t3 = q(i4);
    return t3 === null ? e3.serialize(i4) : t3 === "<{>" ? "{" : t3 === "<}>" ? "}" : t3 === "<$>" ? "$" : t3 === "<$$>" ? "$$" : t3 === "<space>'" ? " " : t3;
  }).join("");
}}, {name: "Parentheses", trigger: {matchfix: "("}, parse: (e3, i3, t3) => {
  var r3;
  const n3 = i3.index;
  if (!i3.match("("))
    return [e3, null];
  let s3 = false, a3 = true, o3 = false, l3 = 0, u3 = "";
  for (; !s3 && a3; ) {
    const e4 = i3.next();
    i3.atEnd || e4 === ")" ? s3 = true : e4 === "\\mathtt" ? (i3.match("<{>"), o3 = true) : T2(e4) || (/^[0-9a-zA-Z]$/.test(e4) ? (l3 = Math.max(l3, parseInt(e4, 36)), u3 += e4) : a3 = false), o3 && i3.match("<}>");
  }
  if (i3.skipSpace(), a3 && i3.match("_")) {
    const t4 = (r3 = N(i3.matchRequiredLatexArgument())) !== null && r3 !== void 0 ? r3 : NaN;
    return !isFinite(t4) || t4 < 2 || t4 > 36 || l3 >= t4 ? (i3.onError({code: "base-out-of-range"}), [e3, f]) : [e3, ["BaseForm", parseInt(u3, t4), t4]];
  }
  i3.index = n3;
  const c3 = i3.matchBalancedExpression("(", ")", i3.onError);
  return c3 ? A(c3) === "Sequence" ? [e3, ["Parentheses", ...k(c3)]] : [e3, ["Parentheses", c3]] : [e3, ["Parentheses"]];
}, serialize: (e3, i3) => e3.wrapString(R(",")(e3, i3), (e3.level, "paren")), separator: ",", closeFence: ")", precedence: 20}, {name: g, trigger: {matchfix: "\\lbrack"}, separator: ",", closeFence: "\\rbrack", precedence: 20, parse: (e3, i3, t3) => {
  if (e3 === null) {
    const t4 = i3.matchBalancedExpression("\\lbrack", "\\rbrack", i3.onError);
    return t4 ? A(t4) === "Sequence" ? [e3, [g, ...k(t4)]] : [e3, [g, t4]] : [null, [g]];
  }
  return [e3, null];
}}, {name: "BaseForm", serialize: (e3, i3) => {
  var t3, r3;
  const n3 = (t3 = N(O(i3, 2))) !== null && t3 !== void 0 ? t3 : NaN;
  if (isFinite(n3) && n3 >= 2 && n3 <= 36) {
    const e4 = (r3 = N(O(i3, 1))) !== null && r3 !== void 0 ? r3 : NaN;
    if (isFinite(e4)) {
      let i4 = Number(e4).toString(n3), t4 = 0;
      if (n3 === 2 || n3 === 10 ? t4 = 4 : n3 === 16 ? t4 = 2 : n3 > 16 && (t4 = 4), t4 > 0) {
        const e5 = i4;
        i4 = "";
        for (let r4 = 0; r4 < e5.length; r4++)
          r4 > 0 && r4 % t4 == 0 && (i4 = "\\, " + i4), i4 = e5[e5.length - r4 - 1] + i4;
      }
      return `(\\mathtt{${i4}})_{${n3}}`;
    }
  }
  return "\\operatorname{BaseForm}(" + e3.serialize(O(i3, 1)) + ", " + e3.serialize(O(i3, 2)) + ")";
}}, {name: "Set", trigger: {matchfix: "\\lbrace"}, separator: ",", closeFence: "\\rbrace", precedence: 20}, {name: "Sequence", trigger: {infix: ","}, parse: C("Sequence", 20, ","), serialize: R(", "), precedence: 20}, {name: "Sequence2", trigger: {infix: ";"}, parse: C("Sequence2", 19, ";"), serialize: R("; "), precedence: 19}, {name: p, trigger: "\\placeholder", serialize: "\\placeholder", requiredLatexArg: 1}, {name: "Subscript", trigger: {infix: "_"}, precedence: 720, serialize: (e3, i3) => L(i3) === 2 ? e3.serialize(O(i3, 1)) + "_{" + e3.serialize(O(i3, 2)) + "}" : "_{" + e3.serialize(O(i3, 1)) + "}", parse: (e3, i3, t3) => {
  var r3;
  if (!i3.match("_"))
    return [e3, null];
  const n3 = (r3 = i3.matchRequiredLatexArgument()) !== null && r3 !== void 0 ? r3 : p;
  return e3 ? [null, ["Subscript", e3, n3]] : [null, ["Subscript", n3]];
}}, {name: "Superplus", trigger: {superfix: "+"}}, {name: "Subplus", trigger: {subfix: "+"}}, {name: "Superminus", trigger: {superfix: "-"}}, {name: "Subminus", trigger: {subfix: "-"}}, {name: "Superstar", trigger: {superfix: "*"}}, {name: "Superstar", trigger: {superfix: "\\star"}}, {name: "Substar", trigger: {subfix: "*"}}, {name: "Substar", trigger: {subfix: "\\star"}}, {name: "Superdagger", trigger: {superfix: "\\dagger"}}, {name: "Superdagger", trigger: {superfix: "\\dag"}}, {name: "Prime", trigger: {superfix: "\\prime"}, arguments: "group"}, {trigger: {superfix: "\\doubleprime"}, parse: (e3, i3) => [null, ["Prime", e3 != null ? e3 : f, 2]], arguments: "group"}, {name: "InverseFunction", serialize: (e3, i3) => e3.serialize(O(i3, 1)) + "^{-1}"}, {name: "Derivative", trigger: "D", parse: (e3, i3) => [e3, ["Derivative", 1]], serialize: (e3, i3) => {
  var t3;
  const r3 = (t3 = N(O(i3, 1))) !== null && t3 !== void 0 ? t3 : NaN;
  if (!isFinite(r3))
    return "";
  const n3 = e3.serialize(O(i3, 2));
  return r3 === 1 ? n3 + "^{\\prime}" : r3 === 2 ? n3 + "^{\\doubleprime}" : n3 + "^{(" + Number(r3).toString() + ")}";
}}, {name: "Piecewise", trigger: {environment: "cases"}, parse: (e3, i3) => {
  var t3;
  return [e3, ["Piecewise", (t3 = i3.matchTabular()) !== null && t3 !== void 0 ? t3 : f]];
}, serialize: (e3, i3) => {
  if (A(O(i3, 1)) !== g)
    return "";
  const t3 = k(O(i3, 1));
  let r3 = "", n3 = "";
  for (const i4 of t3) {
    r3 += n3;
    const t4 = O(i4, 1);
    if (t4 !== null) {
      r3 += e3.serialize(t4);
      const n4 = O(i4, 2);
      n4 !== null && (r3 += "&" + e3.serialize(n4));
    }
    n3 = "\\\\";
  }
  return "\\begin{cases}" + r3 + "\\end{cases}";
}}];
function Z(e3) {
  var i3, t3, r3, n3;
  if (typeof (e3 = B(e3)) == "number")
    return -e3;
  if (e3 && y(e3))
    return e3.num[0] === "-" ? {num: e3.num.slice(1)} : e3.num[0] === "+" ? {num: "-" + e3.num.slice(1)} : {num: "-" + e3.num};
  if (e3 instanceof c.exports.Decimal)
    return e3.mul(-1);
  if (e3 instanceof h.exports.Complex)
    return e3.mul(-1);
  const s3 = A(e3), a3 = L(e3);
  if (s3 === "Negate" && a3 === 1)
    return (i3 = O(e3, 1)) !== null && i3 !== void 0 ? i3 : p;
  if (s3 === v) {
    const i4 = Z((t3 = O(e3, 1)) !== null && t3 !== void 0 ? t3 : p);
    return [v, i4, ...k(e3).slice(1)];
  }
  return s3 === m ? [m, ...I(e3, Z)] : s3 === "Subtract" ? ["Subtract", (r3 = O(e3, 2)) !== null && r3 !== void 0 ? r3 : p, (n3 = O(e3, 1)) !== null && n3 !== void 0 ? n3 : p] : s3 === "Parentheses" && a3 === 1 ? Z(O(O(e3, 1), 1)) : ["Negate", e3 != null ? e3 : p];
}
function B(e3) {
  return e3 === null ? f : S2(e3) ? e3 : M(e3) === "Parentheses" && L(e3) === 1 ? B(O(e3, 1)) : function(e4, i3) {
    const t3 = M(e4);
    if (t3 !== null)
      return [i3(t3), ...k(e4).map(i3)];
    const r3 = P(e4);
    if (r3 !== null) {
      const e5 = Object.keys(r3), t4 = {};
      for (const n3 of e5)
        t4[n3] = i3(r3[n3]);
      return {dict: t4};
    }
    return i3(e4);
  }(e3, B);
}
function _(e3, i3, t3, r3) {
  return t3 === null ? "\\sqrt{}" : (r3 = r3 != null ? r3 : 2, i3 === "solidus" ? e3.wrapShort(t3) + "^{1\\/" + e3.serialize(r3) + "}" : i3 === "quotient" ? e3.wrapShort(t3) + "^{\\frac{1}{" + e3.serialize(r3) + "}}" : N(r3) === 2 ? "\\sqrt{" + e3.serialize(t3) + "}" : "\\sqrt[" + e3.serialize(r3) + "]{" + e3.serialize(t3) + "}");
}
function U(e3, i3, t3) {
  if (!i3.match("\\sqrt"))
    return [e3, null];
  const r3 = i3.matchOptionalLatexArgument(), n3 = i3.matchRequiredLatexArgument();
  return n3 === null ? r3 !== null ? [e3, ["Root", f, r3]] : [e3, ["Sqrt"]] : r3 !== null ? [e3, ["Root", n3, r3]] : [e3, ["Sqrt", n3]];
}
function j(e3, i3, t3) {
  if (276 < t3)
    return [e3, null];
  const r3 = i3.index;
  if (!i3.match("-"))
    return [e3, null];
  const n3 = i3.matchExpression(e3 === null ? 400 : 277);
  return n3 === null ? (i3.index = r3, [e3, null]) : e3 === null ? [null, ["Negate", n3]] : [null, ["Subtract", e3, n3]];
}
function H(e3, i3) {
  var t3;
  if (i3 === null)
    return "";
  e3.level -= 1;
  let r3 = "";
  const [n3, s3] = function(e4) {
    var i4, t4, r4, n4, s4, a3;
    if (A(e4) !== v)
      return [[], []];
    const o4 = [], l4 = [], u4 = k(e4);
    for (const e5 of u4)
      if (A(e5) === x)
        if (A(O(e5, 2)) === "Negate") {
          const r5 = (i4 = O(e5, 1)) !== null && i4 !== void 0 ? i4 : f, n5 = (t4 = O(O(e5, 2), 1)) !== null && t4 !== void 0 ? t4 : f;
          l4.push([x, r5, n5]);
        } else {
          const i5 = (r4 = N(O(e5, 2))) !== null && r4 !== void 0 ? r4 : NaN;
          i5 === -1 ? l4.push((n4 = O(e5, 1)) !== null && n4 !== void 0 ? n4 : f) : i5 < 0 ? l4.push([x, (s4 = O(e5, 1)) !== null && s4 !== void 0 ? s4 : f, (a3 = Z(O(e5, 2))) !== null && a3 !== void 0 ? a3 : f]) : o4.push(e5);
        }
      else
        o4.push(e5);
    return [o4, l4];
  }(i3);
  if (s3.length > 0 && (r3 = s3.length === 1 && s3[0] === 1 ? n3.length === 0 ? "1" : n3.length === 1 ? e3.serialize(n3[0]) : H(e3, [v, ...n3]) : e3.serialize([d, n3.length === 1 ? n3[0] : [v, ...n3], s3.length === 1 ? s3[0] : [v, ...s3]])), r3)
    return e3.level += 1, r3;
  let o3 = false, l3 = null;
  const u3 = L(i3) + 1;
  let c3 = false;
  for (let n4 = 1; n4 < u3; n4++)
    if (l3 = O(i3, n4), l3 !== null) {
      let i4;
      typeof l3 == "number" || y(l3) ? (i4 = e3.serialize(l3), i4 !== "-1" || r3 ? (i4[0] === "-" && (i4 = i4.slice(1), o3 = !o3), r3 = r3 ? a([r3, e3.options.multiply, i4]) : i4) : r3 = "-", c3 = true) : A(l3) !== x || isNaN((t3 = N(O(l3, 1))) !== null && t3 !== void 0 ? t3 : NaN) ? (A(l3) === "Negate" && (l3 = O(l3, 1), o3 = !o3), i4 = e3.wrap(l3, 390), r3 = r3 ? c3 && A(l3) === d ? a([r3, "\\times", i4]) : e3.options.invisibleMultiply ? a([r3, e3.options.invisibleMultiply, i4]) : a([r3, i4]) : i4, c3 = false) : (r3 = r3 ? a([r3, e3.options.multiply, e3.serialize(l3)]) : e3.serialize(l3), c3 = true);
    }
  return e3.level += 1, o3 ? "-" + r3 : r3;
}
function G(e3, i3) {
  if (i3 === null)
    return "";
  if (L(i3) === 1)
    return e3.serialize(O(i3, 1));
  const t3 = e3.level > 3 ? "inline-solidus" : "quotient";
  if (t3 === "inline-solidus" || t3 === "nice-solidus") {
    const r3 = e3.wrapShort(O(i3, 1)), n3 = e3.wrapShort(O(i3, 2));
    return t3 === "nice-solidus" ? `^{${r3}}\\!\\!/\\!_{${n3}}` : `${r3}\\/${n3}`;
  }
  return t3 === "reciprocal" ? e3.wrap(O(i3, 1)) + e3.wrap(O(i3, 2)) + "^{-1}" : t3 === "factor" ? "\\frac{1}{" + e3.serialize(O(i3, 2)) + "}" + e3.wrap(O(i3, 1)) : "\\frac{" + e3.serialize(O(i3, 1)) + "}{" + e3.serialize(O(i3, 2)) + "}";
}
function W(e3, i3) {
  var t3;
  const r3 = O(i3, 1), n3 = O(i3, 2);
  if (n3 === null)
    return e3.serialize(r3);
  if (r3 === null)
    return "";
  const s3 = A(i3);
  if (s3 === "Sqrt" || s3 === "Root")
    return _(e3, F(0, e3.level), O(i3, 1), O(i3, 2));
  const a3 = (t3 = N(n3)) !== null && t3 !== void 0 ? t3 : 1;
  if (a3 === -1)
    return e3.serialize([d, "1", r3]);
  if (a3 < 0)
    return e3.serialize([d, "1", [x, r3, -a3]]);
  if (A(n3) === d) {
    if (N(O(n3, 1)) === 1)
      return _(e3, F(0, e3.level), r3, O(n3, 2));
  } else if (A(n3) === x && N(O(n3, 2)) === -1)
    return _(e3, F(0, e3.level), r3, O(n3, 1));
  return e3.wrapShort(r3) + "^{" + e3.serialize(n3) + "}";
}
function V(e3, i3, t3) {
  var r3;
  const n3 = i3.next();
  let s3 = false, a3 = 0;
  if (i3.skipSpace(), i3.match("^")) {
    if (i3.skipSpace(), i3.match("<{>")) {
      i3.skipSpace(), i3.match("-") && i3.match("1") && (s3 = true);
      do {
        i3.match("\\doubleprime") && (a3 += 2), i3.match("\\prime") && (a3 += 1), i3.match("'") && (a3 += 1);
      } while (!i3.match("<}>") && !i3.atEnd);
    }
    let e4 = false;
    for (; !e4; )
      i3.skipSpace(), i3.match("\\doubleprime") ? a3 += 2 : i3.match("\\prime") || i3.match("'") ? a3 += 1 : e4 = true;
  }
  let o3 = (r3 = {"\\arcsin": "Arcsin", "\\arccos": "Arccos", "\\arctan": "Arctan", "\\arctg": "Arctan", "\\arcctg": "Arctan", "\\arcsec": "Arcsec", "\\arccsc": " Arccsc", "\\arsinh": "Arsinh", "\\arcosh": "Arcosh", "\\artanh": "Artanh", "\\arcsech": "Arcsech", "\\arccsch": "Arcsch", "\\ch": "Cosh", "\\cos": "Cos", "\\cosec": "Csc", "\\cosh": "Csch", "\\cot": "Cot", "\\cotg": "Cot", "\\coth": "Coth", "\\csc": "Csc", "\\ctg": "Cot", "\\cth": "Coth", "\\sec": "Sec", "\\sin": "Sin", "\\sinh": "Sinh", "\\sh": "Sinh", "\\tan": "Tan", "\\tanh": "Tanh", "\\tg": "Tan", "\\th": "Tanh"}[n3]) !== null && r3 !== void 0 ? r3 : n3;
  s3 && (o3 = ["InverseFunction", o3]), a3 >= 1 && (o3 = ["Derivative", a3, o3]);
  const l3 = i3.matchArguments("implicit");
  return l3 === null ? [null, o3] : [null, [o3, ...l3]];
}
function Q(e3) {
  return o(e3);
}
Number.EPSILON.toString();
var Y = {algebra: [{name: "To", trigger: {infix: "\\to"}, precedence: 270}], arithmetic: [{name: "ThreeQuarter", serialize: "\\frac{3}{4}"}, {name: "TwoThird", serialize: "\\frac{2}{3}"}, {name: "Half", serialize: "\\frac{1}{2}"}, {name: "Third", serialize: "\\frac{1}{3}"}, {name: "Quarter", serialize: "\\frac{1}{4}"}, {name: "CatalanConstant", serialize: "G"}, {name: "GoldenRatio", serialize: "\\varphi"}, {name: "EulerGamma", serialize: "\\gamma"}, {name: "Degrees", serialize: "\\frac{\\pi}{180}"}, {name: "MinusDoublePi", serialize: "-2\\pi"}, {name: "MinusPi", serialize: "-\\pi"}, {name: "MinusHalfPi", serialize: "-\\frac{\\pi}{2}"}, {name: "QuarterPi", serialize: "\\frac{\\pi}{4}"}, {name: "ThirdPi", serialize: "\\frac{\\pi}{3}"}, {name: "HalfPi", serialize: "\\frac{\\pi}{2}"}, {name: "TwoThirdPi", serialize: "\\frac{2\\pi}{3}"}, {name: "ThreeQuarterPi", serialize: "\\frac{3\\pi}{4}"}, {name: "DoublePi", serialize: "2\\pi"}, {name: "Complex", precedence: 275, serialize: (e3, i3) => {
  const t3 = N(O(i3, 1)), r3 = N(O(i3, 2));
  if (r3 === 0)
    return e3.serialize(O(i3, 1));
  const n3 = r3 === 1 ? "\\imaginaryI" : r3 === -1 ? "-\\imaginaryI" : a([e3.serialize(O(i3, 2)), "\\imaginaryI"]);
  return t3 === 0 ? n3 : a([e3.serialize(O(i3, 1)), "+", n3]);
}}, {name: "Exp", serialize: (e3, i3) => {
  var t3;
  return a(["\\exponentialE^{", e3.serialize((t3 = O(i3, 1)) !== null && t3 !== void 0 ? t3 : f), "}"]);
}}, {name: "Square", serialize: (e3, i3) => e3.wrapShort(O(i3, 1)) + "^2"}, {trigger: {symbol: "\\infty"}, parse: {num: "+Infinity"}}, {name: "ComplexInfinity", trigger: {symbol: ["\\tilde", "\\infty"]}, serialize: "\\tilde\\infty"}, {name: "ComplexInfinity", trigger: {symbol: ["\\tilde", "<{>", "\\infty", "<}>"]}, serialize: "\\tilde\\infty"}, {name: "Pi", trigger: {symbol: "\\pi"}}, {name: "Pi", trigger: {symbol: "\u03C0"}, serialize: "\\pi"}, {name: "ExponentialE", trigger: {symbol: "e"}, serialize: "e"}, {name: "ImaginaryUnit", trigger: {symbol: "i"}, serialize: "\\imaginaryI"}, {name: "ImaginaryUnit", trigger: {symbol: "\\imaginaryI"}}, {name: m, trigger: {prefix: "+", infix: "+"}, parse: function(e3, i3, t3) {
  if (275 < t3)
    return [e3, null];
  const r3 = i3.index;
  if (!i3.match("+"))
    return [e3, null];
  const n3 = i3.matchExpression(e3 === null ? 400 : 275);
  return n3 === null ? (i3.index = r3, [e3, null]) : e3 === null ? [null, n3] : i3.applyOperator(m, e3, n3);
}, serialize: function(e3, i3) {
  var t3, r3;
  e3.level -= 1;
  const n3 = A(i3);
  let s3 = "", a3 = O(i3, 1), o3 = !Number.isNaN((t3 = N(a3)) !== null && t3 !== void 0 ? t3 : NaN);
  if (n3 === "Negate")
    s3 = "-" + e3.wrap(a3, 276);
  else if (n3 === m) {
    s3 = e3.serialize(a3);
    const t4 = L(i3) + 1;
    for (let n4 = 2; n4 < t4; n4++) {
      a3 = O(i3, n4);
      const t5 = (r3 = N(a3)) !== null && r3 !== void 0 ? r3 : NaN, l3 = !Number.isNaN(t5);
      let u3 = false;
      if (a3 !== null && o3) {
        const [i4, t6] = E(a3);
        i4 !== null && t6 !== null && isFinite(i4) && isFinite(t6) && t6 !== 1 && (s3 += e3.options.invisiblePlus + e3.serialize(a3), u3 = true);
      }
      if (!u3)
        if (t5 < 0)
          s3 += e3.serialize(a3);
        else if (A(a3) === "Negate")
          s3 += e3.wrap(a3, 275);
        else {
          const i4 = e3.wrap(a3, 275);
          i4[0] === "-" || i4[0] === "+" ? s3 += i4 : s3 = s3 + "+" + i4;
        }
      o3 = l3;
    }
  } else if (n3 === "Subtract") {
    const t4 = O(i3, 2);
    s3 = t4 !== null ? e3.wrap(a3, 275) + "-" + e3.wrap(t4, 275) : e3.wrap(a3, 275);
  }
  return e3.level += 1, s3;
}, associativity: "both", precedence: 275}, {name: "Negate", trigger: {prefix: "-"}, parse: j, associativity: "left", precedence: 275}, {name: "Subtract", trigger: {infix: "-"}, parse: j, associativity: "both", precedence: 275}, {name: "PlusMinus", trigger: {infix: "\\pm"}, associativity: "both", precedence: 270}, {name: "MinusPlus", trigger: {infix: "\\mp"}, associativity: "both", precedence: 270}, {name: v, trigger: {infix: "\\times"}, serialize: H, associativity: "both", precedence: 390}, {name: v, trigger: {infix: "\\cdot"}, serialize: H, associativity: "both", precedence: 390}, {name: v, trigger: {infix: "*"}, serialize: H, associativity: "both", precedence: 390}, {name: d, trigger: "\\frac", parse: function(e3, i3, t3) {
  var r3, n3, s3, a3;
  if (!i3.match("\\frac"))
    return [e3, null];
  const o3 = (r3 = i3.matchRequiredLatexArgument()) !== null && r3 !== void 0 ? r3 : p, l3 = (n3 = i3.matchRequiredLatexArgument()) !== null && n3 !== void 0 ? n3 : p;
  if (A(o3) === "PartialDerivative" && (A(l3) === "PartialDerivative" || A(l3) === v && A(O(l3, 1)) === "PartialDerivative")) {
    const t4 = (s3 = O(o3, 3)) !== null && s3 !== void 0 ? s3 : f;
    let r4 = O(o3, 1);
    r4 !== null && r4 !== f || (r4 = (a3 = i3.matchExpression()) !== null && a3 !== void 0 ? a3 : f);
    let n4 = [];
    if (A(l3) === v) {
      for (const e4 of k(l3))
        if (M(e4) === "PartialDerivative") {
          const i4 = O(e4, 2);
          i4 && n4.push(i4);
        }
    } else {
      const e4 = O(l3, 2);
      e4 && n4.push(e4);
    }
    return n4.length > 1 && (n4 = [g, ...n4]), [e3, ["PartialDerivative", r4, n4, t4 === f ? 1 : t4]];
  }
  return [e3, [d, o3, l3]];
}, serialize: G, requiredLatexArg: 2}, {name: d, trigger: {infix: "\\/"}, serialize: G, associativity: "non", precedence: 660}, {name: d, trigger: {infix: "/"}, serialize: G, associativity: "non", precedence: 660}, {name: d, trigger: {infix: "\\div"}, serialize: G, associativity: "non", precedence: 660}, {name: x, trigger: {infix: "^"}, associativity: "non", precedence: 720, serialize: W}, {name: x, trigger: {infix: ["*", "*"]}, associativity: "non", precedence: 720, serialize: W}, {name: "Sqrt", trigger: "\\sqrt", optionalLatexArg: 1, requiredLatexArg: 1, parse: U, serialize: W}, {name: "Root", trigger: "\\sqrt", optionalLatexArg: 1, requiredLatexArg: 1, parse: U}, {name: "Norm", trigger: {matchfix: "\\lVert"}, closeFence: "\\rVert"}, {name: "Norm", trigger: {matchfix: "\\|"}, closeFence: "\\|"}, {name: "Norm", trigger: {matchfix: ["|", "|"]}, closeFence: ["|", "|"]}, {name: "Abs", trigger: {matchfix: "|"}, closeFence: "|"}, {name: "Abs", trigger: {matchfix: "\\lvert"}, closeFence: "\\rvert"}, {name: "Factorial", trigger: {postfix: "!"}, precedence: 810}, {name: "Factorial2", trigger: {postfix: ["!", "!"]}, precedence: 810}, {name: "Lcm", trigger: {symbol: ["\\operatorname", "<{>", "l", "c", "m", "<}>"]}}, {name: "Gcd", trigger: {symbol: ["\\operatorname", "<{>", "g", "c", "d", "<}>"]}}, {name: "Ceil", trigger: {symbol: ["\\operatorname", "<{>", "c", "e", "i", "l", "<}>"]}}, {name: "Floor", trigger: {symbol: ["\\operatorname", "<{>", "f", "l", "o", "o", "r", "<}>"]}}, {name: "Round", trigger: {symbol: ["\\operatorname", "<{>", "r", "o", "u", "n", "d", "<}>"]}}, {name: "Sign", trigger: {symbol: ["\\operatorname", "<{>", "s", "g", "n", "<}>"]}}], calculus: [{trigger: {symbol: "\\int"}, parse: function(e3, i3, t3) {
  if (!i3.match("\\int"))
    return [e3, null];
  let r3 = f, n3 = f, s3 = false;
  for (; !s3; )
    i3.skipSpace(), i3.match("_") ? n3 = i3.matchRequiredLatexArgument() : i3.match("^") ? r3 = i3.matchRequiredLatexArgument() : s3 = true;
  const a3 = i3.matchBalancedExpression("<{>", "<}>");
  return [e3, ["Integral", a3 != null ? a3 : "", r3 != null ? r3 : f, n3 != null ? n3 : f]];
}, serialize: function(e3, i3) {
  return "";
}}], core: $, inequalities: [{name: "NotLess", trigger: {infix: ["!", "<"]}, associativity: "right", precedence: 246}, {name: "NotLess", trigger: {infix: "\\nless"}, associativity: "right", precedence: 246}, {name: "Less", trigger: {infix: "<"}, associativity: "right", precedence: 245}, {name: "Less", trigger: {infix: "\\lt"}, associativity: "right", precedence: 245}, {name: "LessEqual", trigger: {infix: ["<", "="]}, associativity: "right", precedence: 241}, {name: "LessEqual", trigger: {infix: "\\le"}, associativity: "right", precedence: 241}, {name: "LessEqual", trigger: {infix: "\\leq"}, associativity: "right", precedence: 241}, {name: "LessEqual", trigger: {infix: "\\leqslant"}, associativity: "right", precedence: 265}, {name: "LessNotEqual", trigger: {infix: "\\lneqq"}, associativity: "right", precedence: 260}, {name: "NotLessNotEqual", trigger: {infix: "\\nleqq"}, associativity: "right", precedence: 260}, {name: "LessOverEqual", trigger: {infix: "\\leqq"}, associativity: "right", precedence: 265}, {name: "GreaterOverEqual", trigger: {infix: "\\geqq"}, associativity: "right", precedence: 265}, {name: "Equal", trigger: {infix: "="}, associativity: "right", precedence: 260}, {name: "StarEqual", trigger: {infix: ["*", "="]}, associativity: "right", precedence: 260}, {name: "StarEqual", trigger: {infix: ["\\star", "="]}, associativity: "right", precedence: 260}, {name: "PlusEqual", trigger: {infix: ["+", "="]}, associativity: "right", precedence: 260}, {name: "MinusEqual", trigger: {infix: ["-", "="]}, associativity: "right", precedence: 260}, {name: "SlashEqual", trigger: {infix: ["/", "="]}, associativity: "right", precedence: 260}, {name: "EqualEqual", trigger: {infix: ["=", "="]}, associativity: "right", precedence: 260}, {name: "EqualEqualEqual", trigger: {infix: ["=", "=", "="]}, associativity: "right", precedence: 265}, {name: "TildeFullEqual", trigger: {infix: "\\cong"}, associativity: "right", precedence: 260}, {name: "NotTildeFullEqual", trigger: {infix: "\\ncong"}, associativity: "right", precedence: 260}, {name: "Assign", trigger: {infix: [":", "="]}, associativity: "right", precedence: 260}, {name: "Assign", trigger: {infix: "\\coloneq"}, associativity: "right", precedence: 260}, {name: "Approx", trigger: {infix: "\\approx"}, associativity: "right", precedence: 247}, {name: "NotApprox", trigger: {infix: "\\approx"}, associativity: "right", precedence: 247}, {name: "ApproxEqual", trigger: {infix: "\\approxeq"}, associativity: "right", precedence: 260}, {name: "NotApproxEqual", trigger: {infix: ["!", "\\approxeq"]}, associativity: "right", precedence: 250}, {name: "NotEqual", trigger: {infix: "\\ne"}, associativity: "right", precedence: 255}, {name: "Unequal", trigger: {infix: ["!", "="]}, associativity: "right", precedence: 260}, {name: "GreaterEqual", trigger: {infix: "\\ge"}, associativity: "right", precedence: 242}, {name: "GreaterEqual", trigger: {infix: "\\geq"}, associativity: "right", precedence: 242}, {name: "GreaterEqual", trigger: {infix: [">", "="]}, associativity: "right", precedence: 243}, {name: "GreaterEqual", trigger: {infix: "\\geqslant"}, associativity: "right", precedence: 265}, {name: "GreaterNotEqual", trigger: {infix: "\\gneqq"}, associativity: "right", precedence: 260}, {name: "NotGreaterNotEqual", trigger: {infix: "\\ngeqq"}, associativity: "right", precedence: 260}, {name: "Greater", trigger: {infix: ">"}, associativity: "right", precedence: 245}, {name: "Greater", trigger: {infix: "\\gt"}, associativity: "right", precedence: 245}, {name: "NotGreater", trigger: {infix: "\\ngtr"}, associativity: "right", precedence: 244}, {name: "NotGreater", trigger: {infix: ["!", ">"]}, associativity: "right", precedence: 244}, {name: "RingEqual", trigger: {infix: "\\circeq"}, associativity: "right", precedence: 260}, {name: "TriangleEqual", trigger: {infix: "\\triangleq"}, associativity: "right", precedence: 260}, {name: "DotEqual", trigger: {infix: "\\doteq"}, associativity: "right", precedence: 265}, {name: "DotEqualDot", trigger: {infix: "\\doteqdot"}, associativity: "right", precedence: 265}, {name: "FallingDotEqual", trigger: {infix: "\\fallingdotseq"}, associativity: "right", precedence: 265}, {name: "RisingDotEqual", trigger: {infix: "\\fallingdotseq"}, associativity: "right", precedence: 265}, {name: "QuestionEqual", trigger: {infix: "\\questeq"}, associativity: "right", precedence: 260}, {name: "Equivalent", trigger: {infix: "\\equiv"}, associativity: "right", precedence: 260}, {name: "MuchLess", trigger: {infix: "\\ll"}, associativity: "right", precedence: 260}, {name: "MuchGreater", trigger: {infix: "\\gg"}, associativity: "right", precedence: 260}, {name: "Precedes", trigger: {infix: "\\prec"}, associativity: "right", precedence: 260}, {name: "Succeeds", trigger: {infix: "\\succ"}, associativity: "right", precedence: 260}, {name: "PrecedesEqual", trigger: {infix: "\\preccurlyeq"}, associativity: "right", precedence: 260}, {name: "SucceedsEqual", trigger: {infix: "\\curlyeqprec"}, associativity: "right", precedence: 260}, {name: "NotPrecedes", trigger: {infix: "\\nprec"}, associativity: "right", precedence: 260}, {name: "NotSucceeds", trigger: {infix: "\\nsucc"}, associativity: "right", precedence: 260}, {name: "Between", trigger: {infix: "\\between"}, associativity: "right", precedence: 265}], other: D2, physics: [{name: "mu-0", trigger: {symbol: ["\\mu", "_", "0"]}}], sets: [{trigger: {symbol: "\\N"}, parse: "NaturalNumber"}, {trigger: {symbol: "\\Z"}, parse: "Integer"}, {trigger: {symbol: "\\Q"}, parse: "RationalNumber"}, {trigger: {symbol: ["\\mathbb", "<{>", "A", "<}>"]}, parse: "AlgebraicNumber"}, {trigger: {symbol: "\\R"}, parse: "RealNumber"}, {trigger: {symbol: "\\C"}, parse: "ComplexNumber"}, {trigger: {symbol: "\\varnothing"}, parse: "EmptySet"}, {trigger: {symbol: "\\emptyset"}, parse: "EmptySet"}, {name: "Complement", trigger: {infix: "\\complement"}, precedence: 240}, {name: "Element", trigger: {infix: "\\in"}, precedence: 240}, {name: "Intersection", trigger: {infix: "\\Cap"}, precedence: 350}, {name: "NotElement", trigger: {infix: "\\notin"}, precedence: 240}, {name: "SetMinus", trigger: {infix: "\\setminus"}, precedence: 650}, {name: "SubsetEqual", trigger: {infix: "\\subseteq"}, precedence: 240}, {name: "SymmetricDifference", trigger: {infix: "\\triangle"}, precedence: 260}, {name: "Union", trigger: {infix: "\\cup"}, precedence: 350}, {name: "Contains", trigger: {infix: "\\ni"}, associativity: "right", precedence: 160}, {name: "Subset", trigger: {infix: "\\subset"}, associativity: "right", precedence: 240}, {name: "SquareSubset", trigger: {infix: "\\sqsubset"}, associativity: "right", precedence: 265}, {name: "SquareSubsetEqual", trigger: {infix: "\\sqsubseteq"}, associativity: "right", precedence: 265}, {name: "Superset", trigger: {infix: "\\supset"}, associativity: "right", precedence: 240}, {name: "SquareSuperset", trigger: {infix: "\\sqsupset"}, associativity: "right", precedence: 265}, {name: "SquareSupersetEqual", trigger: {infix: "\\sqsupseteq"}, associativity: "right", precedence: 265}, {name: "NotSubset", trigger: {infix: "\\nsubset"}, associativity: "right", precedence: 240}, {name: "NotSuperset", trigger: {infix: "\\nsupset"}, associativity: "right", precedence: 240}, {name: "SupersetEqual", trigger: {infix: "\\supseteq"}, associativity: "right", precedence: 240}, {name: "NotSubsetNotEqual", trigger: {infix: "\\nsubseteq"}, associativity: "right", precedence: 240}, {name: "NotSupersetNotEqual", trigger: {infix: "\\nsupseteq"}, associativity: "right", precedence: 240}, {name: "SubsetNotEqual", trigger: {infix: "\\subsetneq"}, associativity: "right", precedence: 240}, {name: "SubsetNotEqual", trigger: {infix: "\\varsupsetneqq"}, associativity: "right", precedence: 240}, {name: "SupersetNotEqual", trigger: {infix: "\\supsetneq"}, associativity: "right", precedence: 240}, {name: "SupersetNotEqual", trigger: {infix: "\\varsupsetneq"}, associativity: "right", precedence: 240}], symbols: [{trigger: {symbol: "\\alpha"}, parse: "\u03B1"}, {trigger: {symbol: "\\beta"}, parse: "\u03B2"}, {trigger: {symbol: "\\gamma"}, parse: "\u03B3"}, {trigger: {symbol: "\\delta"}, parse: "\u03B4"}, {trigger: {symbol: "\\epsilon"}, parse: "\u03F5"}, {trigger: {symbol: "\\varepsilon"}, parse: "\u03B5"}, {trigger: {symbol: "\\zeta"}, parse: "\u03B6"}, {trigger: {symbol: "\\eta"}, parse: "\u03B7"}, {trigger: {symbol: "\\theta"}, parse: "\u03B8"}, {trigger: {symbol: "\\vartheta"}, parse: "\u03D1"}, {trigger: {symbol: "\\iota"}, parse: "\u03B9"}, {trigger: {symbol: "\\kappa"}, parse: "\u03BA"}, {trigger: {symbol: "\\varkappa"}, parse: "\u03F0"}, {trigger: {symbol: "\\lambda"}, parse: "\u03BB"}, {trigger: {symbol: "\\mu"}, parse: "\u03BC"}, {trigger: {symbol: "\\nu"}, parse: "\u03BD"}, {trigger: {symbol: "\\xi"}, parse: "\u03BE"}, {trigger: {symbol: "\\omicron"}, parse: "\u03BF"}, {trigger: {symbol: "\\varpi"}, parse: "\u03D6"}, {trigger: {symbol: "\\rho"}, parse: "\u03C1"}, {trigger: {symbol: "\\varrho"}, parse: "\u03F1"}, {trigger: {symbol: "\\sigma"}, parse: "\u03C3"}, {trigger: {symbol: "\\varsigma"}, parse: "\u03C2"}, {trigger: {symbol: "\\tau"}, parse: "\u03C4"}, {trigger: {symbol: "\\phi"}, parse: "\u03D5"}, {trigger: {symbol: "\\varphi"}, parse: "\u03C6"}, {trigger: {symbol: "\\upsilon"}, parse: "\u03C5"}, {trigger: {symbol: "\\chi"}, parse: "\u03C7"}, {trigger: {symbol: "\\psi"}, parse: "\u03C8"}, {trigger: {symbol: "\\omega"}, parse: "\u03C9"}, {trigger: {symbol: "\\Gamma"}, parse: "\u0393"}, {trigger: {symbol: "\\Delta"}, parse: "\u0394"}, {trigger: {symbol: "\\Theta"}, parse: "\u0398"}, {trigger: {symbol: "\\Lambda"}, parse: "\u039B"}, {trigger: {symbol: "\\Xi"}, parse: "\u039E"}, {trigger: {symbol: "\\Pi"}, parse: "\u03A0"}, {trigger: {symbol: "\\Sigma"}, parse: "\u03A3"}, {trigger: {symbol: "\\Upsilon"}, parse: "\u03A5"}, {trigger: {symbol: "\\Phi"}, parse: "\u03A6"}, {trigger: {symbol: "\\Psi"}, parse: "\u03A8"}, {trigger: {symbol: "\\Omega"}, parse: "\u03A9"}, {trigger: {symbol: "\\digamma"}, parse: "\u03DD"}, {trigger: {symbol: "\\aleph"}, parse: "\u2135"}, {trigger: {symbol: "\\beth"}, parse: "\u2136"}, {trigger: {symbol: "\\daleth"}, parse: "\u2138"}, {trigger: {symbol: "\\gimel"}, parse: "\u2137"}, {trigger: {symbol: "\\Finv"}, parse: "\u2132"}, {trigger: {symbol: "\\Game"}, parse: "\u2141"}, {trigger: {symbol: "\\wp"}, parse: "\u2118"}, {trigger: {symbol: "\\eth"}, parse: "\xF0"}, {trigger: {symbol: "\\mho"}, parse: "\u2127"}, {trigger: {symbol: "\\clubsuit"}, parse: "\u2663"}, {trigger: {symbol: "\\heartsuit"}, parse: "\u2661"}, {trigger: {symbol: "\\spadesuit"}, parse: "\u2660"}, {trigger: {symbol: "\\diamondsuit"}, parse: "\u2662"}, {trigger: {symbol: "\\sharp"}, parse: "\u266F"}, {trigger: {symbol: "\\flat"}, parse: "\u266D"}, {trigger: {symbol: "\\natural"}, parse: "\u266E"}], trigonometry: [{name: "Arcsin", trigger: "\\arcsin", arguments: "implicit", parse: V}, {name: "Arccos", trigger: "\\arccos", arguments: "implicit", parse: V}, {name: "Arctan", trigger: "\\arctan", arguments: "implicit", parse: V}, {name: "Arctan", trigger: "\\arctg", arguments: "implicit", parse: V}, {name: "Arccot", trigger: "\\arcctg", arguments: "implicit", parse: V}, {name: "Arcsec", trigger: "\\arcsec", arguments: "implicit", parse: V}, {name: "Arccsc", trigger: "\\arccsc", arguments: "implicit", parse: V}, {name: "Arsinh", trigger: "\\arsinh", arguments: "implicit", parse: V}, {name: "Arcosh", trigger: "\\arcosh", arguments: "implicit", parse: V}, {name: "Artanh", trigger: "\\artanh", arguments: "implicit", parse: V}, {name: "Arsech", trigger: "\\arsech", arguments: "implicit", parse: V}, {name: "Arcsch", trigger: "\\arcsch", arguments: "implicit", parse: V}, {name: "Cosh", trigger: "\\ch", arguments: "implicit", parse: V}, {name: "Cosec", trigger: "\\cosec", arguments: "implicit", parse: V}, {name: "Cosh", trigger: "\\cosh", arguments: "implicit", parse: V}, {name: "Cot", trigger: "\\cot", arguments: "implicit", parse: V}, {name: "Cot", trigger: "\\cotg", arguments: "implicit", parse: V}, {name: "Coth", trigger: "\\coth", arguments: "implicit", parse: V}, {name: "Csc", trigger: "\\csc", arguments: "implicit", parse: V}, {name: "Cot", trigger: "\\ctg", arguments: "implicit", parse: V}, {name: "Coth", trigger: "\\cth", arguments: "implicit", parse: V}, {name: "Sec", trigger: "\\sec", arguments: "implicit", parse: V}, {name: "Sinh", trigger: "\\sinh", arguments: "implicit", parse: V}, {name: "Sinh", trigger: "\\sh", arguments: "implicit", parse: V}, {name: "Tan", trigger: "\\tan", arguments: "implicit", parse: V}, {name: "Tan", trigger: "\\tg", arguments: "implicit", parse: V}, {name: "Tanh", trigger: "\\tanh", arguments: "implicit", parse: V}, {name: "Tanh", trigger: "\\th", arguments: "implicit", parse: V}, {name: "Cos", trigger: "\\cos", arguments: "implicit", parse: V}, {name: "Sin", trigger: "\\sin", arguments: "implicit", parse: V}]};
var J = {precision: 15, positiveInfinity: "\\infty", negativeInfinity: "-\\infty", notANumber: "\\operatorname{NaN}", decimalMarker: ".", groupSeparator: ",", exponentProduct: "\\cdot", beginExponentMarker: "10^{", endExponentMarker: "}", notation: "auto", truncationMarker: "\\ldots", beginRepeatingDigits: "\\overline{", endRepeatingDigits: "}", imaginaryNumber: "\\imaginaryI"};
var K = {invisibleOperator: v, skipSpace: true, parseArgumentsOfUnknownLatexCommands: true, parseNumbers: true, promoteUnknownSymbols: /^[a-zA-Z]$/, promoteUnknownFunctions: /^[fg]$/, ignoreCommands: ["\\displaystyle", "\\!", "\\:", "\\enskip", "\\quad", "\\,", "\\;", "\\enspace", "\\qquad", "\\selectfont", "\\tiny", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"], idempotentCommands: ["\\left", "\\right", "\\mleft", "\\mright", "\\middle", "\\bigl", "\\bigm", "\\bigr", "\\Bigl", "\\Bigm", "\\Bigr", "\\biggl", "\\biggm", "\\biggr", "\\Biggl", "\\Biggm", "\\Biggr"], invisiblePlusOperator: m, preserveLatex: false};
var X = {invisibleMultiply: "", invisiblePlus: "", multiply: "\\times"};
function ee(e3, i3) {
  var t3;
  let r3 = e3;
  for (let e4 = 0; e4 < i3.length; e4++) {
    let n3 = (t3 = i3[e4]) !== null && t3 !== void 0 ? t3 : "";
    if (/[a-zA-Z*]/.test(n3[0])) {
      const i4 = r3.match(new RegExp("(.*)#" + Number(e4 + 1).toString()));
      i4 && /\\[a-zA-Z*]+/.test(i4[1]) && (n3 = " " + n3);
    }
    r3 = r3.replace("#" + Number(e4 + 1).toString(), n3);
  }
  return r3;
}
var ie = class {
  constructor(e3, i3, t3, r3) {
    let n3;
    this.index = 0, this.options = {...J, ...K, ...i3}, this.tokens = e3, this.onError = (e4) => r3({...e4, before: this.latexBefore(), after: this.latexAfter()}), this.dictionary = t3, this.invisibleOperatorPrecedence = 0, this.options.invisibleOperator && (n3 = this.dictionary.name.get(this.options.invisibleOperator), n3 === void 0 ? r3({code: "unknown-operator", arg: "invisible operator " + this.options.invisibleOperator}) : n3.precedence === void 0 ? r3({code: "expected-operator", arg: "invisible operator " + this.options.invisibleOperator}) : this.invisibleOperatorPrecedence = n3.precedence);
  }
  clone(e3, i3) {
    return new ie(this.tokens.slice(e3, i3), this.options, this.dictionary, this.onError);
  }
  balancedClone(e3, i3, t3 = true) {
    if (!this.matchAll(e3))
      return t3 || this.onError({code: "syntax-error", arg: "Expected " + o(e3)}), null;
    const r3 = this.index;
    let n3 = r3, s3 = 1;
    for (; !this.atEnd && s3 !== 0; )
      this.skipSpace(), n3 = this.index, this.matchAll(i3) ? s3 -= 1 : this.matchAll(e3) ? s3 += 1 : this.next();
    return s3 !== 0 ? (t3 || this.onError({code: "unbalanced-symbols", arg: o(e3) + o(i3)}), this.index = r3, null) : this.clone(r3, n3);
  }
  get atEnd() {
    return this.index >= this.tokens.length;
  }
  get peek() {
    return this.tokens[this.index];
  }
  latex(e3, i3) {
    return o(this.tokens.slice(e3, i3));
  }
  latexAhead(e3) {
    return o(this.tokens.slice(this.index, this.index + e3));
  }
  latexBefore() {
    return this.latex(0, this.index);
  }
  latexAfter() {
    return this.latex(this.index);
  }
  lookAhead() {
    let e3 = Math.min(this.dictionary.lookahead, this.tokens.length - this.index);
    const i3 = [];
    for (; e3 > 0; )
      i3[e3] = this.latexAhead(e3--);
    return i3;
  }
  peekDefinition(e3) {
    let i3;
    i3 = e3 === "operator" ? this.lookAhead().map((e4, i4) => {
      var t3, r3, n3, s3, a3;
      return (s3 = (r3 = (t3 = this.dictionary.infix[i4]) === null || t3 === void 0 ? void 0 : t3.get(e4)) !== null && r3 !== void 0 ? r3 : (n3 = this.dictionary.postfix[i4]) === null || n3 === void 0 ? void 0 : n3.get(e4)) !== null && s3 !== void 0 ? s3 : (a3 = this.dictionary.prefix[i4]) === null || a3 === void 0 ? void 0 : a3.get(e4);
    }) : this.lookAhead().map((i4, t3) => {
      var r3;
      return (r3 = this.dictionary[e3][t3]) === null || r3 === void 0 ? void 0 : r3.get(i4);
    });
    for (let e4 = i3.length; e4 > 0; e4--)
      if (i3[e4] !== void 0)
        return [i3[e4], e4];
    return [null, 0];
  }
  next() {
    return this.tokens[this.index++];
  }
  skipSpace() {
    if (!this.atEnd && this.peek === "<{>" && this.tokens[this.index + 1] === "<}>")
      return this.index += 2, this.skipSpace(), true;
    let e3 = false;
    for (; !this.atEnd && (this.options.ignoreCommands.includes(this.peek) || this.options.idempotentCommands.includes(this.peek)); )
      this.index += 1, this.skipSpace(), e3 = true;
    if (!this.options.skipSpace)
      return false;
    for (; this.match("<space>"); )
      e3 = true;
    return e3 && this.skipSpace(), e3;
  }
  match(e3) {
    return this.tokens[this.index] === e3 && (this.index++, true);
  }
  matchAll(e3) {
    let i3 = true;
    typeof e3 == "string" && (e3 = [e3]);
    let t3 = 0;
    do {
      i3 = this.tokens[this.index + t3] === e3[t3++];
    } while (i3 && t3 < e3.length);
    return i3 && (this.index += t3), i3;
  }
  matchAny(e3) {
    return e3.includes(this.tokens[this.index]) ? this.tokens[this.index++] : "";
  }
  matchWhile(e3) {
    const i3 = [];
    for (; e3.includes(this.tokens[this.index]); )
      i3.push(this.tokens[this.index++]);
    return i3;
  }
  matchSign() {
    let e3 = false, i3 = false;
    for (; !i3; )
      this.skipSpace() ? i3 = false : this.match("-") ? (e3 = !e3, i3 = false) : i3 = !this.match("+");
    return e3 ? "-" : "+";
  }
  matchDecimalDigits() {
    let e3 = "", i3 = false;
    for (; !i3; )
      if (e3 += this.matchWhile(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]).join(""), i3 = true, this.options.groupSeparator) {
        const e4 = this.index;
        this.match(this.options.groupSeparator) && (/[0-9]/.test(this.peek) ? i3 = false : this.index = e4);
      }
    return e3;
  }
  matchSignedInteger() {
    const e3 = this.index, i3 = this.matchSign(), t3 = this.matchDecimalDigits();
    return t3 ? (i3 === "-" ? "-" : "") + t3 : (this.index = e3, "");
  }
  matchExponent() {
    const e3 = this.index;
    let i3 = "";
    if (this.matchAny(["e", "E", "d", "D"])) {
      const e4 = this.matchSignedInteger();
      e4 && (i3 = "e" + e4);
    }
    if (i3)
      return i3;
    if (this.match("\\times") && (this.skipSpace(), this.match("1") && this.match("0") && this.match("^"))) {
      if (/[0-9]/.test(this.peek))
        return "e" + this.next();
      if (this.match("<{>")) {
        this.skipSpace();
        const e4 = this.matchSignedInteger();
        if (this.skipSpace(), this.match("<}>") && e4)
          return "e" + e4;
      }
    }
    return this.index = e3, "";
  }
  matchNumber() {
    var e3, i3;
    if (!this.options.parseNumbers)
      return "";
    const t3 = this.index, r3 = this.matchSign();
    let n3 = this.matchDecimalDigits();
    if (!n3)
      return this.index = t3, "";
    n3 = (r3 === "-" ? "-" : "") + n3;
    let s3 = false, a3 = false;
    this.match((e3 = this.options.decimalMarker) !== null && e3 !== void 0 ? e3 : "") && (s3 = true, n3 += "." + ((i3 = this.matchDecimalDigits()) !== null && i3 !== void 0 ? i3 : "0"));
    const o3 = this.matchExponent();
    return o3 && (a3 = true), n3 ? n3.length + o3.length > 12 ? s3 || a3 ? n3 + o3 + "d" : n3 + "n" : n3 + o3 : (this.index = t3, "");
  }
  matchOperator(e3, i3 = null, t3 = 0) {
    const [r3, n3] = this.peekDefinition(e3);
    if (r3 === null)
      return null;
    if (typeof r3.parse == "function") {
      let e4 = null;
      return [i3, e4] = r3.parse(i3, this, t3), e4 === null ? null : this.applyInvisibleOperator(i3, e4);
    }
    let s3 = r3.precedence;
    if (s3 === void 0 || s3 < t3)
      return null;
    s3 += r3.associativity === "left" ? 1 : 0, this.index += n3;
    const a3 = this.matchExpression(s3);
    return this.applyInvisibleOperator(...this.applyOperator(r3.parse, i3, a3));
  }
  matchArguments(e3) {
    if (!e3)
      return null;
    const i3 = this.index;
    let t3 = null;
    const r3 = this.matchMatchfixOperator();
    if (e3 === "group" && A(r3) === "Parentheses")
      t3 = k(r3);
    else if (e3 === "implicit")
      if (A(r3) === "Parentheses")
        t3 = k(r3);
      else if (r3 !== null)
        t3 = [r3];
      else {
        const e4 = this.matchPrimary();
        e4 !== null && (t3 = [e4]);
      }
    else
      this.index = i3;
    return t3;
  }
  matchMatchfixOperator() {
    const [e3] = this.peekDefinition("matchfix");
    if (e3 === null)
      return null;
    if (typeof e3.parse == "function")
      return this.applyInvisibleOperator(...e3.parse(null, this, 0));
    const i3 = typeof e3.trigger == "object" ? e3.trigger.matchfix : e3.trigger;
    if (!i3 || !e3.closeFence || !e3.parse)
      return null;
    const t3 = this.matchBalancedExpression(i3, e3.closeFence, this.onError);
    return t3 ? [e3.parse, t3] : [e3.parse];
  }
  matchDefinition(e3) {
    const [i3, t3] = this.peekDefinition(e3);
    if (typeof (i3 == null ? void 0 : i3.parse) == "function") {
      const [, e4] = i3.parse(null, this, 0);
      return [i3, e4];
    }
    return this.index += t3, [i3, null];
  }
  matchSymbol() {
    var e3, i3, t3, r3;
    const [n3, s3] = this.matchDefinition("symbol");
    if (s3 !== null)
      return s3;
    if (n3 === null) {
      if ((e3 = this.options.promoteUnknownFunctions) === null || e3 === void 0 ? void 0 : e3.test(this.peek)) {
        const e4 = this.next(), i4 = this.matchMatchfixOperator();
        return i4 === null ? e4 : A(i4) !== "Parentheses" ? null : [e4, ...k(i4)];
      }
      return ((i3 = this.options.promoteUnknownSymbols) === null || i3 === void 0 ? void 0 : i3.test(this.peek)) ? this.next() : this.matchUnknownLatexCommand();
    }
    const a3 = [], o3 = [];
    let l3, u3 = (t3 = n3.optionalLatexArg) !== null && t3 !== void 0 ? t3 : 0;
    for (; u3 > 0; )
      l3 = this.matchOptionalLatexArgument(), l3 !== null && o3.push(l3), u3--;
    for (u3 = (r3 = n3.requiredLatexArg) !== null && r3 !== void 0 ? r3 : 0; u3 > 0; )
      l3 = this.matchRequiredLatexArgument(), l3 === null && this.onError({code: "expected-argument"}), l3 !== null && a3.push(l3), u3--;
    const c3 = this.matchArguments(n3.arguments);
    return c3 === null ? a3.length === 0 && o3.length === 0 ? n3.parse : [n3.parse, ...a3, ...o3] : [n3.parse, ...a3, ...c3, ...o3];
  }
  matchOptionalLatexArgument() {
    return this.skipSpace(), this.matchBalancedExpression("[", "]");
  }
  matchRequiredLatexArgument() {
    return this.skipSpace(), this.matchBalancedExpression("<{>", "<}>") || (/^[0-9]$/.test(this.peek) ? parseFloat(this.next()) : /^[^\\#]$/.test(this.peek) ? this.next() : this.matchSymbol());
  }
  matchSupsub(e3) {
    if (e3 === null)
      return null;
    let i3 = null;
    return this.skipSpace(), [["^", "superfix"], ["_", "subfix"]].forEach((t3) => {
      var r3, n3, s3;
      if (i3 !== null)
        return;
      const [a3, o3] = t3, l3 = this.index;
      if (!this.match(a3))
        return;
      const u3 = this.index;
      let c3, h3 = 0;
      if (this.match("<{>") ? ([c3, h3] = this.peekDefinition(o3), c3 ? typeof c3.parse == "function" ? i3 = c3.parse(e3, this, 0)[1] : (this.index += h3, this.match("<}>") ? i3 = [(r3 = c3.parse) !== null && r3 !== void 0 ? r3 : c3.name, e3] : this.index = u3) : this.index = u3) : ([c3, h3] = this.peekDefinition(o3), c3 ? typeof c3.parse == "function" ? i3 = c3.parse(e3, this, 0)[1] : (this.index += h3, i3 = [(n3 = c3.parse) !== null && n3 !== void 0 ? n3 : c3.name, e3]) : this.index = u3), i3 === null && (c3 = (s3 = this.dictionary.infix[1]) === null || s3 === void 0 ? void 0 : s3.get(a3), typeof (c3 == null ? void 0 : c3.parse) == "function" ? (this.index = l3, i3 = c3.parse(e3, this, 0)[1]) : typeof (c3 == null ? void 0 : c3.parse) == "string" ? ([e3, i3] = this.applyOperator(c3.parse, e3, this.matchRequiredLatexArgument()), i3 = this.applyInvisibleOperator(e3, i3)) : i3 = this.applyInvisibleOperator(e3, a3)), i3 !== null) {
        const e4 = this.matchArguments(c3 == null ? void 0 : c3.arguments);
        e4 !== null && (i3 = [i3, ...e4]);
      }
    }), i3;
  }
  matchPostfix(e3) {
    if (e3 === null)
      return null;
    const [i3, t3] = this.peekDefinition("postfix");
    return i3 == null ? null : typeof i3.parse == "function" ? ([, e3] = i3.parse(e3, this, 0), e3 === null ? null : e3) : (this.index += t3, [i3.parse, e3]);
  }
  matchString() {
    let e3 = "", i3 = this.atEnd;
    for (; !i3; ) {
      if (this.match("<space>"))
        e3 += " ";
      else {
        const t3 = this.peek;
        t3 === "]" ? i3 = true : /^<({|}|\$|\$\$|space)>$/.test(t3) ? t3[0] === "\\" ? (this.onError({code: "unexpected-command"}), e3 += this.next()) : i3 = true : e3 += this.next();
      }
      i3 = i3 || this.atEnd;
    }
    return e3;
  }
  matchEnvironmentName(e3, i3) {
    if (this.match(e3)) {
      const e4 = this.index;
      if (this.match("<{>")) {
        const e5 = this.matchString();
        if (this.match("<}>") && e5 === i3)
          return true;
      }
      this.index = e4;
    }
    return false;
  }
  matchTabular() {
    const e3 = ["list"];
    let i3 = ["list"], t3 = null, r3 = false;
    for (; !this.atEnd && !r3; )
      if (this.match("&"))
        i3.push(t3 != null ? t3 : f), t3 = null;
      else if (this.match("\\\\") || this.match("\\cr"))
        this.skipSpace(), this.matchOptionalLatexArgument(), t3 !== null && i3.push(t3), e3.push(i3), i3 = ["list"], t3 = null;
      else {
        const e4 = this.matchExpression();
        e4 === null && (r3 = true), t3 = t3 !== null ? this.applyInvisibleOperator(t3, e4) : e4;
      }
    return i3.length > 1 && e3.push(i3), e3;
  }
  matchEnvironment() {
    var e3;
    if (this.match("\\begin") && this.match("<{>")) {
      const i3 = this.matchString();
      if (this.match("<}>")) {
        const t3 = this.index;
        let r3 = this.index, n3 = 1;
        for (; !this.atEnd && n3 !== 0; )
          r3 = this.index, this.matchEnvironmentName("\\begin", i3) ? n3 += 1 : this.matchEnvironmentName("\\end", i3) ? n3 -= 1 : this.next();
        const s3 = this.dictionary.environment.get(i3);
        return typeof (s3 == null ? void 0 : s3.parse) == "function" ? s3.parse(null, this.clone(t3, r3), 0)[1] : (e3 = s3 == null ? void 0 : s3.parse) !== null && e3 !== void 0 ? e3 : null;
      }
    }
    return null;
  }
  applyOperator(e3, i3, t3) {
    var r3, n3, s3, a3;
    const o3 = this.dictionary.name.get(e3);
    if (o3 === void 0)
      return this.onError({code: "unknown-operator"}), [i3, t3];
    if (((r3 = o3.trigger) === null || r3 === void 0 ? void 0 : r3.prefix) !== void 0 && i3 === null && t3 !== null)
      return [null, [o3.name, t3]];
    if (((n3 = o3.trigger) === null || n3 === void 0 ? void 0 : n3.postfix) !== void 0 && i3 !== null)
      return [null, [o3.name, i3]];
    if (((s3 = o3.trigger) === null || s3 === void 0 ? void 0 : s3.matchfix) !== void 0 || ((a3 = o3.trigger) === null || a3 === void 0 ? void 0 : a3.infix) !== void 0) {
      if (o3.associativity === "non")
        return [null, [e3, i3 != null ? i3 : "Missing", t3 != null ? t3 : "Missing"]];
      if (A(i3) === e3) {
        if (o3.associativity === "both") {
          if (A(t3) === e3) {
            if (Array.isArray(i3))
              return [null, i3.concat(k(t3))];
            if (w(i3))
              return [null, i3.fn.concat(k(t3))];
          } else
            t3 && (Array.isArray(i3) && i3.push(t3), w(i3) && i3.fn.push(t3));
          return [null, i3];
        }
        return o3.associativity === "left" ? [null, [e3, i3 != null ? i3 : p, t3 != null ? t3 : p]] : Array.isArray(i3) ? [null, [e3, i3[1], [e3, i3[2], t3 != null ? t3 : p]]] : (w(i3) && (i3.fn[2] = [e3, i3.fn[2], t3 != null ? t3 : p]), [null, i3]);
      }
      return A(t3) === e3 ? o3.associativity === "both" ? (Array.isArray(t3) && i3 && t3.splice(1, 0, i3), w(t3) && i3 && t3.fn.splice(1, 0, i3), [null, t3]) : o3.associativity === "right" ? [null, [e3, i3 != null ? i3 : p, t3 != null ? t3 : p]] : Array.isArray(t3) ? [null, [e3, t3[1], [e3, t3[2], i3 != null ? i3 : p]]] : (w(t3) && (t3.fn[2] = [e3, t3.fn[2], i3 != null ? i3 : p]), [null, t3]) : [null, [e3, i3 != null ? i3 : "Missing", t3 != null ? t3 : "Missing"]];
    }
    return [i3, null];
  }
  applyInvisibleOperator(e3, i3) {
    if (e3 === null)
      return i3;
    if (i3 === null)
      return e3;
    if (this.options.invisiblePlusOperator && (typeof e3 == "number" || y(e3)) && function(e4) {
      var i4, t4;
      const r3 = z(e4);
      if (r3 !== null && ["ThreeQuarter", "TwoThird", "Half", "Third", "Quarter"].includes(r3))
        return true;
      if (A(e4) !== d)
        return false;
      const n3 = (i4 = N(O(e4, 1))) !== null && i4 !== void 0 ? i4 : NaN, s3 = (t4 = N(O(e4, 2))) !== null && t4 !== void 0 ? t4 : NaN;
      return Number.isInteger(n3) && Number.isInteger(s3);
    }(i3))
      return [e3, i3] = this.applyOperator(this.options.invisiblePlusOperator, e3, i3), e3 === null ? i3 : null;
    if (this.options.invisibleOperator)
      return [e3, i3] = this.applyOperator(this.options.invisibleOperator, e3, i3), e3 === null ? i3 : null;
    let t3 = ["LatexTokens"];
    return A(e3) === "LatexTokens" ? t3 = t3.concat(k(e3)) : t3.push(e3), i3 !== null && (A(i3) === "LatexTokens" ? t3 = t3.concat(k(i3)) : t3.push(i3)), this.options.invisibleOperator && this.onError({code: "unexpected-sequence"}), t3;
  }
  matchUnknownLatexCommand() {
    var e3;
    const i3 = this.peek;
    if (!i3 || i3[0] !== "\\")
      return null;
    if (this.next(), i3 === "\\operatorname") {
      if (this.skipSpace(), this.peek === "<{>") {
        let e4 = "";
        for (this.next(); !this.atEnd && this.tokens[this.index] !== "<}>"; )
          e4 += this.next();
        return e4;
      }
      return (e3 = this.next()) !== null && e3 !== void 0 ? e3 : p;
    }
    const t3 = [], r3 = [];
    let n3 = false;
    do {
      n3 = true;
      let e4 = this.matchOptionalLatexArgument();
      e4 !== null && (t3.push(e4), n3 = false), this.skipSpace(), this.peek === "<{>" && (e4 = this.matchRequiredLatexArgument(), e4 !== null && (r3.push(e4), n3 = false));
    } while (!n3);
    return t3.length > 0 || r3.length > 0 ? [i3, ...r3, ...t3] : i3;
  }
  matchPrimary(e3) {
    let i3 = null;
    const t3 = this.index, r3 = this.matchNumber();
    r3 && (i3 = {num: r3}), i3 === null && (i3 = this.matchMatchfixOperator()), i3 === null && (i3 = this.matchEnvironment()), i3 === null && (i3 = this.matchSymbol());
    let n3 = null;
    do {
      n3 = this.matchSupsub(i3), i3 = n3 != null ? n3 : i3;
    } while (n3 !== null);
    let s3 = null;
    do {
      s3 = this.matchPostfix(i3), i3 = s3 != null ? s3 : i3;
    } while (s3 !== null);
    return this.decorate(i3, t3);
  }
  matchBalancedExpression(e3, i3, t3) {
    const r3 = this.balancedClone(e3, i3);
    if (!r3)
      return t3 == null || t3({code: "unbalanced-symbols", arg: o(e3) + o(i3)}), null;
    const n3 = r3.matchExpression();
    return r3.atEnd || t3 == null || t3({code: "unbalanced-symbols", arg: o(e3) + o(i3)}), n3;
  }
  matchExpression(e3 = 0) {
    let i3 = null;
    const t3 = this.index;
    this.skipSpace(), i3 = this.matchPrimary(e3), i3 === null && (i3 = this.matchOperator("prefix"));
    let r3 = false;
    for (; !this.atEnd && !r3; ) {
      this.skipSpace();
      let t4 = this.matchOperator("infix", i3, e3);
      if (t4 === null && i3 !== null) {
        const [e4] = this.peekDefinition("operator");
        if (e4 === null) {
          const e5 = this.matchExpression(this.invisibleOperatorPrecedence);
          e5 !== null && (t4 = this.applyInvisibleOperator(i3, e5));
        }
      }
      t4 !== null ? i3 = t4 : r3 = true;
    }
    return this.decorate(i3, t3);
  }
  decorate(e3, i3) {
    if (e3 === null)
      return null;
    if (this.options.preserveLatex) {
      const t3 = this.latex(i3, this.index);
      Array.isArray(e3) ? e3 = {latex: t3, fn: e3} : typeof e3 == "number" ? e3 = {latex: t3, num: Number(e3).toString()} : typeof e3 == "string" ? e3 = {latex: t3, sym: e3} : typeof e3 == "object" && e3 !== null && (e3.latex = t3);
    }
    return e3;
  }
};
function te(e3, i3) {
  const t3 = e3.length, r3 = e3;
  e3 = e3.slice(0, -1);
  for (let t4 = 0; t4 < e3.length - 16; t4++) {
    const r4 = e3.substr(0, t4);
    for (let n4 = 0; n4 < 17; n4++) {
      const s3 = e3.substr(t4, n4 + 1), a3 = Math.floor((e3.length - r4.length) / s3.length);
      if (a3 > 1 && (r4 + s3.repeat(a3 + 1)).startsWith(e3))
        return s3 === "0" ? r4.replace(/(\d{3})/g, "$1" + i3.groupSeparator) : r4.replace(/(\d{3})/g, "$1" + i3.groupSeparator) + i3.beginRepeatingDigits + s3 + i3.endRepeatingDigits;
    }
  }
  const n3 = t3 > i3.precision - 1;
  return e3 = r3, n3 && (e3 = e3.substr(0, i3.precision - 1)), i3.groupSeparator && (e3 = e3.replace(/(\d{3})/g, "$1" + i3.groupSeparator)).endsWith(i3.groupSeparator) && (e3 = e3.slice(0, -i3.groupSeparator.length)), n3 ? e3 + i3.truncationMarker : e3;
}
function re(e3, i3) {
  var t3;
  return e3 ? i3.beginExponentMarker ? i3.beginExponentMarker + e3 + ((t3 = i3.endExponentMarker) !== null && t3 !== void 0 ? t3 : "") : "10^{" + e3 + "}" : "";
}
var ne = class {
  constructor(e3, i3, t3) {
    this.level = -1, this.options = e3, e3.invisibleMultiply && (/#1/.test(e3.invisibleMultiply) && /#2/.test(e3.invisibleMultiply) || t3({code: "expected-argument", arg: "invisibleMultiply"})), this.onError = t3, this.dictionary = i3;
  }
  wrap(e3, i3) {
    if (e3 === null)
      return "";
    if (i3 === void 0)
      return "(" + this.serialize(e3) + ")";
    if (typeof e3 == "number" || y(e3) || typeof e3 == "string" || b(e3))
      return this.serialize(e3);
    const t3 = A(e3);
    if (t3 && t3 !== "Parentheses") {
      const r3 = this.dictionary.name.get(t3);
      if (r3 && r3.precedence !== void 0 && r3.precedence < i3)
        return this.wrapString(this.serialize(e3), (this.level, "paren"));
    }
    return this.serialize(e3);
  }
  wrapShort(e3) {
    if (e3 === null)
      return "";
    const i3 = this.serialize(e3);
    return A(e3) === "Parentheses" || typeof e3 == "number" || y(e3) || /(^(.|\\[a-zA-Z*]+))$/.test(i3) ? i3 : this.wrapString(i3, (this.level, "paren"));
  }
  wrapString(e3, i3) {
    return i3 === "none" ? e3 : "(" + e3 + ")";
  }
  serializeSymbol(e3, i3) {
    const t3 = M(e3);
    if (!t3) {
      if (typeof (i3 == null ? void 0 : i3.serialize) == "string")
        return i3.serialize;
      const t4 = z(e3);
      if (t4 === null)
        return "";
      switch (function(e4, i4) {
        const t5 = z(e4);
        return t5 === null ? "asis" : t5.length > 1 ? "upright" : "asis";
      }(e3, this.level)) {
        case "upright":
          return "\\operatorname{" + t4 + "}";
        default:
          return t4;
      }
    }
    const r3 = k(e3);
    if (!i3) {
      if (typeof t3 == "string" && t3.length > 0 && t3[0] === "\\") {
        let e4 = t3;
        for (const i4 of r3)
          e4 += "{" + this.serialize(i4) + "}";
        return e4;
      }
      return `${this.serialize(t3)}(${r3.map((e4) => this.serialize(e4)).join(", ")})`;
    }
    if (i3.requiredLatexArg > 0) {
      let e4 = "", t4 = "", n3 = 0;
      for (; n3 < i3.requiredLatexArg; )
        t4 += "{" + this.serialize(r3[n3++]) + "}";
      for (; n3 < Math.min(r3.length, i3.optionalLatexArg + i3.requiredLatexArg); ) {
        const i4 = this.serialize(r3[1 + n3++]);
        i4 && (e4 += "[" + i4 + "]");
      }
      return i3.serialize + (e4 + t4);
    }
    return this.level, i3.serialize + this.serialize(["Parentheses", ...r3]);
  }
  serializeDictionary(e3) {
    return `\\left[\\begin{array}{lll}${Object.keys(e3).map((i3) => `\\textbf{${i3}} & \\rightarrow & ${this.serialize(e3[i3])}`).join("\\\\")}\\end{array}\\right]`;
  }
  serialize(e3) {
    if (e3 === null)
      return "";
    this.level += 1;
    const i3 = (() => {
      var i4, t3, r3, n3;
      const s3 = function(e4, i5) {
        var t4, r4;
        let n4;
        if (typeof e4 == "number")
          n4 = e4;
        else {
          if (!y(e4))
            return "";
          n4 = e4.num;
        }
        if (n4 === 1 / 0 || n4 === "Infinity" || n4 === "+Infinity")
          return i5.positiveInfinity;
        if (n4 === -1 / 0 || n4 === "-Infinity")
          return i5.negativeInfinity;
        if (n4 === "NaN" || typeof n4 == "number" && Number.isNaN(n4))
          return i5.notANumber;
        if (typeof n4 == "number")
          return i5.notation === "engineering" ? function(e5, i6) {
            if (e5 === 0)
              return "0";
            const t5 = Math.abs(e5);
            let r5 = Math.round(Math.log10(t5));
            r5 -= r5 % 3, t5 < 1e3 && (r5 = 0);
            const n5 = t5 / Math.pow(10, r5);
            let s5 = "";
            const a4 = n5.toString().match(/^(.*)\.(.*)$/);
            (a4 == null ? void 0 : a4[1]) && a4[2] && (s5 = a4[1] + i6.decimalMarker + a4[2]), i6.groupSeparator && (s5 = te(n5.toExponential(), i6));
            let o4 = "";
            return r5 !== 0 && (o4 = re(r5.toString(), i6)), (e5 < 0 ? "-" : "") + s5 + o4;
          }(n4, i5) : function(e5, i6) {
            let t5, r5 = e5.match(/^(.*)[e|E]([-+]?[0-9]+)$/i);
            (r5 == null ? void 0 : r5[1]) && r5[2] && (t5 = re(r5[2], i6), t5 && (t5 = i6.exponentProduct + t5));
            let n5 = e5, s5 = "";
            return r5 = (t5 ? r5[1] : e5).match(/^(.*)\.(.*)$/), (r5 == null ? void 0 : r5[1]) && r5[2] && (n5 = r5[1], s5 = r5[2]), i6.groupSeparator && (n5 = n5.replace(/\B(?=(\d{3})+(?!\d))/g, i6.groupSeparator), s5 = te(s5, i6)), s5 && (s5 = i6.decimalMarker + s5), n5 + s5 + (t5 != null ? t5 : "");
          }(n4.toString(), i5);
        /[a-zA-Z]$/.test(n4) && (n4 = n4.slice(0, -1));
        let s4 = "";
        for (n4[0] === "-" ? (s4 = "-", n4 = n4.substr(1)) : n4[0] === "+" && (n4 = n4.substr(1)); n4[0] === "0"; )
          n4 = n4.substr(1);
        if (n4.length === 0)
          return s4 + "0";
        n4[0] === "." && (n4 = "0" + n4);
        let a3 = "";
        if (n4.indexOf(".") >= 0) {
          const e5 = n4.match(/(\d*)\.(\d*)([e|E]([-+]?[0-9]*))?/);
          if (!e5)
            return "";
          const r5 = e5[1], o4 = e5[2];
          if (a3 = (t4 = e5[4]) !== null && t4 !== void 0 ? t4 : "", r5 === "0") {
            let e6 = 0;
            for (; o4[e6] === "0" && e6 < o4.length; )
              e6 += 1;
            let t5 = "";
            if (e6 <= 4)
              t5 = "0" + i5.decimalMarker, t5 += o4.substr(0, e6), t5 += te(n4.substr(t5.length), i5);
            else if (e6 + 1 >= i5.precision)
              t5 = "0", s4 = "";
            else {
              t5 = n4[e6];
              const r6 = te(n4.substr(e6 + 1), i5);
              r6 && (t5 += i5.decimalMarker + r6);
            }
            t5 !== "0" && (!(n4.length - 1 > i5.precision) || i5.endRepeatingDigits && t5.endsWith(i5.endRepeatingDigits) || !i5.truncationMarker || t5.endsWith(i5.truncationMarker) || (t5 += i5.truncationMarker), e6 > 4 && (t5 += i5.exponentProduct + re((1 - e6).toString(), i5))), n4 = t5;
          } else {
            n4 = r5.replace(/\B(?=(\d{3})+(?!\d))/g, i5.groupSeparator);
            const e6 = te(o4, i5);
            e6 && (n4 += i5.decimalMarker + e6);
          }
        } else if (n4.length > i5.precision) {
          const e5 = n4.length;
          let t5 = n4[0];
          const r5 = te(n4.substr(1), i5);
          r5 && (t5 += i5.decimalMarker + r5, i5.truncationMarker && !t5.endsWith(i5.truncationMarker) && i5.endRepeatingDigits && !t5.endsWith(i5.endRepeatingDigits) && (t5 += i5.truncationMarker)), t5 !== "1" ? t5 += i5.exponentProduct : t5 = "", n4 = t5 + re((e5 - 1).toString(), i5);
        } else {
          const e5 = n4.match(/([0-9]*)\.?([0-9]*)([e|E]([-+]?[0-9]+))?/);
          e5 && (n4 = e5[1], e5[2] && (n4 += i5.decimalMarker + e5[2]), a3 = (r4 = e5[4]) !== null && r4 !== void 0 ? r4 : ""), n4 = n4.replace(/\B(?=(\d{3})+(?!\d))/g, i5.groupSeparator);
        }
        const o3 = re(a3, i5);
        return s4 + n4 + (o3 ? i5.exponentProduct + o3 : "");
      }(e3, this.options);
      if (s3)
        return s3;
      const l3 = q(e3);
      if (l3 !== null)
        return `\\text{${l3}}`;
      const u3 = z(e3);
      if (u3 !== null)
        return this.serializeSymbol(e3, this.dictionary.name.get(u3));
      const c3 = P(e3);
      if (c3 !== null)
        return this.serializeDictionary(c3);
      const h3 = A(e3);
      if (h3) {
        if (h3[0] === "\\") {
          const i5 = k(e3);
          return i5.length === 0 ? h3 : h3 + "{" + i5.map((e4) => this.serialize(e4)).filter((e4) => Boolean(e4)).join("}{") + "}";
        }
        const s4 = this.dictionary.name.get(h3);
        if (s4) {
          let l4 = "";
          return typeof s4.serialize == "function" && (l4 = s4.serialize(this, e3)), l4 || s4.precedence === void 0 && !((i4 = s4.trigger) === null || i4 === void 0 ? void 0 : i4.superfix) && !((t3 = s4.trigger) === null || t3 === void 0 ? void 0 : t3.subfix) || (l4 = function(e4, i5, t4) {
            var r4, n4, s5, a3, o3;
            let l5 = "";
            const u4 = L(i5), c4 = A(i5);
            if (((r4 = t4.trigger) === null || r4 === void 0 ? void 0 : r4.superfix) || ((n4 = t4.trigger) === null || n4 === void 0 ? void 0 : n4.subfix))
              return u4 !== 1 && e4.onError({code: "operator-requires-one-operand", arg: e4.serializeSymbol(c4)}), ee(t4.serialize, [e4.serialize(O(i5, 1))]);
            if ((s5 = t4.trigger) === null || s5 === void 0 ? void 0 : s5.postfix)
              return u4 !== 1 && e4.onError({code: "postfix-operator-requires-one-operand", arg: e4.serializeSymbol(c4)}), ee(t4.serialize, [e4.wrap(O(i5, 1), t4.precedence)]);
            if ((a3 = t4.trigger) === null || a3 === void 0 ? void 0 : a3.prefix)
              return u4 !== 1 && e4.onError({code: "prefix-operator-requires-one-operand", arg: e4.serializeSymbol(c4)}), ee(t4.serialize, [e4.wrap(O(i5, 1), t4.precedence + 1)]);
            if ((o3 = t4.trigger) === null || o3 === void 0 ? void 0 : o3.infix) {
              l5 = e4.wrap(O(i5, 1), t4.precedence);
              for (let r5 = 2; r5 < u4 + 1; r5++) {
                const n5 = O(i5, r5);
                n5 !== null && (l5 = ee(t4.serialize, [l5, e4.wrap(n5, t4.precedence)]));
              }
            }
            return l5;
          }(this, e3, s4)), !l4 && ((r3 = s4.trigger) === null || r3 === void 0 ? void 0 : r3.matchfix) && (l4 = function(e4, i5, t4) {
            var r4, n4;
            let s5 = [];
            if (typeof ((r4 = t4.trigger) === null || r4 === void 0 ? void 0 : r4.matchfix) == "string" ? s5.push((n4 = t4.trigger) === null || n4 === void 0 ? void 0 : n4.matchfix) : t4.trigger && Array.isArray(t4.trigger.matchfix) && (s5 = [...t4.trigger.matchfix]), L(i5) >= 1) {
              let r5 = "";
              for (const n5 of k(i5))
                n5 && (s5.push(r5), s5.push(e4.serialize(n5)), r5 = t4.separator);
            }
            return s5.push(o(t4.closeFence)), a(s5);
          }(this, e3, s4)), !l4 && ((n3 = s4.trigger) === null || n3 === void 0 ? void 0 : n3.symbol) && (l4 = this.serializeSymbol(e3, s4)), l4;
        }
      }
      if (Array.isArray(e3) || w(e3))
        return this.serializeSymbol(e3);
      this.onError({code: "syntax-error", arg: JSON.stringify(e3)});
    })();
    return this.level -= 1, i3 != null ? i3 : "";
  }
};
var se = class {
  constructor(e3) {
    var i3, t3;
    this.onError = (i3 = e3 == null ? void 0 : e3.onError) !== null && i3 !== void 0 ? i3 : (e4) => {
      typeof window != "undefined" && (!e4.before || e4.after);
    };
    const r3 = {...e3 != null ? e3 : {}};
    delete r3.dictionary, delete r3.onError, this.options = {...J, ...X, ...K, ...r3}, this.dictionary = function(e4, i4) {
      var t4, r4, n3, s3, a3, o3, l3, u3, c3, h3, g3, p3, f3, m3, d3;
      const v3 = {lookahead: 1, name: new Map(), prefix: [], infix: [], postfix: [], matchfix: [], superfix: [], subfix: [], symbol: [], environment: new Map()};
      for (const x3 of e4)
        x3.parse === void 0 && (x3.parse = x3.name), typeof x3.trigger == "string" && (x3.trigger = {symbol: x3.trigger}), typeof x3.serialize == "string" && ((t4 = x3.trigger) === null || t4 === void 0 ? void 0 : t4.symbol) !== void 0 && /#[0-9]/.test(x3.serialize) && i4({code: "unexpected-argument", arg: x3.name}), x3.serialize === void 0 && (((r4 = x3.trigger) === null || r4 === void 0 ? void 0 : r4.postfix) !== void 0 ? x3.serialize = "#1" + Q(x3.trigger.postfix) : ((n3 = x3.trigger) === null || n3 === void 0 ? void 0 : n3.prefix) !== void 0 ? x3.serialize = Q(x3.trigger.prefix) + "#1" : ((s3 = x3.trigger) === null || s3 === void 0 ? void 0 : s3.infix) !== void 0 ? x3.serialize = "#1" + Q(x3.trigger.infix) + "#2" : ((a3 = x3.trigger) === null || a3 === void 0 ? void 0 : a3.symbol) !== void 0 ? x3.serialize = Q(x3.trigger.symbol) : ((o3 = x3.trigger) === null || o3 === void 0 ? void 0 : o3.superfix) !== void 0 ? x3.serialize = "#1^{" + Q((l3 = x3.trigger) === null || l3 === void 0 ? void 0 : l3.superfix) + "}" : ((u3 = x3.trigger) === null || u3 === void 0 ? void 0 : u3.subfix) !== void 0 ? x3.serialize = "#1_{" + Q((c3 = x3.trigger) === null || c3 === void 0 ? void 0 : c3.subfix) + "}" : x3.serialize = ""), ((h3 = x3.trigger) === null || h3 === void 0 ? void 0 : h3.infix) !== void 0 && (x3.precedence === void 0 && i4({code: "syntax-error", arg: "Infix operators require a precedence"}), x3.associativity || (x3.associativity = "non")), ((g3 = x3.trigger) === null || g3 === void 0 ? void 0 : g3.symbol) !== void 0 && (x3.arguments = (p3 = x3.arguments) !== null && p3 !== void 0 ? p3 : "", x3.optionalLatexArg = (f3 = x3.optionalLatexArg) !== null && f3 !== void 0 ? f3 : 0, x3.requiredLatexArg = (m3 = x3.requiredLatexArg) !== null && m3 !== void 0 ? m3 : 0), ((d3 = x3.trigger) === null || d3 === void 0 ? void 0 : d3.matchfix) !== void 0 && (x3.parse === "function" || x3.closeFence || i4({code: "syntax-error", arg: "Matchfix operators require a close fence or a custom parse function"})), x3.trigger !== void 0 && (["infix", "prefix", "postfix", "symbol", "matchfix", "superfix", "subfix"].forEach((e5) => {
          if (x3.trigger[e5]) {
            const t5 = (i5 = x3.trigger[e5], Array.isArray(i5) ? i5.length : 1);
            v3.lookahead = Math.max(v3.lookahead, t5), v3[e5][t5] === void 0 && (v3[e5][t5] = new Map()), v3[e5][t5].set(Q(x3.trigger[e5]), x3);
          }
          var i5;
        }), x3.trigger.environment !== void 0 && v3.environment.set(x3.trigger.environment, x3)), x3.name !== void 0 ? v3.name.set(Q(x3.name), x3) : typeof x3.parse == "string" && v3.name.set(x3.parse, x3), x3.trigger !== void 0 || x3.name || i4({code: "syntax-error", arg: "Need at least a trigger or a name"});
      return v3;
    }((t3 = e3 == null ? void 0 : e3.dictionary) !== null && t3 !== void 0 ? t3 : se.getDictionary(), this.onError);
  }
  static getDictionary(e3 = "all") {
    if (e3 === "all") {
      let e4 = [];
      for (const i3 of Object.keys(Y))
        e4 = [...e4, ...Y[i3]];
      return e4;
    }
    return Y[e3] ? [...Y[e3]] : [];
  }
  parse(e3) {
    var i3;
    const t3 = new ie(s(e3, []), this.options, this.dictionary, this.onError), r3 = t3.matchExpression();
    return t3.atEnd || (i3 = this.onError) === null || i3 === void 0 || i3.call(this, {code: "syntax-error"}), r3 != null ? r3 : "";
  }
  serialize(e3) {
    return new ne(this.options, this.dictionary, this.onError).serialize(e3);
  }
};
function ae(e3, i3) {
  return new se(i3).parse(e3);
}
function oe(e3, i3) {
  return new se(i3).serialize(e3);
}

// src/editor-model/model-private.ts
var ModelPrivate = class {
  constructor(options, listeners, hooks, target) {
    this.options = options;
    this.root = new Atom("root", {mode: this.options.mode});
    this.root.body = [];
    this._selection = {ranges: [[0, 0]], direction: "none"};
    this._anchor = 0;
    this._position = 0;
    this.setListeners(listeners);
    this.setHooks(hooks);
    this.mathfield = target;
    this.suppressChangeNotifications = false;
  }
  get atoms() {
    return this.root.children;
  }
  get selection() {
    return this._selection;
  }
  set selection(value) {
    this.setSelection(value);
  }
  setSelection(arg1, arg2) {
    return this.deferNotifications({selection: true}, () => {
      const value = this.normalizeSelection(arg1, arg2);
      if (value === void 0) {
        throw new TypeError("Invalid selection");
      }
      if (value.ranges.length === 1 && value.ranges[0][0] === value.ranges[0][1]) {
        const pos = value.ranges[0][0];
        console.assert(pos >= 0 && pos <= this.lastOffset);
        this._position = pos;
        this._anchor = pos;
        this._selection = value;
      } else {
        const selRange = range(value);
        if (value.direction === "backward") {
          [this._position, this._anchor] = selRange;
        } else {
          [this._anchor, this._position] = selRange;
        }
        const first = this.at(selRange[0]);
        const last = this.at(selRange[1]);
        const commonAncestor = Atom.commonAncestor(first, last);
        if (commonAncestor?.type === "array" && first.parent === commonAncestor && last.parent === commonAncestor) {
        } else {
          this._selection = {
            ranges: [[this.offsetOf(first), this.offsetOf(last)]],
            direction: value.direction
          };
          if (value.direction === "backward") {
            this._position = this._selection.ranges[0][0];
          } else {
            this._position = this._selection.ranges[0][1];
          }
          console.assert(this._position >= 0 && this._position <= this.lastOffset);
        }
      }
    });
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this.setSelection(value, value);
  }
  get anchor() {
    return this._anchor;
  }
  get selectionIsCollapsed() {
    return this._anchor === this._position;
  }
  get selectionIsPlaceholder() {
    if (Math.abs(this._anchor - this._position) === 1) {
      return this.at(Math.max(this._anchor, this._position)).type === "placeholder";
    }
    return false;
  }
  collapseSelection(direction = "forward") {
    if (this._anchor === this._position)
      return false;
    if (direction === "backward") {
      this.position = Math.min(this._anchor, this._position);
    } else {
      this.position = Math.max(this._anchor, this._position);
    }
    return true;
  }
  get lastOffset() {
    return this.atoms.length - 1;
  }
  at(index) {
    return this.atoms[index];
  }
  offsetOf(atom) {
    return this.atoms.indexOf(atom);
  }
  getSiblingsRange(offset) {
    const atom = this.at(offset);
    const {parent} = atom;
    if (!parent)
      return [0, this.lastOffset];
    const branch = atom.parent.branch(atom.treeBranch);
    return [this.offsetOf(branch[0]), this.offsetOf(branch[branch.length - 1])];
  }
  getBranchRange(offset, branchName) {
    const branch = this.at(offset).branch(branchName);
    return [this.offsetOf(branch[0]), this.offsetOf(branch[branch.length - 1])];
  }
  getAtoms(arg1, arg2, arg3) {
    let options = arg3 ?? {};
    if (isSelection(arg1)) {
      options = arg2 ?? {};
      if (arg1.ranges.length > 1) {
        return arg1.ranges.reduce((acc, range2) => [...acc, ...this.getAtoms(range2, options)], []);
      }
      arg1 = arg1.ranges[0];
    }
    let start;
    let end;
    if (isOffset(arg1)) {
      start = arg1;
      if (!isOffset(arg2))
        return [];
      end = arg2;
    } else {
      [start, end] = arg1;
      options = arg2 ?? {};
    }
    if (!Number.isFinite(start))
      return [];
    if (options.includeChildren === void 0) {
      options.includeChildren = false;
    }
    if (start < 0)
      start = this.lastOffset - start + 1;
    if (end < 0)
      end = this.lastOffset - end + 1;
    const first = Math.min(start, end) + 1;
    const last = Math.max(start, end);
    if (first === 1 && last === this.lastOffset) {
      return [this.root];
    }
    let result = [];
    for (let i3 = first; i3 <= last; i3++) {
      const atom = this.atoms[i3];
      if (atomIsInRange(this, atom, first, last)) {
        result.push(atom);
      }
    }
    if (!options.includeChildren) {
      result = result.filter((atom) => {
        let ancestorIncluded = false;
        let {parent} = atom;
        while (parent && !ancestorIncluded) {
          ancestorIncluded = atomIsInRange(this, parent, first, last);
          parent = parent.parent;
        }
        return !ancestorIncluded;
      });
    }
    return result;
  }
  getAllAtoms(startingIndex) {
    const result = [];
    const last = this.lastOffset;
    for (let i3 = startingIndex; i3 <= last; i3++) {
      result.push(this.atoms[i3]);
    }
    for (let i3 = 0; i3 < startingIndex; i3++) {
      result.push(this.atoms[i3]);
    }
    return result;
  }
  extractAtoms(range2) {
    let result = this.getAtoms(range2);
    if (result.length === 1 && result[0].type === "root") {
      result = result[0].children;
    }
    for (const child of result)
      child.parent.removeChild(child);
    return result;
  }
  deleteAtoms(range2) {
    this.extractAtoms(range2);
    return range2[0];
  }
  atomToString(atom, inFormat) {
    const format = inFormat ?? "latex";
    let result = "";
    if (format === "latex" || format === "latex-expanded") {
      result = Atom.serialize(atom, {
        expandMacro: format === "latex-expanded",
        defaultMode: this.mathfield.options.defaultMode
      });
    } else if (format === "math-ml") {
      result = atomsToMathML(atom, this.mathfield.options);
    } else if (format === "spoken") {
      result = atomToSpeakableText(atom, this.mathfield.options);
    } else if (format === "spoken-text") {
      const saveTextToSpeechMarkup = this.mathfield.options.textToSpeechMarkup;
      this.mathfield.options.textToSpeechMarkup = "";
      result = atomToSpeakableText(atom, this.mathfield.options);
      this.mathfield.options.textToSpeechMarkup = saveTextToSpeechMarkup;
    } else if (format === "spoken-ssml" || format === "spoken-ssml-with-highlighting") {
      const saveTextToSpeechMarkup = this.mathfield.options.textToSpeechMarkup;
      this.mathfield.options.textToSpeechMarkup = "ssml";
      result = atomToSpeakableText(atom, this.mathfield.options);
      this.mathfield.options.textToSpeechMarkup = saveTextToSpeechMarkup;
    } else if (format === "math-json") {
      try {
        const json = ae(Atom.serialize(atom, {expandMacro: false, defaultMode: "math"}), {
          onError: this.mathfield.options.onError
        });
        result = JSON.stringify(json);
      } catch (e3) {
        return "";
      }
    } else if (format === "ascii-math") {
      result = atomToAsciiMath(atom);
    } else {
      console.warn("Unknown format :", format);
    }
    return result;
  }
  getValue(arg1, arg2, arg3) {
    if (arg1 === void 0) {
      return this.atomToString(this.root, "latex");
    }
    if (typeof arg1 === "string") {
      return this.atomToString(this.root, arg1);
    }
    let ranges;
    let format;
    if (isOffset(arg1) && isOffset(arg2)) {
      ranges = [this.normalizeRange([arg1, arg2])];
      format = arg3 ?? "latex";
    } else if (isRange(arg1)) {
      ranges = [this.normalizeRange(arg1)];
      format = arg2;
    } else if (isSelection(arg1)) {
      ranges = arg1.ranges;
      format = arg2;
    } else {
      ranges = [];
      format = "latex";
    }
    if (format === "latex" || format === "latex-expanded") {
      const options = {
        expandMacro: format === "latex-expanded",
        defaultMode: this.mathfield.options.defaultMode
      };
      return joinLatex(ranges.map((range2) => Atom.serialize(this.getAtoms(range2), options)));
    }
    return ranges.map((range2) => this.getAtoms(range2).map((atom) => this.atomToString(atom, format)).join("")).join("");
  }
  extendSelection(direction) {
    let anchor = this._anchor;
    if (direction === "forward") {
      let pos2 = this._position;
      do {
        let atom = this.at(pos2 + 1);
        if (atom?.inCaptureSelection) {
          while (!atom.captureSelection)
            atom = atom.parent;
          pos2 = this.offsetOf(atom?.parent.lastChild) + 1;
        } else {
          pos2 += 1;
        }
      } while (pos2 <= this.lastOffset && this.at(pos2).isFirstSibling);
      if (pos2 === anchor - 1 && this.at(anchor).type === "first") {
        pos2 = anchor;
      }
      return this.extendSelectionTo(anchor, pos2);
    }
    let pos = this._position - 1;
    if (pos < 0)
      return false;
    while (pos >= 0 && this.at(pos).isLastSibling) {
      let atom = this.at(pos);
      if (atom?.inCaptureSelection) {
        while (!atom.captureSelection)
          atom = atom.parent;
        pos = this.offsetOf(atom?.parent.firstChild) - 1;
      } else {
        pos -= 1;
      }
    }
    if (pos < 0)
      pos = 0;
    if (pos === anchor + 1 && this.at(pos).type === "first") {
      anchor = pos;
    }
    return this.extendSelectionTo(anchor, pos);
  }
  extendSelectionTo(anchor, position) {
    return this.deferNotifications({selection: true}, () => {
      const range2 = this.normalizeRange([anchor, position]);
      let [start, end] = range2;
      let {parent} = this.at(end);
      while (parent !== this.root && childrenInRange(this, parent, [start, end])) {
        end = this.offsetOf(parent);
        parent = parent.parent;
      }
      parent = this.at(start).parent;
      while (parent !== this.root && childrenInRange(this, parent, [start, end])) {
        start = this.offsetOf(parent.leftSibling);
        parent = parent.parent;
      }
      parent = this.at(end).parent;
      while (parent !== this.root && childrenInRange(this, parent, [start, end])) {
        end = this.offsetOf(parent);
        console.assert(end >= 0);
        parent = parent.parent;
      }
      this._position = this.normalizeOffset(position);
      this._selection = {
        ranges: [[start, end]],
        direction: "none"
      };
    });
  }
  setListeners(listeners) {
    this.listeners = listeners;
  }
  setHooks(hooks) {
    this.hooks = {
      announce: hooks?.announce ? hooks.announce : (_target, _command, _previousPosition, _atoms) => {
      },
      moveOut: hooks?.moveOut ? hooks.moveOut : () => true,
      tabOut: hooks?.tabOut ? hooks.tabOut : () => true
    };
  }
  announce(command, previousPosition, atoms = []) {
    this.hooks.announce(this.mathfield, command, previousPosition, atoms);
  }
  deferNotifications(options, f3) {
    const oldSelection = this._selection;
    const oldAnchor = this._anchor;
    const oldPosition = this._position;
    let selectionChanged = false;
    const saved = this.suppressChangeNotifications;
    this.suppressChangeNotifications = true;
    const previousCounter = this.root.changeCounter;
    f3();
    const contentChanged = this.root.changeCounter !== previousCounter;
    if (oldAnchor !== this._anchor || oldPosition !== this._position || compareSelection(this._selection, oldSelection) === "different") {
      selectionChanged = true;
    }
    this.suppressChangeNotifications = saved;
    if (!this.suppressChangeNotifications) {
      if (options.content && contentChanged) {
        contentDidChange(this);
      }
      if (options.selection && selectionChanged) {
        selectionDidChange(this);
      }
    }
    return contentChanged || selectionChanged;
  }
  normalizeOffset(value) {
    if (value > 0) {
      value = Math.min(value, this.lastOffset);
    } else if (value < 0) {
      value = this.lastOffset + value + 1;
    }
    return value;
  }
  normalizeRange(range2) {
    let [start, end] = range2;
    start = this.normalizeOffset(start);
    end = this.normalizeOffset(end);
    return start < end ? [start, end] : [end, start];
  }
  normalizeSelection(value, value2) {
    let result = void 0;
    if (isOffset(value)) {
      const offset = this.normalizeOffset(value);
      if (isOffset(value2)) {
        const offset2 = this.normalizeOffset(value2);
        result = offset <= offset2 ? {ranges: [[offset, offset2]], direction: "none"} : {
          ranges: [[offset2, offset]],
          direction: "backward"
        };
      } else {
        result = {ranges: [[offset, offset]], direction: "none"};
      }
    } else if (isRange(value)) {
      const start = this.normalizeOffset(value[0]);
      const end = this.normalizeOffset(value[1]);
      result = start <= end ? {ranges: [[start, end]], direction: "none"} : {ranges: [[end, start]], direction: "backward"};
    } else if (isSelection(value)) {
      result = {
        ranges: value.ranges.map((x3) => this.normalizeRange(x3)),
        direction: value.direction ?? "none"
      };
    }
    console.assert(result !== void 0);
    return result;
  }
};
function atomIsInRange(model, atom, first, last) {
  const offset = model.offsetOf(atom);
  if (offset < first || offset > last) {
    return false;
  }
  if (!atom.hasChildren)
    return true;
  const firstOffset = model.offsetOf(atom.firstChild);
  if (firstOffset >= first && firstOffset <= last) {
    const lastOffset = model.offsetOf(atom.lastChild);
    if (lastOffset >= first && lastOffset <= last) {
      return true;
    }
  }
  return false;
}
function childrenInRange(model, atom, range2) {
  if (!atom?.hasChildren)
    return false;
  const [start, end] = range2;
  const first = model.offsetOf(atom.firstChild);
  const last = model.offsetOf(atom.lastChild);
  if (first >= start && first <= end && last >= first && last <= end) {
    return true;
  }
  return false;
}

// src/editor-model/array.ts
function addCell(_model, _where) {
}
function convertParentToArray(_model) {
}
function addRowAfter(model) {
  convertParentToArray(model);
  addCell(model, "after row");
  contentDidChange(model);
  return true;
}
function addRowBefore(model) {
  convertParentToArray(model);
  addCell(model, "before row");
  contentDidChange(model);
  return true;
}
function addColumnAfter(model) {
  convertParentToArray(model);
  addCell(model, "after column");
  contentDidChange(model);
  return true;
}
function addColumnBefore(model) {
  convertParentToArray(model);
  addCell(model, "before column");
  contentDidChange(model);
  return true;
}
register2({
  addRowAfter,
  addColumnAfter,
  addRowBefore,
  addColumnBefore
}, {target: "model", category: "array-edit"});

// src/editor-model/delete.ts
function onDelete(model, direction, atom, branch) {
  const parent = atom.parent;
  if (atom instanceof LeftRightAtom) {
    const atStart = !branch && direction === "forward" || branch === "body" && direction === "backward";
    const pos = atStart ? model.offsetOf(atom) - 1 : model.offsetOf(atom.lastChild);
    if (!atStart && atom.leftDelim !== "?" && atom.leftDelim !== ".") {
      parent.addChildBefore(new Atom("mopen", {value: atom.leftDelim}), atom);
    } else if (atStart && atom.rightDelim !== "?" && atom.rightDelim !== ".") {
      parent.addChildAfter(new Atom("mclose", {value: atom.rightDelim}), atom);
    }
    parent.addChildrenAfter(atom.removeBranch("body"), atom);
    parent.removeChild(atom);
    model.position = pos;
    return true;
  }
  if (atom.type === "surd") {
    if (direction === "forward" && !branch || direction === "backward" && branch === "body") {
      const pos = atom.leftSibling;
      if (atom.hasChildren) {
        parent.addChildrenAfter(atom.removeBranch("body"), atom);
      }
      parent.removeChild(atom);
      model.position = model.offsetOf(pos);
    } else if (direction === "forward" && branch === "body") {
      model.position = model.offsetOf(atom);
    } else if (!branch && direction === "backward") {
      if (atom.hasChildren) {
        model.position = model.offsetOf(atom.lastChild);
      } else {
        model.position = Math.max(model.offsetOf(atom) - 1);
        parent.removeChild(atom);
      }
    } else if (branch === "above") {
      if (atom.hasEmptyBranch("above")) {
        atom.removeBranch("above");
      }
      if (direction === "backward") {
        model.position = model.offsetOf(atom.leftSibling);
      } else {
        model.position = model.offsetOf(atom.body[0]);
      }
    }
    return true;
  }
  if (atom.type === "box" || atom.type === "enclose") {
    const pos = branch && direction === "backward" || !branch && direction === "forward" ? atom.leftSibling : atom.lastChild;
    parent.addChildrenAfter(atom.removeBranch("body"), atom);
    parent.removeChild(atom);
    model.position = model.offsetOf(pos);
    return true;
  }
  if (atom.type === "genfrac" || atom.type === "overunder") {
    if (!branch) {
      if (!atom.hasChildren)
        return false;
      model.position = model.offsetOf(direction === "forward" ? atom.firstChild : atom.lastChild);
      return true;
    }
    if (direction === "forward" && branch === "above" || direction === "backward" && branch === "below") {
      const above = atom.removeBranch("above");
      const below = atom.removeBranch("below");
      parent.addChildrenAfter([...above, ...below], atom);
      parent.removeChild(atom);
      model.position = model.offsetOf(above.length > 0 ? above[above.length - 1] : below[0]);
      return true;
    }
    if (direction === "backward") {
      model.position = model.offsetOf(atom.leftSibling);
      return true;
    }
    model.position = model.offsetOf(atom);
    return true;
  }
  if (atom.isExtensibleSymbol || atom.type === "msubsup") {
    if (!branch && direction === "forward")
      return false;
    if (!branch) {
      if (atom.subscript || atom.superscript) {
        const pos = direction === "forward" ? atom.superscript?.[0] ?? atom.subscript?.[0] : atom.subscript?.[0].lastSibling ?? atom.superscript?.[0].lastSibling;
        if (pos)
          model.position = model.offsetOf(pos);
        return true;
      }
      return false;
    }
    if (branch && atom.hasEmptyBranch(branch)) {
      atom.removeBranch(branch);
    }
    if (!atom.hasChildren) {
      const pos = direction === "forward" ? model.offsetOf(atom) : Math.max(0, model.offsetOf(atom) - 1);
      atom.parent.removeChild(atom);
      model.position = pos;
      return true;
    }
    if (branch === "superscript") {
      if (direction === "backward") {
        const pos = model.offsetOf(atom.firstChild) - 1;
        console.assert(pos >= 0);
        model.position = pos;
      } else if (atom.subscript) {
        model.position = model.offsetOf(atom.subscript[0]);
      } else {
        model.position = model.offsetOf(atom);
      }
    } else if (branch === "subscript") {
      if (direction === "backward" && atom.superscript) {
        model.position = model.offsetOf(atom.superscript[0].lastSibling);
      } else if (direction === "backward") {
        model.position = model.offsetOf(atom.firstChild) - 1;
      } else {
        model.position = model.offsetOf(atom);
      }
    }
    return true;
  }
  return false;
}
function deleteBackward(model) {
  if (!model.selectionIsCollapsed) {
    return deleteRange(model, range(model.selection));
  }
  return model.deferNotifications({content: true, selection: true}, () => {
    let target = model.at(model.position);
    if (target && onDelete(model, "backward", target))
      return;
    if (target?.isFirstSibling) {
      if (onDelete(model, "backward", target.parent, target.treeBranch)) {
        return;
      }
      target = null;
    }
    if (!target) {
      model.announce("plonk");
      return;
    }
    const offset = model.offsetOf(target.leftSibling);
    target.parent.removeChild(target);
    model.announce("delete", void 0, [target]);
    model.position = offset;
  });
}
function deleteForward(model) {
  if (!model.selectionIsCollapsed) {
    return deleteRange(model, range(model.selection));
  }
  return model.deferNotifications({content: true, selection: true}, () => {
    let target = model.at(model.position).rightSibling;
    if (target && onDelete(model, "forward", target))
      return;
    if (!target) {
      target = model.at(model.position);
      if (target.isLastSibling && onDelete(model, "forward", target.parent, target.treeBranch)) {
        return;
      }
      target = null;
    } else if (model.at(model.position).isLastSibling && onDelete(model, "forward", target.parent, target.treeBranch)) {
      return;
    }
    if (model.position === model.lastOffset || !target) {
      model.announce("plonk");
      return;
    }
    target.parent.removeChild(target);
    let sibling = model.at(model.position)?.rightSibling;
    while (sibling?.type === "msubsup") {
      sibling.parent.removeChild(sibling);
      sibling = model.at(model.position)?.rightSibling;
    }
    model.announce("delete", void 0, [target]);
  });
}
function deleteRange(model, range2) {
  return model.deferNotifications({content: true, selection: true}, () => {
    model.deleteAtoms(range2);
    model.position = range2[0];
  });
}

// src/core-atoms/composition.ts
var CompositionAtom = class extends Atom {
  constructor(value, options) {
    super("composition", {mode: options?.mode ?? "math", value});
  }
  get computedStyle() {
    return {};
  }
  render(context) {
    const result = new Box(this.value, {
      classes: "ML__composition",
      type: "composition"
    });
    this.bind(context, result);
    if (this.caret)
      result.caret = this.caret;
    return result;
  }
  serialize(_options) {
    return "";
  }
};

// src/editor-model/composition.ts
function updateComposition(model, s3) {
  const cursor = model.at(model.position);
  if (cursor.type === "composition") {
    cursor.value = s3;
  } else {
    const {caret} = cursor;
    cursor.caret = "";
    const atom = new CompositionAtom(s3, {mode: cursor.mode});
    atom.caret = caret;
    cursor.parent.addChildAfter(atom, cursor);
    model.position += 1;
  }
}
function removeComposition(model) {
  const cursor = model.at(model.position);
  if (cursor.type === "composition") {
    cursor.parent.removeChild(cursor);
    model.position -= 1;
  }
}

// src/editor-model/selection.ts
function getMode(model, offset) {
  const atom = model.at(offset);
  let result;
  if (atom) {
    result = atom.mode;
    let ancestor = atom.parent;
    while (!result && ancestor) {
      if (ancestor)
        result = ancestor.mode;
      ancestor = ancestor.parent;
    }
  }
  return result;
}

// src/editor-model/styling.ts
function applyStyleToUnstyledAtoms(atom, style) {
  if (!atom || !style)
    return;
  if (isArray(atom)) {
    atom.forEach((x3) => applyStyleToUnstyledAtoms(x3, style));
  } else if (typeof atom === "object") {
    if (!atom.style.color && !atom.style.backgroundColor && !atom.style.fontFamily && !atom.style.fontShape && !atom.style.fontSeries && !atom.style.fontSize && !atom.style.variant && !atom.style.variantStyle) {
      atom.applyStyle(style);
      applyStyleToUnstyledAtoms(atom.body, style);
      applyStyleToUnstyledAtoms(atom.above, style);
      applyStyleToUnstyledAtoms(atom.below, style);
      applyStyleToUnstyledAtoms(atom.subscript, style);
      applyStyleToUnstyledAtoms(atom.superscript, style);
    }
  }
}
function applyStyle(model, range2, style, options) {
  function everyStyle(property, value) {
    for (const atom of atoms) {
      if (atom.style[property] !== value)
        return false;
    }
    return true;
  }
  range2 = model.normalizeRange(range2);
  if (range2[0] === range2[1])
    return false;
  const atoms = model.getAtoms(range2, {includeChildren: true});
  if (options.operation === "toggle") {
    if (style.color && everyStyle("color", style.color)) {
      style.color = "none";
      style.verbatimColor = void 0;
    }
    if (style.backgroundColor && everyStyle("backgroundColor", style.backgroundColor)) {
      style.backgroundColor = "none";
      style.verbatimBackgroundColor = void 0;
    }
    if (style.fontFamily && everyStyle("fontFamily", style.fontFamily)) {
      style.fontFamily = "none";
    }
    if (style.fontSeries && everyStyle("fontSeries", style.fontSeries)) {
      style.fontSeries = "auto";
    }
    if (style.fontShape && everyStyle("fontShape", style.fontShape)) {
      style.fontShape = "auto";
    }
    if (style.fontSize && everyStyle("fontSize", style.fontSize)) {
      style.fontSize = DEFAULT_FONT_SIZE;
    }
  }
  for (const atom of atoms)
    atom.applyStyle(style);
  return true;
}

// src/editor-model/commands.ts
function wordBoundaryOffset(model, offset, direction) {
  if (model.at(offset).mode !== "text")
    return offset;
  const dir = direction === "backward" ? -1 : 1;
  let result;
  if (LETTER_AND_DIGITS.test(model.at(offset).value)) {
    let i3 = offset;
    let match2;
    do {
      match2 = model.at(i3).mode === "text" && LETTER_AND_DIGITS.test(model.at(i3).value);
      i3 += dir;
    } while (model.at(i3) && match2);
    result = model.at(i3) ? i3 - 2 * dir : i3 - dir;
  } else if (/\s/.test(model.at(offset).value)) {
    let i3 = offset;
    while (model.at(i3) && model.at(i3).mode === "text" && /\s/.test(model.at(i3).value)) {
      i3 += dir;
    }
    if (!model.at(i3)) {
      result = i3 - dir;
    } else {
      let match2 = true;
      do {
        match2 = model.at(i3).mode === "text" && !/\s/.test(model.at(i3).value);
        i3 += dir;
      } while (model.at(i3) && match2);
      result = model.at(i3) ? i3 - 2 * dir : i3 - dir;
    }
  } else {
    let i3 = offset;
    while (model.at(i3) && model.at(i3).mode === "text" && !/\s/.test(model.at(i3).value)) {
      i3 += dir;
    }
    result = model.at(i3) ? i3 : i3 - dir;
    let match2 = true;
    while (model.at(i3) && match2) {
      match2 = model.at(i3).mode === "text" && /\s/.test(model.at(i3).value);
      if (match2)
        result = i3;
      i3 += dir;
    }
    result = model.at(i3) ? i3 - 2 * dir : i3 - dir;
  }
  return result - (dir > 0 ? 0 : 1);
}
function skip(model, direction, options) {
  const previousPosition = model.position;
  if (!(options?.extend ?? false)) {
    model.collapseSelection(direction);
  }
  let atom = model.at(model.position);
  if (direction === "forward") {
    if (atom.type === "msubsup") {
      atom = atom.rightSibling;
      if (!atom) {
        atom = model.at(model.position + 1);
      }
    } else {
      atom = model.at(model.position + 1);
    }
  }
  if (!atom) {
    model.announce("plonk");
    return false;
  }
  let offset = model.offsetOf(atom);
  if (atom instanceof TextAtom) {
    offset = wordBoundaryOffset(model, offset, direction);
  } else if (atom instanceof LatexAtom) {
    if (atom.isSuggestion) {
      console.assert(direction === "forward");
      while (atom && atom instanceof LatexAtom) {
        atom.isSuggestion = false;
        offset = model.offsetOf(atom);
        atom = atom.rightSibling;
      }
    } else if (direction === "forward") {
      atom = atom.rightSibling;
      if (!atom || !(atom instanceof LatexAtom)) {
        model.announce("plonk");
        return false;
      }
      while (atom && atom instanceof LatexAtom && /[a-zA-Z*]/.test(atom.value)) {
        offset = model.offsetOf(atom);
        atom = atom.rightSibling;
      }
    } else {
      atom = atom.leftSibling;
      if (!atom || !(atom instanceof LatexAtom)) {
        model.announce("plonk");
        return false;
      }
      while (atom && atom instanceof LatexAtom && /[a-zA-Z*]/.test(atom.value)) {
        offset = model.offsetOf(atom);
        atom = atom.leftSibling;
      }
    }
  } else if (direction === "forward" && atom.type === "mopen") {
    let level = 0;
    do {
      if (atom.type === "mopen") {
        level += 1;
      } else if (atom.type === "mclose") {
        level -= 1;
      }
      atom = atom.rightSibling;
    } while (!atom.isLastSibling && level !== 0);
    offset = model.offsetOf(atom.leftSibling);
  } else if (direction === "backward" && atom.type === "mclose") {
    let level = 0;
    do {
      if (atom.type === "mopen") {
        level += 1;
      } else if (atom.type === "mclose") {
        level -= 1;
      }
      atom = atom.leftSibling;
    } while (!atom.isFirstSibling && level !== 0);
    offset = model.offsetOf(atom);
  } else if (direction === "backward") {
    if (atom.type === "first") {
      while (offset > 0 && atom.type === "first") {
        offset -= 1;
        atom = model.at(offset);
      }
    } else {
      const type = atom.type;
      if (atom.type === "msubsup") {
        offset = model.offsetOf(model.at(offset).leftSibling);
      }
      offset -= 1;
      let nextType = model.at(offset)?.type;
      while (offset >= 0 && nextType === type) {
        if (model.at(offset)?.type === "msubsup") {
          offset = model.offsetOf(model.at(offset).leftSibling);
        } else {
          offset -= 1;
        }
        nextType = model.at(offset).type;
      }
    }
  } else {
    const {type} = atom;
    let nextType = model.at(offset)?.type;
    const {lastOffset} = model;
    while (offset <= lastOffset && (nextType === type || nextType === "msubsup")) {
      while (model.at(offset).rightSibling?.type === "msubsup") {
        offset = model.offsetOf(model.at(offset).rightSibling);
      }
      offset += 1;
      nextType = model.at(offset)?.type;
    }
    offset -= 1;
  }
  if (options?.extend ?? false) {
    if (!model.setSelection(model.anchor, offset)) {
      model.announce("plonk");
      return false;
    }
  } else {
    if (offset === model.position) {
      model.announce("plonk");
      return false;
    }
    model.position = offset;
  }
  model.announce("move", previousPosition);
  return true;
}
function move(model, direction, options) {
  options = options ?? {extend: false};
  if (direction !== "forward") {
    const [from, to] = getCommandSuggestionRange(model);
    if (from !== void 0 && to !== void 0) {
      model.deleteAtoms([from, to]);
    }
  }
  if (direction === "upward")
    return moveUpward(model, options);
  if (direction === "downward")
    return moveDownward(model, options);
  const previousPosition = model.position;
  if (options.extend) {
    return model.extendSelection(direction);
  }
  if (model.selectionIsPlaceholder) {
    model.collapseSelection(direction);
    return move(model, direction);
  }
  if (!model.collapseSelection(direction)) {
    let pos = model.position + (direction === "forward" ? 1 : -1);
    if (direction === "forward") {
      let atom = model.at(pos);
      if (atom?.inCaptureSelection) {
        while (!atom.captureSelection)
          atom = atom.parent;
        pos = model.offsetOf(atom);
      } else if (!atom?.isFirstSibling && atom?.isLastSibling && atom.parent?.skipBoundary) {
        if (pos + 1 === model.lastOffset) {
          pos = pos + 1;
        } else {
          model.position = pos + 1;
          return move(model, "forward", options);
        }
      } else if (atom instanceof LatexAtom && atom.isSuggestion) {
        atom.isSuggestion = false;
      }
    } else if (direction === "backward") {
      let atom = model.at(pos);
      if (atom?.inCaptureSelection) {
        while (!atom.captureSelection)
          atom = atom.parent;
        pos = Math.max(0, model.offsetOf(atom.leftSibling));
      } else if (!atom?.isLastSibling && atom?.isFirstSibling && atom.parent?.skipBoundary) {
        pos = Math.max(0, pos - 1);
      }
    }
    if (pos < 0 || pos > model.lastOffset) {
      let result = true;
      if (!model.suppressChangeNotifications) {
        result = model.hooks?.moveOut(model, direction);
      }
      if (result)
        model.announce("plonk");
      return result;
    }
    setPositionHandlingPlaceholder(model, pos);
  }
  model.announce("move", previousPosition);
  return true;
}
function setPositionHandlingPlaceholder(model, pos) {
  if (model.at(pos)?.type === "placeholder") {
    model.setSelection(pos - 1, pos);
  } else if (model.at(pos)?.rightSibling?.type === "placeholder") {
    model.setSelection(pos, pos + 1);
  } else {
    model.position = pos;
  }
}
function moveUpward(model, options) {
  const extend = options?.extend ?? false;
  model.collapseSelection("backward");
  let atom = model.at(model.position);
  while (atom && atom.treeBranch !== "below") {
    atom = atom.parent;
  }
  if (atom) {
    if (extend) {
      model.setSelection(model.offsetOf(atom.parent.leftSibling), model.offsetOf(atom.parent));
    } else {
      const branch = atom.parent.branch("above") ?? atom.parent.createBranch("above");
      setPositionHandlingPlaceholder(model, model.offsetOf(branch[branch.length - 1]));
    }
    model.announce("move up");
  } else {
    let result = true;
    if (!model.suppressChangeNotifications) {
      result = model.hooks?.moveOut(model, "upward");
    }
    model.announce(result ? "plonk" : "line");
    return result;
  }
  return true;
}
function moveDownward(model, options) {
  const extend = options?.extend ?? false;
  model.collapseSelection("forward");
  let atom = model.at(model.position);
  while (atom && atom.treeBranch !== "above") {
    atom = atom.parent;
  }
  if (atom) {
    if (extend) {
      model.setSelection(model.offsetOf(atom.parent.leftSibling), model.offsetOf(atom.parent));
    } else {
      const branch = atom.parent.branch("below") ?? atom.parent.createBranch("below");
      setPositionHandlingPlaceholder(model, model.offsetOf(branch[branch.length - 1]));
    }
    model.announce("move down");
  } else {
    let result = true;
    if (!model.suppressChangeNotifications) {
      result = model.hooks?.moveOut(model, "downward");
    }
    model.announce(result ? "plonk" : "line");
    return result;
  }
  return true;
}

// src/editor-model/commands-delete.ts
register2({
  deleteAll: (model) => {
    return deleteRange(model, [0, -1]);
  },
  deleteForward: (model) => deleteForward(model),
  deleteBackward: (model) => deleteBackward(model),
  deleteNextWord: (model) => deleteRange(model, [
    model.anchor,
    wordBoundaryOffset(model, model.position, "forward")
  ]),
  deletePreviousWord: (model) => deleteRange(model, [
    model.anchor,
    wordBoundaryOffset(model, model.position, "backward")
  ]),
  deleteToGroupStart: (model) => deleteRange(model, [
    model.anchor,
    model.offsetOf(model.at(model.position).firstSibling)
  ]),
  deleteToGroupEnd: (model) => deleteRange(model, [
    model.anchor,
    model.offsetOf(model.at(model.position).lastSibling)
  ]),
  deleteToMathFieldStart: (model) => deleteRange(model, [model.anchor, 0]),
  deleteToMathFieldEnd: (model) => deleteRange(model, [model.anchor, -1])
}, {target: "model", category: "delete"});

// src/editor-model/commands-move.ts
function moveAfterParent(model) {
  const previousPosition = model.position;
  if (!model.at(previousPosition).parent) {
    model.announce("plonk");
    return false;
  }
  model.position = model.offsetOf(model.at(model.position).parent);
  model.announce("move", previousPosition);
  return true;
}
function superscriptDepth(model) {
  let result = 0;
  let atom = model.at(model.position);
  let wasSuperscript = false;
  while (atom) {
    if (!atom.hasEmptyBranch("superscript") || !atom.hasEmptyBranch("subscript")) {
      result += 1;
    }
    if (!atom.hasEmptyBranch("superscript")) {
      wasSuperscript = true;
    } else if (!atom.hasEmptyBranch("subscript")) {
      wasSuperscript = false;
    }
    atom = atom.parent;
  }
  return wasSuperscript ? result : 0;
}
function subscriptDepth(model) {
  let result = 0;
  let atom = model.at(model.position);
  let wasSubscript = false;
  while (atom) {
    if (!atom.hasEmptyBranch("superscript") || !atom.hasEmptyBranch("subscript")) {
      result += 1;
    }
    if (!atom.hasEmptyBranch("superscript")) {
      wasSubscript = false;
    } else if (!atom.hasEmptyBranch("subscript")) {
      wasSubscript = true;
    }
    atom = atom.parent;
  }
  return wasSubscript ? result : 0;
}
function moveToSuperscript(model) {
  model.collapseSelection();
  if (superscriptDepth(model) >= model.mathfield.options.scriptDepth[1]) {
    model.announce("plonk");
    return false;
  }
  let target = model.at(model.position);
  if (target.subsupPlacement === void 0) {
    if (target.rightSibling?.type !== "msubsup") {
      target.parent.addChildAfter(new SubsupAtom({style: target.computedStyle}), target);
    }
    target = target.rightSibling;
  }
  target.createBranch("superscript");
  model.setSelection(model.getSiblingsRange(model.offsetOf(target.superscript[0])));
  return true;
}
function moveToSubscript(model) {
  model.collapseSelection();
  if (subscriptDepth(model) >= model.mathfield.options.scriptDepth[0]) {
    model.announce("plonk");
    return false;
  }
  let target = model.at(model.position);
  if (target.subsupPlacement === void 0) {
    if (model.at(model.position + 1)?.type !== "msubsup") {
      target.parent.addChildAfter(new SubsupAtom({
        style: model.at(model.position).computedStyle
      }), target);
    }
    target = model.at(model.position + 1);
  }
  target.createBranch("subscript");
  model.setSelection(model.getSiblingsRange(model.offsetOf(target.subscript[0])));
  return true;
}
function getTabbableElements() {
  function tabbable(element) {
    const regularTabbables = [];
    const orderedTabbables = [];
    const candidates = [
      ...element.querySelectorAll(`input, select, textarea, a[href], button,
        [tabindex], audio[controls], video[controls],
        [contenteditable]:not([contenteditable="false"]), details>summary`)
    ].filter(isNodeMatchingSelectorTabbable);
    candidates.forEach((candidate, i3) => {
      const candidateTabindex = getTabindex(candidate);
      if (candidateTabindex === 0) {
        regularTabbables.push(candidate);
      } else {
        orderedTabbables.push({
          documentOrder: i3,
          tabIndex: candidateTabindex,
          node: candidate
        });
      }
    });
    return orderedTabbables.sort((a3, b3) => a3.tabIndex === b3.tabIndex ? a3.documentOrder - b3.documentOrder : a3.tabIndex - b3.tabIndex).map((a3) => a3.node).concat(regularTabbables);
  }
  function isNodeMatchingSelectorTabbable(element) {
    if (!isNodeMatchingSelectorFocusable(element) || isNonTabbableRadio(element) || getTabindex(element) < 0) {
      return false;
    }
    return true;
  }
  function isNodeMatchingSelectorFocusable(node) {
    if (node.disabled || node.type === "hidden" && node.tagName.toUpperCase() === "INPUT" || isHidden(node)) {
      return false;
    }
    return true;
  }
  function getTabindex(node) {
    const tabindexAttr = Number.parseInt(node.getAttribute("tabindex") ?? "NaN", 10);
    if (!Number.isNaN(tabindexAttr)) {
      return tabindexAttr;
    }
    if (node.contentEditable === "true") {
      return 0;
    }
    if ((node.nodeName === "AUDIO" || node.nodeName === "VIDEO") && node.getAttribute("tabindex") === null) {
      return 0;
    }
    return node.tabIndex;
  }
  function isNonTabbableRadio(node) {
    return node.tagName.toUpperCase() === "INPUT" && node.type === "radio" && !isTabbableRadio(node);
  }
  function getCheckedRadio(nodes, form) {
    for (const node of nodes) {
      if (node.checked && node.form === form) {
        return node;
      }
    }
    return null;
  }
  function isTabbableRadio(node) {
    if (!node.name) {
      return true;
    }
    const radioScope = node.form ?? node.ownerDocument;
    const radioSet = radioScope.querySelectorAll('input[type="radio"][name="' + node.name + '"]');
    const checked = getCheckedRadio(radioSet, node.form);
    return !checked || checked === node;
  }
  function isHidden(element) {
    if (!isBrowser() || element === document.activeElement || element.contains(document.activeElement)) {
      return false;
    }
    if (getComputedStyle(element).visibility === "hidden")
      return true;
    const bounds = element.getBoundingClientRect();
    if (bounds.width === 0 || bounds.height === 0)
      return true;
    while (element) {
      if (getComputedStyle(element).display === "none")
        return true;
      element = element.parentElement;
    }
    return false;
  }
  if (!isBrowser())
    return [];
  return tabbable(document.body);
}
function leap(model, dir, callHooks = true) {
  const dist = dir === "forward" ? 1 : -1;
  if (model.at(model.anchor).type === "placeholder") {
    move(model, dir);
  }
  const atoms = model.getAllAtoms(Math.max(model.position + dist, 0));
  if (dir === "backward")
    atoms.reverse();
  const placeholders = atoms.filter((atom) => atom.type === "placeholder" || atom.treeDepth > 2 && atom.isFirstSibling && atom.isLastSibling);
  if (placeholders.length === 0) {
    const handled = !callHooks || !model.hooks.tabOut?.(model, dir);
    if (handled) {
      model.announce("plonk");
      return false;
    }
    const tabbable = getTabbableElements();
    if (!document.activeElement || tabbable.length === 1) {
      model.announce("plonk");
      return false;
    }
    let index = tabbable.indexOf(document.activeElement) + dist;
    if (document.activeElement instanceof mathfield_element_default && moveToNextNestedMathfield(document.activeElement, dir, dist)) {
      return true;
    }
    if (index < 0)
      index = tabbable.length - 1;
    if (index >= tabbable.length)
      index = 0;
    if (tabbable[index] instanceof mathfield_element_default && moveToNextNestedMathfield(tabbable[index], dir, dist)) {
      return true;
    }
    tabbable[index].focus();
    if (index === 0) {
      model.announce("plonk");
      return false;
    }
    return true;
  }
  function moveToNextNestedMathfield(element, dir2, dist2) {
    const nestedMathfield = [
      ...element.shadowRoot?.querySelectorAll("math-field") ?? []
    ];
    if (nestedMathfield.length) {
      const activeMathfield = element.shadowRoot?.activeElement;
      console.log(activeMathfield);
      const activeIndex = nestedMathfield.indexOf(activeMathfield);
      let newMathfieldIndex = activeIndex + dist2;
      console.log(activeIndex);
      if (activeIndex < 0 && dir2 === "backward") {
        newMathfieldIndex = nestedMathfield.length - 1;
      }
      if (newMathfieldIndex >= 0 && newMathfieldIndex < nestedMathfield.length) {
        console.log(newMathfieldIndex, nestedMathfield, "forward");
        nestedMathfield[newMathfieldIndex].focus();
        return true;
      }
    }
    return false;
  }
  const previousPosition = model.position;
  const newPosition = model.offsetOf(placeholders[0]);
  if (placeholders[0].type === "placeholder") {
    model.setSelection(newPosition - 1, newPosition);
  } else {
    model.position = newPosition;
  }
  model.announce("move", previousPosition);
  return true;
}
register2({
  moveToOpposite: (model) => {
    const OPPOSITE_RELATIONS = {
      superscript: "subscript",
      subscript: "superscript",
      above: "below",
      below: "above"
    };
    const cursor = model.at(model.position);
    const {parent} = cursor;
    if (!parent) {
      model.announce("plonk");
      return false;
    }
    const relation = cursor.treeBranch;
    let oppositeRelation;
    if (typeof relation === "string") {
      oppositeRelation = OPPOSITE_RELATIONS[relation];
    }
    if (!oppositeRelation) {
      if (!cursor.subsupPlacement) {
        return moveToSuperscript(model);
      }
      return moveToSubscript(model);
    }
    if (!parent.branch(oppositeRelation)) {
      parent.createBranch(oppositeRelation);
    }
    return model.setSelection(model.getBranchRange(model.offsetOf(parent), oppositeRelation));
  },
  moveBeforeParent: (model) => {
    const {parent} = model.at(model.position);
    if (!parent) {
      model.announce("plonk");
      return false;
    }
    model.position = model.offsetOf(parent);
    return true;
  },
  moveAfterParent: (model) => moveAfterParent(model),
  moveToNextPlaceholder: (model) => leap(model, "forward"),
  moveToPreviousPlaceholder: (model) => leap(model, "backward"),
  moveToNextChar: (model) => move(model, "forward"),
  moveToPreviousChar: (model) => move(model, "backward"),
  moveUp: (model) => move(model, "upward"),
  moveDown: (model) => move(model, "downward"),
  moveToNextWord: (model) => skip(model, "forward"),
  moveToPreviousWord: (model) => skip(model, "backward"),
  moveToGroupStart: (model) => {
    const pos = model.offsetOf(model.at(model.position).firstSibling);
    if (pos === model.position) {
      model.announce("plonk");
      return false;
    }
    model.position = pos;
    return true;
  },
  moveToGroupEnd: (model) => {
    const pos = model.offsetOf(model.at(model.position).lastSibling);
    if (pos === model.position) {
      model.announce("plonk");
      return false;
    }
    model.position = pos;
    return true;
  },
  moveToMathFieldStart: (model) => {
    if (model.position === 0) {
      model.announce("plonk");
      return false;
    }
    model.position = 0;
    return true;
  },
  moveToMathFieldEnd: (model) => {
    if (model.position === model.lastOffset) {
      model.announce("plonk");
      return false;
    }
    model.position = model.lastOffset;
    return true;
  },
  moveToSuperscript: (model) => moveToSuperscript(model),
  moveToSubscript: (model) => moveToSubscript(model)
}, {target: "model", category: "selection-anchor"});

// src/editor-model/commands-select.ts
function isNumber(atom) {
  if (!atom)
    return false;
  return atom.type === "mord" && /[\d.]/.test(atom.value) || atom.type === "mpunct" && atom.value === ",";
}
function selectGroup(model) {
  if (getMode(model, model.position) === "text") {
    let start = Math.min(model.anchor, model.position);
    let end = Math.max(model.anchor, model.position);
    let done = false;
    while (!done && start > 0) {
      const atom = model.at(start);
      if (atom.mode === "text" && LETTER_AND_DIGITS.test(atom.value)) {
        start -= 1;
      } else {
        done = true;
      }
    }
    done = false;
    while (!done && end <= model.lastOffset) {
      const atom = model.at(end);
      if (atom.mode === "text" && LETTER_AND_DIGITS.test(atom.value)) {
        end += 1;
      } else {
        done = true;
      }
    }
    if (done) {
      end -= 1;
    }
    if (start >= end) {
      model.setSelection(end - 1, end);
      return true;
    }
    model.setSelection(start, end);
  } else {
    const atom = model.at(model.position);
    if (isNumber(atom)) {
      let start = Math.min(model.anchor, model.position);
      let end = Math.max(model.anchor, model.position);
      while (isNumber(model.at(start)))
        start -= 1;
      while (isNumber(model.at(end)))
        end += 1;
      model.setSelection(start, end - 1);
    } else {
      model.setSelection(model.offsetOf(atom.firstSibling), model.offsetOf(atom.lastSibling));
    }
  }
  return true;
}
register2({
  selectGroup: (model) => {
    const result = selectGroup(model);
    if (!result)
      model.announce("plonk");
    return result;
  },
  selectAll: (model) => model.setSelection(0, model.lastOffset),
  extendSelectionForward: (model) => {
    const result = model.extendSelection("forward");
    if (!result)
      model.announce("plonk");
    return result;
  },
  extendSelectionBackward: (model) => {
    const result = model.extendSelection("backward");
    if (!result)
      model.announce("plonk");
    return result;
  },
  extendToNextWord: (model) => skip(model, "forward", {extend: true}),
  extendToPreviousWord: (model) => skip(model, "backward", {extend: true}),
  extendSelectionUpward: (model) => move(model, "upward", {extend: true}),
  extendSelectionDownward: (model) => move(model, "downward", {extend: true}),
  extendToNextBoundary: (model) => skip(model, "forward", {extend: true}),
  extendToPreviousBoundary: (model) => skip(model, "backward", {extend: true}),
  extendToGroupStart: (model) => {
    const result = model.setSelection(model.anchor, model.offsetOf(model.at(model.position).firstSibling));
    if (!result)
      model.announce("plonk");
    return result;
  },
  extendToGroupEnd: (model) => {
    const result = model.setSelection(model.anchor, model.offsetOf(model.at(model.position).lastSibling));
    if (!result)
      model.announce("plonk");
    return result;
  },
  extendToMathFieldStart: (model) => {
    const result = model.setSelection(model.anchor, 0);
    if (!result)
      model.announce("plonk");
    return result;
  },
  extendToMathFieldEnd: (model) => {
    const result = model.setSelection(model.anchor, model.lastOffset);
    if (!result)
      model.announce("plonk");
    return result;
  }
}, {target: "model", category: "selection-extend"});

// src/editor/keyboard.ts
var PRINTABLE_KEYCODE = new Set([
  "Backquote",
  "Digit0",
  "Digit1",
  "Digit2",
  "Digit3",
  "Digit4",
  "Digit5",
  "Digit6",
  "Digit7",
  "Digit8",
  "Digit9",
  "Minus",
  "Equal",
  "IntlYen",
  "KeyQ",
  "KeyW",
  "KeyE",
  "KeyR",
  "KeyT",
  "KeyY",
  "KeyU",
  "KeyI",
  "KeyO",
  "KeyP",
  "BracketLeft",
  "BracketRight",
  "Backslash",
  "KeyA",
  "KeyS",
  "KeyD",
  "KeyF",
  "KeyG",
  "KeyH",
  "KeyJ",
  "KeyK",
  "KeyL",
  "Semicolon",
  "Quote",
  "IntlBackslash",
  "KeyZ",
  "KeyX",
  "KeyC",
  "KeyV",
  "KeyB",
  "KeyN",
  "KeyM",
  "Comma",
  "Period",
  "Slash",
  "IntlRo",
  "Space",
  "Numpad0",
  "Numpad1",
  "Numpad2",
  "Numpad3",
  "Numpad4",
  "Numpad5",
  "Numpad6",
  "Numpad7",
  "Numpad8",
  "Numpad9",
  "NumpadAdd",
  "NumpadComma",
  "NumpadDecimal",
  "NumpadDivide",
  "NumpadEqual",
  "NumpadHash",
  "NumpadMultiply",
  "NumpadParenLeft",
  "NumpadParenRight",
  "NumpadStar",
  "NumpadSubstract"
]);
function mightProducePrintableCharacter(evt) {
  if (evt.ctrlKey || evt.metaKey) {
    return false;
  }
  if (evt.key === "Dead")
    return false;
  if (evt.code === "")
    return true;
  return PRINTABLE_KEYCODE.has(evt.code);
}
function keyboardEventToString(evt) {
  evt = normalizeKeyboardEvent(evt);
  const modifiers = [];
  if (evt.ctrlKey)
    modifiers.push("ctrl");
  if (evt.metaKey)
    modifiers.push("meta");
  if (evt.altKey)
    modifiers.push("alt");
  if (evt.shiftKey)
    modifiers.push("shift");
  if (modifiers.length === 0)
    return "[" + evt.code + "]";
  modifiers.push("[" + evt.code + "]");
  return modifiers.join("+");
}
function delegateKeyboardEvents(textarea, handlers) {
  let keydownEvent = null;
  let keypressEvent = null;
  let compositionInProgress = false;
  let focusInProgress = false;
  let blurInProgress = false;
  let callbackTimeoutID;
  function defer(cb) {
    clearTimeout(callbackTimeoutID);
    callbackTimeoutID = setTimeout(() => {
      clearTimeout(callbackTimeoutID);
      cb();
    });
  }
  function handleTypedText() {
    if (textarea.selectionStart !== textarea.selectionEnd)
      return;
    const text = textarea.value;
    textarea.value = "";
    if (text.length > 0)
      handlers.typedText(text);
  }
  const target = textarea;
  target.addEventListener("keydown", (event) => {
    if (compositionInProgress || event.key === "Process" || event.code === "CapsLock" || /(Control|Meta|Alt|Shift)(Left|Right)/.test(event.code)) {
      keydownEvent = null;
      return;
    }
    keydownEvent = event;
    keypressEvent = null;
    if (!handlers.keystroke(keyboardEventToString(event), event)) {
      keydownEvent = null;
      textarea.value = "";
    } else if (isTouchCapable()) {
      handlers.typedText(event.key);
    }
  }, true);
  target.addEventListener("keypress", (event) => {
    if (compositionInProgress)
      return;
    if (!compositionInProgress) {
      if (keydownEvent && keypressEvent) {
        handlers.keystroke(keyboardEventToString(keydownEvent), keydownEvent);
      }
      keypressEvent = event;
      defer(handleTypedText);
    }
  }, true);
  target.addEventListener("keyup", () => {
    if (compositionInProgress)
      return;
    if (keydownEvent && !keypressEvent) {
      handleTypedText();
    }
  }, true);
  target.addEventListener("paste", (event) => {
    textarea.focus();
    textarea.value = "";
    handlers.paste(event);
  }, true);
  target.addEventListener("cut", (ev) => handlers.cut(ev), true);
  target.addEventListener("copy", (ev) => handlers.copy(ev), true);
  target.addEventListener("blur", (event) => {
    if (event.relatedTarget === event.target.getRootNode().host) {
      event.preventDefault();
      event.stopPropagation();
      return;
    }
    if (blurInProgress || focusInProgress)
      return;
    blurInProgress = true;
    keydownEvent = null;
    keypressEvent = null;
    if (handlers.blur)
      handlers.blur();
    blurInProgress = false;
  }, true);
  target.addEventListener("focus", (_ev) => {
    if (blurInProgress || focusInProgress)
      return;
    focusInProgress = true;
    if (handlers.focus)
      handlers.focus();
    focusInProgress = false;
  }, true);
  target.addEventListener("compositionstart", (event) => {
    compositionInProgress = true;
    textarea.value = "";
    if (handlers.compositionStart) {
      handlers.compositionStart(event.data);
    }
  }, true);
  target.addEventListener("compositionupdate", (ev) => {
    if (!compositionInProgress)
      return;
    if (handlers.compositionUpdate)
      handlers.compositionUpdate(ev.data);
  }, true);
  target.addEventListener("compositionend", (ev) => {
    textarea.value = "";
    if (!compositionInProgress)
      return;
    compositionInProgress = false;
    if (handlers.compositionEnd)
      handlers.compositionEnd(ev.data);
  }, true);
  target.addEventListener("input", (ev) => {
    if (compositionInProgress)
      return;
    if (ev.inputType === "insertCompositionText")
      return;
    if (ev.inputType === "insertFromPaste") {
      ev.preventDefault();
      ev.stopPropagation();
      return;
    }
    defer(handleTypedText);
    ev.preventDefault();
    ev.stopPropagation();
  });
  return {
    cancelComposition: () => {
      const savedBlur = handlers.blur;
      const savedFocus = handlers.focus;
      handlers.blur = null;
      handlers.focus = null;
      textarea.blur();
      textarea.focus();
      handlers.blur = savedBlur;
      handlers.focus = savedFocus;
    },
    blur: () => {
      if (typeof textarea.blur === "function") {
        textarea.blur();
      }
    },
    focus: () => {
      if (typeof textarea.focus === "function") {
        textarea.focus();
      }
    },
    hasFocus: () => {
      return deepActiveElement2() === textarea;
    },
    setValue: (value) => {
      if (value) {
        textarea.value = value;
        if (deepActiveElement2() === textarea && textarea.select) {
          textarea.select();
        }
      } else {
        textarea.value = "";
        textarea.setAttribute("aria-label", "");
      }
    },
    setAriaLabel: (value) => {
      textarea.setAttribute("aria-label", "after: " + value);
    },
    moveTo: (x3, y3) => {
      textarea.style.top = `${y3}px`;
      textarea.style.left = `${x3}px`;
    }
  };
}
function deepActiveElement2() {
  if (!isBrowser())
    return null;
  let a3 = document.activeElement;
  while (a3?.shadowRoot?.activeElement) {
    a3 = a3.shadowRoot.activeElement;
  }
  return a3;
}
function eventToChar(evt) {
  if (!evt)
    return "";
  let result;
  if (evt.key === "Unidentified") {
    if (evt.target) {
      result = evt.target.value;
    }
  }
  result = result ?? evt.key ?? evt.code;
  if (/^(Dead|Return|Enter|Tab|Escape|Delete|PageUp|PageDown|Home|End|Help|ArrowLeft|ArrowRight|ArrowUp|ArrowDown)$/.test(result)) {
    result = "";
  }
  return result;
}

// src/editor/undo.ts
var UndoManager = class {
  constructor(model) {
    this.record = false;
    this.canCoalesce = false;
    this.model = model;
    this.reset();
  }
  get maximumDepth() {
    return 1e3;
  }
  reset() {
    this.stack = [];
    this.index = -1;
  }
  startRecording() {
    this.record = true;
  }
  canUndo() {
    return this.index > 0;
  }
  canRedo() {
    return this.index !== this.stack.length - 1;
  }
  undo(options) {
    if (this.canUndo()) {
      if (typeof options?.onUndoStateWillChange === "function") {
        options.onUndoStateWillChange(this.model.mathfield, "undo");
      }
      this.restore(this.stack[this.index - 1], options);
      this.index -= 1;
      if (options && typeof options.onUndoStateDidChange === "function") {
        options.onUndoStateDidChange(this.model.mathfield, "undo");
      }
      this.canCoalesce = false;
    }
  }
  redo(options) {
    if (this.canRedo()) {
      if (typeof options?.onUndoStateWillChange === "function") {
        options.onUndoStateWillChange(this.model.mathfield, "redo");
      }
      this.index += 1;
      this.restore(this.stack[this.index], options);
      if (options && typeof options.onUndoStateDidChange === "function") {
        options.onUndoStateDidChange(this.model.mathfield, "redo");
      }
      this.canCoalesce = false;
    }
  }
  pop() {
    if (this.canUndo()) {
      this.index -= 1;
      this.stack.pop();
    }
  }
  snapshot(options) {
    if (!this.record)
      return;
    if (typeof options?.onUndoStateWillChange === "function") {
      options.onUndoStateWillChange(this.model.mathfield, "snapshot");
    }
    this.stack.splice(this.index + 1, this.stack.length - this.index - 1);
    this.stack.push({
      latex: Atom.serialize(this.model.root, {
        expandMacro: false,
        defaultMode: this.model.mathfield.options.defaultMode
      }),
      selection: this.model.selection
    });
    this.index++;
    if (this.stack.length > this.maximumDepth) {
      this.stack.shift();
    }
    if (options && typeof options.onUndoStateDidChange === "function") {
      options.onUndoStateDidChange(this.model.mathfield, "snapshot");
    }
    this.canCoalesce = false;
  }
  snapshotAndCoalesce(options) {
    if (this.canCoalesce) {
      this.pop();
    }
    this.snapshot(options);
    this.canCoalesce = true;
  }
  save() {
    return {
      latex: Atom.serialize(this.model.root, {
        expandMacro: false,
        defaultMode: this.model.mathfield.options.defaultMode
      }),
      selection: this.model.selection
    };
  }
  restore(state, options) {
    const wasSuppressing = this.model.suppressChangeNotifications;
    if (options.suppressChangeNotifications !== void 0) {
      this.model.suppressChangeNotifications = options.suppressChangeNotifications;
    }
    ModeEditor.insert("math", this.model, state ? state.latex : "", {
      ...options,
      format: "latex",
      insertionMode: "replaceAll",
      selectionMode: "after",
      smartFence: false
    });
    this.model.selection = state ? state.selection : {ranges: [[0, 0]]};
    this.model.suppressChangeNotifications = wasSuppressing;
  }
};

// src/editor-model/find.ts
function match(pattern, latex) {
  if (typeof pattern === "string") {
    return pattern === latex;
  }
  return pattern.test(latex);
}
function findInBranch(model, atom, branchName, value, options) {
  const branch = atom.branch(branchName);
  if (!branch)
    return [];
  const result = [];
  let {length} = branch;
  while (length > 0) {
    for (let i3 = 1; i3 < branch.length - length + 1; i3++) {
      const latex = Atom.serialize(branch.slice(i3, i3 + length), {
        expandMacro: false,
        defaultMode: model.mathfield.options.defaultMode
      });
      if (match(value, latex)) {
        result.push([
          model.offsetOf(branch[i3].leftSibling),
          model.offsetOf(branch[i3 + length - 1])
        ]);
        i3 += length;
      }
    }
    length--;
  }
  return branch.reduce((acc, x3) => [...acc, ...findInAtom(model, x3, value, options)], result);
}
function findInAtom(model, atom, value, options) {
  if (atom.type === "first")
    return [];
  if (options?.mode && options.mode !== atom.mode)
    return [];
  return atom.branches.reduce((acc, x3) => {
    return [...acc, ...findInBranch(model, atom, x3, value, options)];
  }, []);
}
function find(model, value, options) {
  return findInBranch(model, model.root, "body", value, options).sort((a3, b3) => {
    if (b3[0] === a3[0]) {
      return b3[1] - a3[1];
    }
    return b3[0] - a3[0];
  });
}
function replaceInBranch(model, atom, branchName, pattern, replacement, options) {
  const branch = atom.branch(branchName);
  if (!branch)
    return;
  branch.forEach((x3) => replaceInAtom(model, x3, pattern, replacement, options));
  let i3 = 1;
  while (i3 < branch.length) {
    let length = branch.length - i3;
    while (length > 0) {
      let matched = false;
      const latex = Atom.serialize(branch.slice(i3, i3 + length), {
        expandMacro: false,
        defaultMode: model.mathfield.options.defaultMode
      });
      const replacementArgs = {latex};
      if (typeof pattern === "string" && latex === pattern) {
        matched = true;
      } else if (pattern instanceof RegExp) {
        const match2 = latex.match(pattern);
        if (match2 !== null) {
          matched = true;
          if (match2.length > 0) {
            replacementArgs.p = [...match2];
          }
          replacementArgs.groups = match2.groups;
        }
      }
      if (matched) {
        for (let j2 = i3 + length - 1; j2 >= i3; j2--) {
          atom.removeChild(branch[j2]);
        }
        let replacementString;
        if (typeof replacement === "string") {
          replacementString = replacement;
          if (replacementArgs.p) {
            replacementArgs.p.forEach((x3, index) => {
              if (typeof x3 === "string") {
                replacementString = replacementString.replace("$" + Number(index).toString(), x3);
              }
            });
          }
          if (replacementArgs.groups) {
            Object.keys(replacementArgs.groups).forEach((x3) => {
              if (typeof x3 === "string") {
                replacementString = replacementString.replace("$" + x3, replacementArgs.groups[x3]);
              }
            });
          }
          replacementString = replacementString.replace("$$", "$");
        } else {
          replacementString = replacement(replacementArgs);
        }
        const lastChild = atom.addChildrenAfter(parseLatex(replacementString, {parseMode: atom.mode}), branch[i3 - 1]);
        i3 = branch.indexOf(lastChild) + 1;
        length = branch.length - i3;
      } else {
        length--;
      }
    }
    i3++;
  }
}
function replaceInAtom(model, atom, pattern, replacement, options) {
  if (atom.type === "first")
    return;
  if (options?.mode && options.mode !== atom.mode)
    return;
  atom.branches.forEach((x3) => replaceInBranch(model, atom, x3, pattern, replacement, options));
}
function replace(model, pattern, replacement, options) {
  replaceInBranch(model, model.root, "body", pattern, replacement, options);
  model.position = model.normalizeOffset(model.position);
}

// src/editor-mathfield/smartmode.ts
function convertLastAtomsToText(model, count, until) {
  if (typeof count === "function") {
    until = count;
    count = Infinity;
  }
  if (count === void 0) {
    count = Infinity;
  }
  let i3 = model.position;
  let done = false;
  while (!done) {
    const atom = model.at(i3);
    done = count === 0 || atom === void 0 || atom.mode !== "math" || !(/mord|textord|mpunct/.test(atom.type) || atom.type === "mop" && /[a-zA-Z]+/.test(atom.value)) || !atom.hasEmptyBranch("superscript") || !atom.hasEmptyBranch("subscript") || typeof until === "function" && !until(atom);
    if (!done) {
      atom.mode = "text";
      atom.command = atom.value;
      atom.verbatimLatex = void 0;
    }
    i3 -= 1;
    count -= 1;
  }
  contentDidChange(model);
}
function convertLastAtomsToMath(model, count, until) {
  if (typeof count === "function") {
    until = count;
    count = Infinity;
  }
  if (count === void 0) {
    count = Infinity;
  }
  let i3 = model.position;
  let done = false;
  while (!done) {
    const atom = model.at(i3);
    done = count === 0 || !atom || atom.isFirstSibling || atom.mode !== "text" || atom.value === " " || until && !until(atom);
    if (!done) {
      atom.mode = "math";
    }
    i3 -= 1;
    count -= 1;
  }
  removeIsolatedSpace(model);
  contentDidChange(model);
}
function removeIsolatedSpace(model) {
  let i3 = model.position - 1;
  while (i3 >= 0 && model.at(i3)?.mode === "math") {
    i3 -= 1;
  }
  if (i3 < 0)
    return;
  if (model.at(i3).mode === "text" && model.at(i3).value === " " && model.at(i3 - 1).mode === "math") {
    model.at(i3 - 1).parent.removeChild(model.at(i3 - 1));
    contentDidChange(model);
    const save = model.suppressChangeNotifications;
    model.suppressChangeNotifications = true;
    model.position -= 1;
    model.suppressChangeNotifications = save;
  }
}
function getTextBeforePosition(model) {
  let result = "";
  let i3 = model.position;
  let done = false;
  while (!done) {
    const atom = model.at(i3);
    done = !(atom && (atom.mode === "text" || atom.mode === "math" && /mord|textord|mpunct/.test(atom.type)));
    if (!done) {
      result = atom.value + result;
    }
    i3 -= 1;
  }
  return result;
}
function smartMode(mathfield, keystroke, evt) {
  if (mathfield.smartModeSuppressed) {
    return false;
  }
  const {model} = mathfield;
  if (!model.at(model.position).isLastSibling) {
    return false;
  }
  if (!evt || !mightProducePrintableCharacter(evt)) {
    return false;
  }
  const c3 = eventToChar(evt);
  if (!model.selectionIsCollapsed) {
    if (mathfield.mode === "text") {
      if (/[/_^]/.test(c3)) {
        return true;
      }
    }
    return false;
  }
  const context = getTextBeforePosition(model) + c3;
  if (mathfield.mode === "text") {
    if (keystroke === "Esc" || /[/\\]/.test(c3)) {
      return true;
    }
    if (/[\^_]/.test(c3)) {
      if (/(^|\s)[a-zA-Z][^_]$/.test(context)) {
        convertLastAtomsToMath(model, 1);
      }
      return true;
    }
    const lFence = {")": "(", "}": "{", "]": "["}[c3];
    const {parent} = model.at(model.position);
    if (lFence && parent instanceof LeftRightAtom && parent.leftDelim === lFence) {
      return true;
    }
    if (/(^|[^a-zA-Z])(a|I) $/.test(context)) {
      return false;
    }
    if (/[$]/u.test(c3)) {
      return true;
    }
    if (/(^|[^a-zA-Z'])[a-zA-Z] $/.test(context)) {
      convertLastAtomsToMath(model, 1);
      return false;
    }
    if (/\D\.[^\d\s]$/.test(context)) {
      convertLastAtomsToMath(model, 1);
      const atom = model.at(model.position);
      atom.value = "\u22C5";
      atom.style.variant = "normal";
      atom.command = "\\cdot";
      atom.verbatimLatex = void 0;
      contentDidChange(model);
      return true;
    }
    if (/(^|\s)[a-zA-Z][^a-zA-Z]$/.test(context)) {
      convertLastAtomsToMath(model, 1);
      return true;
    }
    if (/\.\d$/.test(context)) {
      convertLastAtomsToMath(model, 1);
      return true;
    }
    if (/\([\d+\-.]$/.test(context)) {
      convertLastAtomsToMath(model, 1);
      return true;
    }
    if (/\([a-z][,;]$/.test(context)) {
      convertLastAtomsToMath(model, 2);
      return true;
    }
    if (/[\d+\-=><*|]$/.test(c3)) {
      removeIsolatedSpace(model);
      return true;
    }
  } else {
    if (keystroke === "[Space]") {
      convertLastAtomsToText(model, void 0, (a3) => /[a-z][:,;.]$/.test(a3.value));
      return true;
    }
    if (/[a-zA-Z]{3,}$/.test(context) && !/(dxd|abc|xyz|uvw)$/.test(context)) {
      convertLastAtomsToText(model, void 0, (a3) => /[a-zA-Z]/.test(a3.value));
      return true;
    }
    if (/(^|\W)(if)$/i.test(context)) {
      convertLastAtomsToText(model, 1);
      return true;
    }
    if (/(\u0393|\u0394|\u0398|\u039B|\u039E|\u03A0|\u03A3|\u03A5|\u03A6|\u03A8|\u03A9|[\u03B1-\u03C9]|\u03D1|\u03D5|\u03D6|\u03F1|\u03F5){3,}$/u.test(context) && !/()$/.test(context)) {
      convertLastAtomsToText(model, void 0, (a3) => /(:|,|;|.|\u0393|\u0394|\u0398|\u039B|\u039E|\u03A0|\u03A3|\u03A5|\u03A6|\u03A8|\u03A9|[\u03B1-\u03C9]|\u03D1|\u03D5|\u03D6|\u03F1|\u03F5)/u.test(a3.value));
      return true;
    }
    if (c3 === "?") {
      return true;
    }
    if (c3 === "." && !/[\d-+]\.$/.test(context)) {
      return true;
    }
  }
  return false;
}

// src/editor-mathfield/mode-editor-math.ts
var MathModeEditor = class extends ModeEditor {
  constructor() {
    super("math");
  }
  onPaste(mathfield, ev) {
    if (!ev.clipboardData)
      return false;
    let text = "";
    let format = "auto";
    const json = ev.clipboardData.getData("application/json");
    if (json) {
      try {
        text = oe(JSON.parse(json), {});
        format = "latex";
      } catch {
        text = "";
      }
    }
    if (!text) {
      text = ev.clipboardData.getData("text/plain");
    }
    if (text) {
      mathfield.snapshot();
      if (this.insert(mathfield.model, text, {
        smartFence: mathfield.options.smartFence,
        colorMap: mathfield.colorMap,
        backgroundColorMap: mathfield.backgroundColorMap,
        format
      })) {
        requestUpdate(mathfield);
      }
      ev.preventDefault();
      ev.stopPropagation();
    }
    return true;
  }
  insert(model, text, options) {
    if (!options.insertionMode)
      options.insertionMode = "replaceSelection";
    if (!options.selectionMode)
      options.selectionMode = "placeholder";
    if (!options.format)
      options.format = "auto";
    options.macros = options.macros ?? model.options.macros;
    if (!(options.smartFence ?? false)) {
      if (options.insertionMode !== "replaceAll") {
        const {parent: parent2} = model.at(model.position);
        if (parent2 instanceof LeftRightAtom && parent2.rightDelim === "?" && model.at(model.position).isLastSibling && /^[)}\]|]$/.test(text)) {
          parent2.rightDelim = text;
          model.position += 1;
          selectionDidChange(model);
          contentDidChange(model);
          return true;
        }
      }
    } else if (model.selectionIsCollapsed && insertSmartFence(model, text, options.style)) {
      return true;
    }
    const {suppressChangeNotifications} = model;
    if (options.suppressChangeNotifications) {
      model.suppressChangeNotifications = true;
    }
    const contentWasChanging = model.suppressChangeNotifications;
    model.suppressChangeNotifications = true;
    const args = {};
    args[0] = model.getValue(model.selection);
    args["?"] = "\\placeholder{}";
    args["@"] = args["?"];
    if (options.insertionMode === "replaceSelection" && !model.selectionIsCollapsed) {
      model.position = model.deleteAtoms(range(model.selection));
    } else if (options.insertionMode === "replaceAll") {
      model.root.setChildren([], "body");
      model.position = 0;
    } else if (options.insertionMode === "insertBefore") {
      model.collapseSelection("backward");
    } else if (options.insertionMode === "insertAfter") {
      model.collapseSelection("forward");
    }
    if (!model.at(model.position).isLastSibling && model.at(model.position + 1).type === "placeholder") {
      model.deleteAtoms([model.position, model.position + 1]);
    } else if (model.at(model.position).type === "placeholder") {
      model.deleteAtoms([model.position - 1, model.position]);
      model.position -= 1;
    }
    if (args[0]) {
      args["@"] = args[0];
    } else if (/(^|[^\\])#@/.test(text)) {
      const offset = getImplicitArgOffset(model);
      if (offset >= 0) {
        args["@"] = model.getValue(offset, model.position);
        model.deleteAtoms([offset, model.position]);
        model.position = offset;
      }
    }
    if (!args[0])
      args[0] = args["?"];
    let usedArg = false;
    const argFunction = (arg) => {
      usedArg = true;
      return args[arg];
    };
    const [format, newAtoms] = convertStringToAtoms(model, text, argFunction, options);
    if (!newAtoms)
      return false;
    const placeholdersFound = findPlaceholders(newAtoms);
    const newPlaceholders = placeholdersFound.filter((atom) => atom.placeholderId && !model.mathfield._placeholders.has(atom.placeholderId));
    const idsFound = placeholdersFound.map((atom) => atom.placeholderId);
    const removedPlaceholder = [...model.mathfield._placeholders.keys()].filter((placeholderId) => !idsFound.includes(placeholderId));
    removedPlaceholder.forEach((placeholderId) => {
      if (model.mathfield._placeholders.has(placeholderId)) {
        model.mathfield._placeholders.get(placeholderId)?.field.remove();
        model.mathfield._placeholders.delete(placeholderId);
      }
    });
    newPlaceholders.forEach((placeholder) => {
      if (placeholder.placeholderId && !model.mathfield._placeholders.has(placeholder.placeholderId)) {
        const element = new mathfield_element_default({
          virtualKeyboardMode: "onfocus",
          readOnly: false,
          fontsDirectory: model.mathfield.options.fontsDirectory
        });
        const container = model.mathfield.element?.querySelector(".ML__placeholdercontainer");
        element.value = placeholder.defaultValue?.length ? Atom.serialize(placeholder.defaultValue, {defaultMode: "text"}) : "";
        element.classList.add("nested-mathfield");
        element.style.display = "inline-block";
        element.style.zIndex = "1001";
        element.style.position = "absolute";
        element.style.minWidth = "30px";
        const style = document.createElement("style");
        style.innerHTML = `.nested-mathfield {
          border: 1px solid black;
        }
          .ML__fieldcontainer{
            min-height:auto !important;
          }

          `;
        element.appendChild(style);
        element.addEventListener("input", () => {
          placeholderDidChange(model, placeholder.placeholderId);
          setTimeout(() => {
            requestUpdate(model.mathfield);
          });
        });
        container?.appendChild(element);
        model.mathfield._placeholders.set(placeholder.placeholderId, {
          atom: placeholder,
          field: element
        });
      }
    });
    const {parent} = model.at(model.position);
    if (format !== "latex" && model.options.removeExtraneousParentheses && parent instanceof LeftRightAtom && parent.leftDelim === "(" && parent.hasEmptyBranch("body") && newAtoms.length === 1 && newAtoms[0].type === "genfrac") {
      const newParent = parent.parent;
      const branch = parent.treeBranch;
      newParent.removeChild(parent);
      newParent.setChildren(newAtoms, branch);
    }
    const hadEmptyBody = parent.hasEmptyBranch("body");
    const cursor = model.at(model.position);
    cursor.parent.addChildrenAfter(newAtoms, cursor);
    if (format === "latex") {
      if (parent.type === "root" && hadEmptyBody && !usedArg) {
        parent.verbatimLatex = text;
      }
    }
    model.suppressChangeNotifications = contentWasChanging;
    const lastNewAtom = newAtoms[newAtoms.length - 1];
    if (options.selectionMode === "placeholder") {
      const newPlaceholders2 = newAtoms.reduce((acc, atom) => [
        ...acc,
        ...atom.children.filter((x3) => x3.type === "placeholder")
      ], []);
      if (newPlaceholders2.length > 0) {
        const placeholderOffset = model.offsetOf(newPlaceholders2[0]);
        model.setSelection(placeholderOffset - 1, placeholderOffset);
        model.announce("move");
      } else if (lastNewAtom) {
        model.position = model.offsetOf(lastNewAtom);
      }
    } else if (options.selectionMode === "before") {
    } else if (options.selectionMode === "after") {
      if (lastNewAtom) {
        model.position = model.offsetOf(lastNewAtom);
      }
    } else if (options.selectionMode === "item") {
      model.setSelection(model.anchor, model.offsetOf(lastNewAtom));
    }
    contentDidChange(model);
    model.suppressChangeNotifications = suppressChangeNotifications;
    return true;
  }
};
function convertStringToAtoms(model, s3, args, options) {
  let format = void 0;
  let result = [];
  if (options.format === "ascii-math") {
    [format, s3] = parseMathString(s3, {
      format: "ascii-math",
      inlineShortcuts: model.mathfield.options.inlineShortcuts
    });
    result = parseLatex(s3, {
      parseMode: "math",
      macros: options?.macros,
      onError: model.listeners.onError,
      colorMap: options.colorMap,
      backgroundColorMap: options.backgroundColorMap
    });
    if (format !== "latex" && model.options.removeExtraneousParentheses) {
      simplifyParen(result);
    }
  } else if (options.format === "auto" || options.format === "latex") {
    if (options.format === "auto") {
      [format, s3] = parseMathString(s3, {
        format: "auto",
        inlineShortcuts: model.mathfield.options.inlineShortcuts
      });
    }
    if (options.format === "latex")
      [, s3] = trimModeShiftCommand(s3);
    result = parseLatex(s3, {
      parseMode: "math",
      args,
      macros: options.macros,
      smartFence: options.smartFence,
      onError: model.listeners.onError,
      colorMap: options.colorMap,
      backgroundColorMap: options.backgroundColorMap
    });
    if (options.format !== "latex" && model.options.removeExtraneousParentheses) {
      simplifyParen(result);
    }
  }
  applyStyleToUnstyledAtoms(result, options.style);
  return [format ?? "latex", result];
}
function removeParen(atoms) {
  if (!atoms)
    return null;
  console.assert(atoms[0].type === "first");
  if (atoms.length > 1)
    return null;
  const atom = atoms[0];
  if (atom instanceof LeftRightAtom && atom.leftDelim === "(" && atom.rightDelim === ")") {
    return atom.removeBranch("body");
  }
  return null;
}
function simplifyParen(atoms) {
  if (!atoms)
    return;
  for (let i3 = 0; atoms[i3]; i3++) {
    const atom = atoms[i3];
    if (atom instanceof LeftRightAtom && atom.leftDelim === "(") {
      let genFracCount = 0;
      let genFracIndex = 0;
      let nonGenFracCount = 0;
      for (let j2 = 0; atom.body[j2]; j2++) {
        if (atom.body[j2].type === "genfrac") {
          genFracCount++;
          genFracIndex = j2;
        }
        nonGenFracCount++;
      }
      if (nonGenFracCount === 0 && genFracCount === 1) {
        atoms[i3] = atom.body[genFracIndex];
      }
    }
  }
  for (const atom of atoms) {
    for (const branch of atom.branches) {
      if (!atom.hasEmptyBranch(branch)) {
        simplifyParen(atom.branch(branch));
        const newChildren = removeParen(atom.branch(branch));
        if (newChildren)
          atom.setChildren(newChildren, branch);
      }
    }
    if (atom instanceof ArrayAtom) {
      for (const x3 of atom.cells)
        simplifyParen(x3);
    }
  }
}
function findPlaceholders(atoms) {
  if (!atoms)
    return [];
  let result = [];
  for (const atom of atoms) {
    for (const branch of atom.branches) {
      if (!atom.hasEmptyBranch(branch)) {
        const branchPlaceholder = findPlaceholders(atom.branch(branch));
        result = result.concat(branchPlaceholder);
      }
    }
    if (atom instanceof PlaceholderAtom) {
      result.push(atom);
    }
  }
  return result;
}
function getImplicitArgOffset(model) {
  let atom = model.at(model.position);
  if (atom.mode === "text") {
    while (!atom.isFirstSibling && atom.mode === "text") {
      atom = atom.leftSibling;
    }
    return model.offsetOf(atom);
  }
  if (!isImplicitArg(atom)) {
    return -1;
  }
  while (!atom.isFirstSibling && isImplicitArg(atom)) {
    atom = atom.leftSibling;
  }
  return model.offsetOf(atom);
}
function isImplicitArg(atom) {
  if (/^(mord|surd|msubsup|leftright|mop)$/.test(atom.type)) {
    if (atom.isExtensibleSymbol)
      return false;
    return true;
  }
  return false;
}
function insertSmartFence(model, fence, style) {
  console.assert(model.selectionIsCollapsed);
  const atom = model.at(model.position);
  const {parent} = atom;
  let delims = parent instanceof LeftRightAtom ? parent.leftDelim + parent.rightDelim : "";
  if (delims === "\\lbrace\\rbrace")
    delims = "{}";
  if (delims === "\\{\\}")
    delims = "{}";
  if (delims === "\\lparen\\rparen")
    delims = "()";
  if (delims === "{}" && /\||\\vert|\\Vert|\\mvert|\\mid/.test(fence)) {
    ModeEditor.insert("math", model, "\\,\\middle" + fence + "\\, ", {
      format: "latex",
      style
    });
    return true;
  }
  if (fence === "{" || fence === "\\{")
    fence = "\\lbrace";
  if (fence === "}" || fence === "\\}")
    fence = "\\rbrace";
  if (fence === "[")
    fence = "\\lbrack";
  if (fence === "]")
    fence = "\\rbrack";
  const rDelim = RIGHT_DELIM[fence];
  if (rDelim && !(parent instanceof LeftRightAtom && parent.leftDelim === "|")) {
    let s3 = "";
    s3 = atom.isFunction ? `\\mleft${fence}\\mright${rDelim}` : `\\left${fence}\\right?`;
    const lastSiblingOffset = model.offsetOf(atom.lastSibling);
    const content = model.extractAtoms([model.position, lastSiblingOffset]);
    ModeEditor.insert("math", model, s3, {
      format: "latex",
      style
    });
    model.at(model.position).body = content;
    model.position -= 1;
    return true;
  }
  let lDelim = "";
  Object.keys(RIGHT_DELIM).forEach((delim) => {
    if (fence === RIGHT_DELIM[delim])
      lDelim = delim;
  });
  if (lDelim) {
    if (parent instanceof LeftRightAtom && atom.isLastSibling) {
      parent.rightDelim = fence;
      model.position += 1;
      contentDidChange(model);
      return true;
    }
    const firstSibling = model.offsetOf(atom.firstSibling);
    let i3;
    for (i3 = model.position; i3 >= firstSibling; i3--) {
      const atom2 = model.at(i3);
      if (atom2 instanceof LeftRightAtom && atom2.rightDelim === "?") {
        break;
      }
    }
    const match2 = model.at(i3);
    if (i3 >= firstSibling && match2 instanceof LeftRightAtom) {
      match2.rightDelim = fence;
      match2.addChildren(model.extractAtoms([i3, model.position]), atom.treeBranch);
      model.position = i3;
      contentDidChange(model);
      return true;
    }
    if (parent instanceof LeftRightAtom && parent.rightDelim === "?") {
      parent.rightDelim = fence;
      parent.parent.addChildren(model.extractAtoms([model.position, model.offsetOf(atom.lastSibling)]), parent.treeBranch);
      model.position = model.offsetOf(parent);
      contentDidChange(model);
      return true;
    }
    const grandparent = parent.parent;
    if (grandparent instanceof LeftRightAtom && grandparent.rightDelim === "?" && model.at(model.position).isLastSibling) {
      model.position = model.offsetOf(grandparent);
      return insertSmartFence(model, fence, style);
    }
    return false;
  }
  return false;
}
new MathModeEditor();

// css/keystroke-caption.less
var keystroke_caption_default = "/* The element that displays the keys as the user type them */\n#mathlive-keystroke-caption-panel {\n  visibility: hidden;\n  /*min-width: 160px;*/\n  /*background-color: rgba(97, 97, 200, .95);*/\n  background: var(--secondary, hsl(var(--hue, 212), 19%, 26%));\n  border-color: var(--secondary-border, hsl(0, 0%, 91%));\n  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16), 0 3px 6px rgba(0, 0, 0, 0.23);\n  text-align: center;\n  border-radius: 6px;\n  padding: 16px;\n  position: absolute;\n  z-index: 1;\n  display: flex;\n  flex-direction: row-reverse;\n  justify-content: center;\n  --keystroke: white;\n  --on-keystroke: #555;\n  --keystroke-border: #f7f7f7;\n}\n@media (prefers-color-scheme: dark) {\n  body:not([theme='light']) #mathlive-keystroke-caption-panel {\n    --keystroke: hsl(var(--hue, 212), 50%, 30%);\n    --on-keystroke: hsl(0, 0%, 98%);\n    --keystroke-border: hsl(var(--hue, 212), 50%, 25%);\n  }\n}\nbody[theme='dark'] #mathlive-keystroke-caption-panel {\n  --keystroke: hsl(var(--hue, 212), 50%, 30%);\n  --on-keystroke: hsl(0, 0%, 98%);\n  --keystroke-border: hsl(var(--hue, 212), 50%, 25%);\n}\n#mathlive-keystroke-caption-panel > span {\n  min-width: 14px;\n  /*height: 8px;*/\n  margin: 0 8px 0 0;\n  padding: 4px;\n  background-color: var(--keystroke);\n  color: var(--on-keystroke);\n  fill: currentColor;\n  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;\n  font-size: 1em;\n  border-radius: 6px;\n  border: 2px solid var(--keystroke-border);\n  /*box-shadow: 0 7px 14px rgba(0,0,0,0.25), 0 5px 5px rgba(0,0,0,0.22);*/\n}\n";

// src/editor-mathfield/keystroke-caption.ts
var KEYSTROKE_CAPTION_STYLESHEET_HASH = void 0;
var gKeystrokeCaptionStylesheet = null;
var gCoreStylesheet2 = null;
function showKeystroke(mathfield, keystroke) {
  if (mathfield.options.readOnly || !mathfield.keystrokeCaptionVisible)
    return;
  const vb = createKeystrokeCaption(mathfield);
  const bounds = mathfield.element.getBoundingClientRect();
  vb.style.left = `${bounds.left}px`;
  vb.style.top = `${bounds.top - 64}px`;
  vb.innerHTML = mathfield.options.createHTML("<span>" + (getKeybindingMarkup(keystroke) || keystroke) + "</span>" + vb.innerHTML);
  vb.style.visibility = "visible";
  setTimeout(() => {
    if (vb.childNodes.length > 0) {
      vb.childNodes[vb.childNodes.length - 1].remove();
    }
    if (vb.childNodes.length === 0) {
      vb.style.visibility = "hidden";
    }
  }, 3e3);
}
function toggleKeystrokeCaption(mathfield) {
  mathfield.keystrokeCaptionVisible = !mathfield.keystrokeCaptionVisible;
  if (!mathfield.keystrokeCaptionVisible) {
    if (mathfield.keystrokeCaption) {
      mathfield.keystrokeCaption.style.visibility = "hidden";
    }
  } else {
    mathfield.keystrokeCaption = createKeystrokeCaption(mathfield);
    mathfield.keystrokeCaption.innerHTML = "";
  }
  return false;
}
function createKeystrokeCaption(mf) {
  if (mf.keystrokeCaption)
    return mf.keystrokeCaption;
  mf.keystrokeCaption = getSharedElement("mathlive-keystroke-caption-panel");
  if (KEYSTROKE_CAPTION_STYLESHEET_HASH === void 0) {
    KEYSTROKE_CAPTION_STYLESHEET_HASH = hashCode(keystroke_caption_default).toString(36);
  }
  gKeystrokeCaptionStylesheet = inject(null, keystroke_caption_default, KEYSTROKE_CAPTION_STYLESHEET_HASH);
  gCoreStylesheet2 = inject(null, core_default, hashCode(core_default).toString(36));
  return mf.keystrokeCaption;
}
function disposeKeystrokeCaption(mf) {
  releaseSharedElement(mf.keystrokeCaption);
  if (gKeystrokeCaptionStylesheet)
    gKeystrokeCaptionStylesheet.release();
  if (gCoreStylesheet2)
    gCoreStylesheet2.release();
  delete mf.keystrokeCaption;
}

// src/editor-mathfield/keyboard-input.ts
function onKeystroke(mathfield, keystroke, evt) {
  const {model} = mathfield;
  validateKeyboardLayout(evt);
  const activeLayout = getActiveKeyboardLayout();
  if (mathfield.keyboardLayout !== activeLayout.id) {
    mathfield.keyboardLayout = activeLayout.id;
    mathfield._keybindings = void 0;
  }
  showKeystroke(mathfield, keystroke);
  clearTimeout(mathfield.keystrokeBufferResetTimer);
  if (!mathfield.options.readOnly && mathfield.options.onKeystroke && !mathfield.options.onKeystroke(mathfield, keystroke, evt)) {
    if (evt?.preventDefault) {
      evt.preventDefault();
      evt.stopPropagation();
    }
    return false;
  }
  let shortcut;
  let stateIndex;
  let selector = "";
  let resetKeystrokeBuffer = false;
  if (mathfield.mode !== "latex" && (!evt || !evt.ctrlKey && !evt.metaKey)) {
    if (keystroke === "[Backspace]") {
      mathfield.keystrokeBuffer = mathfield.keystrokeBuffer.slice(0, -1);
      mathfield.keystrokeBufferStates.pop();
      mathfield.resetKeystrokeBuffer({defer: true});
    } else if (evt && !mightProducePrintableCharacter(evt)) {
      mathfield.resetKeystrokeBuffer();
    } else {
      const c3 = eventToChar(evt);
      const candidate = mathfield.keystrokeBuffer + c3;
      let i3 = 0;
      while (!shortcut && i3 < candidate.length) {
        const context = mathfield.keystrokeBufferStates[i3] ? parseLatex(mathfield.keystrokeBufferStates[i3].latex, {
          parseMode: effectiveMode(mathfield.options),
          macros: mathfield.options.macros
        }) : model.getAtoms(model.offsetOf(model.at(model.position).firstSibling), model.position);
        shortcut = getInlineShortcut(context, candidate.slice(i3), mathfield.options.inlineShortcuts);
        i3 += 1;
      }
      stateIndex = mathfield.keystrokeBufferStates.length - (candidate.length - i3);
      mathfield.keystrokeBuffer += c3;
      mathfield.keystrokeBufferStates.push(mathfield.getUndoRecord());
      if (getInlineShortcutsStartingWith(candidate, mathfield.options).length <= 1) {
        resetKeystrokeBuffer = true;
      } else {
        mathfield.resetKeystrokeBuffer({defer: true});
      }
    }
  }
  if (mathfield.options.smartMode) {
    const previousMode = mathfield.mode;
    if (shortcut) {
      mathfield.mode = "math";
    } else if (smartMode(mathfield, keystroke, evt)) {
      mathfield.mode = {math: "text", text: "math"}[mathfield.mode];
      selector = "";
    }
    if (mathfield.mode !== previousMode && typeof mathfield.options.onModeChange === "function") {
      mathfield.options.onModeChange(mathfield, mathfield.mode);
    }
  }
  if (!shortcut && !selector) {
    selector = getCommandForKeybinding(mathfield.keybindings, mathfield.mode, keystroke);
  }
  if (!shortcut && !selector && (keystroke === "[Enter]" || keystroke === "[Return]")) {
    if (typeof mathfield.options.onCommit === "function") {
      mathfield.options.onCommit(mathfield);
      if (evt?.preventDefault) {
        evt.preventDefault();
        evt.stopPropagation();
      }
      return false;
    }
  }
  if (!shortcut && !selector) {
    return true;
  }
  const child = model.at(Math.max(model.position, model.anchor));
  const {parent} = child;
  if (selector === "moveAfterParent" && parent && parent.type === "leftright" && child.isLastSibling && mathfield.options.smartFence && insertSmartFence(model, ".", mathfield.style)) {
    selector = "";
    requestUpdate(mathfield);
  }
  if (mathfield.mode === "math" && keystroke === "[Space]" && !shortcut) {
    if (mathfield.options.mathModeSpace) {
      mathfield.snapshot();
      ModeEditor.insert("math", model, mathfield.options.mathModeSpace);
      selector = "";
      mathfield.dirty = true;
    } else {
      const nextSibling = model.at(model.position + 1);
      const previousSibling = model.at(model.position - 1);
      if (nextSibling && nextSibling.mode === "text" || previousSibling && previousSibling.mode === "text") {
        mathfield.snapshot();
        ModeEditor.insert("text", model, " ");
        mathfield.dirty = true;
      }
    }
  }
  if (selector) {
    mathfield.executeCommand(selector);
  } else if (shortcut) {
    mathfield.keyboardDelegate.cancelComposition();
    const style = {
      ...model.at(model.position).computedStyle,
      ...mathfield.style
    };
    if (!/^(\\{|\\}|\\[|\\]|\\@|\\#|\\$|\\%|\\^|\\_|\\backslash)$/.test(shortcut)) {
      const saveMode = mathfield.mode;
      ModeEditor.insert(mathfield.mode, model, eventToChar(evt), {
        suppressChangeNotifications: true,
        style
      });
      mathfield.snapshot();
      mathfield.restoreToUndoRecord(mathfield.keystrokeBufferStates[stateIndex]);
      mathfield.mode = saveMode;
    }
    model.deferNotifications({content: true, selection: true}, () => {
      ModeEditor.insert(mathfield.mode, model, shortcut, {
        format: "latex",
        style,
        smartFence: true
      });
      removeIsolatedSpace(mathfield.model);
      if (shortcut.endsWith(" ")) {
        mathfield.mode = "text";
        ModeEditor.insert("text", model, " ", {style});
      }
      return true;
    });
    mathfield.snapshot();
    mathfield.dirty = true;
    model.announce("replacement");
    if (resetKeystrokeBuffer) {
      mathfield.resetKeystrokeBuffer();
    }
  }
  mathfield.scrollIntoView();
  if (evt?.preventDefault) {
    evt.preventDefault();
    evt.stopPropagation();
  }
  return false;
}
function onTypedText(mathfield, text, options) {
  const {model} = mathfield;
  if (mathfield.options.readOnly) {
    model.announce("plonk");
    return;
  }
  options = options ?? {};
  if (options.focus) {
    mathfield.focus();
  }
  if (options.feedback) {
    if (mathfield.options.keypressVibration && canVibrate()) {
      navigator.vibrate(HAPTIC_FEEDBACK_DURATION);
    }
    mathfield.keypressSound?.play().catch(console.warn);
  }
  if (typeof options.mode === "string" && mathfield.mode !== options.mode) {
    mathfield.switchMode(options.mode);
  }
  if (options.simulateKeystroke) {
    const c3 = text.charAt(0);
    const ev = new KeyboardEvent("keypress", {key: c3});
    if (!onKeystroke(mathfield, c3, ev)) {
      return;
    }
  }
  const style = {
    ...model.at(model.position).computedStyle,
    ...mathfield.style
  };
  if (!model.selectionIsCollapsed) {
    model.position = model.deleteAtoms(range(model.selection));
    mathfield.snapshot();
  }
  const graphemes = splitGraphemes(text);
  if (mathfield.mode === "latex") {
    model.deferNotifications({content: true, selection: true}, () => {
      for (const c3 of graphemes) {
        ModeEditor.insert("latex", model, c3);
      }
      updateAutocomplete(mathfield);
    });
  } else if (mathfield.mode === "text") {
    for (const c3 of graphemes) {
      ModeEditor.insert("text", model, c3, {style});
    }
  } else if (mathfield.mode === "math") {
    for (const c3 of graphemes) {
      let selector = {
        "^": "moveToSuperscript",
        "_": "moveToSubscript",
        " ": "moveAfterParent"
      }[c3];
      if (c3 === " " && mathfield.options.mathModeSpace) {
        selector = ["insert", mathfield.options.mathModeSpace];
      }
      if (selector) {
        mathfield.executeCommand(selector);
      } else if (/\d/.test(c3) && mathfield.options.smartSuperscript && model.at(model.position).treeBranch === "superscript" && model.at(model.position).hasNoSiblings) {
        ModeEditor.insert("math", model, c3, {style});
        moveAfterParent(model);
      } else {
        ModeEditor.insert("math", model, c3, {
          style,
          smartFence: mathfield.options.smartFence
        });
      }
    }
  }
  mathfield.snapshotAndCoalesce();
  mathfield.dirty = true;
  mathfield.scrollIntoView();
}

// src/editor-mathfield/commands.ts
register2({
  undo: (mathfield) => {
    complete(mathfield, "accept");
    mathfield.undo();
    return true;
  },
  redo: (mathfield) => {
    complete(mathfield, "accept");
    mathfield.redo();
    return true;
  },
  scrollIntoView: (mathfield) => {
    mathfield.scrollIntoView();
    return true;
  },
  scrollToStart: (mathfield) => {
    mathfield.field.scroll(0, 0);
    return true;
  },
  scrollToEnd: (mathfield) => {
    const fieldBounds = mathfield.field.getBoundingClientRect();
    mathfield.field.scroll(fieldBounds.left - window.scrollX, 0);
    return true;
  },
  enterLatexMode: (mathfield) => {
    mathfield.switchMode("latex");
    return true;
  },
  toggleKeystrokeCaption,
  switchMode: (mathfield, mode, prefix, suffix) => {
    mathfield.switchMode(mode, prefix, suffix);
    return true;
  },
  insert: (mathfield, s3, options) => mathfield.insert(s3, options),
  typedText: (mathfield, text, options) => {
    onTypedText(mathfield, text, options);
    return true;
  },
  commit: (mathfield) => {
    if (typeof mathfield.options.onCommit === "function") {
      mathfield.options.onCommit(mathfield);
    }
    return true;
  }
});
register2({
  copyToClipboard: (mathfield) => {
    mathfield.focus();
    if (mathfield.model.selectionIsCollapsed) {
      mathfield.select();
    }
    document.execCommand("copy");
    return false;
  },
  cutToClipboard: (mathfield) => {
    mathfield.focus();
    document.execCommand("cut");
    return true;
  },
  pasteFromClipboard: (mathfield) => {
    mathfield.focus();
    document.execCommand("paste");
    return true;
  }
}, {target: "mathfield", category: "clipboard"});

// src/editor-mathfield/styling.ts
function applyStyle2(mathfield, inStyle) {
  const style = validateStyle(mathfield, inStyle);
  mathfield.resetKeystrokeBuffer();
  const {model} = mathfield;
  if (model.selectionIsCollapsed) {
    if (mathfield.style.fontSeries && style.fontSeries === mathfield.style.fontSeries) {
      style.fontSeries = "auto";
    }
    if (style.fontShape && style.fontShape === mathfield.style.fontShape) {
      style.fontShape = "auto";
    }
    if (style.color && style.color === mathfield.style.color) {
      style.color = "none";
    }
    if (style.backgroundColor && style.backgroundColor === mathfield.style.backgroundColor) {
      style.backgroundColor = "none";
    }
    if (style.fontSize && style.fontSize === mathfield.style.fontSize) {
      style.fontSize = "auto";
    }
    mathfield.style = {...mathfield.style, ...style};
  } else {
    mathfield.model.deferNotifications({content: true}, () => {
      model.selection.ranges.forEach((range2) => applyStyle(model, range2, style, {operation: "toggle"}));
      mathfield.snapshot();
    });
  }
  return true;
}
register2({applyStyle: applyStyle2}, {target: "mathfield"});
function validateStyle(mathfield, style) {
  const result = {};
  if (typeof style.color === "string") {
    if (!result.verbatimColor)
      result.verbatimColor = style.color;
    result.color = mathfield.colorMap(style.color);
  }
  if (typeof style.backgroundColor === "string") {
    if (!result.verbatimBackgroundColor) {
      result.verbatimBackgroundColor = style.backgroundColor;
    }
    result.backgroundColor = mathfield.backgroundColorMap(style.backgroundColor);
  }
  if (typeof style.fontFamily === "string") {
    result.fontFamily = style.fontFamily;
  }
  if (typeof style.series === "string") {
    result.fontSeries = style.series;
  }
  if (typeof style.fontSeries === "string") {
    result.fontSeries = style.fontSeries.toLowerCase();
  }
  if (result.fontSeries) {
    result.fontSeries = {
      bold: "b",
      medium: "m",
      normal: "m"
    }[result.fontSeries] || result.fontSeries;
  }
  if (typeof style.shape === "string") {
    result.fontShape = style.shape;
  }
  if (typeof style.fontShape === "string") {
    result.fontShape = style.fontShape.toLowerCase();
  }
  if (result.fontShape) {
    result.fontShape = {
      italic: "it",
      up: "n",
      upright: "n",
      normal: "n"
    }[result.fontShape] || result.fontShape;
  }
  const size = style.size ?? style.fontSize;
  if (typeof size === "number") {
    result.fontSize = Math.max(1, Math.min(10, size));
  } else if (typeof size === "string") {
    result.fontSize = {
      size1: 1,
      size2: 2,
      size3: 3,
      size4: 4,
      size5: 5,
      size6: 6,
      size7: 7,
      size8: 8,
      size9: 9,
      size10: 10
    }[size.toLowerCase()] ?? {
      tiny: 1,
      scriptsize: 2,
      footnotesize: 3,
      small: 4,
      normal: 5,
      normalsize: 5,
      large: 6,
      Large: 7,
      LARGE: 8,
      huge: 9,
      Huge: 10
    }[size];
  }
  return result;
}

// src/editor-mathfield/pointer-input.ts
var gLastTap = null;
var gTapCount = 0;
function isTouchEvent(evt) {
  return globalThis.TouchEvent !== void 0 && evt instanceof TouchEvent;
}
function onPointerDown(mathfield, evt) {
  mathfield._atomBoundsCache = new Map();
  const that = mathfield;
  let anchor;
  let trackingPointer = false;
  let trackingWords = false;
  let dirty = "none";
  if (evt instanceof PointerEvent && evt.buttons !== 1 && evt.buttons !== 0) {
    return;
  }
  let scrollLeft = false;
  let scrollRight = false;
  const anchorX = isTouchEvent(evt) ? evt.touches[0].clientX : evt.clientX;
  const anchorY = isTouchEvent(evt) ? evt.touches[0].clientY : evt.clientY;
  const anchorTime = Date.now();
  const field = that.field;
  const scrollInterval = setInterval(() => {
    if (scrollLeft) {
      field.scroll({top: 0, left: field.scrollLeft - 16});
    } else if (scrollRight) {
      field.scroll({top: 0, left: field.scrollLeft + 16});
    }
  }, 32);
  function endPointerTracking(evt2) {
    if (window.PointerEvent) {
      off(field, "pointermove", onPointerMove);
      off(field, "pointerup pointercancel", endPointerTracking);
      if (evt2 instanceof PointerEvent) {
        field.releasePointerCapture(evt2.pointerId);
      }
    } else {
      off(field, "touchmove", onPointerMove);
      off(field, "touchcancel touchend", endPointerTracking);
      off(window, "mousemove", onPointerMove);
      off(window, "mouseup blur", endPointerTracking);
    }
    trackingPointer = false;
    clearInterval(scrollInterval);
    mathfield.element.classList.remove("tracking");
    if (evt2) {
      evt2.preventDefault();
      evt2.stopPropagation();
    }
  }
  function onPointerMove(evt2) {
    if (!that.hasFocus()) {
      endPointerTracking(null);
      return;
    }
    const x3 = isTouchEvent(evt2) ? evt2.touches[0].clientX : evt2.clientX;
    const y3 = isTouchEvent(evt2) ? evt2.touches[0].clientY : evt2.clientY;
    const hysteresis = isTouchEvent(evt2) || evt2.pointerType === "touch" ? 20 : 5;
    if (Date.now() < anchorTime + 500 && Math.abs(anchorX - x3) < hysteresis && Math.abs(anchorY - y3) < hysteresis) {
      evt2.preventDefault();
      evt2.stopPropagation();
      return;
    }
    const fieldBounds = field.getBoundingClientRect();
    scrollRight = x3 > fieldBounds.right;
    scrollLeft = x3 < fieldBounds.left;
    let actualAnchor = anchor;
    if (evt2 instanceof PointerEvent) {
      if (!evt2.isPrimary) {
        actualAnchor = offsetFromPoint(that, evt2.clientX, evt2.clientY, {
          bias: 0
        });
      }
    } else if (evt2.touches && evt2.touches.length === 2) {
      actualAnchor = offsetFromPoint(that, evt2.touches[1].clientX, evt2.touches[1].clientY, {bias: 0});
    }
    const focus = offsetFromPoint(that, x3, y3, {
      bias: x3 <= anchorX ? x3 === anchorX ? 0 : -1 : 1
    });
    if (trackingWords) {
    }
    if (actualAnchor >= 0 && focus >= 0) {
      that.model.extendSelectionTo(actualAnchor, focus);
      requestUpdate(mathfield);
    }
    evt2.preventDefault();
    evt2.stopPropagation();
  }
  if (gLastTap && Math.abs(gLastTap.x - anchorX) < 5 && Math.abs(gLastTap.y - anchorY) < 5 && Date.now() < gLastTap.time + 500) {
    gTapCount += 1;
    gLastTap.time = anchorTime;
  } else {
    gLastTap = {
      x: anchorX,
      y: anchorY,
      time: anchorTime
    };
    gTapCount = 1;
  }
  const bounds = field.getBoundingClientRect();
  if (anchorX >= bounds.left && anchorX <= bounds.right && anchorY >= bounds.top && anchorY <= bounds.bottom) {
    if (!mathfield.hasFocus()) {
      dirty = "all";
      mathfield.keyboardDelegate.focus();
    }
    mathfield.resetKeystrokeBuffer();
    mathfield.smartModeSuppressed = false;
    anchor = offsetFromPoint(mathfield, anchorX, anchorY, {
      bias: 0
    });
    if (anchor >= 0) {
      mathfield.element.classList.add("tracking");
      if (evt.shiftKey) {
        const wasCollapsed = mathfield.model.selectionIsCollapsed;
        mathfield.model.extendSelectionTo(mathfield.model.anchor, anchor);
        if (acceptCommandSuggestion(mathfield.model) || wasCollapsed) {
          dirty = "all";
        } else {
          dirty = "selection";
        }
      } else if (mathfield.model.at(anchor).type === "placeholder") {
        mathfield.model.setSelection(anchor - 1, anchor);
        dirty = "selection";
      } else if (mathfield.model.at(anchor).rightSibling?.type === "placeholder") {
        mathfield.model.setSelection(anchor, anchor + 1);
        dirty = "selection";
      } else {
        mathfield.model.position = anchor;
        if (acceptCommandSuggestion(mathfield.model)) {
          dirty = "all";
        } else {
          dirty = "selection";
        }
      }
      mathfield.style = {};
      if (evt.detail === 3 || gTapCount > 2) {
        endPointerTracking(evt);
        if (evt.detail === 3 || gTapCount === 3) {
          mathfield.model.selection = {
            ranges: [[0, mathfield.model.lastOffset]]
          };
          dirty = "all";
        }
      } else if (!trackingPointer) {
        trackingPointer = true;
        if (window.PointerEvent) {
          on(field, "pointermove", onPointerMove);
          on(field, "pointerup pointercancel", endPointerTracking);
          if (evt instanceof PointerEvent) {
            field.setPointerCapture(evt.pointerId);
          }
        } else {
          on(window, "blur", endPointerTracking);
          if (isTouchEvent(evt) && evt.touches) {
            on(evt.target, "touchmove", onPointerMove);
            on(evt.target, "touchcancel touchend", endPointerTracking);
          } else {
            on(window, "mousemove", onPointerMove);
            on(window, "mouseup", endPointerTracking);
          }
        }
        if (evt.detail === 2 || gTapCount === 2) {
          trackingWords = true;
          selectGroup(mathfield.model);
          dirty = "all";
        }
      }
    }
  } else {
    gLastTap = null;
  }
  if (dirty !== "none") {
    if (mathfield.model.selectionIsCollapsed)
      dirty = "all";
    requestUpdate(mathfield);
  }
  evt.preventDefault();
}
function distance(x3, y3, r3) {
  const dx = x3 - (r3.left + r3.right) / 2;
  const dy = y3 - (r3.top + r3.bottom) / 2;
  return dx * dx + dy * dy;
}
function nearestAtomFromPointRecursive(mathfield, cache, atom, x3, y3) {
  if (!atom.id)
    return [Infinity, null];
  if (cache.has(atom.id))
    return cache.get(atom.id);
  const bounds = getAtomBounds(mathfield, atom);
  if (!bounds)
    return [Infinity, null];
  let result = [
    atom.type === "group" ? Infinity : distance(x3, y3, bounds),
    atom
  ];
  if (!atom.captureSelection && x3 >= bounds.left && x3 <= bounds.right && atom.hasChildren) {
    for (const child of atom.children) {
      const r3 = nearestAtomFromPointRecursive(mathfield, cache, child, x3, y3);
      if (r3[0] < result[0])
        result = r3;
    }
  }
  if (!result[1]) {
    result = [distance(x3, y3, bounds), atom];
  }
  cache.set(atom.id, result);
  return result;
}
function nearestAtomFromPoint(mathfield, x3, y3) {
  const [, atom] = nearestAtomFromPointRecursive(mathfield, new Map(), mathfield.model.root, x3, y3);
  return atom;
}
function offsetFromPoint(mathfield, x3, y3, options) {
  const bounds = mathfield.fieldContent.getBoundingClientRect();
  if (x3 > bounds.right || y3 > bounds.bottom + 8) {
    return mathfield.model.lastOffset;
  }
  if (x3 < bounds.left || y3 < bounds.top - 8) {
    return 0;
  }
  options = options ?? {};
  options.bias = options.bias ?? 0;
  let atom = nearestAtomFromPoint(mathfield, x3, y3);
  const parents = [];
  let parent = atom;
  while (parent) {
    parents.unshift(parent);
    parent = parent.parent;
  }
  for (const x4 of parents) {
    if (x4.captureSelection) {
      atom = x4;
      break;
    }
  }
  let result = mathfield.model.offsetOf(atom);
  if (result < 0)
    return -1;
  if (atom.leftSibling) {
    if (options.bias === 0 && atom.type !== "placeholder") {
      const bounds2 = getAtomBounds(mathfield, atom);
      if (bounds2 && x3 < (bounds2.left + bounds2.right) / 2) {
        result = mathfield.model.offsetOf(atom.leftSibling);
      }
    } else if (options.bias < 0) {
      result = mathfield.model.offsetOf(atom.leftSibling);
    }
  }
  return result;
}

// css/mathfield.less
var mathfield_default = `@keyframes ML__caret-blink {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0;
  }
}
.ML__caret:after {
  content: '';
  border: none;
  border-radius: 2px;
  border-right: 2px solid var(--caret, hsl(var(--hue, 212), 40%, 49%));
  margin-right: -2px;
  position: relative;
  left: -1px;
  animation: ML__caret-blink 1.05s step-end forwards infinite;
}
.ML__text-caret:after {
  content: '';
  border: none;
  border-radius: 1px;
  border-right: 1px solid var(--caret, hsl(var(--hue, 212), 40%, 49%));
  margin-right: -1px;
  position: relative;
  left: 0;
  animation: ML__caret-blink 1.05s step-end forwards infinite;
}
.ML__latex-caret:after {
  content: '_';
  border: none;
  margin-right: 0;
  margin-right: calc(-1ex - 2px);
  position: relative;
  color: var(--caret, hsl(var(--hue, 212), 40%, 49%));
  animation: ML__caret-blink 1.05s step-end forwards infinite;
}
.ML__fieldcontainer {
  display: flex;
  flex-flow: row;
  justify-content: space-between;
  align-items: flex-end;
  min-height: 39px;
  /* Need some room for the virtual keyboard toggle */
  /* Prevent the browser from trying to interpret touch gestures in the field */
  /* "Disabling double-tap to zoom removes the need for browsers to
        delay the generation of click events when the user taps the screen." */
  touch-action: none;
  width: 100%;
}
/* This is the actual field content (formula) */
.ML__fieldcontainer__field {
  display: flex;
  align-items: center;
  align-self: center;
  position: relative;
  overflow: hidden;
  padding: 2px 0 2px 1px;
  width: 100%;
}
.ML__virtual-keyboard-toggle {
  display: none;
}
.ML__virtual-keyboard-toggle > span {
  display: flex;
  align-self: center;
  align-items: center;
}
.ML__virtual-keyboard-toggle.is-visible {
  display: flex;
  align-self: center;
  align-items: center;
  flex-shrink: 0;
  flex-direction: column;
  justify-content: center;
  width: 34px;
  height: 34px;
  padding: 0;
  margin-right: 4px;
  cursor: pointer;
  box-sizing: border-box;
  /* Avoid some weird blinking with :hover */
  border-radius: 8px;
  border: 1px solid transparent;
  transition: background 0.2s cubic-bezier(0.64, 0.09, 0.08, 1);
  color: var(--primary, hsl(var(--hue, 212), 40%, 50%));
  fill: currentColor;
  background: transparent;
}
.ML__virtual-keyboard-toggle.is-visible:hover {
  background: hsla(0, 0%, 70%, 0.5);
  color: #333;
  fill: currentColor;
  border-radius: 8px;
}
/* Style for the invisible textarea element which is used
to capture keyboard events. We're just trying really hard
to make sure it doesn't show. */
.ML__textarea__textarea {
  display: inline-block;
  transform: scale(0);
  resize: none;
  outline: none;
  border: none;
  /* Need these for Microsoft Edge */
  position: absolute;
  clip: rect(0 0 0 0);
  width: 1px;
  height: 1px;
  /*-ms-transform: scale(0);*/
  /* Need this to prevent iOS Safari from auto-zooming */
  font-size: 1em;
  font-family: KaTeX_Main;
}
.ML__focused .ML__text {
  background: hsla(var(--hue, 212), 40%, 50%, 0.1);
}
/* When using smartFence, the anticipated closing fence is displayed
with this style */
.ML__smart-fence__close {
  opacity: var(--smart-fence-opacity, 0.5);
  color: var(--smart-fence-color, currentColor);
}
.ML__selection {
  background: var(--highlight-inactive, #ccc);
  box-sizing: border-box;
}
.ML__focused .ML__selection {
  background: var(--highlight, hsl(var(--hue, 212), 97%, 85%)) !important;
  color: var(--on-highlight);
}
.ML__contains-caret.ML__close,
.ML__contains-caret.ML__open,
.ML__contains-caret > .ML__close,
.ML__contains-caret > .ML__open,
.ML__contains-caret .ML__sqrt-sign,
.ML__contains-caret .ML__sqrt-line {
  color: var(--caret, hsl(var(--hue, 212), 40%, 49%));
}
.ML__contains-highlight {
  background: var(--contains-highlight, var(--highlight, hsl(var(--hue, 212), 40%, 95%)));
  box-sizing: border-box;
}
.ML__latex {
  font-family: 'IBM Plex Mono', 'Source Code Pro', Consolas, 'Roboto Mono', Menlo, 'Bitstream Vera Sans Mono', 'DejaVu Sans Mono', Monaco, Courier, monospace;
  font-weight: 400;
  color: var(--primary, hsl(var(--hue, 212), 40%, 50%));
}
:not(.ML__latex) + .ML__latex {
  margin-left: 0.25em;
}
.ML__latex + :not(.ML__latex) {
  padding-left: 0.25em;
}
.ML__suggestion {
  opacity: 0.5;
}
.ML__virtual-keyboard-toggle.is-visible.is-pressed:hover {
  background: hsl(var(--hue, 212), 25%, 35%);
  color: #fafafa;
  fill: currentColor;
}
.ML__virtual-keyboard-toggle:focus {
  outline: none;
  border-radius: 8px;
  border: 2px solid var(--primary, hsl(var(--hue, 212), 40%, 50%));
}
.ML__virtual-keyboard-toggle.is-pressed,
.ML__virtual-keyboard-toggle.is-active:hover,
.ML__virtual-keyboard-toggle.is-active {
  background: hsl(var(--hue, 212), 25%, 35%);
  color: #fafafa;
  fill: currentColor;
}
/* Styling for an element which is overlaid
to the left and right of the mathfield while
scrolling to prevent the capture of hover events */
.ML__scroller {
  position: fixed;
  z-index: 1;
  top: 0;
  height: 100vh;
  width: 200px;
}
/* Add an attribute 'data-ML__tooltip' to automatically show a
   tooltip over a element on hover.
   Use 'data-position="top"' to place the tooltip above the
   element rather than below.
   Use 'data-delay' to delay the triggering of the tooltip.
*/
[data-ML__tooltip] {
  position: relative;
}
[data-ML__tooltip][data-placement='top']::after {
  top: inherit;
  bottom: 100%;
}
[data-ML__tooltip]::after {
  position: absolute;
  display: none;
  content: attr(data-ML__tooltip);
  top: 110%;
  width: max-content;
  max-width: 200px;
  padding: 8px 8px;
  background: #616161;
  color: #fff;
  text-align: center;
  z-index: 2;
  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);
  border-radius: 2px;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
  font-weight: 400;
  font-size: 12px;
  /* Phone */
  opacity: 0;
  transform: scale(0.5);
  transition: all 0.15s cubic-bezier(0.4, 0, 1, 1);
}
@media only screen and (max-width: 767px) {
  [data-ML__tooltip]::after {
    padding: 8px 16px;
    font-size: 14px;
  }
}
:not(.tracking) [data-ML__tooltip]:hover {
  position: relative;
}
:not(.tracking) [data-ML__tooltip]:hover::after {
  visibility: visible;
  display: inline-table;
  opacity: 1;
  transform: scale(1);
}
[data-ML__tooltip][data-delay]::after {
  transition-delay: 0s;
}
[data-ML__tooltip][data-delay]:hover::after {
  transition-delay: 1s;
  /* attr(data-delay); Should work. But doesn't. */
}
`;

// src/editor-mathfield/mode-editor-text.ts
var TextModeEditor = class extends ModeEditor {
  constructor() {
    super("text");
  }
  onPaste(mathfield, ev) {
    if (!ev.clipboardData)
      return false;
    const text = ev.clipboardData.getData("text/plain");
    if (text) {
      mathfield.snapshot();
      if (this.insert(mathfield.model, text)) {
        requestUpdate(mathfield);
      }
      ev.preventDefault();
      ev.stopPropagation();
      return true;
    }
    return false;
  }
  insert(model, text, options = {}) {
    if (!options.insertionMode)
      options.insertionMode = "replaceSelection";
    if (!options.selectionMode)
      options.selectionMode = "placeholder";
    if (!options.format)
      options.format = "auto";
    options.macros = options.macros ?? model.options.macros;
    const {suppressChangeNotifications} = model;
    if (options.suppressChangeNotifications) {
      model.suppressChangeNotifications = true;
    }
    const contentWasChanging = model.suppressChangeNotifications;
    model.suppressChangeNotifications = true;
    if (options.insertionMode === "replaceSelection" && !model.selectionIsCollapsed) {
      model.position = model.deleteAtoms(range(model.selection));
    } else if (options.insertionMode === "replaceAll") {
      model.root.setChildren([], "body");
      model.position = 0;
    } else if (options.insertionMode === "insertBefore") {
      model.collapseSelection("backward");
    } else if (options.insertionMode === "insertAfter") {
      model.collapseSelection("forward");
    }
    const newAtoms = convertStringToAtoms2(text);
    applyStyleToUnstyledAtoms(newAtoms, options.style);
    if (!newAtoms)
      return false;
    const cursor = model.at(model.position);
    const lastNewAtom = cursor.parent.addChildrenAfter(newAtoms, cursor);
    model.suppressChangeNotifications = contentWasChanging;
    if (options.selectionMode === "before") {
    } else if (options.selectionMode === "item") {
      model.setSelection(model.anchor, model.offsetOf(lastNewAtom));
    } else if (lastNewAtom) {
      model.position = model.offsetOf(lastNewAtom);
    }
    contentDidChange(model);
    model.suppressChangeNotifications = suppressChangeNotifications;
    return true;
  }
};
function convertStringToAtoms2(s3) {
  s3 = s3.replace(/\\/g, "\\textbackslash ");
  s3 = s3.replace(/#/g, "\\#");
  s3 = s3.replace(/\$/g, "\\$");
  s3 = s3.replace(/%/g, "\\%");
  s3 = s3.replace(/&/g, "\\&");
  s3 = s3.replace(/_/g, "\\_");
  s3 = s3.replace(/{/g, "\\textbraceleft ");
  s3 = s3.replace(/}/g, "\\textbraceright ");
  s3 = s3.replace(/\^/g, "\\textasciicircum ");
  s3 = s3.replace(/~/g, "\\textasciitilde ");
  s3 = s3.replace(//g, "\\textsterling ");
  return parseLatex(s3, {parseMode: "text", registers: {}});
}
new TextModeEditor();

// src/editor-mathfield/mathfield-private.ts
var CORE_STYLESHEET_HASH = void 0;
var MATHFIELD_STYLESHEET_HASH = void 0;
var MathfieldPrivate = class {
  constructor(element, options) {
    this.focusBlurInProgress = false;
    this.stylesheets = [];
    this.options = update(getDefault(), options.readOnly ? {...options, virtualKeyboardMode: "off"} : {
      plonkSound: "plonk.wav",
      keypressSound: {
        spacebar: "keypress-spacebar.wav",
        return: "keypress-return.wav",
        delete: "keypress-delete.wav",
        default: "keypress-standard.wav"
      },
      ...options
    });
    this.macros = this.options.macros;
    this._placeholders = new Map();
    this.colorMap = (name) => {
      let result = void 0;
      if (typeof this.options.colorMap === "function") {
        result = this.options.colorMap(name);
      }
      if (!result)
        result = defaultColorMap(name);
      return result;
    };
    this.backgroundColorMap = (name) => {
      let result = void 0;
      if (typeof this.options.backgroundColorMap === "function") {
        result = this.options.backgroundColorMap(name);
      }
      if (!result && typeof this.options.colorMap === "function") {
        result = this.options.colorMap(name);
      }
      if (!result)
        result = defaultBackgroundColorMap(name);
      return result;
    };
    if (!this.options.readOnly) {
      this.virtualKeyboard = options.useSharedVirtualKeyboard ? new VirtualKeyboardDelegate({
        targetOrigin: this.options.sharedVirtualKeyboardTargetOrigin,
        originValidator: this.options.originValidator,
        mathfield: this
      }) : new VirtualKeyboard(this.options, this);
    }
    this.plonkSound = this.options.plonkSound;
    if (!this.options.keypressSound) {
      this.keypressSound = null;
      this.spacebarKeypressSound = null;
      this.returnKeypressSound = null;
      this.deleteKeypressSound = null;
    } else if (this.options.keypressSound && typeof this.options.keypressSound !== "string" && !(this.options.keypressSound instanceof HTMLAudioElement)) {
      this.keypressSound = this.options.keypressSound.default;
      this.spacebarKeypressSound = this.options.keypressSound.spacebar;
      this.returnKeypressSound = this.options.keypressSound.return;
      this.deleteKeypressSound = this.options.keypressSound.delete;
    }
    this.element = element;
    element.mathfield = this;
    let elementText = options.value ?? this.element.textContent;
    if (elementText) {
      elementText = elementText.trim();
    }
    void loadFonts(this.options.fontsDirectory, this.options.onError);
    if (!CORE_STYLESHEET_HASH) {
      CORE_STYLESHEET_HASH = hashCode(core_default).toString(36);
    }
    this.stylesheets.push(inject(element, core_default, CORE_STYLESHEET_HASH));
    if (!MATHFIELD_STYLESHEET_HASH) {
      MATHFIELD_STYLESHEET_HASH = hashCode(mathfield_default).toString(36);
    }
    this.stylesheets.push(inject(element, mathfield_default, MATHFIELD_STYLESHEET_HASH));
    let markup = "";
    markup += "<span class='ML__textarea'>";
    markup += isTouchCapable() ? `<span class='ML__textarea__textarea' tabindex="-1" role="textbox"></span>` : `<textarea class="ML__textarea__textarea" autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false" aria-hidden="true" tabindex="${element.tabIndex ?? 0}"></textarea>`;
    markup += "</span>";
    markup += '<span class="ML__fieldcontainer"><span class="ML__fieldcontainer__field"></span>';
    markup += `<div part='virtual-keyboard-toggle' class="ML__virtual-keyboard-toggle" role="button" data-ML__tooltip="${localize("tooltip.toggle virtual keyboard")}">`;
    markup += this.options.virtualKeyboardToggleGlyph ?? DEFAULT_KEYBOARD_TOGGLE_GLYPH;
    markup += "</div>";
    markup += "<div class='ML__placeholdercontainer'></div>";
    markup += "</span>";
    markup += '<div class="ML__sr-only"><span aria-live="assertive" aria-atomic="true"></span><span></span></div>';
    this.element.innerHTML = this.options.createHTML(markup);
    if (!this.element.children) {
      console.error("%cMathlive: Something went wrong and the mathfield could not be created.%c\nIf you are using Vue, this may be because you are using the runtime-only build of Vue. Make sure to include 'runtimeCompiler: true' in your Vue configuration. Theremay a warning from Vue in the log above.", "color:red;font-family:system-ui;font-size:1.2rem;font-weight:bold", "color:inherith;font-family:system-ui;font-size:inherit;font-weight:inherit");
      return;
    }
    let iChild = 0;
    const textarea = this.element.children[iChild++].firstElementChild;
    this.field = this.element.children[iChild].children[0];
    this.field.addEventListener("wheel", this, {passive: false});
    iChild++;
    this.virtualKeyboardToggle = this.element.querySelector(".ML__virtual-keyboard-toggle");
    if (!this.options.readOnly && this.options.virtualKeyboardMode === "manual") {
      this.virtualKeyboardToggle.classList.add("is-visible");
    } else {
      this.virtualKeyboardToggle.classList.remove("is-visible");
    }
    if (this.options.readOnly) {
      this.element.classList.add("ML__isReadOnly");
    } else {
      this.element.classList.remove("ML__isReadOnly");
    }
    if (this.options.defaultMode === "inline-math") {
      this.element.classList.add("ML__isInline");
    } else {
      this.element.classList.remove("ML__isInline");
    }
    attachButtonHandlers((command) => this.executeCommand(command), this.virtualKeyboardToggle, {
      default: "toggleVirtualKeyboard",
      alt: "toggleVirtualKeyboardAlt",
      shift: "toggleVirtualKeyboardShift"
    });
    this.ariaLiveText = this.element.children[iChild].children[0];
    this.accessibleNode = this.element.children[iChild++].children[1];
    this.keystrokeCaptionVisible = false;
    this.popoverVisible = false;
    this.suggestionIndex = 0;
    this.keystrokeBuffer = "";
    this.keystrokeBufferStates = [];
    this.keystrokeBufferResetTimer = 0;
    this.mode = effectiveMode(this.options);
    this.smartModeSuppressed = false;
    this.style = {};
    this.blurred = true;
    on(this.element, "focus", this);
    on(this.element, "blur", this);
    this.keyboardDelegate = delegateKeyboardEvents(textarea, {
      typedText: (text) => onTypedText(this, text),
      cut: (_ev) => {
        if (this.options.readOnly) {
          this.model.announce("plonk");
          return;
        }
        this.snapshot();
        setTimeout(() => {
          deleteRange(this.model, range(this.model.selection));
          requestUpdate(this);
        }, 0);
      },
      copy: (ev) => ModeEditor.onCopy(this, ev),
      paste: (ev) => {
        if (this.options.readOnly) {
          this.model.announce("plonk");
          return;
        }
        ModeEditor.onPaste(this.model.at(this.model.position).mode, this, ev);
      },
      keystroke: (keystroke, event) => onKeystroke(this, keystroke, event),
      focus: () => this.onFocus(),
      blur: () => this.onBlur(),
      compositionStart: (composition) => this.onCompositionStart(composition),
      compositionUpdate: (composition) => this.onCompositionUpdate(composition),
      compositionEnd: (composition) => this.onCompositionEnd(composition)
    });
    if (window.PointerEvent) {
      on(this.field, "pointerdown", this);
    } else {
      on(this.field, "touchstart:active mousedown", this);
    }
    on(window, "resize", this);
    this.model = new ModelPrivate({
      mode: effectiveMode(this.options),
      macros: this.macros,
      removeExtraneousParentheses: this.options.removeExtraneousParentheses
    }, {
      onContentDidChange: (_sender) => this.options.onContentDidChange(this),
      onSelectionDidChange: (_sender) => this._onSelectionDidChange(),
      onContentWillChange: () => this.options.onContentWillChange(this),
      onSelectionWillChange: () => this.options.onSelectionWillChange(this),
      onError: this.options.onError,
      onPlaceholderDidChange: (_sender, placeholderId) => this.options.onPlaceholderDidChange(this, placeholderId)
    }, {
      announce: (_sender, command, previousPosition, atoms) => this.options.onAnnounce?.(this, command, previousPosition, atoms),
      moveOut: (_sender, direction) => this.options.onMoveOutOf(this, direction),
      tabOut: (_sender, direction) => this.options.onTabOutOf(this, direction)
    }, this);
    this.undoManager = new UndoManager(this.model);
    if (elementText) {
      ModeEditor.insert("math", this.model, elementText, {
        insertionMode: "replaceAll",
        selectionMode: "after",
        format: "latex",
        suppressChangeNotifications: true,
        macros: this.options.macros
      });
    }
    this.undoManager.startRecording();
    this.undoManager.snapshot(this.options);
    this.model.setListeners({
      onContentDidChange: (_sender) => this.options.onContentDidChange(this),
      onSelectionDidChange: (_sender) => this._onSelectionDidChange(),
      onContentWillChange: () => this.options.onContentWillChange(this),
      onSelectionWillChange: () => this.options.onSelectionWillChange(this),
      onError: this.options.onError,
      onPlaceholderDidChange: (_sender, placeholderId) => this.options.onPlaceholderDidChange(this, placeholderId)
    });
    this.model.setHooks({
      announce: (_sender, command, previousPosition, atoms) => this.options.onAnnounce?.(this, command, previousPosition, atoms),
      moveOut: (_sender, direction) => this.options.onMoveOutOf(this, direction),
      tabOut: (_sender, direction) => this.options.onTabOutOf(this, direction)
    });
    if (!this.options.locale.startsWith(getActiveKeyboardLayout().locale)) {
      setKeyboardLayoutLocale(this.options.locale);
    }
    requestUpdate(this);
    if (isBrowser()) {
      document.fonts.ready.then(() => render(this));
    }
  }
  get virtualKeyboardState() {
    if (this.virtualKeyboard?.visible)
      return "visible";
    return "hidden";
  }
  set virtualKeyboardState(value) {
    if (!this.virtualKeyboard)
      return;
    if (value === "hidden") {
      this.virtualKeyboard.executeCommand("hideVirtualKeyboard");
    } else if (value === "visible") {
      this.virtualKeyboard.executeCommand("showVirtualKeyboard");
    }
  }
  get keybindings() {
    if (this._keybindings)
      return this._keybindings;
    this._keybindings = normalizeKeybindings(this.options.keybindings, getActiveKeyboardLayout() ?? DEFAULT_KEYBOARD_LAYOUT, (e3) => {
      if (typeof this.options.onError === "function") {
        this.options.onError({
          code: "invalid-keybinding",
          arg: e3.join("\n")
        });
      }
      console.error(e3.join("\n"));
    });
    return this._keybindings;
  }
  setOptions(config) {
    this.options = update(this.options, config);
    this.model.setListeners({
      onContentDidChange: (_sender) => this.options.onContentDidChange(this),
      onSelectionDidChange: (_sender) => this._onSelectionDidChange(),
      onContentWillChange: () => this.options.onContentWillChange(this),
      onSelectionWillChange: () => this.options.onSelectionWillChange(this),
      onError: this.options.onError,
      onPlaceholderDidChange: (_sender, placeholderId) => this.options.onPlaceholderDidChange(this, placeholderId)
    });
    this.model.setHooks({
      announce: (_sender, command, previousPosition, atoms) => this.options.onAnnounce?.(this, command, previousPosition, atoms),
      moveOut: (_sender, direction) => this.options.onMoveOutOf(this, direction),
      tabOut: (_sender, direction) => this.options.onTabOutOf(this, direction)
    });
    if (!this.options.locale.startsWith(getActiveKeyboardLayout().locale)) {
      setKeyboardLayoutLocale(this.options.locale);
    }
    this._keybindings = void 0;
    this.plonkSound = this.options.plonkSound;
    if (this.options.keypressSound && typeof this.options.keypressSound !== "string" && !(this.options.keypressSound instanceof HTMLAudioElement)) {
      this.keypressSound = this.options.keypressSound.default;
      this.spacebarKeypressSound = this.options.keypressSound.spacebar;
      this.returnKeypressSound = this.options.keypressSound.return;
      this.deleteKeypressSound = this.options.keypressSound.delete;
    }
    if (this.options.readOnly) {
      this.onBlur();
      this.element.classList.add("ML__isReadOnly");
    } else {
      this.element.classList.remove("ML__isReadOnly");
    }
    if (this.options.defaultMode === "inline-math") {
      this.element.classList.add("ML__isInline");
    } else {
      this.element.classList.remove("ML__isInline");
    }
    this.virtualKeyboard?.setOptions(this.options);
    if (!this.options.readOnly && this.options.virtualKeyboardMode === "manual") {
      this.virtualKeyboardToggle?.classList.add("is-visible");
    } else {
      this.virtualKeyboardToggle?.classList.remove("is-visible");
    }
    if ("virtualKeyboardToggleGlyph" in config) {
      const toggle = this.element?.querySelector(".ML__virtual-keyboard-toggle");
      if (toggle) {
        toggle.innerHTML = this.options.createHTML(this.options.virtualKeyboardToggleGlyph);
      }
    }
    this.colorMap = (name) => {
      let result = void 0;
      if (typeof this.options.colorMap === "function") {
        result = this.options.colorMap(name);
      }
      if (!result)
        result = defaultColorMap(name);
      return result;
    };
    this.backgroundColorMap = (name) => {
      let result = void 0;
      if (typeof this.options.backgroundColorMap === "function") {
        result = this.options.backgroundColorMap(name);
      }
      if (!result && typeof this.options.colorMap === "function") {
        result = this.options.colorMap(name);
      }
      if (!result)
        result = defaultBackgroundColorMap(name);
      return result;
    };
    const content = Atom.serialize(this.model.root, {
      expandMacro: false,
      defaultMode: this.options.defaultMode
    });
    if ("macros" in config || this.model.getValue() !== content) {
      ModeEditor.insert("math", this.model, content, {
        insertionMode: "replaceAll",
        selectionMode: "after",
        format: "latex",
        suppressChangeNotifications: true,
        macros: this.options.macros
      });
    }
    requestUpdate(this);
  }
  getOptions(keys) {
    return get(this.options, keys);
  }
  getOption(key) {
    return get(this.options, key);
  }
  handleEvent(evt) {
    switch (evt.type) {
      case "focus":
        if (!this.focusBlurInProgress) {
          this.focusBlurInProgress = true;
          this.onFocus();
          this.focusBlurInProgress = false;
        }
        break;
      case "blur":
        if (!this.focusBlurInProgress) {
          this.focusBlurInProgress = true;
          this.onBlur();
          this.focusBlurInProgress = false;
        }
        break;
      case "touchstart":
      case "mousedown":
        onPointerDown(this, evt);
        break;
      case "pointerdown":
        onPointerDown(this, evt);
        break;
      case "resize":
        if (this.resizeTimer) {
          cancelAnimationFrame(this.resizeTimer);
        }
        this.resizeTimer = requestAnimationFrame(() => isValidMathfield(this) && this.onResize());
        break;
      case "wheel":
        this.onWheel(evt);
        break;
      default:
        console.warn("Unexpected event type", evt.type);
    }
  }
  dispose() {
    if (!isValidMathfield(this))
      return;
    const element = this.element;
    delete this.element;
    delete element.mathfield;
    element.innerHTML = this.getValue();
    off(element, "pointerdown", this);
    off(element, "touchstart:active mousedown", this);
    off(element, "focus", this);
    off(element, "blur", this);
    off(window, "resize", this);
    delete this.accessibleNode;
    delete this.ariaLiveText;
    delete this.field;
    delete this.fieldContent;
    delete this.keyboardDelegate;
    this.virtualKeyboardToggle.remove();
    delete this.virtualKeyboardToggle;
    if (this.virtualKeyboard) {
      this.virtualKeyboard.dispose();
      delete this.virtualKeyboard;
    }
    disposePopover(this);
    disposeKeystrokeCaption(this);
    this.stylesheets.forEach((x3) => x3?.release());
  }
  resetKeystrokeBuffer(options) {
    options = options ?? {defer: false};
    if (options.defer) {
      if (this.options.inlineShortcutTimeout > 0) {
        this.keystrokeBufferResetTimer = setTimeout(() => {
          this.resetKeystrokeBuffer();
        }, this.options.inlineShortcutTimeout);
      }
      return;
    }
    this.keystrokeBuffer = "";
    this.keystrokeBufferStates = [];
    clearTimeout(this.keystrokeBufferResetTimer);
  }
  executeCommand(command) {
    if (getCommandTarget(command) === "virtual-keyboard") {
      return this.virtualKeyboard?.executeCommand(command) ?? false;
    }
    return perform(this, command);
  }
  get lastOffset() {
    return this.model.lastOffset;
  }
  get selection() {
    return this.model.selection;
  }
  set selection(value) {
    this.model.selection = value;
  }
  getValue(arg1, arg2, arg3) {
    return this.model.getValue(arg1, arg2, arg3);
  }
  setValue(value, options) {
    options = options ?? {mode: "math"};
    if (options.insertionMode === void 0) {
      options.insertionMode = "replaceAll";
    }
    if (options.format === void 0 || options.format === "auto") {
      options.format = "latex";
    }
    let mode = "math";
    if (options.mode === void 0 || options.mode === "auto") {
      mode = getMode(this.model, this.model.position) ?? "math";
    }
    if (ModeEditor.insert(mode, this.model, value, {
      ...options,
      colorMap: this.colorMap,
      backgroundColorMap: this.backgroundColorMap
    })) {
      this.undoManager.snapshot(this.options);
      requestUpdate(this);
    }
  }
  find(value, options) {
    return find(this.model, value, options);
  }
  replace(searchValue, newValue, options) {
    replace(this.model, searchValue, newValue, options);
  }
  getPlaceholderField(placeholderId) {
    return this._placeholders.get(placeholderId)?.field;
  }
  scrollIntoView() {
    if (this.dirty) {
      render(this);
    }
    const fieldBounds = this.field.getBoundingClientRect();
    let caretPoint = void 0;
    if (this.model.selectionIsCollapsed) {
      caretPoint = getCaretPoint(this.field)?.x;
    } else {
      const selectionBounds = getSelectionBounds(this);
      if (selectionBounds.length > 0) {
        let maxRight = -Infinity;
        for (const r3 of selectionBounds) {
          if (r3.right > maxRight)
            maxRight = r3.right;
        }
        caretPoint = maxRight + fieldBounds.left - this.field.scrollLeft;
      }
    }
    if (caretPoint !== void 0) {
      const x3 = caretPoint - window.scrollX;
      if (x3 < fieldBounds.left) {
        this.field.scroll({
          top: 0,
          left: x3 - fieldBounds.left + this.field.scrollLeft - 20,
          behavior: "smooth"
        });
      } else if (x3 > fieldBounds.right) {
        this.field.scroll({
          top: 0,
          left: x3 - fieldBounds.right + this.field.scrollLeft + 20,
          behavior: "smooth"
        });
      }
    }
  }
  insert(s3, options) {
    if (typeof s3 === "string" && s3.length > 0) {
      options = options ?? {mode: "math"};
      if (options.focus) {
        this.focus();
      }
      if (options.feedback) {
        if (this.options.keypressVibration && canVibrate()) {
          navigator.vibrate(HAPTIC_FEEDBACK_DURATION);
        }
        void this.keypressSound?.play().catch(console.warn);
      }
      if (options.scrollIntoView) {
        this.scrollIntoView();
      }
      if (s3 === "\\\\") {
        addRowAfter(this.model);
      } else if (s3 === "&") {
        addColumnAfter(this.model);
      } else {
        const savedStyle = this.style;
        ModeEditor.insert(this.mode, this.model, s3, {
          style: this.model.at(this.model.position).computedStyle,
          ...options
        });
        if (options.resetStyle) {
          this.style = savedStyle;
        }
      }
      this.undoManager.snapshot(this.options);
      requestUpdate(this);
      return true;
    }
    return false;
  }
  switchMode(mode, prefix = "", suffix = "") {
    if (this.mode === mode || this.options.readOnly)
      return;
    const {model} = this;
    model.deferNotifications({content: Boolean(suffix) || Boolean(prefix), selection: true}, () => {
      let contentChanged = false;
      this.resetKeystrokeBuffer();
      this.smartModeSuppressed = /text|math/.test(this.mode) && /text|math/.test(mode);
      if (prefix && mode !== "latex") {
        const atoms = parseLatex(prefix, {
          parseMode: {math: "text", text: "math"}[mode]
        });
        model.collapseSelection("forward");
        const cursor = model.at(model.position);
        model.position = model.offsetOf(cursor.parent.addChildrenAfter(atoms, cursor));
        contentChanged = true;
      }
      this.mode = mode;
      if (mode === "latex") {
        let wasCollapsed = model.selectionIsCollapsed;
        complete(this, "accept");
        if (this.virtualKeyboard?.visible) {
          this.executeCommand(["switchKeyboardLayer", "latex-lower"]);
        }
        let latex;
        let cursor = model.at(model.position);
        if (wasCollapsed) {
          latex = "\\";
        } else {
          const selRange = range(model.selection);
          latex = this.model.getValue(selRange, "latex");
          const extractedAtoms = this.model.extractAtoms(selRange);
          if (extractedAtoms.length === 1 && extractedAtoms[0] instanceof PlaceholderAtom) {
            latex = prefix;
            wasCollapsed = true;
          }
          cursor = model.at(selRange[0]);
        }
        const atom = new LatexGroupAtom(latex);
        cursor.parent.addChildAfter(atom, cursor);
        if (wasCollapsed) {
          model.position = model.offsetOf(atom.lastChild);
        } else {
          model.setSelection(model.offsetOf(atom.firstChild), model.offsetOf(atom.lastChild));
        }
      } else {
        getLatexGroupBody(model).forEach((x3) => {
          x3.isError = false;
        });
      }
      if (suffix) {
        const atoms = parseLatex(suffix, {
          parseMode: {math: "text", text: "math"}[mode]
        });
        model.collapseSelection("forward");
        const cursor = model.at(model.position);
        model.position = model.offsetOf(cursor.parent.addChildrenAfter(atoms, cursor));
        contentChanged = true;
      }
      if (typeof this.options.onModeChange === "function") {
        this.options.onModeChange(this, this.mode);
      }
      requestUpdate(this);
      return contentChanged;
    });
  }
  hasFocus() {
    return isBrowser() && document.hasFocus() && this.keyboardDelegate.hasFocus();
  }
  focus() {
    if (!this.hasFocus()) {
      this.keyboardDelegate.focus();
      this.model.announce("line");
    }
  }
  blur() {
    if (this.hasFocus()) {
      this.keyboardDelegate.blur();
    }
  }
  select() {
    this.model.selection = {ranges: [[0, this.model.lastOffset]]};
  }
  applyStyle(inStyle, inOptions = {}) {
    const options = {
      operation: "set",
      suppressChangeNotifications: false
    };
    if (isRange(inOptions)) {
      options.range = inOptions;
    } else {
      options.range = inOptions.range;
      options.suppressChangeNotifications = inOptions.suppressChangeNotifications ?? false;
    }
    const style = validateStyle(this, inStyle);
    const operation = options.operation ?? "set";
    this.model.deferNotifications({content: !options.suppressChangeNotifications}, () => {
      if (options.range === void 0) {
        this.model.selection.ranges.forEach((range2) => applyStyle(this.model, range2, style, {operation}));
      } else {
        applyStyle(this.model, options.range, style, {operation});
      }
    });
    requestUpdate(this);
  }
  getCaretPoint() {
    const caretOffset = getCaretPoint(this.field);
    return caretOffset ? {x: caretOffset.x, y: caretOffset.y} : null;
  }
  setCaretPoint(x3, y3) {
    const newPosition = offsetFromPoint(this, x3, y3, {bias: 0});
    if (newPosition < 0)
      return false;
    const previousPosition = this.model.position;
    this.model.position = newPosition;
    this.model.announce("move", previousPosition);
    requestUpdate(this);
    return true;
  }
  attachNestedMathfield() {
    let needsUpdate = false;
    this._placeholders.forEach((v3) => {
      const container = this.field?.querySelector(`[data-placeholder-id=${v3.atom.placeholderId}]`);
      if (container) {
        const placeholderPosition = container.getBoundingClientRect();
        const parentPosition = this.field?.getBoundingClientRect();
        const scaleDownFontsize = parseInt(window.getComputedStyle(container).fontSize) * 0.6;
        if (!v3.field.style.fontSize || Math.abs(scaleDownFontsize - parseFloat(v3.field.style.fontSize)) >= 0.2) {
          needsUpdate = true;
          v3.field.style.fontSize = `${scaleDownFontsize}px`;
        }
        const newTop = (placeholderPosition?.top ?? 0) - (parentPosition?.top ?? 0) + (this.element?.offsetTop ?? 0);
        const newLeft = (placeholderPosition?.left ?? 0) - (parentPosition?.left ?? 0) + (this.element?.offsetLeft ?? 0);
        if (!v3.field.style.left || Math.abs(newLeft - parseFloat(v3.field.style.left)) >= 1) {
          needsUpdate = true;
          v3.field.style.left = `${newLeft}px`;
        }
        if (!v3.field.style.top || Math.abs(newTop - parseFloat(v3.field.style.top)) >= 1) {
          needsUpdate = true;
          v3.field.style.top = `${newTop}px`;
        }
        console.log("attaching", !!v3.field.style.left, !!v3.field.style.top);
      }
    });
    if (needsUpdate) {
      requestUpdate(this);
    }
  }
  canUndo() {
    return this.undoManager.canUndo();
  }
  canRedo() {
    return this.undoManager.canRedo();
  }
  popUndoStack() {
    this.undoManager.pop();
  }
  snapshot() {
    this.undoManager.snapshot({
      ...this.options,
      onUndoStateDidChange: (mf, reason) => {
        this.virtualKeyboard?.executeCommand([
          "onUndoStateChanged",
          this.canUndo(),
          this.canRedo()
        ]);
        this.options.onUndoStateDidChange(mf, reason);
      }
    });
  }
  snapshotAndCoalesce() {
    this.undoManager.snapshotAndCoalesce({
      ...this.options,
      onUndoStateDidChange: (mf, reason) => {
        this.virtualKeyboard?.executeCommand([
          "onUndoStateChanged",
          this.canUndo(),
          this.canRedo()
        ]);
        this.options.onUndoStateDidChange(mf, reason);
      }
    });
  }
  getUndoRecord() {
    return this.undoManager.save();
  }
  restoreToUndoRecord(s3) {
    this.undoManager.restore(s3, {
      ...this.options,
      suppressChangeNotifications: true
    });
  }
  undo() {
    return this.undoManager.undo({
      ...this.options,
      onUndoStateDidChange: (mf, reason) => {
        this.virtualKeyboard.executeCommand([
          "onUndoStateChanged",
          this.canUndo(),
          this.canRedo()
        ]);
        this.options.onUndoStateDidChange(mf, reason);
      }
    });
  }
  redo() {
    return this.undoManager.redo({
      ...this.options,
      onUndoStateDidChange: (mf, reason) => {
        this.virtualKeyboard?.executeCommand([
          "onUndoStateChanged",
          this.canUndo(),
          this.canRedo()
        ]);
        this.options.onUndoStateDidChange(mf, reason);
      }
    });
  }
  _onSelectionDidChange() {
    this.keyboardDelegate.setValue(this.getValue(this.model.selection, "latex-expanded"));
    const selectedAtoms = this.model.getAtoms(this.model.selection);
    if (selectedAtoms.length === 1 && selectedAtoms[0].type === "placeholder") {
      const placeholder = selectedAtoms[0];
      if (this.model.mathfield._placeholders.has(placeholder.placeholderId)) {
        this.model.mathfield._placeholders.get(placeholder.placeholderId)?.field.focus();
      }
    }
    {
      const cursor = this.model.at(this.model.position);
      const newMode = cursor.mode ?? effectiveMode(this.options);
      if (this.mode !== newMode) {
        if (this.mode === "latex") {
          complete(this, "accept", {mode: newMode});
          this.model.position = this.model.offsetOf(cursor);
        } else {
          this.switchMode(newMode);
        }
      }
    }
    if (typeof this.options.onSelectionDidChange === "function") {
      this.options.onSelectionDidChange(this);
    }
  }
  onFocus() {
    if (this.blurred) {
      this.blurred = false;
      this.keyboardDelegate.focus();
      this.virtualKeyboard?.enable();
      if (this.options.virtualKeyboardMode === "onfocus") {
        this.executeCommand("showVirtualKeyboard");
      }
      updatePopoverPosition(this);
      this.options.onFocus?.(this);
      this.valueOnFocus = this.getValue();
      requestUpdate(this);
    }
  }
  onBlur() {
    if (!this.blurred) {
      this.blurred = true;
      this.ariaLiveText.textContent = "";
      if (/onfocus|manual/.test(this.options.virtualKeyboardMode)) {
        this.executeCommand("hideVirtualKeyboard");
      }
      complete(this, "accept");
      requestUpdate(this);
      if (typeof this.options.onBlur === "function") {
        this.options.onBlur(this);
      }
      this.virtualKeyboard?.disable();
      if (typeof this.options.onCommit === "function" && this.getValue() !== this.valueOnFocus) {
        this.options.onCommit(this);
      }
    }
  }
  onCompositionStart(_composition) {
    this.model.position = this.model.deleteAtoms(range(this.model.selection));
    requestAnimationFrame(() => {
      render(this);
      const caretPoint = getCaretPoint(this.field);
      if (!caretPoint)
        return;
      this.keyboardDelegate.moveTo(caretPoint.x, caretPoint.y);
    });
  }
  onCompositionUpdate(composition) {
    updateComposition(this.model, composition);
    requestUpdate(this);
  }
  onCompositionEnd(composition) {
    removeComposition(this.model);
    onTypedText(this, composition, {
      simulateKeystroke: true
    });
  }
  onResize() {
    if (!isValidMathfield(this))
      return;
    this.element.classList.remove("ML__isNarrowWidth", "ML__isWideWidth", "ML__isExtendedWidth");
    if (window.innerWidth >= 1024) {
      this.element.classList.add("ML__isExtendedWidth");
    } else if (window.innerWidth >= 768) {
      this.element.classList.add("ML__isWideWidth");
    } else {
      this.element.classList.add("ML__isNarrowWidth");
    }
    updatePopoverPosition(this);
  }
  onWheel(ev) {
    const wheelDelta = 5 * ev.deltaX;
    if (!Number.isFinite(wheelDelta) || wheelDelta === 0)
      return;
    const field = this.field;
    if (wheelDelta < 0 && field.scrollLeft === 0)
      return;
    if (wheelDelta > 0 && field.offsetWidth + field.scrollLeft >= field.scrollWidth) {
      return;
    }
    field.scrollBy({top: 0, left: wheelDelta});
    ev.preventDefault();
    ev.stopPropagation();
  }
};

// src/public/mathfield-element.ts
var MATHFIELD_TEMPLATE = document.createElement("template");
MATHFIELD_TEMPLATE.innerHTML = `<style>
:host { display: block; position: relative; }
:host([hidden]) { display: none; }
:host([disabled]) { opacity:  .5; }
:host(:focus), :host(:focus-within) {
  outline: Highlight auto 1px;    /* For Firefox */
  outline: -webkit-focus-ring-color auto 1px;
}
:host([readonly]), :host([read-only]) { outline: none; }
</style>
<div></div><slot style="display:none"></slot>`;
var gDeferredState = new WeakMap();
var MathfieldElement = class extends HTMLElement {
  static get optionsAttributes() {
    return {
      "default-mode": "string",
      "fonts-directory": "string",
      "sounds-directory": "string",
      "horizontal-spacing-scale": "string",
      "math-mode-space": "string",
      "inline-shortcut-timeout": "string",
      "keypress-vibration": "boolean",
      "keypress-sound": "string",
      "plonk-sound": "string",
      "letter-shape-style": "string",
      "locale": "string",
      "read-only": "boolean",
      "remove-extraneous-parentheses": "boolean",
      "smart-fence": "boolean",
      "smart-mode": "boolean",
      "smart-superscript": "boolean",
      "speech-engine": "string",
      "speech-engine-rate": "string",
      "speech-engine-voice": "string",
      "text-to-speech-markup": "string",
      "text-to-speech-rules": "string",
      "virtual-keyboard-layout": "string",
      "virtual-keyboard-mode": "string",
      "virtual-keyboard-theme": "string",
      "virtual-keyboards": "string",
      "use-shared-virtual-keyboard": "boolean",
      "shared-virtual-keyboard-target-origin": "string"
    };
  }
  static get observedAttributes() {
    return [
      ...Object.keys(MathfieldElement.optionsAttributes),
      "disabled",
      "readonly"
    ];
  }
  constructor(options) {
    throwIfNotInBrowser();
    super();
    this.attachShadow({mode: "open"});
    this.shadowRoot.append(MATHFIELD_TEMPLATE.content.cloneNode(true));
    const slot = this.shadowRoot.querySelector("slot:not([name])");
    this._slotValue = slot.assignedNodes().map((x3) => x3.nodeType === 3 ? x3.textContent : "").join("").trim();
    if (options) {
      this.setOptions(options);
    }
    this.shadowRoot.host.addEventListener("focus", (_event) => {
      if (!this.readOnly) {
        this._mathfield?.focus();
      }
    }, true);
    this.shadowRoot.host.addEventListener("blur", (_event) => {
      if (!this.readOnly) {
        this._mathfield?.blur();
      }
    }, true);
  }
  getPlaceholderField(placeholderId) {
    return this._mathfield?.getPlaceholderField(placeholderId);
  }
  addEventListener(type, listener, options) {
    return super.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    super.removeEventListener(type, listener, options);
  }
  get mode() {
    return this._mathfield?.mode ?? "math";
  }
  set mode(value) {
    if (!this._mathfield)
      return;
    this._mathfield.mode = value;
  }
  getOptions(keys) {
    if (this._mathfield) {
      return get(this._mathfield.options, keys);
    }
    if (!gDeferredState.has(this))
      return null;
    return get(update(getDefault(), gDeferredState.get(this).options), keys);
  }
  getOption(key) {
    return this.getOptions([key])[key];
  }
  setOptions(options) {
    if (this._mathfield) {
      this._mathfield.setOptions(options);
      this._mathfield._placeholders.forEach((placeholder) => {
        placeholder.field.setOptions({
          ...options,
          virtualKeyboardMode: "onfocus",
          readOnly: false
        });
      });
    } else if (gDeferredState.has(this)) {
      const mergedOptions = {
        ...gDeferredState.get(this).options,
        ...options
      };
      gDeferredState.set(this, {
        value: gDeferredState.get(this).value,
        selection: {ranges: mergedOptions.readOnly ? [[0, 0]] : [[0, -1]]},
        options: mergedOptions
      });
    } else {
      gDeferredState.set(this, {
        value: "",
        selection: {ranges: [[0, 0]]},
        options
      });
    }
    reflectAttributes(this);
  }
  executeCommand(command) {
    return this._mathfield?.executeCommand(command) ?? false;
  }
  getValue(arg1, arg2, arg3) {
    if (this._mathfield) {
      return this._mathfield.getValue(arg1, arg2, arg3);
    }
    if (gDeferredState.has(this)) {
      let start;
      let end;
      let format = void 0;
      if (isSelection(arg1)) {
        [start, end] = arg1.ranges[0];
        format = arg2;
      } else if (isRange(arg1)) {
        [start, end] = arg1;
        format = arg2;
      } else if (isOffset(arg1) && isOffset(arg2)) {
        start = arg1;
        end = arg2;
        format = arg3;
      } else {
        start = 0;
        end = -1;
        format = arg1;
      }
      if ((format === void 0 || format === "latex") && start === 0 && end === -1) {
        return gDeferredState.get(this).value;
      }
    }
    return "";
  }
  setValue(value, options) {
    if (this._mathfield) {
      this._mathfield.setValue(value ?? "", options);
      return;
    }
    if (gDeferredState.has(this)) {
      const options2 = gDeferredState.get(this).options;
      gDeferredState.set(this, {
        value: value ?? "",
        selection: {
          ranges: options2.readOnly ? [[0, 0]] : [[0, -1]],
          direction: "forward"
        },
        options: options2
      });
      return;
    }
    const attrOptions = getOptionsFromAttributes(this);
    gDeferredState.set(this, {
      value: value ?? "",
      selection: {
        ranges: attrOptions.readOnly ? [[0, 0]] : [[0, -1]],
        direction: "forward"
      },
      options: attrOptions
    });
  }
  hasFocus() {
    return this._mathfield?.hasFocus() ?? false;
  }
  get virtualKeyboardState() {
    return this._mathfield?.virtualKeyboardState ?? "hidden";
  }
  set virtualKeyboardState(value) {
    if (this._mathfield) {
      this._mathfield.virtualKeyboardState = value;
    }
  }
  focus() {
    super.focus();
  }
  blur() {
    super.blur();
  }
  select() {
    this._mathfield?.select();
  }
  insert(s3, options) {
    return this._mathfield?.insert(s3, options) ?? false;
  }
  applyStyle(style, options) {
    return this._mathfield?.applyStyle(style, options);
  }
  get caretPoint() {
    return this._mathfield?.getCaretPoint() ?? null;
  }
  set caretPoint(point) {
    if (!point)
      return;
    this._mathfield?.setCaretPoint(point.x, point.y);
  }
  setCaretPoint(x3, y3) {
    return this._mathfield?.setCaretPoint(x3, y3) ?? false;
  }
  find(pattern, options) {
    return this._mathfield?.find(pattern, options) ?? [];
  }
  replace(pattern, replacement, options) {
    this._mathfield?.replace(pattern, replacement, options);
  }
  connectedCallback() {
    if (!this.hasAttribute("role"))
      this.setAttribute("role", "textbox");
    if (!this.hasAttribute("tabindex"))
      this.setAttribute("tabindex", "0");
    const slot = this.shadowRoot.querySelector("slot:not([name])");
    try {
      this._style = slot.assignedElements().filter((x3) => x3.tagName.toLowerCase() === "style").map((x3) => x3.textContent).join("");
    } catch (error) {
      console.log(error);
    }
    if (this._style) {
      const styleElement = document.createElement("style");
      styleElement.textContent = this._style;
      this.shadowRoot.appendChild(styleElement);
    }
    try {
      const json = slot.assignedElements().filter((x3) => x3.tagName.toLowerCase() === "script" && x3.type === "application/json").map((x3) => x3.textContent).join("");
      if (json) {
        this.setOptions(JSON.parse(json));
      }
    } catch (error) {
      console.log(error);
    }
    let value = "";
    if (this.hasAttribute("value")) {
      value = this.getAttribute("value") ?? "";
    } else {
      value = slot?.assignedNodes().map((x3) => x3.nodeType === 3 ? x3.textContent : "").join("").trim() ?? "";
    }
    this._mathfield = new MathfieldPrivate(this.shadowRoot.querySelector(":host > div"), {
      onBlur: () => {
        this.dispatchEvent(new Event("blur", {
          cancelable: false,
          bubbles: false,
          composed: true
        }));
      },
      onContentDidChange: () => {
        this.dispatchEvent(new Event("input", {
          cancelable: false,
          bubbles: true,
          composed: true
        }));
      },
      onError: (err) => {
        this.dispatchEvent(new CustomEvent("math-error", {
          detail: {
            code: err.code,
            arg: err.arg,
            latex: err.latex,
            before: err.before,
            after: err.after
          },
          cancelable: false,
          bubbles: true,
          composed: true
        }));
      },
      onFocus: () => {
        this.dispatchEvent(new Event("focus", {
          cancelable: false,
          bubbles: false,
          composed: true
        }));
      },
      onKeystroke: (_sender, keystroke, ev) => {
        return this.dispatchEvent(new CustomEvent("keystroke", {
          detail: {
            keystroke,
            event: ev
          },
          cancelable: true,
          bubbles: true,
          composed: true
        }));
      },
      onModeChange: (_sender, _mode) => {
        this.dispatchEvent(new Event("mode-change", {
          cancelable: false,
          bubbles: true,
          composed: true
        }));
      },
      onCommit: (_sender) => {
        this.dispatchEvent(new Event("change", {
          cancelable: false,
          bubbles: true,
          composed: true
        }));
      },
      onMoveOutOf: (_sender, direction) => {
        return this.dispatchEvent(new CustomEvent("move-out", {
          detail: {direction},
          cancelable: true,
          bubbles: true,
          composed: true
        }));
      },
      onTabOutOf: (_sender, direction) => {
        return this.dispatchEvent(new CustomEvent("focus-out", {
          detail: {direction},
          cancelable: true,
          bubbles: true,
          composed: true
        }));
      },
      onReadAloudStatus: () => {
        this.dispatchEvent(new Event("read-aloud-status-change", {
          cancelable: false,
          bubbles: true,
          composed: true
        }));
      },
      onSelectionDidChange: () => {
        this.dispatchEvent(new Event("selection-change", {
          cancelable: false,
          bubbles: true,
          composed: true
        }));
      },
      onUndoStateDidChange: () => {
        this.dispatchEvent(new Event("undo-state-change", {
          cancelable: false,
          bubbles: true,
          composed: true
        }));
      },
      ...gDeferredState.has(this) ? gDeferredState.get(this).options : getOptionsFromAttributes(this),
      value
    });
    if (!gDeferredState.has(this)) {
      this.upgradeProperty("disabled");
      this.upgradeProperty("readonly");
      for (const attr of Object.keys(MathfieldElement.optionsAttributes)) {
        this.upgradeProperty(toCamelCase(attr));
      }
    }
    if (!this._mathfield || !this._mathfield.model) {
      this._mathfield = null;
      return;
    }
    if (gDeferredState.has(this)) {
      this._mathfield.model.deferNotifications({content: false, selection: false}, () => {
        this._mathfield.setValue(gDeferredState.get(this).value);
        this._mathfield.selection = gDeferredState.get(this).selection;
        gDeferredState.delete(this);
      });
    }
    slot.addEventListener("slotchange", (event) => {
      if (event.target !== slot)
        return;
      const value2 = slot.assignedNodes().map((x3) => x3.nodeType === 3 ? x3.textContent : "").join("").trim();
      if (value2 === this._slotValue)
        return;
      if (!this._mathfield) {
        this.value = value2;
      } else {
        this._mathfield.setValue(value2);
      }
    });
    this.dispatchEvent(new Event("mount", {cancelable: false, bubbles: true, composed: true}));
  }
  disconnectedCallback() {
    this.dispatchEvent(new Event("unmount", {cancelable: false, bubbles: true, composed: true}));
    if (!this._mathfield)
      return;
    const options = get(this._mathfield.options, Object.keys(MathfieldElement.optionsAttributes).map((x3) => toCamelCase(x3)));
    gDeferredState.set(this, {
      value: this._mathfield.getValue(),
      selection: this._mathfield.selection,
      options
    });
    this._mathfield.dispose();
    this._mathfield = null;
  }
  upgradeProperty(prop) {
    if (this.hasOwnProperty(prop)) {
      const value = this[prop];
      delete this[prop];
      if (prop === "readonly")
        prop = "readOnly";
      this[prop] = value;
    }
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue === newValue)
      return;
    const hasValue = newValue !== null;
    switch (name) {
      case "disabled":
        this.disabled = hasValue;
        break;
      case "readonly":
        this.readOnly = hasValue;
        break;
      default:
    }
  }
  get readonly() {
    return this.hasAttribute("readonly") || this.hasAttribute("read-only");
  }
  set readonly(value) {
    const isDisabled = Boolean(value);
    if (isDisabled)
      this.setAttribute("disabled", "");
    else
      this.removeAttribute("disabled");
    this.setAttribute("aria-disabled", isDisabled ? "true" : "false");
    this.setOptions({readOnly: isDisabled});
  }
  get disabled() {
    return this.hasAttribute("disabled");
  }
  set disabled(value) {
    const isDisabled = Boolean(value);
    if (isDisabled)
      this.setAttribute("disabled", "");
    else
      this.removeAttribute("disabled");
    this.setAttribute("aria-disabled", isDisabled ? "true" : "false");
    this.setOptions({readOnly: isDisabled});
  }
  get value() {
    return this.getValue();
  }
  set value(value) {
    this.setValue(value);
  }
  get defaultMode() {
    return this.getOption("defaultMode");
  }
  set defaultMode(value) {
    this.setOptions({defaultMode: value});
  }
  get fontsDirectory() {
    return this.getOption("fontsDirectory");
  }
  set fontsDirectory(value) {
    this.setOptions({fontsDirectory: value});
  }
  get mathModeSpace() {
    return this.getOption("fontsDirectory");
  }
  set mathModeSpace(value) {
    this.setOptions({mathModeSpace: value});
  }
  get inlineShortcutTimeout() {
    return this.getOption("inlineShortcutTimeout");
  }
  set inlineShortcutTimeout(value) {
    this.setOptions({inlineShortcutTimeout: value});
  }
  get keypressVibration() {
    return this.getOption("keypressVibration");
  }
  set keypressVibration(value) {
    this.setOptions({keypressVibration: value});
  }
  get keypressSound() {
    return this.getOption("keypressSound");
  }
  set keypressSound(value) {
    this.setOptions({keypressSound: value});
  }
  get plonkSound() {
    return this.getOption("plonkSound") ?? null;
  }
  set plonkSound(value) {
    this.setOptions({plonkSound: value});
  }
  get letterShapeStyle() {
    return this.getOption("letterShapeStyle");
  }
  set letterShapeStyle(value) {
    this.setOptions({letterShapeStyle: value});
  }
  get locale() {
    return this.getOption("locale");
  }
  set locale(value) {
    this.setOptions({locale: value});
  }
  get readOnly() {
    return this.getOption("readOnly");
  }
  set readOnly(value) {
    this.setOptions({readOnly: value});
  }
  get removeExtraneousParentheses() {
    return this.getOption("removeExtraneousParentheses");
  }
  set removeExtraneousParentheses(value) {
    this.setOptions({removeExtraneousParentheses: value});
  }
  get smartFence() {
    return this.getOption("smartFence");
  }
  set smartFence(value) {
    this.setOptions({smartFence: value});
  }
  get smartMode() {
    return this.getOption("smartMode");
  }
  set smartMode(value) {
    this.setOptions({smartMode: value});
  }
  get smartSuperscript() {
    return this.getOption("smartSuperscript");
  }
  set smartSuperscript(value) {
    this.setOptions({smartSuperscript: value});
  }
  get speechEngine() {
    return this.getOption("speechEngine");
  }
  set speechEngine(value) {
    this.setOptions({speechEngine: value});
  }
  get speechEngineRate() {
    return this.getOption("speechEngineRate");
  }
  set speechEngineRate(value) {
    this.setOptions({speechEngineRate: value});
  }
  get speechEngineVoice() {
    return this.getOption("speechEngineVoice");
  }
  set speechEngineVoice(value) {
    this.setOptions({speechEngineVoice: value});
  }
  get textToSpeechMarkup() {
    return this.getOption("textToSpeechMarkup");
  }
  set textToSpeechMarkup(value) {
    this.setOptions({textToSpeechMarkup: value});
  }
  get textToSpeechRules() {
    return this.getOption("textToSpeechRules");
  }
  set textToSpeechRule(value) {
    this.setOptions({textToSpeechRules: value});
  }
  get virtualKeyboardLayout() {
    return this.getOption("virtualKeyboardLayout");
  }
  set virtualKeyboardLayout(value) {
    this.setOptions({virtualKeyboardLayout: value});
  }
  get virtualKeyboardMode() {
    return this.getOption("virtualKeyboardMode");
  }
  set virtualKeyboardMode(value) {
    this.setOptions({virtualKeyboardMode: value});
  }
  get virtualKeyboardTheme() {
    return this.getOption("virtualKeyboardTheme");
  }
  set virtualKeyboardTheme(value) {
    this.setOptions({virtualKeyboardTheme: value});
  }
  get virtualKeyboards() {
    return this.getOption("virtualKeyboards");
  }
  set virtualKeyboards(value) {
    this.setOptions({virtualKeyboards: value});
  }
  get useSharedVirtualKeyboard() {
    return this.getOption("useSharedVirtualKeyboard");
  }
  set useSharedVirtualKeyboard(value) {
    this.setOptions({useSharedVirtualKeyboard: value});
  }
  get sharedVirtualKeyboardTargetOrigin() {
    return this.getOption("sharedVirtualKeyboardTargetOrigin");
  }
  set sharedVirtualKeyboardTargetOrigin(value) {
    this.setOptions({sharedVirtualKeyboardTargetOrigin: value});
  }
  get selection() {
    if (this._mathfield) {
      return this._mathfield.selection;
    }
    if (gDeferredState.has(this)) {
      return gDeferredState.get(this).selection;
    }
    return {ranges: [[0, 0]], direction: "forward"};
  }
  set selection(value) {
    if (typeof value === "number") {
      value = {ranges: [[value, value]]};
    }
    if (this._mathfield) {
      this._mathfield.selection = value;
      return;
    }
    if (gDeferredState.has(this)) {
      gDeferredState.set(this, {
        value: gDeferredState.get(this).value,
        selection: value,
        options: gDeferredState.get(this).options
      });
      return;
    }
    gDeferredState.set(this, {
      value: "",
      selection: value,
      options: getOptionsFromAttributes(this)
    });
  }
  get position() {
    if (this._mathfield) {
      return this._mathfield.model.position;
    }
    if (gDeferredState.has(this)) {
      return gDeferredState.get(this).selection.ranges[0][0];
    }
    return 0;
  }
  set position(offset) {
    if (this._mathfield) {
      this._mathfield.model.position = offset;
    }
    if (gDeferredState.has(this)) {
      gDeferredState.set(this, {
        value: gDeferredState.get(this).value,
        selection: {ranges: [[offset, offset]]},
        options: gDeferredState.get(this).options
      });
      return;
    }
    gDeferredState.set(this, {
      value: "",
      selection: {ranges: [[offset, offset]]},
      options: getOptionsFromAttributes(this)
    });
  }
  getOffsetDepth(offset) {
    if (this._mathfield) {
      return this._mathfield.model.at(offset)?.treeDepth - 2;
    }
    return 0;
  }
  get lastOffset() {
    return this._mathfield?.lastOffset ?? -1;
  }
};
function toCamelCase(s3) {
  return s3.toLowerCase().replace(/[^a-zA-Z\d]+(.)/g, (m3, c3) => c3.toUpperCase());
}
function reflectAttributes(element) {
  const defaultOptions = getDefault();
  const options = element.getOptions();
  Object.keys(MathfieldElement.optionsAttributes).forEach((x3) => {
    const prop = toCamelCase(x3);
    if (defaultOptions[prop] !== options[prop]) {
      if (MathfieldElement.optionsAttributes[x3] === "boolean") {
        if (options[prop]) {
          element.setAttribute(x3, "");
        } else {
          element.removeAttribute(x3);
        }
      } else {
        if (typeof options[prop] === "string" || typeof options[prop] === "number") {
          element.setAttribute(x3, options[prop].toString());
        }
      }
    }
  });
}
function getOptionsFromAttributes(mfe) {
  const result = {};
  const attribs = MathfieldElement.optionsAttributes;
  Object.keys(attribs).forEach((x3) => {
    if (mfe.hasAttribute(x3)) {
      const value = mfe.getAttribute(x3);
      if (attribs[x3] === "boolean") {
        result[toCamelCase(x3)] = true;
      } else if (attribs[x3] === "number") {
        result[toCamelCase(x3)] = Number.parseFloat(value ?? "0");
      } else {
        result[toCamelCase(x3)] = value;
      }
    } else if (attribs[x3] === "boolean") {
      result[toCamelCase(x3)] = false;
    }
  });
  return result;
}
var mathfield_element_default = MathfieldElement;
if (isBrowser() && !window.customElements?.get("math-field")) {
  window.MathfieldElement = MathfieldElement;
  window.customElements?.define("math-field", MathfieldElement);
}

// node_modules/@cortex-js/compute-engine/dist/compute-engine.min.esm.js
var e2 = [127462, 127487];
function i2(e3) {
  return e3 === 8205 || e3 === 65038 || e3 === 65039 || e3 >= 127995 && e3 <= 128e3 || e3 >= 129456 && e3 <= 129460 || e3 >= 917536 && e3 <= 917632;
}
function n2(i3) {
  return i3 >= e2[0] && i3 <= e2[1];
}
var t2 = class {
  constructor(e3) {
    this.obeyspaces = false, this.s = function(e4) {
      if (/^[\u0020-\u00FF]*$/.test(e4))
        return e4;
      const t3 = [], r3 = function(e5) {
        const i3 = [];
        for (let n3 = 0; n3 < e5.length; n3++) {
          let t4 = e5.charCodeAt(n3);
          if (t4 >= 55296 && t4 <= 56319) {
            const i4 = e5.charCodeAt(n3 + 1);
            i4 >= 56320 && i4 <= 57343 && (t4 = 65536 + 1024 * (t4 - 55296) + (i4 - 56320), n3++);
          }
          i3.push(t4);
        }
        return i3;
      }(e4);
      let o3 = 0;
      for (; o3 < r3.length; ) {
        const e5 = r3[o3++], s3 = r3[o3];
        if (s3 === 8205) {
          const e6 = o3 - 1;
          for (o3 += 2; r3[o3] === 8205; )
            o3 += 2;
          t3.push(String.fromCodePoint(...r3.slice(e6, 2 * o3 - e6 + 1)));
        } else if (i2(s3)) {
          const e6 = o3 - 1;
          for (; i2(r3[o3]); )
            o3 += r3[o3] === 8205 ? 2 : 1;
          t3.push(String.fromCodePoint(...r3.slice(e6, 2 * o3 - e6 - 1)));
        } else
          n2(e5) ? (o3 += 1, t3.push(String.fromCodePoint(...r3.slice(o3 - 2, 2)))) : t3.push(String.fromCodePoint(e5));
      }
      return t3;
    }(e3), this.pos = 0;
  }
  end() {
    return this.pos >= this.s.length;
  }
  get() {
    return this.pos < this.s.length ? this.s[this.pos++] : "";
  }
  peek() {
    return this.s[this.pos];
  }
  match(e3) {
    let i3;
    return i3 = typeof this.s == "string" ? e3.exec(this.s.slice(this.pos)) : e3.exec(this.s.slice(this.pos).join("")), (i3 == null ? void 0 : i3[0]) ? (this.pos += i3[0].length, i3[0]) : null;
  }
  next() {
    if (this.end())
      return null;
    if (!this.obeyspaces && this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]+/))
      return "<space>";
    if (this.obeyspaces && this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]/))
      return "<space>";
    const e3 = this.get();
    if (e3 === "\\") {
      if (!this.end()) {
        let e4 = this.match(/^[a-zA-Z*]+/);
        if (e4)
          this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]*/);
        else if (e4 = this.get(), e4 === " ")
          return "<space>";
        return "\\" + e4;
      }
    } else {
      if (e3 === "{")
        return "<{>";
      if (e3 === "}")
        return "<}>";
      if (e3 === "^") {
        if (this.peek() === "^") {
          this.get();
          const e4 = this.match(/^(\^(\^(\^(\^[0-9a-f])?[0-9a-f])?[0-9a-f])?[0-9a-f])?[0-9a-f][0-9a-f]/);
          if (e4)
            return String.fromCodePoint(parseInt(e4.slice(e4.lastIndexOf("^") + 1), 16));
        }
        return e3;
      }
      if (e3 === "#") {
        if (!this.end()) {
          let e4 = false;
          if (/[0-9?]/.test(this.peek()) && (e4 = true, this.pos + 1 < this.s.length)) {
            const i3 = this.s[this.pos + 1];
            e4 = /[^0-9A-Za-z]/.test(i3);
          }
          return e4 ? "#" + this.get() : "#";
        }
      } else if (e3 === "$")
        return this.peek() === "$" ? (this.get(), "<$$>") : "<$>";
    }
    return e3;
  }
};
function r2(e3, i3) {
  var n3, t3, r3, s3;
  let a3 = [], l3 = e3.next();
  if (l3)
    if (l3 === "\\relax")
      ;
    else if (l3 === "\\noexpand")
      l3 = e3.next(), l3 && a3.push(l3);
    else if (l3 === "\\obeyspaces")
      e3.obeyspaces = true;
    else if (l3 === "\\space" || l3 === "~")
      a3.push("<space>");
    else if (l3 === "\\bgroup")
      a3.push("<{>");
    else if (l3 === "\\egroup")
      a3.push("<}>");
    else if (l3 === "\\string")
      l3 = e3.next(), l3 && (l3[0] === "\\" ? Array.from(l3).forEach((e4) => a3.push(e4 === "\\" ? "\\backslash" : e4)) : l3 === "<{>" ? a3.push("\\{") : l3 === "<space>" ? a3.push("~") : l3 === "<}>" && a3.push("\\}"));
    else if (l3 === "\\csname") {
      for (; e3.peek() === "<space>"; )
        e3.next();
      let r4 = "", s4 = false, u3 = [];
      do {
        if (u3.length === 0)
          if (/^#[0-9?]$/.test(e3.peek())) {
            const r5 = e3.get().slice(1);
            u3 = o2((t3 = (n3 = i3 == null ? void 0 : i3[r5]) !== null && n3 !== void 0 ? n3 : i3 == null ? void 0 : i3["?"]) !== null && t3 !== void 0 ? t3 : "\\placeholder{}", i3), l3 = u3[0];
          } else
            l3 = e3.next(), u3 = l3 ? [l3] : [];
        s4 = u3.length === 0, s4 || l3 !== "\\endcsname" || (s4 = true, u3.shift()), s4 || (s4 = l3 === "<$>" || l3 === "<$$>" || l3 === "<{>" || l3 === "<}>" || !!l3 && l3.length > 1 && l3[0] === "\\"), s4 || (r4 += u3.shift());
      } while (!s4);
      r4 && a3.push("\\" + r4), a3 = a3.concat(u3);
    } else if (l3 === "\\endcsname")
      ;
    else if (l3.length > 1 && l3[0] === "#") {
      const e4 = l3.slice(1);
      a3 = a3.concat(o2((s3 = (r3 = i3 == null ? void 0 : i3[e4]) !== null && r3 !== void 0 ? r3 : i3 == null ? void 0 : i3["?"]) !== null && s3 !== void 0 ? s3 : "\\placeholder{}", i3));
    } else
      a3.push(l3);
  return a3;
}
function o2(e3, i3) {
  const n3 = e3.toString().split(/\r?\n/);
  let o3 = "", s3 = "";
  for (const e4 of n3) {
    o3 += s3, s3 = " ";
    const i4 = e4.match(/((?:\\%)|[^%])*/);
    i4 !== null && (o3 += i4[0]);
  }
  const a3 = new t2(o3);
  let l3 = [];
  do {
    l3 = l3.concat(r2(a3, i3));
  } while (!a3.end());
  return l3;
}
function s2(e3) {
  let i3 = "", n3 = "";
  for (const t3 of e3)
    t3 && (/[a-zA-Z*]/.test(t3[0]) && (n3 += i3), i3 = /\\[a-zA-Z]+\*?$/.test(t3) ? " " : "", n3 += t3);
  return n3;
}
function a2(e3) {
  let i3 = [];
  if (Array.isArray(e3))
    for (const n3 of e3)
      Array.isArray(n3) ? i3 = [...i3, ...n3] : i3.push(n3);
  else
    i3 = [e3];
  return s2(i3.map((e4) => {
    var i4;
    return (i4 = {"<space>": " ", "<$$>": "$$", "<$>": "$", "<{>": "{", "<}>": "}"}[e4]) !== null && i4 !== void 0 ? i4 : e4;
  }));
}
var l2;
var u2 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
var c2 = {exports: {}};
l2 = c2, function(e3) {
  var i3, n3, t3, r3, o3 = 9e15, s3 = 1e9, a3 = "0123456789abcdef", u3 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", c3 = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", m3 = {precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -o3, maxE: o3, crypto: false}, f3 = true, h3 = "[DecimalError] ", p3 = h3 + "Invalid argument: ", g3 = h3 + "Precision limit exceeded", d3 = h3 + "crypto unavailable", v3 = Math.floor, x3 = Math.pow, y3 = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, b3 = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, N3 = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, w3 = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, S4 = 1e7, M25 = u3.length - 1, E3 = c3.length - 1, D4 = {name: "[object Decimal]"};
  function A3(e4) {
    var i4, n4, t4, r4 = e4.length - 1, o4 = "", s4 = e4[0];
    if (r4 > 0) {
      for (o4 += s4, i4 = 1; i4 < r4; i4++)
        (n4 = 7 - (t4 = e4[i4] + "").length) && (o4 += _3(n4)), o4 += t4;
      (n4 = 7 - (t4 = (s4 = e4[i4]) + "").length) && (o4 += _3(n4));
    } else if (s4 === 0)
      return "0";
    for (; s4 % 10 == 0; )
      s4 /= 10;
    return o4 + s4;
  }
  function C3(e4, i4, n4) {
    if (e4 !== ~~e4 || e4 < i4 || e4 > n4)
      throw Error(p3 + e4);
  }
  function q3(e4, i4, n4, t4) {
    var r4, o4, s4, a4;
    for (o4 = e4[0]; o4 >= 10; o4 /= 10)
      --i4;
    return --i4 < 0 ? (i4 += 7, r4 = 0) : (r4 = Math.ceil((i4 + 1) / 7), i4 %= 7), o4 = x3(10, 7 - i4), a4 = e4[r4] % o4 | 0, t4 == null ? i4 < 3 ? (i4 == 0 ? a4 = a4 / 100 | 0 : i4 == 1 && (a4 = a4 / 10 | 0), s4 = n4 < 4 && a4 == 99999 || n4 > 3 && a4 == 49999 || a4 == 5e4 || a4 == 0) : s4 = (n4 < 4 && a4 + 1 == o4 || n4 > 3 && a4 + 1 == o4 / 2) && (e4[r4 + 1] / o4 / 100 | 0) == x3(10, i4 - 2) - 1 || (a4 == o4 / 2 || a4 == 0) && (e4[r4 + 1] / o4 / 100 | 0) == 0 : i4 < 4 ? (i4 == 0 ? a4 = a4 / 1e3 | 0 : i4 == 1 ? a4 = a4 / 100 | 0 : i4 == 2 && (a4 = a4 / 10 | 0), s4 = (t4 || n4 < 4) && a4 == 9999 || !t4 && n4 > 3 && a4 == 4999) : s4 = ((t4 || n4 < 4) && a4 + 1 == o4 || !t4 && n4 > 3 && a4 + 1 == o4 / 2) && (e4[r4 + 1] / o4 / 1e3 | 0) == x3(10, i4 - 3) - 1, s4;
  }
  function F3(e4, i4, n4) {
    for (var t4, r4, o4 = [0], s4 = 0, l3 = e4.length; s4 < l3; ) {
      for (r4 = o4.length; r4--; )
        o4[r4] *= i4;
      for (o4[0] += a3.indexOf(e4.charAt(s4++)), t4 = 0; t4 < o4.length; t4++)
        o4[t4] > n4 - 1 && (o4[t4 + 1] === void 0 && (o4[t4 + 1] = 0), o4[t4 + 1] += o4[t4] / n4 | 0, o4[t4] %= n4);
    }
    return o4.reverse();
  }
  D4.absoluteValue = D4.abs = function() {
    var e4 = new this.constructor(this);
    return e4.s < 0 && (e4.s = 1), k3(e4);
  }, D4.ceil = function() {
    return k3(new this.constructor(this), this.e + 1, 2);
  }, D4.comparedTo = D4.cmp = function(e4) {
    var i4, n4, t4, r4, o4 = this, s4 = o4.d, a4 = (e4 = new o4.constructor(e4)).d, l3 = o4.s, u4 = e4.s;
    if (!s4 || !a4)
      return l3 && u4 ? l3 !== u4 ? l3 : s4 === a4 ? 0 : !s4 ^ l3 < 0 ? 1 : -1 : NaN;
    if (!s4[0] || !a4[0])
      return s4[0] ? l3 : a4[0] ? -u4 : 0;
    if (l3 !== u4)
      return l3;
    if (o4.e !== e4.e)
      return o4.e > e4.e ^ l3 < 0 ? 1 : -1;
    for (i4 = 0, n4 = (t4 = s4.length) < (r4 = a4.length) ? t4 : r4; i4 < n4; ++i4)
      if (s4[i4] !== a4[i4])
        return s4[i4] > a4[i4] ^ l3 < 0 ? 1 : -1;
    return t4 === r4 ? 0 : t4 > r4 ^ l3 < 0 ? 1 : -1;
  }, D4.cosine = D4.cos = function() {
    var e4, i4, n4 = this, t4 = n4.constructor;
    return n4.d ? n4.d[0] ? (e4 = t4.precision, i4 = t4.rounding, t4.precision = e4 + Math.max(n4.e, n4.sd()) + 7, t4.rounding = 1, n4 = function(e5, i5) {
      var n5, t5, r4 = i5.d.length;
      r4 < 32 ? t5 = (1 / W3(4, n5 = Math.ceil(r4 / 3))).toString() : (n5 = 16, t5 = "2.3283064365386962890625e-10"), e5.precision += n5, i5 = G3(e5, 1, i5.times(t5), new e5(1));
      for (var o4 = n5; o4--; ) {
        var s4 = i5.times(i5);
        i5 = s4.times(s4).minus(s4).times(8).plus(1);
      }
      return e5.precision -= n5, i5;
    }(t4, V3(t4, n4)), t4.precision = e4, t4.rounding = i4, k3(r3 == 2 || r3 == 3 ? n4.neg() : n4, e4, i4, true)) : new t4(1) : new t4(NaN);
  }, D4.cubeRoot = D4.cbrt = function() {
    var e4, i4, n4, t4, r4, o4, s4, a4, l3, u4, c4 = this, m4 = c4.constructor;
    if (!c4.isFinite() || c4.isZero())
      return new m4(c4);
    for (f3 = false, (o4 = c4.s * x3(c4.s * c4, 1 / 3)) && Math.abs(o4) != 1 / 0 ? t4 = new m4(o4.toString()) : (n4 = A3(c4.d), (o4 = ((e4 = c4.e) - n4.length + 1) % 3) && (n4 += o4 == 1 || o4 == -2 ? "0" : "00"), o4 = x3(n4, 1 / 3), e4 = v3((e4 + 1) / 3) - (e4 % 3 == (e4 < 0 ? -1 : 2)), (t4 = new m4(n4 = o4 == 1 / 0 ? "5e" + e4 : (n4 = o4.toExponential()).slice(0, n4.indexOf("e") + 1) + e4)).s = c4.s), s4 = (e4 = m4.precision) + 3; ; )
      if (u4 = (l3 = (a4 = t4).times(a4).times(a4)).plus(c4), t4 = I3(u4.plus(c4).times(a4), u4.plus(l3), s4 + 2, 1), A3(a4.d).slice(0, s4) === (n4 = A3(t4.d)).slice(0, s4)) {
        if ((n4 = n4.slice(s4 - 3, s4 + 1)) != "9999" && (r4 || n4 != "4999")) {
          +n4 && (+n4.slice(1) || n4.charAt(0) != "5") || (k3(t4, e4 + 1, 1), i4 = !t4.times(t4).times(t4).eq(c4));
          break;
        }
        if (!r4 && (k3(a4, e4 + 1, 0), a4.times(a4).times(a4).eq(c4))) {
          t4 = a4;
          break;
        }
        s4 += 4, r4 = 1;
      }
    return f3 = true, k3(t4, e4, m4.rounding, i4);
  }, D4.decimalPlaces = D4.dp = function() {
    var e4, i4 = this.d, n4 = NaN;
    if (i4) {
      if (n4 = 7 * ((e4 = i4.length - 1) - v3(this.e / 7)), e4 = i4[e4])
        for (; e4 % 10 == 0; e4 /= 10)
          n4--;
      n4 < 0 && (n4 = 0);
    }
    return n4;
  }, D4.dividedBy = D4.div = function(e4) {
    return I3(this, new this.constructor(e4));
  }, D4.dividedToIntegerBy = D4.divToInt = function(e4) {
    var i4 = this.constructor;
    return k3(I3(this, new i4(e4), 0, 1, 1), i4.precision, i4.rounding);
  }, D4.equals = D4.eq = function(e4) {
    return this.cmp(e4) === 0;
  }, D4.floor = function() {
    return k3(new this.constructor(this), this.e + 1, 3);
  }, D4.greaterThan = D4.gt = function(e4) {
    return this.cmp(e4) > 0;
  }, D4.greaterThanOrEqualTo = D4.gte = function(e4) {
    var i4 = this.cmp(e4);
    return i4 == 1 || i4 === 0;
  }, D4.hyperbolicCosine = D4.cosh = function() {
    var e4, i4, n4, t4, r4, o4 = this, s4 = o4.constructor, a4 = new s4(1);
    if (!o4.isFinite())
      return new s4(o4.s ? 1 / 0 : NaN);
    if (o4.isZero())
      return a4;
    n4 = s4.precision, t4 = s4.rounding, s4.precision = n4 + Math.max(o4.e, o4.sd()) + 4, s4.rounding = 1, (r4 = o4.d.length) < 32 ? i4 = (1 / W3(4, e4 = Math.ceil(r4 / 3))).toString() : (e4 = 16, i4 = "2.3283064365386962890625e-10"), o4 = G3(s4, 1, o4.times(i4), new s4(1), true);
    for (var l3, u4 = e4, c4 = new s4(8); u4--; )
      l3 = o4.times(o4), o4 = a4.minus(l3.times(c4.minus(l3.times(c4))));
    return k3(o4, s4.precision = n4, s4.rounding = t4, true);
  }, D4.hyperbolicSine = D4.sinh = function() {
    var e4, i4, n4, t4, r4 = this, o4 = r4.constructor;
    if (!r4.isFinite() || r4.isZero())
      return new o4(r4);
    if (i4 = o4.precision, n4 = o4.rounding, o4.precision = i4 + Math.max(r4.e, r4.sd()) + 4, o4.rounding = 1, (t4 = r4.d.length) < 3)
      r4 = G3(o4, 2, r4, r4, true);
    else {
      e4 = (e4 = 1.4 * Math.sqrt(t4)) > 16 ? 16 : 0 | e4, r4 = G3(o4, 2, r4 = r4.times(1 / W3(5, e4)), r4, true);
      for (var s4, a4 = new o4(5), l3 = new o4(16), u4 = new o4(20); e4--; )
        s4 = r4.times(r4), r4 = r4.times(a4.plus(s4.times(l3.times(s4).plus(u4))));
    }
    return o4.precision = i4, o4.rounding = n4, k3(r4, i4, n4, true);
  }, D4.hyperbolicTangent = D4.tanh = function() {
    var e4, i4, n4 = this, t4 = n4.constructor;
    return n4.isFinite() ? n4.isZero() ? new t4(n4) : (e4 = t4.precision, i4 = t4.rounding, t4.precision = e4 + 7, t4.rounding = 1, I3(n4.sinh(), n4.cosh(), t4.precision = e4, t4.rounding = i4)) : new t4(n4.s);
  }, D4.inverseCosine = D4.acos = function() {
    var e4, i4 = this, n4 = i4.constructor, t4 = i4.abs().cmp(1), r4 = n4.precision, o4 = n4.rounding;
    return t4 !== -1 ? t4 === 0 ? i4.isNeg() ? z3(n4, r4, o4) : new n4(0) : new n4(NaN) : i4.isZero() ? z3(n4, r4 + 4, o4).times(0.5) : (n4.precision = r4 + 6, n4.rounding = 1, i4 = i4.asin(), e4 = z3(n4, r4 + 4, o4).times(0.5), n4.precision = r4, n4.rounding = o4, e4.minus(i4));
  }, D4.inverseHyperbolicCosine = D4.acosh = function() {
    var e4, i4, n4 = this, t4 = n4.constructor;
    return n4.lte(1) ? new t4(n4.eq(1) ? 0 : NaN) : n4.isFinite() ? (e4 = t4.precision, i4 = t4.rounding, t4.precision = e4 + Math.max(Math.abs(n4.e), n4.sd()) + 4, t4.rounding = 1, f3 = false, n4 = n4.times(n4).minus(1).sqrt().plus(n4), f3 = true, t4.precision = e4, t4.rounding = i4, n4.ln()) : new t4(n4);
  }, D4.inverseHyperbolicSine = D4.asinh = function() {
    var e4, i4, n4 = this, t4 = n4.constructor;
    return !n4.isFinite() || n4.isZero() ? new t4(n4) : (e4 = t4.precision, i4 = t4.rounding, t4.precision = e4 + 2 * Math.max(Math.abs(n4.e), n4.sd()) + 6, t4.rounding = 1, f3 = false, n4 = n4.times(n4).plus(1).sqrt().plus(n4), f3 = true, t4.precision = e4, t4.rounding = i4, n4.ln());
  }, D4.inverseHyperbolicTangent = D4.atanh = function() {
    var e4, i4, n4, t4, r4 = this, o4 = r4.constructor;
    return r4.isFinite() ? r4.e >= 0 ? new o4(r4.abs().eq(1) ? r4.s / 0 : r4.isZero() ? r4 : NaN) : (e4 = o4.precision, i4 = o4.rounding, t4 = r4.sd(), Math.max(t4, e4) < 2 * -r4.e - 1 ? k3(new o4(r4), e4, i4, true) : (o4.precision = n4 = t4 - r4.e, r4 = I3(r4.plus(1), new o4(1).minus(r4), n4 + e4, 1), o4.precision = e4 + 4, o4.rounding = 1, r4 = r4.ln(), o4.precision = e4, o4.rounding = i4, r4.times(0.5))) : new o4(NaN);
  }, D4.inverseSine = D4.asin = function() {
    var e4, i4, n4, t4, r4 = this, o4 = r4.constructor;
    return r4.isZero() ? new o4(r4) : (i4 = r4.abs().cmp(1), n4 = o4.precision, t4 = o4.rounding, i4 !== -1 ? i4 === 0 ? ((e4 = z3(o4, n4 + 4, t4).times(0.5)).s = r4.s, e4) : new o4(NaN) : (o4.precision = n4 + 6, o4.rounding = 1, r4 = r4.div(new o4(1).minus(r4.times(r4)).sqrt().plus(1)).atan(), o4.precision = n4, o4.rounding = t4, r4.times(2)));
  }, D4.inverseTangent = D4.atan = function() {
    var e4, i4, n4, t4, r4, o4, s4, a4, l3, u4 = this, c4 = u4.constructor, m4 = c4.precision, h4 = c4.rounding;
    if (u4.isFinite()) {
      if (u4.isZero())
        return new c4(u4);
      if (u4.abs().eq(1) && m4 + 4 <= E3)
        return (s4 = z3(c4, m4 + 4, h4).times(0.25)).s = u4.s, s4;
    } else {
      if (!u4.s)
        return new c4(NaN);
      if (m4 + 4 <= E3)
        return (s4 = z3(c4, m4 + 4, h4).times(0.5)).s = u4.s, s4;
    }
    for (c4.precision = a4 = m4 + 10, c4.rounding = 1, e4 = n4 = Math.min(28, a4 / 7 + 2 | 0); e4; --e4)
      u4 = u4.div(u4.times(u4).plus(1).sqrt().plus(1));
    for (f3 = false, i4 = Math.ceil(a4 / 7), t4 = 1, l3 = u4.times(u4), s4 = new c4(u4), r4 = u4; e4 !== -1; )
      if (r4 = r4.times(l3), o4 = s4.minus(r4.div(t4 += 2)), r4 = r4.times(l3), (s4 = o4.plus(r4.div(t4 += 2))).d[i4] !== void 0)
        for (e4 = i4; s4.d[e4] === o4.d[e4] && e4--; )
          ;
    return n4 && (s4 = s4.times(2 << n4 - 1)), f3 = true, k3(s4, c4.precision = m4, c4.rounding = h4, true);
  }, D4.isFinite = function() {
    return !!this.d;
  }, D4.isInteger = D4.isInt = function() {
    return !!this.d && v3(this.e / 7) > this.d.length - 2;
  }, D4.isNaN = function() {
    return !this.s;
  }, D4.isNegative = D4.isNeg = function() {
    return this.s < 0;
  }, D4.isPositive = D4.isPos = function() {
    return this.s > 0;
  }, D4.isZero = function() {
    return !!this.d && this.d[0] === 0;
  }, D4.lessThan = D4.lt = function(e4) {
    return this.cmp(e4) < 0;
  }, D4.lessThanOrEqualTo = D4.lte = function(e4) {
    return this.cmp(e4) < 1;
  }, D4.logarithm = D4.log = function(e4) {
    var i4, n4, t4, r4, o4, s4, a4, l3, u4 = this, c4 = u4.constructor, m4 = c4.precision, h4 = c4.rounding;
    if (e4 == null)
      e4 = new c4(10), i4 = true;
    else {
      if (n4 = (e4 = new c4(e4)).d, e4.s < 0 || !n4 || !n4[0] || e4.eq(1))
        return new c4(NaN);
      i4 = e4.eq(10);
    }
    if (n4 = u4.d, u4.s < 0 || !n4 || !n4[0] || u4.eq(1))
      return new c4(n4 && !n4[0] ? -1 / 0 : u4.s != 1 ? NaN : n4 ? 0 : 1 / 0);
    if (i4)
      if (n4.length > 1)
        o4 = true;
      else {
        for (r4 = n4[0]; r4 % 10 == 0; )
          r4 /= 10;
        o4 = r4 !== 1;
      }
    if (f3 = false, s4 = $3(u4, a4 = m4 + 5), t4 = i4 ? O3(c4, a4 + 10) : $3(e4, a4), q3((l3 = I3(s4, t4, a4, 1)).d, r4 = m4, h4))
      do {
        if (s4 = $3(u4, a4 += 10), t4 = i4 ? O3(c4, a4 + 10) : $3(e4, a4), l3 = I3(s4, t4, a4, 1), !o4) {
          +A3(l3.d).slice(r4 + 1, r4 + 15) + 1 == 1e14 && (l3 = k3(l3, m4 + 1, 0));
          break;
        }
      } while (q3(l3.d, r4 += 10, h4));
    return f3 = true, k3(l3, m4, h4);
  }, D4.minus = D4.sub = function(e4) {
    var i4, n4, t4, r4, o4, s4, a4, l3, u4, c4, m4, h4, p4 = this, g4 = p4.constructor;
    if (e4 = new g4(e4), !p4.d || !e4.d)
      return p4.s && e4.s ? p4.d ? e4.s = -e4.s : e4 = new g4(e4.d || p4.s !== e4.s ? p4 : NaN) : e4 = new g4(NaN), e4;
    if (p4.s != e4.s)
      return e4.s = -e4.s, p4.plus(e4);
    if (u4 = p4.d, h4 = e4.d, a4 = g4.precision, l3 = g4.rounding, !u4[0] || !h4[0]) {
      if (h4[0])
        e4.s = -e4.s;
      else {
        if (!u4[0])
          return new g4(l3 === 3 ? -0 : 0);
        e4 = new g4(p4);
      }
      return f3 ? k3(e4, a4, l3) : e4;
    }
    if (n4 = v3(e4.e / 7), c4 = v3(p4.e / 7), u4 = u4.slice(), o4 = c4 - n4) {
      for ((m4 = o4 < 0) ? (i4 = u4, o4 = -o4, s4 = h4.length) : (i4 = h4, n4 = c4, s4 = u4.length), o4 > (t4 = Math.max(Math.ceil(a4 / 7), s4) + 2) && (o4 = t4, i4.length = 1), i4.reverse(), t4 = o4; t4--; )
        i4.push(0);
      i4.reverse();
    } else {
      for ((m4 = (t4 = u4.length) < (s4 = h4.length)) && (s4 = t4), t4 = 0; t4 < s4; t4++)
        if (u4[t4] != h4[t4]) {
          m4 = u4[t4] < h4[t4];
          break;
        }
      o4 = 0;
    }
    for (m4 && (i4 = u4, u4 = h4, h4 = i4, e4.s = -e4.s), s4 = u4.length, t4 = h4.length - s4; t4 > 0; --t4)
      u4[s4++] = 0;
    for (t4 = h4.length; t4 > o4; ) {
      if (u4[--t4] < h4[t4]) {
        for (r4 = t4; r4 && u4[--r4] === 0; )
          u4[r4] = S4 - 1;
        --u4[r4], u4[t4] += S4;
      }
      u4[t4] -= h4[t4];
    }
    for (; u4[--s4] === 0; )
      u4.pop();
    for (; u4[0] === 0; u4.shift())
      --n4;
    return u4[0] ? (e4.d = u4, e4.e = T4(u4, n4), f3 ? k3(e4, a4, l3) : e4) : new g4(l3 === 3 ? -0 : 0);
  }, D4.modulo = D4.mod = function(e4) {
    var i4, n4 = this, t4 = n4.constructor;
    return e4 = new t4(e4), !n4.d || !e4.s || e4.d && !e4.d[0] ? new t4(NaN) : !e4.d || n4.d && !n4.d[0] ? k3(new t4(n4), t4.precision, t4.rounding) : (f3 = false, t4.modulo == 9 ? (i4 = I3(n4, e4.abs(), 0, 3, 1)).s *= e4.s : i4 = I3(n4, e4, 0, t4.modulo, 1), i4 = i4.times(e4), f3 = true, n4.minus(i4));
  }, D4.naturalExponential = D4.exp = function() {
    return H3(this);
  }, D4.naturalLogarithm = D4.ln = function() {
    return $3(this);
  }, D4.negated = D4.neg = function() {
    var e4 = new this.constructor(this);
    return e4.s = -e4.s, k3(e4);
  }, D4.plus = D4.add = function(e4) {
    var i4, n4, t4, r4, o4, s4, a4, l3, u4, c4, m4 = this, h4 = m4.constructor;
    if (e4 = new h4(e4), !m4.d || !e4.d)
      return m4.s && e4.s ? m4.d || (e4 = new h4(e4.d || m4.s === e4.s ? m4 : NaN)) : e4 = new h4(NaN), e4;
    if (m4.s != e4.s)
      return e4.s = -e4.s, m4.minus(e4);
    if (u4 = m4.d, c4 = e4.d, a4 = h4.precision, l3 = h4.rounding, !u4[0] || !c4[0])
      return c4[0] || (e4 = new h4(m4)), f3 ? k3(e4, a4, l3) : e4;
    if (o4 = v3(m4.e / 7), t4 = v3(e4.e / 7), u4 = u4.slice(), r4 = o4 - t4) {
      for (r4 < 0 ? (n4 = u4, r4 = -r4, s4 = c4.length) : (n4 = c4, t4 = o4, s4 = u4.length), r4 > (s4 = (o4 = Math.ceil(a4 / 7)) > s4 ? o4 + 1 : s4 + 1) && (r4 = s4, n4.length = 1), n4.reverse(); r4--; )
        n4.push(0);
      n4.reverse();
    }
    for ((s4 = u4.length) - (r4 = c4.length) < 0 && (r4 = s4, n4 = c4, c4 = u4, u4 = n4), i4 = 0; r4; )
      i4 = (u4[--r4] = u4[r4] + c4[r4] + i4) / S4 | 0, u4[r4] %= S4;
    for (i4 && (u4.unshift(i4), ++t4), s4 = u4.length; u4[--s4] == 0; )
      u4.pop();
    return e4.d = u4, e4.e = T4(u4, t4), f3 ? k3(e4, a4, l3) : e4;
  }, D4.precision = D4.sd = function(e4) {
    var i4, n4 = this;
    if (e4 !== void 0 && e4 !== !!e4 && e4 !== 1 && e4 !== 0)
      throw Error(p3 + e4);
    return n4.d ? (i4 = L3(n4.d), e4 && n4.e + 1 > i4 && (i4 = n4.e + 1)) : i4 = NaN, i4;
  }, D4.round = function() {
    var e4 = this, i4 = e4.constructor;
    return k3(new i4(e4), e4.e + 1, i4.rounding);
  }, D4.sine = D4.sin = function() {
    var e4, i4, n4 = this, t4 = n4.constructor;
    return n4.isFinite() ? n4.isZero() ? new t4(n4) : (e4 = t4.precision, i4 = t4.rounding, t4.precision = e4 + Math.max(n4.e, n4.sd()) + 7, t4.rounding = 1, n4 = function(e5, i5) {
      var n5, t5 = i5.d.length;
      if (t5 < 3)
        return G3(e5, 2, i5, i5);
      n5 = (n5 = 1.4 * Math.sqrt(t5)) > 16 ? 16 : 0 | n5, i5 = G3(e5, 2, i5 = i5.times(1 / W3(5, n5)), i5);
      for (var r4, o4 = new e5(5), s4 = new e5(16), a4 = new e5(20); n5--; )
        r4 = i5.times(i5), i5 = i5.times(o4.plus(r4.times(s4.times(r4).minus(a4))));
      return i5;
    }(t4, V3(t4, n4)), t4.precision = e4, t4.rounding = i4, k3(r3 > 2 ? n4.neg() : n4, e4, i4, true)) : new t4(NaN);
  }, D4.squareRoot = D4.sqrt = function() {
    var e4, i4, n4, t4, r4, o4, s4 = this, a4 = s4.d, l3 = s4.e, u4 = s4.s, c4 = s4.constructor;
    if (u4 !== 1 || !a4 || !a4[0])
      return new c4(!u4 || u4 < 0 && (!a4 || a4[0]) ? NaN : a4 ? s4 : 1 / 0);
    for (f3 = false, (u4 = Math.sqrt(+s4)) == 0 || u4 == 1 / 0 ? (((i4 = A3(a4)).length + l3) % 2 == 0 && (i4 += "0"), u4 = Math.sqrt(i4), l3 = v3((l3 + 1) / 2) - (l3 < 0 || l3 % 2), t4 = new c4(i4 = u4 == 1 / 0 ? "5e" + l3 : (i4 = u4.toExponential()).slice(0, i4.indexOf("e") + 1) + l3)) : t4 = new c4(u4.toString()), n4 = (l3 = c4.precision) + 3; ; )
      if (t4 = (o4 = t4).plus(I3(s4, o4, n4 + 2, 1)).times(0.5), A3(o4.d).slice(0, n4) === (i4 = A3(t4.d)).slice(0, n4)) {
        if ((i4 = i4.slice(n4 - 3, n4 + 1)) != "9999" && (r4 || i4 != "4999")) {
          +i4 && (+i4.slice(1) || i4.charAt(0) != "5") || (k3(t4, l3 + 1, 1), e4 = !t4.times(t4).eq(s4));
          break;
        }
        if (!r4 && (k3(o4, l3 + 1, 0), o4.times(o4).eq(s4))) {
          t4 = o4;
          break;
        }
        n4 += 4, r4 = 1;
      }
    return f3 = true, k3(t4, l3, c4.rounding, e4);
  }, D4.tangent = D4.tan = function() {
    var e4, i4, n4 = this, t4 = n4.constructor;
    return n4.isFinite() ? n4.isZero() ? new t4(n4) : (e4 = t4.precision, i4 = t4.rounding, t4.precision = e4 + 10, t4.rounding = 1, (n4 = n4.sin()).s = 1, n4 = I3(n4, new t4(1).minus(n4.times(n4)).sqrt(), e4 + 10, 0), t4.precision = e4, t4.rounding = i4, k3(r3 == 2 || r3 == 4 ? n4.neg() : n4, e4, i4, true)) : new t4(NaN);
  }, D4.times = D4.mul = function(e4) {
    var i4, n4, t4, r4, o4, s4, a4, l3, u4, c4 = this, m4 = c4.constructor, h4 = c4.d, p4 = (e4 = new m4(e4)).d;
    if (e4.s *= c4.s, !(h4 && h4[0] && p4 && p4[0]))
      return new m4(!e4.s || h4 && !h4[0] && !p4 || p4 && !p4[0] && !h4 ? NaN : h4 && p4 ? 0 * e4.s : e4.s / 0);
    for (n4 = v3(c4.e / 7) + v3(e4.e / 7), (l3 = h4.length) < (u4 = p4.length) && (o4 = h4, h4 = p4, p4 = o4, s4 = l3, l3 = u4, u4 = s4), o4 = [], t4 = s4 = l3 + u4; t4--; )
      o4.push(0);
    for (t4 = u4; --t4 >= 0; ) {
      for (i4 = 0, r4 = l3 + t4; r4 > t4; )
        a4 = o4[r4] + p4[t4] * h4[r4 - t4 - 1] + i4, o4[r4--] = a4 % S4 | 0, i4 = a4 / S4 | 0;
      o4[r4] = (o4[r4] + i4) % S4 | 0;
    }
    for (; !o4[--s4]; )
      o4.pop();
    return i4 ? ++n4 : o4.shift(), e4.d = o4, e4.e = T4(o4, n4), f3 ? k3(e4, m4.precision, m4.rounding) : e4;
  }, D4.toBinary = function(e4, i4) {
    return Y3(this, 2, e4, i4);
  }, D4.toDecimalPlaces = D4.toDP = function(e4, i4) {
    var n4 = this, t4 = n4.constructor;
    return n4 = new t4(n4), e4 === void 0 ? n4 : (C3(e4, 0, s3), i4 === void 0 ? i4 = t4.rounding : C3(i4, 0, 8), k3(n4, e4 + n4.e + 1, i4));
  }, D4.toExponential = function(e4, i4) {
    var n4, t4 = this, r4 = t4.constructor;
    return e4 === void 0 ? n4 = P3(t4, true) : (C3(e4, 0, s3), i4 === void 0 ? i4 = r4.rounding : C3(i4, 0, 8), n4 = P3(t4 = k3(new r4(t4), e4 + 1, i4), true, e4 + 1)), t4.isNeg() && !t4.isZero() ? "-" + n4 : n4;
  }, D4.toFixed = function(e4, i4) {
    var n4, t4, r4 = this, o4 = r4.constructor;
    return e4 === void 0 ? n4 = P3(r4) : (C3(e4, 0, s3), i4 === void 0 ? i4 = o4.rounding : C3(i4, 0, 8), n4 = P3(t4 = k3(new o4(r4), e4 + r4.e + 1, i4), false, e4 + t4.e + 1)), r4.isNeg() && !r4.isZero() ? "-" + n4 : n4;
  }, D4.toFraction = function(e4) {
    var i4, n4, t4, r4, o4, s4, a4, l3, u4, c4, m4, h4, g4 = this, d4 = g4.d, v4 = g4.constructor;
    if (!d4)
      return new v4(g4);
    if (u4 = n4 = new v4(1), t4 = l3 = new v4(0), s4 = (o4 = (i4 = new v4(t4)).e = L3(d4) - g4.e - 1) % 7, i4.d[0] = x3(10, s4 < 0 ? 7 + s4 : s4), e4 == null)
      e4 = o4 > 0 ? i4 : u4;
    else {
      if (!(a4 = new v4(e4)).isInt() || a4.lt(u4))
        throw Error(p3 + a4);
      e4 = a4.gt(i4) ? o4 > 0 ? i4 : u4 : a4;
    }
    for (f3 = false, a4 = new v4(A3(d4)), c4 = v4.precision, v4.precision = o4 = 7 * d4.length * 2; m4 = I3(a4, i4, 0, 1, 1), (r4 = n4.plus(m4.times(t4))).cmp(e4) != 1; )
      n4 = t4, t4 = r4, r4 = u4, u4 = l3.plus(m4.times(r4)), l3 = r4, r4 = i4, i4 = a4.minus(m4.times(r4)), a4 = r4;
    return r4 = I3(e4.minus(n4), t4, 0, 1, 1), l3 = l3.plus(r4.times(u4)), n4 = n4.plus(r4.times(t4)), l3.s = u4.s = g4.s, h4 = I3(u4, t4, o4, 1).minus(g4).abs().cmp(I3(l3, n4, o4, 1).minus(g4).abs()) < 1 ? [u4, t4] : [l3, n4], v4.precision = c4, f3 = true, h4;
  }, D4.toHexadecimal = D4.toHex = function(e4, i4) {
    return Y3(this, 16, e4, i4);
  }, D4.toNearest = function(e4, i4) {
    var n4 = this, t4 = n4.constructor;
    if (n4 = new t4(n4), e4 == null) {
      if (!n4.d)
        return n4;
      e4 = new t4(1), i4 = t4.rounding;
    } else {
      if (e4 = new t4(e4), i4 === void 0 ? i4 = t4.rounding : C3(i4, 0, 8), !n4.d)
        return e4.s ? n4 : e4;
      if (!e4.d)
        return e4.s && (e4.s = n4.s), e4;
    }
    return e4.d[0] ? (f3 = false, n4 = I3(n4, e4, 0, i4, 1).times(e4), f3 = true, k3(n4)) : (e4.s = n4.s, n4 = e4), n4;
  }, D4.toNumber = function() {
    return +this;
  }, D4.toOctal = function(e4, i4) {
    return Y3(this, 8, e4, i4);
  }, D4.toPower = D4.pow = function(e4) {
    var i4, n4, t4, r4, o4, s4, a4 = this, l3 = a4.constructor, u4 = +(e4 = new l3(e4));
    if (!(a4.d && e4.d && a4.d[0] && e4.d[0]))
      return new l3(x3(+a4, u4));
    if ((a4 = new l3(a4)).eq(1))
      return a4;
    if (t4 = l3.precision, o4 = l3.rounding, e4.eq(1))
      return k3(a4, t4, o4);
    if ((i4 = v3(e4.e / 7)) >= e4.d.length - 1 && (n4 = u4 < 0 ? -u4 : u4) <= 9007199254740991)
      return r4 = R3(l3, a4, n4, t4), e4.s < 0 ? new l3(1).div(r4) : k3(r4, t4, o4);
    if ((s4 = a4.s) < 0) {
      if (i4 < e4.d.length - 1)
        return new l3(NaN);
      if ((1 & e4.d[i4]) == 0 && (s4 = 1), a4.e == 0 && a4.d[0] == 1 && a4.d.length == 1)
        return a4.s = s4, a4;
    }
    return (i4 = (n4 = x3(+a4, u4)) != 0 && isFinite(n4) ? new l3(n4 + "").e : v3(u4 * (Math.log("0." + A3(a4.d)) / Math.LN10 + a4.e + 1))) > l3.maxE + 1 || i4 < l3.minE - 1 ? new l3(i4 > 0 ? s4 / 0 : 0) : (f3 = false, l3.rounding = a4.s = 1, n4 = Math.min(12, (i4 + "").length), (r4 = H3(e4.times($3(a4, t4 + n4)), t4)).d && q3((r4 = k3(r4, t4 + 5, 1)).d, t4, o4) && (i4 = t4 + 10, +A3((r4 = k3(H3(e4.times($3(a4, i4 + n4)), i4), i4 + 5, 1)).d).slice(t4 + 1, t4 + 15) + 1 == 1e14 && (r4 = k3(r4, t4 + 1, 0))), r4.s = s4, f3 = true, l3.rounding = o4, k3(r4, t4, o4));
  }, D4.toPrecision = function(e4, i4) {
    var n4, t4 = this, r4 = t4.constructor;
    return e4 === void 0 ? n4 = P3(t4, t4.e <= r4.toExpNeg || t4.e >= r4.toExpPos) : (C3(e4, 1, s3), i4 === void 0 ? i4 = r4.rounding : C3(i4, 0, 8), n4 = P3(t4 = k3(new r4(t4), e4, i4), e4 <= t4.e || t4.e <= r4.toExpNeg, e4)), t4.isNeg() && !t4.isZero() ? "-" + n4 : n4;
  }, D4.toSignificantDigits = D4.toSD = function(e4, i4) {
    var n4 = this.constructor;
    return e4 === void 0 ? (e4 = n4.precision, i4 = n4.rounding) : (C3(e4, 1, s3), i4 === void 0 ? i4 = n4.rounding : C3(i4, 0, 8)), k3(new n4(this), e4, i4);
  }, D4.toString = function() {
    var e4 = this, i4 = e4.constructor, n4 = P3(e4, e4.e <= i4.toExpNeg || e4.e >= i4.toExpPos);
    return e4.isNeg() && !e4.isZero() ? "-" + n4 : n4;
  }, D4.truncated = D4.trunc = function() {
    return k3(new this.constructor(this), this.e + 1, 1);
  }, D4.valueOf = D4.toJSON = function() {
    var e4 = this, i4 = e4.constructor, n4 = P3(e4, e4.e <= i4.toExpNeg || e4.e >= i4.toExpPos);
    return e4.isNeg() ? "-" + n4 : n4;
  };
  var I3 = function() {
    function e4(e5, i5, n4) {
      var t5, r4 = 0, o4 = e5.length;
      for (e5 = e5.slice(); o4--; )
        t5 = e5[o4] * i5 + r4, e5[o4] = t5 % n4 | 0, r4 = t5 / n4 | 0;
      return r4 && e5.unshift(r4), e5;
    }
    function i4(e5, i5, n4, t5) {
      var r4, o4;
      if (n4 != t5)
        o4 = n4 > t5 ? 1 : -1;
      else
        for (r4 = o4 = 0; r4 < n4; r4++)
          if (e5[r4] != i5[r4]) {
            o4 = e5[r4] > i5[r4] ? 1 : -1;
            break;
          }
      return o4;
    }
    function t4(e5, i5, n4, t5) {
      for (var r4 = 0; n4--; )
        e5[n4] -= r4, r4 = e5[n4] < i5[n4] ? 1 : 0, e5[n4] = r4 * t5 + e5[n4] - i5[n4];
      for (; !e5[0] && e5.length > 1; )
        e5.shift();
    }
    return function(r4, o4, s4, a4, l3, u4) {
      var c4, m4, f4, h4, p4, g4, d4, x4, y4, b4, N4, w4, M26, E4, D5, A4, C4, q4, F4, I4, P4 = r4.constructor, T5 = r4.s == o4.s ? 1 : -1, O4 = r4.d, z4 = o4.d;
      if (!(O4 && O4[0] && z4 && z4[0]))
        return new P4(r4.s && o4.s && (O4 ? !z4 || O4[0] != z4[0] : z4) ? O4 && O4[0] == 0 || !z4 ? 0 * T5 : T5 / 0 : NaN);
      for (u4 ? (p4 = 1, m4 = r4.e - o4.e) : (u4 = S4, p4 = 7, m4 = v3(r4.e / p4) - v3(o4.e / p4)), F4 = z4.length, C4 = O4.length, b4 = (y4 = new P4(T5)).d = [], f4 = 0; z4[f4] == (O4[f4] || 0); f4++)
        ;
      if (z4[f4] > (O4[f4] || 0) && m4--, s4 == null ? (E4 = s4 = P4.precision, a4 = P4.rounding) : E4 = l3 ? s4 + (r4.e - o4.e) + 1 : s4, E4 < 0)
        b4.push(1), g4 = true;
      else {
        if (E4 = E4 / p4 + 2 | 0, f4 = 0, F4 == 1) {
          for (h4 = 0, z4 = z4[0], E4++; (f4 < C4 || h4) && E4--; f4++)
            D5 = h4 * u4 + (O4[f4] || 0), b4[f4] = D5 / z4 | 0, h4 = D5 % z4 | 0;
          g4 = h4 || f4 < C4;
        } else {
          for ((h4 = u4 / (z4[0] + 1) | 0) > 1 && (z4 = e4(z4, h4, u4), O4 = e4(O4, h4, u4), F4 = z4.length, C4 = O4.length), A4 = F4, w4 = (N4 = O4.slice(0, F4)).length; w4 < F4; )
            N4[w4++] = 0;
          (I4 = z4.slice()).unshift(0), q4 = z4[0], z4[1] >= u4 / 2 && ++q4;
          do {
            h4 = 0, (c4 = i4(z4, N4, F4, w4)) < 0 ? (M26 = N4[0], F4 != w4 && (M26 = M26 * u4 + (N4[1] || 0)), (h4 = M26 / q4 | 0) > 1 ? (h4 >= u4 && (h4 = u4 - 1), (c4 = i4(d4 = e4(z4, h4, u4), N4, x4 = d4.length, w4 = N4.length)) == 1 && (h4--, t4(d4, F4 < x4 ? I4 : z4, x4, u4))) : (h4 == 0 && (c4 = h4 = 1), d4 = z4.slice()), (x4 = d4.length) < w4 && d4.unshift(0), t4(N4, d4, w4, u4), c4 == -1 && (c4 = i4(z4, N4, F4, w4 = N4.length)) < 1 && (h4++, t4(N4, F4 < w4 ? I4 : z4, w4, u4)), w4 = N4.length) : c4 === 0 && (h4++, N4 = [0]), b4[f4++] = h4, c4 && N4[0] ? N4[w4++] = O4[A4] || 0 : (N4 = [O4[A4]], w4 = 1);
          } while ((A4++ < C4 || N4[0] !== void 0) && E4--);
          g4 = N4[0] !== void 0;
        }
        b4[0] || b4.shift();
      }
      if (p4 == 1)
        y4.e = m4, n3 = g4;
      else {
        for (f4 = 1, h4 = b4[0]; h4 >= 10; h4 /= 10)
          f4++;
        y4.e = f4 + m4 * p4 - 1, k3(y4, l3 ? s4 + y4.e + 1 : s4, a4, g4);
      }
      return y4;
    };
  }();
  function k3(e4, i4, n4, t4) {
    var r4, o4, s4, a4, l3, u4, c4, m4, h4, p4 = e4.constructor;
    e:
      if (i4 != null) {
        if (!(m4 = e4.d))
          return e4;
        for (r4 = 1, a4 = m4[0]; a4 >= 10; a4 /= 10)
          r4++;
        if ((o4 = i4 - r4) < 0)
          o4 += 7, s4 = i4, l3 = (c4 = m4[h4 = 0]) / x3(10, r4 - s4 - 1) % 10 | 0;
        else if ((h4 = Math.ceil((o4 + 1) / 7)) >= (a4 = m4.length)) {
          if (!t4)
            break e;
          for (; a4++ <= h4; )
            m4.push(0);
          c4 = l3 = 0, r4 = 1, s4 = (o4 %= 7) - 7 + 1;
        } else {
          for (c4 = a4 = m4[h4], r4 = 1; a4 >= 10; a4 /= 10)
            r4++;
          l3 = (s4 = (o4 %= 7) - 7 + r4) < 0 ? 0 : c4 / x3(10, r4 - s4 - 1) % 10 | 0;
        }
        if (t4 = t4 || i4 < 0 || m4[h4 + 1] !== void 0 || (s4 < 0 ? c4 : c4 % x3(10, r4 - s4 - 1)), u4 = n4 < 4 ? (l3 || t4) && (n4 == 0 || n4 == (e4.s < 0 ? 3 : 2)) : l3 > 5 || l3 == 5 && (n4 == 4 || t4 || n4 == 6 && (o4 > 0 ? s4 > 0 ? c4 / x3(10, r4 - s4) : 0 : m4[h4 - 1]) % 10 & 1 || n4 == (e4.s < 0 ? 8 : 7)), i4 < 1 || !m4[0])
          return m4.length = 0, u4 ? (i4 -= e4.e + 1, m4[0] = x3(10, (7 - i4 % 7) % 7), e4.e = -i4 || 0) : m4[0] = e4.e = 0, e4;
        if (o4 == 0 ? (m4.length = h4, a4 = 1, h4--) : (m4.length = h4 + 1, a4 = x3(10, 7 - o4), m4[h4] = s4 > 0 ? (c4 / x3(10, r4 - s4) % x3(10, s4) | 0) * a4 : 0), u4)
          for (; ; ) {
            if (h4 == 0) {
              for (o4 = 1, s4 = m4[0]; s4 >= 10; s4 /= 10)
                o4++;
              for (s4 = m4[0] += a4, a4 = 1; s4 >= 10; s4 /= 10)
                a4++;
              o4 != a4 && (e4.e++, m4[0] == S4 && (m4[0] = 1));
              break;
            }
            if (m4[h4] += a4, m4[h4] != S4)
              break;
            m4[h4--] = 0, a4 = 1;
          }
        for (o4 = m4.length; m4[--o4] === 0; )
          m4.pop();
      }
    return f3 && (e4.e > p4.maxE ? (e4.d = null, e4.e = NaN) : e4.e < p4.minE && (e4.e = 0, e4.d = [0])), e4;
  }
  function P3(e4, i4, n4) {
    if (!e4.isFinite())
      return j2(e4);
    var t4, r4 = e4.e, o4 = A3(e4.d), s4 = o4.length;
    return i4 ? (n4 && (t4 = n4 - s4) > 0 ? o4 = o4.charAt(0) + "." + o4.slice(1) + _3(t4) : s4 > 1 && (o4 = o4.charAt(0) + "." + o4.slice(1)), o4 = o4 + (e4.e < 0 ? "e" : "e+") + e4.e) : r4 < 0 ? (o4 = "0." + _3(-r4 - 1) + o4, n4 && (t4 = n4 - s4) > 0 && (o4 += _3(t4))) : r4 >= s4 ? (o4 += _3(r4 + 1 - s4), n4 && (t4 = n4 - r4 - 1) > 0 && (o4 = o4 + "." + _3(t4))) : ((t4 = r4 + 1) < s4 && (o4 = o4.slice(0, t4) + "." + o4.slice(t4)), n4 && (t4 = n4 - s4) > 0 && (r4 + 1 === s4 && (o4 += "."), o4 += _3(t4))), o4;
  }
  function T4(e4, i4) {
    var n4 = e4[0];
    for (i4 *= 7; n4 >= 10; n4 /= 10)
      i4++;
    return i4;
  }
  function O3(e4, i4, n4) {
    if (i4 > M25)
      throw f3 = true, n4 && (e4.precision = n4), Error(g3);
    return k3(new e4(u3), i4, 1, true);
  }
  function z3(e4, i4, n4) {
    if (i4 > E3)
      throw Error(g3);
    return k3(new e4(c3), i4, n4, true);
  }
  function L3(e4) {
    var i4 = e4.length - 1, n4 = 7 * i4 + 1;
    if (i4 = e4[i4]) {
      for (; i4 % 10 == 0; i4 /= 10)
        n4--;
      for (i4 = e4[0]; i4 >= 10; i4 /= 10)
        n4++;
    }
    return n4;
  }
  function _3(e4) {
    for (var i4 = ""; e4--; )
      i4 += "0";
    return i4;
  }
  function R3(e4, i4, n4, t4) {
    var r4, o4 = new e4(1), s4 = Math.ceil(t4 / 7 + 4);
    for (f3 = false; ; ) {
      if (n4 % 2 && J3((o4 = o4.times(i4)).d, s4) && (r4 = true), (n4 = v3(n4 / 2)) === 0) {
        n4 = o4.d.length - 1, r4 && o4.d[n4] === 0 && ++o4.d[n4];
        break;
      }
      J3((i4 = i4.times(i4)).d, s4);
    }
    return f3 = true, o4;
  }
  function Z3(e4) {
    return 1 & e4.d[e4.d.length - 1];
  }
  function Q3(e4, i4, n4) {
    for (var t4, r4 = new e4(i4[0]), o4 = 0; ++o4 < i4.length; ) {
      if (!(t4 = new e4(i4[o4])).s) {
        r4 = t4;
        break;
      }
      r4[n4](t4) && (r4 = t4);
    }
    return r4;
  }
  function H3(e4, i4) {
    var n4, t4, r4, o4, s4, a4, l3, u4 = 0, c4 = 0, m4 = 0, h4 = e4.constructor, p4 = h4.rounding, g4 = h4.precision;
    if (!e4.d || !e4.d[0] || e4.e > 17)
      return new h4(e4.d ? e4.d[0] ? e4.s < 0 ? 0 : 1 / 0 : 1 : e4.s ? e4.s < 0 ? 0 : e4 : NaN);
    for (i4 == null ? (f3 = false, l3 = g4) : l3 = i4, a4 = new h4(0.03125); e4.e > -2; )
      e4 = e4.times(a4), m4 += 5;
    for (l3 += t4 = Math.log(x3(2, m4)) / Math.LN10 * 2 + 5 | 0, n4 = o4 = s4 = new h4(1), h4.precision = l3; ; ) {
      if (o4 = k3(o4.times(e4), l3, 1), n4 = n4.times(++c4), A3((a4 = s4.plus(I3(o4, n4, l3, 1))).d).slice(0, l3) === A3(s4.d).slice(0, l3)) {
        for (r4 = m4; r4--; )
          s4 = k3(s4.times(s4), l3, 1);
        if (i4 != null)
          return h4.precision = g4, s4;
        if (!(u4 < 3 && q3(s4.d, l3 - t4, p4, u4)))
          return k3(s4, h4.precision = g4, p4, f3 = true);
        h4.precision = l3 += 10, n4 = o4 = a4 = new h4(1), c4 = 0, u4++;
      }
      s4 = a4;
    }
  }
  function $3(e4, i4) {
    var n4, t4, r4, o4, s4, a4, l3, u4, c4, m4, h4, p4 = 1, g4 = e4, d4 = g4.d, v4 = g4.constructor, x4 = v4.rounding, y4 = v4.precision;
    if (g4.s < 0 || !d4 || !d4[0] || !g4.e && d4[0] == 1 && d4.length == 1)
      return new v4(d4 && !d4[0] ? -1 / 0 : g4.s != 1 ? NaN : d4 ? 0 : g4);
    if (i4 == null ? (f3 = false, c4 = y4) : c4 = i4, v4.precision = c4 += 10, t4 = (n4 = A3(d4)).charAt(0), !(Math.abs(o4 = g4.e) < 15e14))
      return u4 = O3(v4, c4 + 2, y4).times(o4 + ""), g4 = $3(new v4(t4 + "." + n4.slice(1)), c4 - 10).plus(u4), v4.precision = y4, i4 == null ? k3(g4, y4, x4, f3 = true) : g4;
    for (; t4 < 7 && t4 != 1 || t4 == 1 && n4.charAt(1) > 3; )
      t4 = (n4 = A3((g4 = g4.times(e4)).d)).charAt(0), p4++;
    for (o4 = g4.e, t4 > 1 ? (g4 = new v4("0." + n4), o4++) : g4 = new v4(t4 + "." + n4.slice(1)), m4 = g4, l3 = s4 = g4 = I3(g4.minus(1), g4.plus(1), c4, 1), h4 = k3(g4.times(g4), c4, 1), r4 = 3; ; ) {
      if (s4 = k3(s4.times(h4), c4, 1), A3((u4 = l3.plus(I3(s4, new v4(r4), c4, 1))).d).slice(0, c4) === A3(l3.d).slice(0, c4)) {
        if (l3 = l3.times(2), o4 !== 0 && (l3 = l3.plus(O3(v4, c4 + 2, y4).times(o4 + ""))), l3 = I3(l3, new v4(p4), c4, 1), i4 != null)
          return v4.precision = y4, l3;
        if (!q3(l3.d, c4 - 10, x4, a4))
          return k3(l3, v4.precision = y4, x4, f3 = true);
        v4.precision = c4 += 10, u4 = s4 = g4 = I3(m4.minus(1), m4.plus(1), c4, 1), h4 = k3(g4.times(g4), c4, 1), r4 = a4 = 1;
      }
      l3 = u4, r4 += 2;
    }
  }
  function j2(e4) {
    return String(e4.s * e4.s / 0);
  }
  function B3(e4, i4) {
    var n4, t4, r4;
    for ((n4 = i4.indexOf(".")) > -1 && (i4 = i4.replace(".", "")), (t4 = i4.search(/e/i)) > 0 ? (n4 < 0 && (n4 = t4), n4 += +i4.slice(t4 + 1), i4 = i4.substring(0, t4)) : n4 < 0 && (n4 = i4.length), t4 = 0; i4.charCodeAt(t4) === 48; t4++)
      ;
    for (r4 = i4.length; i4.charCodeAt(r4 - 1) === 48; --r4)
      ;
    if (i4 = i4.slice(t4, r4)) {
      if (r4 -= t4, e4.e = n4 = n4 - t4 - 1, e4.d = [], t4 = (n4 + 1) % 7, n4 < 0 && (t4 += 7), t4 < r4) {
        for (t4 && e4.d.push(+i4.slice(0, t4)), r4 -= 7; t4 < r4; )
          e4.d.push(+i4.slice(t4, t4 += 7));
        t4 = 7 - (i4 = i4.slice(t4)).length;
      } else
        t4 -= r4;
      for (; t4--; )
        i4 += "0";
      e4.d.push(+i4), f3 && (e4.e > e4.constructor.maxE ? (e4.d = null, e4.e = NaN) : e4.e < e4.constructor.minE && (e4.e = 0, e4.d = [0]));
    } else
      e4.e = 0, e4.d = [0];
    return e4;
  }
  function U2(e4, n4) {
    var t4, r4, o4, s4, a4, l3, u4, c4, m4;
    if (n4 === "Infinity" || n4 === "NaN")
      return +n4 || (e4.s = NaN), e4.e = NaN, e4.d = null, e4;
    if (b3.test(n4))
      t4 = 16, n4 = n4.toLowerCase();
    else if (y3.test(n4))
      t4 = 2;
    else {
      if (!N3.test(n4))
        throw Error(p3 + n4);
      t4 = 8;
    }
    for ((s4 = n4.search(/p/i)) > 0 ? (u4 = +n4.slice(s4 + 1), n4 = n4.substring(2, s4)) : n4 = n4.slice(2), a4 = (s4 = n4.indexOf(".")) >= 0, r4 = e4.constructor, a4 && (s4 = (l3 = (n4 = n4.replace(".", "")).length) - s4, o4 = R3(r4, new r4(t4), s4, 2 * s4)), s4 = m4 = (c4 = F3(n4, t4, S4)).length - 1; c4[s4] === 0; --s4)
      c4.pop();
    return s4 < 0 ? new r4(0 * e4.s) : (e4.e = T4(c4, m4), e4.d = c4, f3 = false, a4 && (e4 = I3(e4, o4, 4 * l3)), u4 && (e4 = e4.times(Math.abs(u4) < 54 ? x3(2, u4) : i3.pow(2, u4))), f3 = true, e4);
  }
  function G3(e4, i4, n4, t4, r4) {
    var o4, s4, a4, l3, u4 = e4.precision, c4 = Math.ceil(u4 / 7);
    for (f3 = false, l3 = n4.times(n4), a4 = new e4(t4); ; ) {
      if (s4 = I3(a4.times(l3), new e4(i4++ * i4++), u4, 1), a4 = r4 ? t4.plus(s4) : t4.minus(s4), t4 = I3(s4.times(l3), new e4(i4++ * i4++), u4, 1), (s4 = a4.plus(t4)).d[c4] !== void 0) {
        for (o4 = c4; s4.d[o4] === a4.d[o4] && o4--; )
          ;
        if (o4 == -1)
          break;
      }
      o4 = a4, a4 = t4, t4 = s4, s4 = o4;
    }
    return f3 = true, s4.d.length = c4 + 1, s4;
  }
  function W3(e4, i4) {
    for (var n4 = e4; --i4; )
      n4 *= e4;
    return n4;
  }
  function V3(e4, i4) {
    var n4, t4 = i4.s < 0, o4 = z3(e4, e4.precision, 1), s4 = o4.times(0.5);
    if ((i4 = i4.abs()).lte(s4))
      return r3 = t4 ? 4 : 1, i4;
    if ((n4 = i4.divToInt(o4)).isZero())
      r3 = t4 ? 3 : 2;
    else {
      if ((i4 = i4.minus(n4.times(o4))).lte(s4))
        return r3 = Z3(n4) ? t4 ? 2 : 3 : t4 ? 4 : 1, i4;
      r3 = Z3(n4) ? t4 ? 1 : 4 : t4 ? 3 : 2;
    }
    return i4.minus(o4).abs();
  }
  function Y3(e4, i4, t4, r4) {
    var o4, l3, u4, c4, m4, f4, h4, p4, g4, d4 = e4.constructor, v4 = t4 !== void 0;
    if (v4 ? (C3(t4, 1, s3), r4 === void 0 ? r4 = d4.rounding : C3(r4, 0, 8)) : (t4 = d4.precision, r4 = d4.rounding), e4.isFinite()) {
      for (v4 ? (o4 = 2, i4 == 16 ? t4 = 4 * t4 - 3 : i4 == 8 && (t4 = 3 * t4 - 2)) : o4 = i4, (u4 = (h4 = P3(e4)).indexOf(".")) >= 0 && (h4 = h4.replace(".", ""), (g4 = new d4(1)).e = h4.length - u4, g4.d = F3(P3(g4), 10, o4), g4.e = g4.d.length), l3 = m4 = (p4 = F3(h4, 10, o4)).length; p4[--m4] == 0; )
        p4.pop();
      if (p4[0]) {
        if (u4 < 0 ? l3-- : ((e4 = new d4(e4)).d = p4, e4.e = l3, p4 = (e4 = I3(e4, g4, t4, r4, 0, o4)).d, l3 = e4.e, f4 = n3), u4 = p4[t4], c4 = o4 / 2, f4 = f4 || p4[t4 + 1] !== void 0, f4 = r4 < 4 ? (u4 !== void 0 || f4) && (r4 === 0 || r4 === (e4.s < 0 ? 3 : 2)) : u4 > c4 || u4 === c4 && (r4 === 4 || f4 || r4 === 6 && 1 & p4[t4 - 1] || r4 === (e4.s < 0 ? 8 : 7)), p4.length = t4, f4)
          for (; ++p4[--t4] > o4 - 1; )
            p4[t4] = 0, t4 || (++l3, p4.unshift(1));
        for (m4 = p4.length; !p4[m4 - 1]; --m4)
          ;
        for (u4 = 0, h4 = ""; u4 < m4; u4++)
          h4 += a3.charAt(p4[u4]);
        if (v4) {
          if (m4 > 1)
            if (i4 == 16 || i4 == 8) {
              for (u4 = i4 == 16 ? 4 : 3, --m4; m4 % u4; m4++)
                h4 += "0";
              for (m4 = (p4 = F3(h4, o4, i4)).length; !p4[m4 - 1]; --m4)
                ;
              for (u4 = 1, h4 = "1."; u4 < m4; u4++)
                h4 += a3.charAt(p4[u4]);
            } else
              h4 = h4.charAt(0) + "." + h4.slice(1);
          h4 = h4 + (l3 < 0 ? "p" : "p+") + l3;
        } else if (l3 < 0) {
          for (; ++l3; )
            h4 = "0" + h4;
          h4 = "0." + h4;
        } else if (++l3 > m4)
          for (l3 -= m4; l3--; )
            h4 += "0";
        else
          l3 < m4 && (h4 = h4.slice(0, l3) + "." + h4.slice(l3));
      } else
        h4 = v4 ? "0p+0" : "0";
      h4 = (i4 == 16 ? "0x" : i4 == 2 ? "0b" : i4 == 8 ? "0o" : "") + h4;
    } else
      h4 = j2(e4);
    return e4.s < 0 ? "-" + h4 : h4;
  }
  function J3(e4, i4) {
    if (e4.length > i4)
      return e4.length = i4, true;
  }
  function X3(e4) {
    return new this(e4).abs();
  }
  function K2(e4) {
    return new this(e4).acos();
  }
  function ee2(e4) {
    return new this(e4).acosh();
  }
  function ie3(e4, i4) {
    return new this(e4).plus(i4);
  }
  function ne3(e4) {
    return new this(e4).asin();
  }
  function te3(e4) {
    return new this(e4).asinh();
  }
  function re3(e4) {
    return new this(e4).atan();
  }
  function oe3(e4) {
    return new this(e4).atanh();
  }
  function se3(e4, i4) {
    e4 = new this(e4), i4 = new this(i4);
    var n4, t4 = this.precision, r4 = this.rounding, o4 = t4 + 4;
    return e4.s && i4.s ? e4.d || i4.d ? !i4.d || e4.isZero() ? (n4 = i4.s < 0 ? z3(this, t4, r4) : new this(0)).s = e4.s : !e4.d || i4.isZero() ? (n4 = z3(this, o4, 1).times(0.5)).s = e4.s : i4.s < 0 ? (this.precision = o4, this.rounding = 1, n4 = this.atan(I3(e4, i4, o4, 1)), i4 = z3(this, o4, 1), this.precision = t4, this.rounding = r4, n4 = e4.s < 0 ? n4.minus(i4) : n4.plus(i4)) : n4 = this.atan(I3(e4, i4, o4, 1)) : (n4 = z3(this, o4, 1).times(i4.s > 0 ? 0.25 : 0.75)).s = e4.s : n4 = new this(NaN), n4;
  }
  function ae3(e4) {
    return new this(e4).cbrt();
  }
  function le2(e4) {
    return k3(e4 = new this(e4), e4.e + 1, 2);
  }
  function ue2(e4) {
    if (!e4 || typeof e4 != "object")
      throw Error(h3 + "Object expected");
    var i4, n4, t4, r4 = e4.defaults === true, a4 = ["precision", 1, s3, "rounding", 0, 8, "toExpNeg", -o3, 0, "toExpPos", 0, o3, "maxE", 0, o3, "minE", -o3, 0, "modulo", 0, 9];
    for (i4 = 0; i4 < a4.length; i4 += 3)
      if (n4 = a4[i4], r4 && (this[n4] = m3[n4]), (t4 = e4[n4]) !== void 0) {
        if (!(v3(t4) === t4 && t4 >= a4[i4 + 1] && t4 <= a4[i4 + 2]))
          throw Error(p3 + n4 + ": " + t4);
        this[n4] = t4;
      }
    if (n4 = "crypto", r4 && (this[n4] = m3[n4]), (t4 = e4[n4]) !== void 0) {
      if (t4 !== true && t4 !== false && t4 !== 0 && t4 !== 1)
        throw Error(p3 + n4 + ": " + t4);
      if (t4) {
        if (typeof crypto == "undefined" || !crypto || !crypto.getRandomValues && !crypto.randomBytes)
          throw Error(d3);
        this[n4] = true;
      } else
        this[n4] = false;
    }
    return this;
  }
  function ce2(e4) {
    return new this(e4).cos();
  }
  function me(e4) {
    return new this(e4).cosh();
  }
  function fe2(e4, i4) {
    return new this(e4).div(i4);
  }
  function he2(e4) {
    return new this(e4).exp();
  }
  function pe2(e4) {
    return k3(e4 = new this(e4), e4.e + 1, 3);
  }
  function ge2() {
    var e4, i4, n4 = new this(0);
    for (f3 = false, e4 = 0; e4 < arguments.length; )
      if ((i4 = new this(arguments[e4++])).d)
        n4.d && (n4 = n4.plus(i4.times(i4)));
      else {
        if (i4.s)
          return f3 = true, new this(1 / 0);
        n4 = i4;
      }
    return f3 = true, n4.sqrt();
  }
  function de2(e4) {
    return e4 instanceof i3 || e4 && e4.name === "[object Decimal]" || false;
  }
  function ve2(e4) {
    return new this(e4).ln();
  }
  function xe2(e4, i4) {
    return new this(e4).log(i4);
  }
  function ye2(e4) {
    return new this(e4).log(2);
  }
  function be2(e4) {
    return new this(e4).log(10);
  }
  function Ne2() {
    return Q3(this, arguments, "lt");
  }
  function we2() {
    return Q3(this, arguments, "gt");
  }
  function Se2(e4, i4) {
    return new this(e4).mod(i4);
  }
  function Me(e4, i4) {
    return new this(e4).mul(i4);
  }
  function Ee2(e4, i4) {
    return new this(e4).pow(i4);
  }
  function De2(e4) {
    var i4, n4, t4, r4, o4 = 0, a4 = new this(1), l3 = [];
    if (e4 === void 0 ? e4 = this.precision : C3(e4, 1, s3), t4 = Math.ceil(e4 / 7), this.crypto)
      if (crypto.getRandomValues)
        for (i4 = crypto.getRandomValues(new Uint32Array(t4)); o4 < t4; )
          (r4 = i4[o4]) >= 429e7 ? i4[o4] = crypto.getRandomValues(new Uint32Array(1))[0] : l3[o4++] = r4 % 1e7;
      else {
        if (!crypto.randomBytes)
          throw Error(d3);
        for (i4 = crypto.randomBytes(t4 *= 4); o4 < t4; )
          (r4 = i4[o4] + (i4[o4 + 1] << 8) + (i4[o4 + 2] << 16) + ((127 & i4[o4 + 3]) << 24)) >= 214e7 ? crypto.randomBytes(4).copy(i4, o4) : (l3.push(r4 % 1e7), o4 += 4);
        o4 = t4 / 4;
      }
    else
      for (; o4 < t4; )
        l3[o4++] = 1e7 * Math.random() | 0;
    for (e4 %= 7, (t4 = l3[--o4]) && e4 && (r4 = x3(10, 7 - e4), l3[o4] = (t4 / r4 | 0) * r4); l3[o4] === 0; o4--)
      l3.pop();
    if (o4 < 0)
      n4 = 0, l3 = [0];
    else {
      for (n4 = -1; l3[0] === 0; n4 -= 7)
        l3.shift();
      for (t4 = 1, r4 = l3[0]; r4 >= 10; r4 /= 10)
        t4++;
      t4 < 7 && (n4 -= 7 - t4);
    }
    return a4.e = n4, a4.d = l3, a4;
  }
  function Ae2(e4) {
    return k3(e4 = new this(e4), e4.e + 1, this.rounding);
  }
  function Ce2(e4) {
    return (e4 = new this(e4)).d ? e4.d[0] ? e4.s : 0 * e4.s : e4.s || NaN;
  }
  function qe(e4) {
    return new this(e4).sin();
  }
  function Fe2(e4) {
    return new this(e4).sinh();
  }
  function Ie2(e4) {
    return new this(e4).sqrt();
  }
  function ke2(e4, i4) {
    return new this(e4).sub(i4);
  }
  function Pe2(e4) {
    return new this(e4).tan();
  }
  function Te2(e4) {
    return new this(e4).tanh();
  }
  function Oe2(e4) {
    return k3(e4 = new this(e4), e4.e + 1, 1);
  }
  (i3 = function e4(i4) {
    var n4, t4, r4;
    function o4(e5) {
      var i5, n5, t5, r5 = this;
      if (!(r5 instanceof o4))
        return new o4(e5);
      if (r5.constructor = o4, e5 instanceof o4)
        return r5.s = e5.s, void (f3 ? !e5.d || e5.e > o4.maxE ? (r5.e = NaN, r5.d = null) : e5.e < o4.minE ? (r5.e = 0, r5.d = [0]) : (r5.e = e5.e, r5.d = e5.d.slice()) : (r5.e = e5.e, r5.d = e5.d ? e5.d.slice() : e5.d));
      if ((t5 = typeof e5) == "number") {
        if (e5 === 0)
          return r5.s = 1 / e5 < 0 ? -1 : 1, r5.e = 0, void (r5.d = [0]);
        if (e5 < 0 ? (e5 = -e5, r5.s = -1) : r5.s = 1, e5 === ~~e5 && e5 < 1e7) {
          for (i5 = 0, n5 = e5; n5 >= 10; n5 /= 10)
            i5++;
          return void (f3 ? i5 > o4.maxE ? (r5.e = NaN, r5.d = null) : i5 < o4.minE ? (r5.e = 0, r5.d = [0]) : (r5.e = i5, r5.d = [e5]) : (r5.e = i5, r5.d = [e5]));
        }
        return 0 * e5 != 0 ? (e5 || (r5.s = NaN), r5.e = NaN, void (r5.d = null)) : B3(r5, e5.toString());
      }
      if (t5 !== "string")
        throw Error(p3 + e5);
      return (n5 = e5.charCodeAt(0)) === 45 ? (e5 = e5.slice(1), r5.s = -1) : (n5 === 43 && (e5 = e5.slice(1)), r5.s = 1), w3.test(e5) ? B3(r5, e5) : U2(r5, e5);
    }
    if (o4.prototype = D4, o4.ROUND_UP = 0, o4.ROUND_DOWN = 1, o4.ROUND_CEIL = 2, o4.ROUND_FLOOR = 3, o4.ROUND_HALF_UP = 4, o4.ROUND_HALF_DOWN = 5, o4.ROUND_HALF_EVEN = 6, o4.ROUND_HALF_CEIL = 7, o4.ROUND_HALF_FLOOR = 8, o4.EUCLID = 9, o4.config = o4.set = ue2, o4.clone = e4, o4.isDecimal = de2, o4.abs = X3, o4.acos = K2, o4.acosh = ee2, o4.add = ie3, o4.asin = ne3, o4.asinh = te3, o4.atan = re3, o4.atanh = oe3, o4.atan2 = se3, o4.cbrt = ae3, o4.ceil = le2, o4.cos = ce2, o4.cosh = me, o4.div = fe2, o4.exp = he2, o4.floor = pe2, o4.hypot = ge2, o4.ln = ve2, o4.log = xe2, o4.log10 = be2, o4.log2 = ye2, o4.max = Ne2, o4.min = we2, o4.mod = Se2, o4.mul = Me, o4.pow = Ee2, o4.random = De2, o4.round = Ae2, o4.sign = Ce2, o4.sin = qe, o4.sinh = Fe2, o4.sqrt = Ie2, o4.sub = ke2, o4.tan = Pe2, o4.tanh = Te2, o4.trunc = Oe2, i4 === void 0 && (i4 = {}), i4 && i4.defaults !== true)
      for (r4 = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], n4 = 0; n4 < r4.length; )
        i4.hasOwnProperty(t4 = r4[n4++]) || (i4[t4] = this[t4]);
    return o4.config(i4), o4;
  }(m3)).default = i3.Decimal = i3, u3 = new i3(u3), c3 = new i3(c3), l2.exports ? (typeof Symbol == "function" && typeof Symbol.iterator == "symbol" && (D4[Symbol.for("nodejs.util.inspect.custom")] = D4.toString, D4[Symbol.toStringTag] = "Decimal"), l2.exports = i3) : (e3 || (e3 = typeof self != "undefined" && self && self.self == self ? self : window), t3 = e3.Decimal, i3.noConflict = function() {
    return e3.Decimal = t3, i3;
  }, e3.Decimal = i3);
}(u2);
var m2 = {exports: {}};
!function(e3, i3) {
  !function(i4) {
    var n3 = function(e4) {
      return 0.5 * (Math.exp(e4) + Math.exp(-e4));
    }, t3 = function(e4) {
      return 0.5 * (Math.exp(e4) - Math.exp(-e4));
    }, r3 = function() {
      throw SyntaxError("Invalid Param");
    };
    function o3(e4, i5) {
      var n4 = Math.abs(e4), t4 = Math.abs(i5);
      return e4 === 0 ? Math.log(t4) : i5 === 0 ? Math.log(n4) : n4 < 3e3 && t4 < 3e3 ? 0.5 * Math.log(e4 * e4 + i5 * i5) : Math.log(e4 / Math.cos(Math.atan2(i5, e4)));
    }
    function s3(e4, i5) {
      if (!(this instanceof s3))
        return new s3(e4, i5);
      var n4 = function(e5, i6) {
        var n5 = {re: 0, im: 0};
        if (e5 == null)
          n5.re = n5.im = 0;
        else if (i6 !== void 0)
          n5.re = e5, n5.im = i6;
        else
          switch (typeof e5) {
            case "object":
              if ("im" in e5 && "re" in e5)
                n5.re = e5.re, n5.im = e5.im;
              else if ("abs" in e5 && "arg" in e5) {
                if (!Number.isFinite(e5.abs) && Number.isFinite(e5.arg))
                  return s3.INFINITY;
                n5.re = e5.abs * Math.cos(e5.arg), n5.im = e5.abs * Math.sin(e5.arg);
              } else if ("r" in e5 && "phi" in e5) {
                if (!Number.isFinite(e5.r) && Number.isFinite(e5.phi))
                  return s3.INFINITY;
                n5.re = e5.r * Math.cos(e5.phi), n5.im = e5.r * Math.sin(e5.phi);
              } else
                e5.length === 2 ? (n5.re = e5[0], n5.im = e5[1]) : r3();
              break;
            case "string":
              n5.im = n5.re = 0;
              var t4 = e5.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g), o4 = 1, a3 = 0;
              t4 === null && r3();
              for (var l3 = 0; l3 < t4.length; l3++) {
                var u3 = t4[l3];
                u3 === " " || u3 === "	" || u3 === "\n" || (u3 === "+" ? o4++ : u3 === "-" ? a3++ : u3 === "i" || u3 === "I" ? (o4 + a3 === 0 && r3(), t4[l3 + 1] === " " || isNaN(t4[l3 + 1]) ? n5.im += parseFloat((a3 % 2 ? "-" : "") + "1") : (n5.im += parseFloat((a3 % 2 ? "-" : "") + t4[l3 + 1]), l3++), o4 = a3 = 0) : ((o4 + a3 === 0 || isNaN(u3)) && r3(), t4[l3 + 1] === "i" || t4[l3 + 1] === "I" ? (n5.im += parseFloat((a3 % 2 ? "-" : "") + u3), l3++) : n5.re += parseFloat((a3 % 2 ? "-" : "") + u3), o4 = a3 = 0));
              }
              o4 + a3 > 0 && r3();
              break;
            case "number":
              n5.im = 0, n5.re = e5;
              break;
            default:
              r3();
          }
        return isNaN(n5.re) || isNaN(n5.im), n5;
      }(e4, i5);
      this.re = n4.re, this.im = n4.im;
    }
    s3.prototype = {re: 0, im: 0, sign: function() {
      var e4 = this.abs();
      return new s3(this.re / e4, this.im / e4);
    }, add: function(e4, i5) {
      var n4 = new s3(e4, i5);
      return this.isInfinite() && n4.isInfinite() ? s3.NAN : this.isInfinite() || n4.isInfinite() ? s3.INFINITY : new s3(this.re + n4.re, this.im + n4.im);
    }, sub: function(e4, i5) {
      var n4 = new s3(e4, i5);
      return this.isInfinite() && n4.isInfinite() ? s3.NAN : this.isInfinite() || n4.isInfinite() ? s3.INFINITY : new s3(this.re - n4.re, this.im - n4.im);
    }, mul: function(e4, i5) {
      var n4 = new s3(e4, i5);
      return this.isInfinite() && n4.isZero() || this.isZero() && n4.isInfinite() ? s3.NAN : this.isInfinite() || n4.isInfinite() ? s3.INFINITY : n4.im === 0 && this.im === 0 ? new s3(this.re * n4.re, 0) : new s3(this.re * n4.re - this.im * n4.im, this.re * n4.im + this.im * n4.re);
    }, div: function(e4, i5) {
      var n4 = new s3(e4, i5);
      if (this.isZero() && n4.isZero() || this.isInfinite() && n4.isInfinite())
        return s3.NAN;
      if (this.isInfinite() || n4.isZero())
        return s3.INFINITY;
      if (this.isZero() || n4.isInfinite())
        return s3.ZERO;
      e4 = this.re, i5 = this.im;
      var t4, r4, o4 = n4.re, a3 = n4.im;
      return a3 === 0 ? new s3(e4 / o4, i5 / o4) : Math.abs(o4) < Math.abs(a3) ? new s3((e4 * (r4 = o4 / a3) + i5) / (t4 = o4 * r4 + a3), (i5 * r4 - e4) / t4) : new s3((e4 + i5 * (r4 = a3 / o4)) / (t4 = a3 * r4 + o4), (i5 - e4 * r4) / t4);
    }, pow: function(e4, i5) {
      var n4 = new s3(e4, i5);
      if (e4 = this.re, i5 = this.im, n4.isZero())
        return s3.ONE;
      if (n4.im === 0) {
        if (i5 === 0 && e4 > 0)
          return new s3(Math.pow(e4, n4.re), 0);
        if (e4 === 0)
          switch ((n4.re % 4 + 4) % 4) {
            case 0:
              return new s3(Math.pow(i5, n4.re), 0);
            case 1:
              return new s3(0, Math.pow(i5, n4.re));
            case 2:
              return new s3(-Math.pow(i5, n4.re), 0);
            case 3:
              return new s3(0, -Math.pow(i5, n4.re));
          }
      }
      if (e4 === 0 && i5 === 0 && n4.re > 0 && n4.im >= 0)
        return s3.ZERO;
      var t4 = Math.atan2(i5, e4), r4 = o3(e4, i5);
      return e4 = Math.exp(n4.re * r4 - n4.im * t4), i5 = n4.im * r4 + n4.re * t4, new s3(e4 * Math.cos(i5), e4 * Math.sin(i5));
    }, sqrt: function() {
      var e4, i5, n4 = this.re, t4 = this.im, r4 = this.abs();
      if (n4 >= 0) {
        if (t4 === 0)
          return new s3(Math.sqrt(n4), 0);
        e4 = 0.5 * Math.sqrt(2 * (r4 + n4));
      } else
        e4 = Math.abs(t4) / Math.sqrt(2 * (r4 - n4));
      return i5 = n4 <= 0 ? 0.5 * Math.sqrt(2 * (r4 - n4)) : Math.abs(t4) / Math.sqrt(2 * (r4 + n4)), new s3(e4, t4 < 0 ? -i5 : i5);
    }, exp: function() {
      var e4 = Math.exp(this.re);
      return this.im, new s3(e4 * Math.cos(this.im), e4 * Math.sin(this.im));
    }, expm1: function() {
      var e4 = this.re, i5 = this.im;
      return new s3(Math.expm1(e4) * Math.cos(i5) + function(e5) {
        var i6 = Math.PI / 4;
        if (e5 < -i6 || e5 > i6)
          return Math.cos(e5) - 1;
        var n4 = e5 * e5;
        return n4 * (n4 * (1 / 24 + n4 * (-1 / 720 + n4 * (1 / 40320 + n4 * (-1 / 3628800 + n4 * (1 / 4790014600 + n4 * (-1 / 87178291200 + n4 * (1 / 20922789888e3))))))) - 0.5);
      }(i5), Math.exp(e4) * Math.sin(i5));
    }, log: function() {
      var e4 = this.re, i5 = this.im;
      return new s3(o3(e4, i5), Math.atan2(i5, e4));
    }, abs: function() {
      return e4 = this.re, i5 = this.im, n4 = Math.abs(e4), t4 = Math.abs(i5), n4 < 3e3 && t4 < 3e3 ? Math.sqrt(n4 * n4 + t4 * t4) : (n4 < t4 ? (n4 = t4, t4 = e4 / i5) : t4 = i5 / e4, n4 * Math.sqrt(1 + t4 * t4));
      var e4, i5, n4, t4;
    }, arg: function() {
      return Math.atan2(this.im, this.re);
    }, sin: function() {
      var e4 = this.re, i5 = this.im;
      return new s3(Math.sin(e4) * n3(i5), Math.cos(e4) * t3(i5));
    }, cos: function() {
      var e4 = this.re, i5 = this.im;
      return new s3(Math.cos(e4) * n3(i5), -Math.sin(e4) * t3(i5));
    }, tan: function() {
      var e4 = 2 * this.re, i5 = 2 * this.im, r4 = Math.cos(e4) + n3(i5);
      return new s3(Math.sin(e4) / r4, t3(i5) / r4);
    }, cot: function() {
      var e4 = 2 * this.re, i5 = 2 * this.im, r4 = Math.cos(e4) - n3(i5);
      return new s3(-Math.sin(e4) / r4, t3(i5) / r4);
    }, sec: function() {
      var e4 = this.re, i5 = this.im, r4 = 0.5 * n3(2 * i5) + 0.5 * Math.cos(2 * e4);
      return new s3(Math.cos(e4) * n3(i5) / r4, Math.sin(e4) * t3(i5) / r4);
    }, csc: function() {
      var e4 = this.re, i5 = this.im, r4 = 0.5 * n3(2 * i5) - 0.5 * Math.cos(2 * e4);
      return new s3(Math.sin(e4) * n3(i5) / r4, -Math.cos(e4) * t3(i5) / r4);
    }, asin: function() {
      var e4 = this.re, i5 = this.im, n4 = new s3(i5 * i5 - e4 * e4 + 1, -2 * e4 * i5).sqrt(), t4 = new s3(n4.re - i5, n4.im + e4).log();
      return new s3(t4.im, -t4.re);
    }, acos: function() {
      var e4 = this.re, i5 = this.im, n4 = new s3(i5 * i5 - e4 * e4 + 1, -2 * e4 * i5).sqrt(), t4 = new s3(n4.re - i5, n4.im + e4).log();
      return new s3(Math.PI / 2 - t4.im, t4.re);
    }, atan: function() {
      var e4 = this.re, i5 = this.im;
      if (e4 === 0) {
        if (i5 === 1)
          return new s3(0, 1 / 0);
        if (i5 === -1)
          return new s3(0, -1 / 0);
      }
      var n4 = e4 * e4 + (1 - i5) * (1 - i5), t4 = new s3((1 - i5 * i5 - e4 * e4) / n4, -2 * e4 / n4).log();
      return new s3(-0.5 * t4.im, 0.5 * t4.re);
    }, acot: function() {
      var e4 = this.re, i5 = this.im;
      if (i5 === 0)
        return new s3(Math.atan2(1, e4), 0);
      var n4 = e4 * e4 + i5 * i5;
      return n4 !== 0 ? new s3(e4 / n4, -i5 / n4).atan() : new s3(e4 !== 0 ? e4 / 0 : 0, i5 !== 0 ? -i5 / 0 : 0).atan();
    }, asec: function() {
      var e4 = this.re, i5 = this.im;
      if (e4 === 0 && i5 === 0)
        return new s3(0, 1 / 0);
      var n4 = e4 * e4 + i5 * i5;
      return n4 !== 0 ? new s3(e4 / n4, -i5 / n4).acos() : new s3(e4 !== 0 ? e4 / 0 : 0, i5 !== 0 ? -i5 / 0 : 0).acos();
    }, acsc: function() {
      var e4 = this.re, i5 = this.im;
      if (e4 === 0 && i5 === 0)
        return new s3(Math.PI / 2, 1 / 0);
      var n4 = e4 * e4 + i5 * i5;
      return n4 !== 0 ? new s3(e4 / n4, -i5 / n4).asin() : new s3(e4 !== 0 ? e4 / 0 : 0, i5 !== 0 ? -i5 / 0 : 0).asin();
    }, sinh: function() {
      var e4 = this.re, i5 = this.im;
      return new s3(t3(e4) * Math.cos(i5), n3(e4) * Math.sin(i5));
    }, cosh: function() {
      var e4 = this.re, i5 = this.im;
      return new s3(n3(e4) * Math.cos(i5), t3(e4) * Math.sin(i5));
    }, tanh: function() {
      var e4 = 2 * this.re, i5 = 2 * this.im, r4 = n3(e4) + Math.cos(i5);
      return new s3(t3(e4) / r4, Math.sin(i5) / r4);
    }, coth: function() {
      var e4 = 2 * this.re, i5 = 2 * this.im, r4 = n3(e4) - Math.cos(i5);
      return new s3(t3(e4) / r4, -Math.sin(i5) / r4);
    }, csch: function() {
      var e4 = this.re, i5 = this.im, r4 = Math.cos(2 * i5) - n3(2 * e4);
      return new s3(-2 * t3(e4) * Math.cos(i5) / r4, 2 * n3(e4) * Math.sin(i5) / r4);
    }, sech: function() {
      var e4 = this.re, i5 = this.im, r4 = Math.cos(2 * i5) + n3(2 * e4);
      return new s3(2 * n3(e4) * Math.cos(i5) / r4, -2 * t3(e4) * Math.sin(i5) / r4);
    }, asinh: function() {
      var e4 = this.im;
      this.im = -this.re, this.re = e4;
      var i5 = this.asin();
      return this.re = -this.im, this.im = e4, e4 = i5.re, i5.re = -i5.im, i5.im = e4, i5;
    }, acosh: function() {
      var e4 = this.acos();
      if (e4.im <= 0) {
        var i5 = e4.re;
        e4.re = -e4.im, e4.im = i5;
      } else
        i5 = e4.im, e4.im = -e4.re, e4.re = i5;
      return e4;
    }, atanh: function() {
      var e4 = this.re, i5 = this.im, n4 = e4 > 1 && i5 === 0, t4 = 1 - e4, r4 = 1 + e4, a3 = t4 * t4 + i5 * i5, l3 = a3 !== 0 ? new s3((r4 * t4 - i5 * i5) / a3, (i5 * t4 + r4 * i5) / a3) : new s3(e4 !== -1 ? e4 / 0 : 0, i5 !== 0 ? i5 / 0 : 0), u3 = l3.re;
      return l3.re = o3(l3.re, l3.im) / 2, l3.im = Math.atan2(l3.im, u3) / 2, n4 && (l3.im = -l3.im), l3;
    }, acoth: function() {
      var e4 = this.re, i5 = this.im;
      if (e4 === 0 && i5 === 0)
        return new s3(0, Math.PI / 2);
      var n4 = e4 * e4 + i5 * i5;
      return n4 !== 0 ? new s3(e4 / n4, -i5 / n4).atanh() : new s3(e4 !== 0 ? e4 / 0 : 0, i5 !== 0 ? -i5 / 0 : 0).atanh();
    }, acsch: function() {
      var e4 = this.re, i5 = this.im;
      if (i5 === 0)
        return new s3(e4 !== 0 ? Math.log(e4 + Math.sqrt(e4 * e4 + 1)) : 1 / 0, 0);
      var n4 = e4 * e4 + i5 * i5;
      return n4 !== 0 ? new s3(e4 / n4, -i5 / n4).asinh() : new s3(e4 !== 0 ? e4 / 0 : 0, i5 !== 0 ? -i5 / 0 : 0).asinh();
    }, asech: function() {
      var e4 = this.re, i5 = this.im;
      if (this.isZero())
        return s3.INFINITY;
      var n4 = e4 * e4 + i5 * i5;
      return n4 !== 0 ? new s3(e4 / n4, -i5 / n4).acosh() : new s3(e4 !== 0 ? e4 / 0 : 0, i5 !== 0 ? -i5 / 0 : 0).acosh();
    }, inverse: function() {
      if (this.isZero())
        return s3.INFINITY;
      if (this.isInfinite())
        return s3.ZERO;
      var e4 = this.re, i5 = this.im, n4 = e4 * e4 + i5 * i5;
      return new s3(e4 / n4, -i5 / n4);
    }, conjugate: function() {
      return new s3(this.re, -this.im);
    }, neg: function() {
      return new s3(-this.re, -this.im);
    }, ceil: function(e4) {
      return e4 = Math.pow(10, e4 || 0), new s3(Math.ceil(this.re * e4) / e4, Math.ceil(this.im * e4) / e4);
    }, floor: function(e4) {
      return e4 = Math.pow(10, e4 || 0), new s3(Math.floor(this.re * e4) / e4, Math.floor(this.im * e4) / e4);
    }, round: function(e4) {
      return e4 = Math.pow(10, e4 || 0), new s3(Math.round(this.re * e4) / e4, Math.round(this.im * e4) / e4);
    }, equals: function(e4, i5) {
      var n4 = new s3(e4, i5);
      return Math.abs(n4.re - this.re) <= s3.EPSILON && Math.abs(n4.im - this.im) <= s3.EPSILON;
    }, clone: function() {
      return new s3(this.re, this.im);
    }, toString: function() {
      var e4 = this.re, i5 = this.im, n4 = "";
      return this.isNaN() ? "NaN" : this.isInfinite() ? "Infinity" : (Math.abs(e4) < s3.EPSILON && (e4 = 0), Math.abs(i5) < s3.EPSILON && (i5 = 0), i5 === 0 ? n4 + e4 : (e4 !== 0 ? (n4 += e4, n4 += " ", i5 < 0 ? (i5 = -i5, n4 += "-") : n4 += "+", n4 += " ") : i5 < 0 && (i5 = -i5, n4 += "-"), i5 !== 1 && (n4 += i5), n4 + "i"));
    }, toVector: function() {
      return [this.re, this.im];
    }, valueOf: function() {
      return this.im === 0 ? this.re : null;
    }, isNaN: function() {
      return isNaN(this.re) || isNaN(this.im);
    }, isZero: function() {
      return this.im === 0 && this.re === 0;
    }, isFinite: function() {
      return isFinite(this.re) && isFinite(this.im);
    }, isInfinite: function() {
      return !(this.isNaN() || this.isFinite());
    }}, s3.ZERO = new s3(0, 0), s3.ONE = new s3(1, 0), s3.I = new s3(0, 1), s3.PI = new s3(Math.PI, 0), s3.E = new s3(Math.E, 0), s3.INFINITY = new s3(1 / 0, 1 / 0), s3.NAN = new s3(NaN, NaN), s3.EPSILON = 1e-15, Object.defineProperty(s3, "__esModule", {value: true}), s3.default = s3, s3.Complex = s3, e3.exports = s3;
  }();
}(m2);
var f2 = new c2.exports.Decimal(0);
var h2 = new c2.exports.Decimal(1);
var p2 = new c2.exports.Decimal(-1);
var g2 = new c2.exports.Decimal(NaN);
var d2 = new c2.exports.Decimal(1 / 0);
var v2 = new c2.exports.Decimal(-1 / 0);
function x2(e3) {
  if (typeof e3 == "number" && (e3 = new c2.exports.Decimal(e3)), !e3.isInteger() || e3.isNegative())
    return g2;
  if (e3.lessThan(10))
    return new c2.exports.Decimal([1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800][e3.toNumber()]);
  if (e3.gt(Number.MAX_SAFE_INTEGER)) {
    let i4 = h2, n4 = new c2.exports.Decimal(2);
    for (; n4.lessThan(e3); )
      i4 = i4.mul(n4), n4 = n4.add(1);
    return i4;
  }
  if (e3.modulo(2).eq(1))
    return e3.times(x2(e3.minus(1)));
  let i3 = e3.toNumber(), n3 = e3.toNumber(), t3 = e3;
  for (; i3 > 2; )
    i3 -= 2, n3 += i3, t3 = t3.mul(n3);
  return t3;
}
var y2 = [0.9999999999998099, 676.5203681218851, -1259.1392167224028, 771.3234287776531, -176.6150291621406, 12.507343278686905, -0.13857109526572012, 9984369578019572e-21, 15056327351493116e-23].map((e3) => new c2.exports.Decimal(e3));
var b2 = new c2.exports.Decimal(607).div(128);
var N2 = [0.9999999999999971, 57.15623566586292, -59.59796035547549, 14.136097974741746, -0.4919138160976202, 3399464998481189e-20, 4652362892704858e-20, -9837447530487956e-20, 1580887032249125e-19, -21026444172410488e-20, 21743961811521265e-20, -1643181065367639e-19, 8441822398385275e-20, -26190838401581408e-21, 36899182659531625e-22].map((e3) => new c2.exports.Decimal(e3));
function w2(e3) {
  if (typeof e3 == "number" && (e3 = new c2.exports.Decimal(e3)), e3.isNegative())
    return g2;
  let i3 = N2[0];
  for (let n4 = N2.length - 1; n4 > 0; --n4)
    i3 = i3.add(N2[n4].div(e3.add(n4)));
  const n3 = e3.add(b2).add(0.5);
  return c2.exports.Decimal.acos(-1).mul(2).log().mul(0.5).add(n3.log().mul(e3.add(0.5)).minus(n3).add(i3.log()).minus(e3.log()));
}
function S3(e3) {
  if (typeof e3 == "number" && (e3 = new c2.exports.Decimal(e3)), e3.lessThan(0.5)) {
    const i3 = c2.exports.Decimal.acos(-1);
    return i3.div(i3.mul(e3).sin().mul(S3(c2.exports.Decimal.sub(1, e3))));
  }
  if (e3.greaterThan(100))
    return w2(e3).exp();
  {
    e3 = e3.sub(1);
    let i3 = y2[0];
    for (let n4 = 1; n4 < 9; n4++)
      i3 = i3.add(y2[n4].div(e3.add(n4)));
    const n3 = e3.add(7).add(0.5);
    return c2.exports.Decimal.acos(-1).times(2).sqrt().mul(i3.mul(n3.neg().exp()).mul(c2.exports.Decimal.pow(n3, e3.add(0.5))));
  }
}
var M24 = Math.log10(Math.pow(2, 53));
var E2 = Math.pow(10, -10);
var D3 = new Set([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919]);
function A2(e3, i3) {
  if (!Number.isInteger(e3) || !Number.isInteger(i3))
    return NaN;
  for (; i3 !== 0; )
    [e3, i3] = [i3, e3 % i3];
  return e3 < 0 ? -e3 : e3;
}
var C2 = [0.9999999999998099, 676.5203681218851, -1259.1392167224028, 771.3234287776531, -176.6150291621406, 12.507343278686905, -0.13857109526572012, 9984369578019572e-21, 15056327351493116e-23];
var q2 = [0.9999999999999971, 57.15623566586292, -59.59796035547549, 14.136097974741746, -0.4919138160976202, 3399464998481189e-20, 4652362892704858e-20, -9837447530487956e-20, 1580887032249125e-19, -21026444172410488e-20, 21743961811521265e-20, -1643181065367639e-19, 8441822398385275e-20, -26190838401581408e-21, 36899182659531625e-22];
function F2(e3) {
  if (e3 < 0)
    return NaN;
  let i3 = q2[0];
  for (let n4 = q2.length - 1; n4 > 0; --n4)
    i3 += q2[n4] / (e3 + n4);
  const n3 = e3 + 4.7421875 + 0.5;
  return 0.5 * Math.log(2 * Math.PI) + (e3 + 0.5) * Math.log(n3) - n3 + Math.log(i3) - Math.log(e3);
}
function I2(e3) {
  if (e3 < 0.5)
    return Math.PI / (Math.sin(Math.PI * e3) * I2(1 - e3));
  if (e3 > 100)
    return Math.exp(F2(e3));
  {
    e3 -= 1;
    let i3 = C2[0];
    for (let n4 = 1; n4 < 9; n4++)
      i3 += C2[n4] / (e3 + n4);
    const n3 = e3 + 7 + 0.5;
    return Math.sqrt(2 * Math.PI) * Math.pow(n3, e3 + 0.5) * Math.exp(-n3) * i3;
  }
}
var k2 = "List";
var P2 = "Missing";
var T3 = "Nothing";
var O2 = "Add";
var z2 = "Divide";
var L2 = "Multiply";
var _2 = "Negate";
var R2 = "Power";
var Z2 = "Root";
var Q2 = "Sqrt";
function H2(e3) {
  return e3 !== null && typeof e3 == "object" && "num" in e3;
}
function $2(e3) {
  return e3 !== null && typeof e3 == "object" && "sym" in e3;
}
function B2(e3) {
  return e3 !== null && typeof e3 == "object" && "fn" in e3;
}
function G2(e3) {
  if (typeof e3 == "number")
    return e3;
  if (e3 === null)
    return null;
  if (H2(e3))
    return e3.num.endsWith("d") || e3.num.endsWith("n") ? null : parseFloat(e3.num);
  const i3 = re2(e3);
  return i3 === null ? null : i3 === "NaN" ? NaN : i3 === "+Infinity" ? 1 / 0 : i3 === "-Infinity" ? -1 / 0 : te2(e3) === "Complex" && G2(le(e3, 2)) === 0 ? G2(le(e3, 1)) : null;
}
function W2(e3) {
  if (e3 === null)
    return null;
  if (e3 instanceof m2.exports.Complex)
    return e3;
  const i3 = re2(e3);
  if (i3 !== null) {
    if (i3 === "ComplexInfinity")
      return m2.exports.Complex.INFINITY;
    if (i3 === "ImaginaryUnit")
      return m2.exports.Complex.I;
  }
  const n3 = te2(e3);
  if (n3 === "Complex") {
    const i4 = G2(le(e3, 1)), n4 = G2(le(e3, 2));
    return i4 === null || n4 === null ? null : new m2.exports.Complex(i4, n4);
  }
  let t3 = V2(e3);
  if (t3 !== null)
    return new m2.exports.Complex(0, t3);
  if (n3 === "Add" && ue(e3) === 2) {
    let i4 = G2(le(e3, 1));
    if (i4 !== null ? t3 = V2(le(e3, 2)) : (t3 = V2(le(e3, 1)), t3 !== null && (i4 = G2(le(e3, 2)))), i4 !== null && t3 !== null)
      return new m2.exports.Complex(i4, t3);
  }
  if (n3 === "Subtract") {
    const i4 = G2(le(e3, 1)), n4 = le(e3, 2);
    if (i4 !== null) {
      if (re2(n4) === "ImaginaryUnit")
        return new m2.exports.Complex(i4, -1);
      if (te2(n4) === "Multiply" && le(n4, 2) === "ImaginaryUnit") {
        const e4 = G2(le(n4, 1));
        if (e4 !== null)
          return new m2.exports.Complex(i4, -e4);
      }
    }
  }
  if (n3 === "Multiply" && ue(e3) === 2) {
    let i4 = null;
    if (re2(le(e3, 2)) === "ImaginaryUnit" ? i4 = G2(le(e3, 2)) : re2(le(e3, 1)) === "ImaginaryUnit" && (i4 = G2(le(e3, 1))), i4 !== null && Number.isInteger(i4))
      return i4 === 0 ? m2.exports.Complex.ZERO : i4 === 1 ? m2.exports.Complex.ONE : i4 === -1 ? m2.exports.Complex.ONE.neg() : new m2.exports.Complex(0, i4);
  }
  if (n3 === "Negate") {
    const i4 = W2(le(e3, 1));
    if (i4 !== null)
      return i4.neg();
  }
  return null;
}
function V2(e3) {
  if (re2(e3) === "ImaginaryUnit")
    return 1;
  let i3 = null;
  const n3 = te2(e3);
  return n3 === "Multiply" && ue(e3) === 2 ? re2(le(e3, 1)) === "ImaginaryUnit" ? i3 = G2(le(e3, 2)) : re2(le(e3, 2)) === "ImaginaryUnit" && (i3 = G2(le(e3, 1))) : n3 === "Negate" && ue(e3) === 1 && re2(le(e3, 1)) === "ImaginaryUnit" && (i3 = -1), i3 === 0 ? null : i3;
}
function Y2(e3) {
  var i3, n3;
  if (e3 instanceof c2.exports.Decimal)
    return e3;
  const t3 = re2(e3);
  if (t3 !== null) {
    if (t3 === "NaN")
      return g2;
    if (t3 === "+Infinity")
      return d2;
    if (t3 === "-Infinity")
      return v2;
  }
  if (H2(e3))
    return e3.num.endsWith("d") || e3.num.endsWith("n") ? new c2.exports.Decimal(e3.num.slice(0, -1)) : new c2.exports.Decimal((i3 = G2(e3)) !== null && i3 !== void 0 ? i3 : NaN);
  if (e3 !== null && e3 instanceof m2.exports.Complex) {
    const i4 = e3;
    return i4.im === 0 ? new c2.exports.Decimal(i4.re) : null;
  }
  return te2(e3) === "Complex" && G2(le(e3, 2)) === 0 ? new c2.exports.Decimal((n3 = G2(le(e3, 1))) !== null && n3 !== void 0 ? n3 : NaN) : null;
}
function J2(e3) {
  return e3 === null ? null : typeof e3 == "object" && "str" in e3 ? e3.str : typeof e3 != "string" || e3.length < 2 || e3[0] !== "'" || e3[e3.length - 1] !== "'" ? null : e3.substring(1, e3.length - 1);
}
function X2(e3) {
  var i3, n3, t3, r3, o3, s3;
  const a3 = re2(e3);
  if (a3 === "ThreeQuarter")
    return [3, 4];
  if (a3 === "TwoThird")
    return [2, 3];
  if (a3 === "Half")
    return [1, 2];
  if (a3 === "Third")
    return [1, 3];
  if (a3 === "Quarter")
    return [1, 4];
  if (ne2(e3))
    return [null, null];
  const l3 = te2(e3);
  if (!l3)
    return [null, null];
  let u3 = null, c3 = null;
  if (l3 === R2) {
    const t4 = G2(le(e3, 2));
    t4 === 1 ? (u3 = (i3 = G2(le(e3, 1))) !== null && i3 !== void 0 ? i3 : null, c3 = 1) : t4 === -1 && (u3 = 1, c3 = (n3 = G2(le(e3, 1))) !== null && n3 !== void 0 ? n3 : null);
  }
  return l3 === z2 && (u3 = (t3 = G2(le(e3, 1))) !== null && t3 !== void 0 ? t3 : null, c3 = (r3 = G2(le(e3, 2))) !== null && r3 !== void 0 ? r3 : null), l3 === L2 && te2(le(e3, 2)) === R2 && G2(le(le(e3, 2), 2)) === -1 && (u3 = (o3 = G2(le(e3, 1))) !== null && o3 !== void 0 ? o3 : null, c3 = (s3 = G2(le(le(e3, 2), 1))) !== null && s3 !== void 0 ? s3 : null), u3 === null || c3 === null ? [null, null] : Number.isInteger(u3) && Number.isInteger(c3) ? [u3, c3] : [null, null];
}
function ie2(e3) {
  return e3 === null ? null : Array.isArray(e3) ? e3[0] : B2(e3) ? e3.fn[0] : null;
}
function ne2(e3) {
  return e3 === null || !Array.isArray(e3) && (typeof e3 != "object" || !("fn" in e3 || "dic" in e3));
}
function te2(e3) {
  if (e3 === null)
    return "";
  const i3 = ie2(e3);
  return typeof i3 == "string" ? i3 : "";
}
function re2(e3) {
  return e3 === null ? null : typeof e3 == "string" ? e3.length >= 2 && e3[0] === "'" && e3[e3.length - 1] === "'" ? null : e3 : $2(e3) ? e3.sym : null;
}
function oe2(e3) {
  return Array.isArray(e3) ? e3.slice(1) : B2(e3) ? e3.fn.slice(1) : [];
}
function se2(e3, i3) {
  const n3 = ie2(e3);
  if (n3 !== null)
    return [i3(n3), ...oe2(e3).map(i3)];
  const t3 = ce(e3);
  if (t3 !== null) {
    const e4 = Object.keys(t3), n4 = {};
    for (const r3 of e4)
      n4[r3] = i3(t3[r3]);
    return {dict: n4};
  }
  return i3(e3);
}
function ae2(e3, i3) {
  let n3 = null;
  if (Array.isArray(e3) && (n3 = e3), B2(e3) && (n3 = e3.fn), n3 === null)
    return [];
  let t3 = 1;
  const r3 = [];
  for (; t3 < n3.length; )
    r3.push(i3(n3[t3])), t3 += 1;
  return r3;
}
function le(e3, i3) {
  var n3, t3;
  return e3 === null ? null : Array.isArray(e3) ? (n3 = e3[i3]) !== null && n3 !== void 0 ? n3 : null : B2(e3) && (t3 = e3.fn[i3]) !== null && t3 !== void 0 ? t3 : null;
}
function ue(e3) {
  return Array.isArray(e3) ? Math.max(0, e3.length - 1) : B2(e3) ? Math.max(0, e3.fn.length - 1) : 0;
}
function ce(e3) {
  return typeof e3 == "object" && "dict" in e3 ? e3.dict : null;
}
var fe = [{name: "Overscript", trigger: {infix: "\\overset"}, precedence: 700}, {name: "Underscript", trigger: {infix: "\\underset"}, precedence: 700}, {name: "Increment", trigger: {postfix: ["+", "+"]}, precedence: 880}, {name: "Decrement", trigger: {postfix: ["-", "-"]}, precedence: 880}, {name: "PreIncrement", trigger: {prefix: ["+", "+"]}, precedence: 880}, {name: "PreDecrement", trigger: {prefix: ["-", "-"]}, precedence: 880}, {name: "Ring", trigger: {infix: "\\circ"}, precedence: 265}, {name: "Transpose", trigger: {superfix: "T"}}, {name: "ConjugateTranspose", trigger: {superfix: "H"}}, {name: "StringJoin", trigger: {infix: ["\\lt", "\\gt"]}, precedence: 780}, {name: "Starstar", trigger: {infix: ["\\star", "\\star"]}, precedence: 780}, {name: "PartialDerivative", trigger: {prefix: "\\partial"}, parse: (e3, i3, n3) => {
  var t3, r3;
  let o3 = false, s3 = T3, a3 = T3;
  for (; !o3; )
    i3.skipSpace(), i3.match("_") ? a3 = i3.matchRequiredLatexArgument() : i3.match("^") ? s3 = i3.matchRequiredLatexArgument() : o3 = true;
  if (te2(a3) === "Sequence" && (a3 = [k2, ...oe2(a3)]), !a3 || !s3)
    return [e3, null];
  let l3 = (t3 = i3.matchRequiredLatexArgument()) !== null && t3 !== void 0 ? t3 : T3;
  return l3 !== T3 && (l3 = [l3, ...(r3 = i3.matchArguments("group")) !== null && r3 !== void 0 ? r3 : T3]), [null, ["PartialDerivative", l3, a3, s3]];
}, serialize: (e3, i3) => {
  let n3 = "\\partial";
  const t3 = le(i3, 1), r3 = le(i3, 2), o3 = le(i3, 3);
  return r3 !== null && r3 !== T3 && (ie2(r3) === k2 ? n3 += "_{" + e3.serialize(["Sequence", ...oe2(r3)]) + "}" : n3 += "_{" + e3.serialize(r3) + "}"), o3 !== null && o3 !== T3 && (n3 += "^{" + e3.serialize(o3) + "}"), t3 !== null && t3 !== T3 && (n3 += e3.serialize(t3)), n3;
}, precedence: 740}, {name: "OverBar", trigger: {symbol: "\\overline"}, requiredLatexArg: 1}, {name: "UnderBar", trigger: {symbol: "\\underline"}, requiredLatexArg: 1}, {name: "OverVector", trigger: {symbol: "\\vec"}, requiredLatexArg: 1}, {name: "OverTile", trigger: {symbol: "\\tilde"}, requiredLatexArg: 1}, {name: "OverHat", trigger: {symbol: "\\hat"}, requiredLatexArg: 1}, {name: "OverHat", trigger: {symbol: "\\hat"}, requiredLatexArg: 1}, {name: "OverRightArrow", trigger: {symbol: "\\overrightarrow"}, requiredLatexArg: 1}, {name: "OverLeftArrow", trigger: {symbol: "\\overleftarrow"}, requiredLatexArg: 1}, {name: "OverRightDoubleArrow", trigger: {symbol: "\\Overrightarrow"}, requiredLatexArg: 1}, {name: "OverLeftHarpoon", trigger: {symbol: "\\overleftharpoon"}, requiredLatexArg: 1}, {name: "OverRightHarpoon", trigger: {symbol: "\\overrightharpoon"}, requiredLatexArg: 1}, {name: "OverLeftRightArrow", trigger: {symbol: "\\overleftrightarrow"}, requiredLatexArg: 1}, {name: "OverBrace", trigger: {symbol: "\\overbrace"}, requiredLatexArg: 1}, {name: "OverLineSegment", trigger: {symbol: "\\overlinesegment"}, requiredLatexArg: 1}, {name: "OverGroup", trigger: {symbol: "\\overgroup"}, requiredLatexArg: 1}];
function he(e3, i3) {
  return i3 > 2 ? "solidus" : "radical";
}
function pe(e3) {
  return e3 === "<space>" || e3 === "\\qquad" || e3 === "\\quad" || e3 === "\\enskip" || e3 === "\\;" || e3 === "\\," || e3 === "\\ " || e3 === "~";
}
function ge(e3, i3, n3) {
  return (t3, r3, o3) => {
    if (o3 >= i3)
      return [t3, null];
    r3.skipSpace(), r3.match(n3), t3 === "Missing" && (t3 = T3);
    const s3 = [e3, t3 != null ? t3 : T3];
    let a3 = false;
    for (; !a3; ) {
      for (a3 = true, r3.skipSpace(); r3.match(n3); )
        s3.push(T3), r3.skipSpace();
      if (r3.atEnd)
        s3.push(T3);
      else {
        const e4 = r3.matchExpression(i3);
        s3.push(e4 != null ? e4 : T3), a3 = e4 === null;
      }
      a3 || (r3.skipSpace(), a3 = !r3.match(n3));
    }
    return [null, s3];
  };
}
function de(e3) {
  return (i3, n3) => oe2(n3).map((e4) => i3.serialize(e4)).join(e3);
}
var ve = [{name: "LatexTokens", serialize: function(e3, i3) {
  return oe2(i3).map((i4) => {
    const n3 = J2(i4);
    return n3 === null ? e3.serialize(i4) : n3 === "<{>" ? "{" : n3 === "<}>" ? "}" : n3 === "<$>" ? "$" : n3 === "<$$>" ? "$$" : n3 === "<space>'" ? " " : n3;
  }).join("");
}}, {name: "Parentheses", trigger: {matchfix: "("}, parse: (e3, i3, n3) => {
  var t3;
  const r3 = i3.index;
  if (!i3.match("("))
    return [e3, null];
  let o3 = false, s3 = true, a3 = false, l3 = 0, u3 = "";
  for (; !o3 && s3; ) {
    const e4 = i3.next();
    i3.atEnd || e4 === ")" ? o3 = true : e4 === "\\mathtt" ? (i3.match("<{>"), a3 = true) : pe(e4) || (/^[0-9a-zA-Z]$/.test(e4) ? (l3 = Math.max(l3, parseInt(e4, 36)), u3 += e4) : s3 = false), a3 && i3.match("<}>");
  }
  if (i3.skipSpace(), s3 && i3.match("_")) {
    const n4 = (t3 = G2(i3.matchRequiredLatexArgument())) !== null && t3 !== void 0 ? t3 : NaN;
    return !isFinite(n4) || n4 < 2 || n4 > 36 || l3 >= n4 ? (i3.onError({code: "base-out-of-range"}), [e3, T3]) : [e3, ["BaseForm", parseInt(u3, n4), n4]];
  }
  i3.index = r3;
  const c3 = i3.matchBalancedExpression("(", ")", i3.onError);
  return c3 ? te2(c3) === "Sequence" ? [e3, ["Parentheses", ...oe2(c3)]] : [e3, ["Parentheses", c3]] : [e3, ["Parentheses"]];
}, serialize: (e3, i3) => e3.wrapString(de(",")(e3, i3), (e3.level, "paren")), separator: ",", closeFence: ")", precedence: 20}, {name: k2, trigger: {matchfix: "\\lbrack"}, separator: ",", closeFence: "\\rbrack", precedence: 20, parse: (e3, i3, n3) => {
  if (e3 === null) {
    const n4 = i3.matchBalancedExpression("\\lbrack", "\\rbrack", i3.onError);
    return n4 ? te2(n4) === "Sequence" ? [e3, [k2, ...oe2(n4)]] : [e3, [k2, n4]] : [null, [k2]];
  }
  return [e3, null];
}}, {name: "BaseForm", serialize: (e3, i3) => {
  var n3, t3;
  const r3 = (n3 = G2(le(i3, 2))) !== null && n3 !== void 0 ? n3 : NaN;
  if (isFinite(r3) && r3 >= 2 && r3 <= 36) {
    const e4 = (t3 = G2(le(i3, 1))) !== null && t3 !== void 0 ? t3 : NaN;
    if (isFinite(e4)) {
      let i4 = Number(e4).toString(r3), n4 = 0;
      if (r3 === 2 || r3 === 10 ? n4 = 4 : r3 === 16 ? n4 = 2 : r3 > 16 && (n4 = 4), n4 > 0) {
        const e5 = i4;
        i4 = "";
        for (let t4 = 0; t4 < e5.length; t4++)
          t4 > 0 && t4 % n4 == 0 && (i4 = "\\, " + i4), i4 = e5[e5.length - t4 - 1] + i4;
      }
      return `(\\mathtt{${i4}})_{${r3}}`;
    }
  }
  return "\\operatorname{BaseForm}(" + e3.serialize(le(i3, 1)) + ", " + e3.serialize(le(i3, 2)) + ")";
}}, {name: "Set", trigger: {matchfix: "\\lbrace"}, separator: ",", closeFence: "\\rbrace", precedence: 20}, {name: "Sequence", trigger: {infix: ","}, parse: ge("Sequence", 20, ","), serialize: de(", "), precedence: 20}, {name: "Sequence2", trigger: {infix: ";"}, parse: ge("Sequence2", 19, ";"), serialize: de("; "), precedence: 19}, {name: P2, trigger: "\\placeholder", serialize: "\\placeholder", requiredLatexArg: 1}, {name: "Subscript", trigger: {infix: "_"}, precedence: 720, serialize: (e3, i3) => ue(i3) === 2 ? e3.serialize(le(i3, 1)) + "_{" + e3.serialize(le(i3, 2)) + "}" : "_{" + e3.serialize(le(i3, 1)) + "}", parse: (e3, i3, n3) => {
  var t3;
  if (!i3.match("_"))
    return [e3, null];
  const r3 = (t3 = i3.matchRequiredLatexArgument()) !== null && t3 !== void 0 ? t3 : P2;
  return e3 ? [null, ["Subscript", e3, r3]] : [null, ["Subscript", r3]];
}}, {name: "Superplus", trigger: {superfix: "+"}}, {name: "Subplus", trigger: {subfix: "+"}}, {name: "Superminus", trigger: {superfix: "-"}}, {name: "Subminus", trigger: {subfix: "-"}}, {name: "Superstar", trigger: {superfix: "*"}}, {name: "Superstar", trigger: {superfix: "\\star"}}, {name: "Substar", trigger: {subfix: "*"}}, {name: "Substar", trigger: {subfix: "\\star"}}, {name: "Superdagger", trigger: {superfix: "\\dagger"}}, {name: "Superdagger", trigger: {superfix: "\\dag"}}, {name: "Prime", trigger: {superfix: "\\prime"}, arguments: "group"}, {trigger: {superfix: "\\doubleprime"}, parse: (e3, i3) => [null, ["Prime", e3 != null ? e3 : T3, 2]], arguments: "group"}, {name: "InverseFunction", serialize: (e3, i3) => e3.serialize(le(i3, 1)) + "^{-1}"}, {name: "Derivative", trigger: "D", parse: (e3, i3) => [e3, ["Derivative", 1]], serialize: (e3, i3) => {
  var n3;
  const t3 = (n3 = G2(le(i3, 1))) !== null && n3 !== void 0 ? n3 : NaN;
  if (!isFinite(t3))
    return "";
  const r3 = e3.serialize(le(i3, 2));
  return t3 === 1 ? r3 + "^{\\prime}" : t3 === 2 ? r3 + "^{\\doubleprime}" : r3 + "^{(" + Number(t3).toString() + ")}";
}}, {name: "Piecewise", trigger: {environment: "cases"}, parse: (e3, i3) => {
  var n3;
  return [e3, ["Piecewise", (n3 = i3.matchTabular()) !== null && n3 !== void 0 ? n3 : T3]];
}, serialize: (e3, i3) => {
  if (te2(le(i3, 1)) !== k2)
    return "";
  const n3 = oe2(le(i3, 1));
  let t3 = "", r3 = "";
  for (const i4 of n3) {
    t3 += r3;
    const n4 = le(i4, 1);
    if (n4 !== null) {
      t3 += e3.serialize(n4);
      const r4 = le(i4, 2);
      r4 !== null && (t3 += "&" + e3.serialize(r4));
    }
    r3 = "\\\\";
  }
  return "\\begin{cases}" + t3 + "\\end{cases}";
}}];
function xe(e3, i3) {
  const n3 = G2(i3);
  return n3 !== null ? n3 === 0 : !!e3.is(["Equal", i3, 0]) || e3.is(["NotEqual", i3, 0]) !== true && e3.is(["Greater", i3, 0]) !== true && e3.is(["Less", i3, 0]) !== true && n3 === null && void 0;
}
function ye(e3, i3) {
  const n3 = xe(e3, i3);
  return n3 === void 0 ? void 0 : !n3;
}
function be(e3, i3) {
  if (i3 === null)
    return;
  const n3 = G2(i3);
  if (n3 !== null && !Number.isFinite(n3))
    return true;
  if (n3 !== null && isNaN(n3))
    return;
  const t3 = re2(i3);
  if (t3 === "ComplexInfinity")
    return true;
  if (t3 === P2 || t3 === T3)
    return false;
  if (e3.is(i3, "ComplexNumber"))
    return false;
  const r3 = te2(i3);
  if (r3 === "Negate") {
    if (be(e3, le(i3, 1)))
      return true;
  } else if (r3 === "Multiply") {
    const n4 = oe2(i3);
    if (n4.some((i4) => be(e3, i4) === true) && n4.every((i4) => ye(e3, i4) === true))
      return true;
  }
  return n3 === null && void 0;
}
function Ne(e3, i3) {
  if (i3 === null)
    return;
  const n3 = G2(i3);
  if (n3 !== null)
    return n3 > 0;
  const t3 = re2(i3);
  if (t3 && ["Quarter", "Third", "Half", "TwoThird", "ThreeQuarter", "MinusDoublePi", "MinusPi", "QuarterPi", "ThirdPi", "HalfPi", "TwoThirdPi", "ThreeQuarterPi", "Pi", "DoublePi", "MachineEpsilon", "CatalanConstant", "GoldenRatio", "EulerGamma", "ExponentialE"].includes(t3))
    return true;
  if (e3.is(["Greater", i3, 0]))
    return true;
  if (e3.is(["LessEqual", i3, 0]))
    return false;
  if (e3.is(["Less", i3, 0]))
    return false;
  const r3 = te2(i3);
  if (r3) {
    if ((r3 === "Cosh" || r3 === "Exp") && Se(0, le(i3, 1)))
      return true;
    if (r3 === "Sqrt" && Ne(e3, le(i3, 1)))
      return true;
    if (r3 === L2 || r3 === O2)
      return oe2(i3).every((i4) => Ne(e3, i4) === true);
    if (r3 === z2 && Ne(e3, le(i3, 1)) && Ne(e3, le(i3, 2)))
      return true;
    if (r3 === R2 && Ne(e3, le(i3, 1)))
      return true;
  }
}
function we(e3, i3) {
  const n3 = Ne(e3, i3);
  return n3 !== true && (n3 !== void 0 ? xe(e3, i3) === false : void 0);
}
function Se(e3, i3) {
  return i3 !== null && G2(i3) !== null;
}
var Ee = {MachineEpsilon: {domain: "RealNumber", constant: true, value: {num: Number.EPSILON.toString()}}, ImaginaryUnit: {domain: "ImaginaryNumber", constant: true, wikidata: "Q193796"}, ExponentialE: {domain: "TranscendentalNumber", wikidata: "Q82435", constant: true, value: (e3) => e3.numericFormat === "decimal" ? c2.exports.Decimal.exp(1) : e3.numericFormat === "complex" ? m2.exports.Complex.E : 2.718281828459045}, GoldenRatio: {domain: "IrrationalNumber", wikidata: "Q41690", constant: true, hold: false, value: ["Divide", ["Add", 1, ["Sqrt", 5]], 2]}, CatalanConstant: {domain: "RealNumber", wikidata: "Q855282", constant: true, value: {num: "0.91596559417721901505"}}, EulerGamma: {domain: "RealNumber", wikidata: "Q273023", constant: true, value: {num: "0.577215664901532860606"}}, Quarter: {domain: "RationalNumber", wikidata: "Q2310416", constant: true, hold: false, value: [z2, 3, 4]}, Third: {domain: "RationalNumber", wikidata: "Q20021125", constant: true, hold: false, value: [z2, 1, 3]}, Half: {domain: "RationalNumber", wikidata: "Q2114394", constant: true, hold: false, value: [z2, 1, 2]}, TwoThird: {domain: "RationalNumber", constant: true, hold: false, value: [z2, 2, 3]}, ThreeQuarter: {domain: "RationalNumber", constant: true, hold: false, value: [z2, 3, 4]}, Abs: {domain: "Function", wikidata: "Q3317982", threadable: true, idempotent: true, numeric: true, range: ["Interval", 0, 1 / 0], evalNumber: (e3, i3) => Math.abs(i3), evalComplex: (e3, i3) => m2.exports.Complex.abs(i3), evalDecimal: (e3, i3) => c2.exports.Decimal.abs(i3)}, Add: {domain: "Function", wikidata: "Q32043", associative: true, commutative: true, threadable: true, idempotent: true, range: "Number", numeric: true, simplify: function(e3, ...i3) {
  var n3, t3;
  if (i3.length === 0)
    return 0;
  if (i3.length === 1)
    return i3[0];
  let r3 = 0, o3 = 1, s3 = f2, a3 = m2.exports.Complex.ZERO, l3 = false, u3 = false;
  const c3 = [];
  for (const n4 of i3) {
    const i4 = re2(n4);
    if (i4 === P2 || i4 === T3)
      return NaN;
    if (i4 === "ComplexInfinity")
      return "ComplexInfinity";
    be(e3, n4) && (Ne(e3, n4) ? l3 = true : u3 = true);
    const [t4, m3] = X2(n4);
    if (t4 !== null && m3 !== null) {
      if (isNaN(t4) || isNaN(m3))
        return NaN;
      r3 = r3 * m3 + t4 * o3, o3 *= m3;
    } else {
      const i5 = W2(n4);
      if (i5 !== null)
        Number.isInteger(i5.re) && Number.isInteger(i5.im) ? a3 = a3.add(i5) : c3.push(n4);
      else {
        const i6 = Y2(n4);
        if (i6 !== null && i6.isInteger())
          s3 = s3.add(i6);
        else {
          const i7 = G2(n4);
          i7 !== null && Number.isInteger(i7) ? r3 += i7 : ye(e3, n4) !== false && c3.push(n4);
        }
      }
    }
  }
  if (l3 && u3)
    return NaN;
  if (l3)
    return 1 / 0;
  if (u3)
    return -1 / 0;
  if (s3.isZero() || c3.push(s3), a3.isZero() || c3.push(a3), c3.length === 0)
    return r3 === 0 ? 0 : o3 === 1 ? r3 : ["Divide", r3, o3];
  if (r3 !== 0) {
    const e4 = A2(r3, o3);
    r3 /= e4, o3 /= e4, o3 === 1 ? c3.push(r3) : c3.push(["Divide", r3, o3]);
  }
  return c3.length === 1 ? c3[0] : c3.length === 2 && te2(c3[1]) === _2 ? ["Subtract", c3[0], (n3 = le(c3[1], 1)) !== null && n3 !== void 0 ? n3 : P2] : c3.length === 2 && te2(c3[0]) === _2 ? ["Subtract", c3[1], (t3 = le(c3[0], 1)) !== null && t3 !== void 0 ? t3 : P2] : ["Add", ...c3];
}, evalNumber: (e3, ...i3) => {
  if (i3.length === 0)
    return 0;
  let n3 = 0;
  for (const e4 of i3)
    n3 += e4;
  return n3;
}, evalComplex: (e3, ...i3) => {
  if (i3.length === 0)
    return m2.exports.Complex.ZERO;
  let n3 = m2.exports.Complex.ZERO;
  for (const e4 of i3)
    n3 = n3.add(e4);
  return n3;
}, evalDecimal: (e3, ...i3) => {
  if (i3.length === 0)
    return f2;
  let n3 = f2;
  for (const e4 of i3)
    n3 = n3.add(e4);
  return n3;
}, evaluate: (e3, ...i3) => {
  if (i3.length === 0)
    return 0;
  let n3 = ["Add"];
  const t3 = i3.filter((e4) => e4 instanceof c2.exports.Decimal);
  t3.length > 0 && (t3.length === 1 ? n3.push(t3[0]) : n3.push(e3.N(["Add", ...t3])));
  const r3 = i3.filter((e4) => e4 instanceof m2.exports.Complex);
  r3.length > 0 && (r3.length === 1 ? n3.push(r3[0]) : n3.push(e3.N(["Add", ...r3])));
  const o3 = i3.filter((e4) => typeof e4 == "number");
  o3.length > 0 && (o3.length === 1 ? n3.push(o3[0]) : n3.push(e3.N(["Add", ...o3])));
  const s3 = i3.filter((e4) => !(typeof e4 == "number" || e4 instanceof c2.exports.Decimal || e4 instanceof m2.exports.Complex));
  return n3 = [...n3, ...s3], n3.length === 0 ? 0 : n3.length === 1 ? n3[1] : n3;
}}, Chop: {domain: "Function", associative: true, threadable: true, idempotent: true, numeric: true, range: "Number", evalNumber: (e3, i3) => e3.chop(i3), evalComplex: (e3, i3) => e3.chop(i3), evalDecimal: (e3, i3) => e3.chop(i3)}, Ceil: {domain: "Function", range: "Number", numeric: true, evalNumber: (e3, i3) => Math.ceil(i3), evalComplex: (e3, i3) => m2.exports.Complex.ceil(i3), evalDecimal: (e3, i3) => c2.exports.Decimal.ceil(i3)}, Divide: {domain: "Function", range: "Number", numeric: true, evalNumber: (e3, i3, n3) => i3 / n3, evalComplex: (e3, i3, n3) => typeof i3 == "number" ? new m2.exports.Complex(i3).div(n3) : i3.div(n3), evalDecimal: (e3, i3, n3) => c2.exports.Decimal.div(i3, n3)}, Exp: {domain: ["ContinuousFunction", "MonotonicFunction"], wikidata: "Q168698", threadable: true, range: "Number", numeric: true, evalNumber: (e3, i3) => Math.exp(i3), evalComplex: (e3, i3) => typeof i3 == "number" ? new m2.exports.Complex(i3).exp() : i3.exp(), evalDecimal: (e3, i3) => c2.exports.Decimal.exp(i3)}, Erf: {domain: ["ContinuousFunction", "MonotonicFunction"], range: "Number", numeric: true}, Erfc: {domain: ["ContinuousFunction", "MonotonicFunction"], range: "Number", numeric: true}, Factorial: {wikidata: "Q120976", domain: "MonotonicFunction", range: "Integer", numeric: true, evalNumber: (e3, i3) => function(e4) {
  if (!Number.isInteger(e4) || e4 < 0)
    return NaN;
  let i4 = 1;
  for (let n3 = 2; n3 <= e4; n3++)
    i4 *= n3;
  return i4;
}(i3), evalComplex: (e3, i3) => typeof i3 == "number" ? new m2.exports.Complex(i3 + 1) : i3.add(1), evalDecimal: (e3, i3) => x2(i3)}, Floor: {domain: "Function", wikidata: "Q56860783", range: "Number", numeric: true, evalNumber: (e3, i3) => Math.floor(i3), evalDecimal: (e3, i3) => c2.exports.Decimal.floor(i3)}, Gamma: {domain: "Function", wikidata: "Q190573", range: "Number", numeric: true, evalNumber: (e3, i3) => I2(i3), evalDecimal: (e3, i3) => S3(i3)}, LogGamma: {domain: "Function", range: "Number", numeric: true, evalNumber: (e3, i3) => F2(i3), evalDecimal: (e3, i3) => w2(i3)}, Ln: {domain: "Function", wikidata: "Q11197", range: "Number", numeric: true, evalNumber: (e3, i3) => Math.log(i3), evalComplex: (e3, i3) => typeof i3 == "number" ? new m2.exports.Complex(i3).log() : i3.log(), evalDecimal: (e3, i3) => c2.exports.Decimal.log(i3)}, Log: {domain: "Function", range: "Number", numeric: true, evalNumber: (e3, i3, n3) => Math.log(n3) / Math.log(i3), evalComplex: (e3, i3, n3) => {
  const t3 = typeof i3 == "number" ? new m2.exports.Complex(i3) : i3;
  return (typeof n3 == "number" ? new m2.exports.Complex(n3) : n3).log().div(t3.log());
}, evalDecimal: (e3, i3, n3) => c2.exports.Decimal.log(n3).div(c2.exports.Decimal.log(i3))}, Lb: {domain: "Function", wikidata: "Q581168", range: "Number", numeric: true, evalNumber: (e3, i3) => Math.log2(i3), evalComplex: (e3, i3, n3) => (typeof n3 == "number" ? new m2.exports.Complex(n3) : n3).log().div(m2.exports.Complex.log(2)), evalDecimal: (e3, i3) => c2.exports.Decimal.log(i3).div(c2.exports.Decimal.log(2))}, Lg: {domain: "Function", wikidata: "Q966582", range: "Number", numeric: true, evalNumber: (e3, i3) => Math.log10(i3), evalComplex: (e3, i3, n3) => (typeof n3 == "number" ? new m2.exports.Complex(n3) : n3).log().div(m2.exports.Complex.log(10)), evalDecimal: (e3, i3) => c2.exports.Decimal.log(i3).div(c2.exports.Decimal.log(10))}, Multiply: {domain: "Function", wikidata: "Q40276", associative: true, commutative: true, idempotent: true, range: "Number", simplify: function(e3, ...i3) {
  if (i3.length === 0)
    return 1;
  if (i3.length === 1)
    return i3[0];
  const n3 = [];
  let t3 = 1, r3 = 1, o3 = m2.exports.Complex.ONE;
  for (const s3 of i3) {
    const i4 = G2(s3);
    if (i4 === 0)
      return 0;
    if (i4 === null || Number.isFinite(i4) && !Number.isInteger(i4)) {
      const [i5, a3] = [null, null];
      if (i5 !== null && a3 !== null)
        t3 *= i5, r3 *= a3;
      else {
        const i6 = W2(s3);
        if (i6 !== null)
          Number.isInteger(i6.re) && Number.isInteger(i6.im) ? o3 = o3.mul(i6) : n3.push(s3);
        else {
          if (xe(e3, s3))
            return 0;
          n3.push(s3);
        }
      }
    } else
      t3 *= i4;
  }
  return o3.im !== 0 ? (o3 = o3.mul(t3), t3 = 1) : (t3 *= o3.re, o3 = m2.exports.Complex.ONE), t3 !== 0 && isFinite(t3) ? (o3.equals(m2.exports.Complex.ONE) || n3.push(["Complex", o3.re, o3.im]), n3.length === 0 ? r3 === 1 ? t3 : ["Divide", t3, r3] : (r3 !== 1 && (n3.unshift(["Divide", t3, r3]), t3 = 1, r3 = 1), n3.length === 1 && t3 === 1 ? n3[0] : n3.length === 1 && t3 === -1 ? ["Negate", n3[0]] : t3 === 1 ? ["Multiply", ...n3] : t3 === -1 ? ["Negate", ["Multiply", ...n3]] : ["Multiply", t3, ...n3])) : t3 / r3;
}, numeric: true, evalNumber: function(e3, ...i3) {
  if (i3.length === 0)
    return 1;
  if (i3.length === 1)
    return i3[0];
  let n3 = 1;
  for (const e4 of i3)
    n3 *= e4;
  return n3;
}, evalComplex: (e3, ...i3) => {
  if (i3.length === 0)
    return m2.exports.Complex.ONE;
  let n3 = m2.exports.Complex.ONE;
  for (const e4 of i3)
    n3 = n3.mul(e4);
  return n3;
}, evalDecimal: (e3, ...i3) => {
  if (i3.length === 0)
    return h2;
  let n3 = h2;
  for (const e4 of i3)
    n3 = n3.mul(e4);
  return n3;
}, evaluate: (e3, ...i3) => {
  if (i3.length === 0)
    return 0;
  let n3 = ["Multiply"];
  const t3 = i3.filter((e4) => e4 instanceof c2.exports.Decimal);
  t3.length > 0 && (t3.length === 1 ? n3.push(t3[0]) : n3.push(e3.N(["Multiply", ...t3])));
  const r3 = i3.filter((e4) => e4 instanceof m2.exports.Complex);
  r3.length > 0 && (r3.length === 1 ? n3.push(r3[0]) : n3.push(e3.N(["Multiply", ...r3])));
  const o3 = i3.filter((e4) => typeof e4 == "number");
  o3.length > 0 && (o3.length === 1 ? n3.push(o3[0]) : n3.push(e3.N(["Multiply", ...o3])));
  const s3 = i3.filter((e4) => !(typeof e4 == "number" || e4 instanceof c2.exports.Decimal || e4 instanceof m2.exports.Complex));
  return n3 = [...n3, ...s3], n3.length === 0 ? 1 : n3.length === 1 ? n3[1] : n3;
}}, Negate: {domain: "Function", wikidata: "Q715358", range: "Number", simplify: (e3, i3) => {
  var n3;
  return (n3 = De(i3)) !== null && n3 !== void 0 ? n3 : ["Negate", i3];
}, numeric: true, evalNumber: (e3, i3) => -i3, evalComplex: (e3, i3) => typeof i3 == "number" ? new m2.exports.Complex(-i3) : i3.neg(), evalDecimal: (e3, i3) => typeof i3 == "number" ? new c2.exports.Decimal(-i3) : i3.neg()}, Power: {domain: "Function", wikidata: "Q33456", commutative: false, numeric: true, range: "Number", simplify: (e3, ...i3) => Ce(e3, ["Power", ...i3]), evalNumber: (e3, i3, n3) => Math.pow(i3, n3), evalComplex: (e3, i3, n3) => {
  const t3 = typeof i3 == "number" ? new m2.exports.Complex(i3) : i3, r3 = typeof n3 == "number" ? new m2.exports.Complex(n3) : n3;
  return m2.exports.Complex.pow(t3, r3);
}, evalDecimal: (e3, i3, n3) => c2.exports.Decimal.pow(i3, n3)}, Round: {domain: "Function", range: "Number", numeric: true, evalNumber: (e3, i3) => Math.round(i3), evalComplex: (e3, i3) => typeof i3 == "number" ? new m2.exports.Complex(i3).round() : i3.round(), evalDecimal: (e3, i3) => c2.exports.Decimal.round(i3)}, Sign: {domain: "Function", range: ["Range", -1, 1], numeric: true, simplify: (e3, i3) => xe(e3, i3) ? 0 : we(e3, i3) ? -1 : 1, evalNumber: (e3, i3) => i3 === 0 ? 0 : i3 < 0 ? -1 : 1, evalComplex: (e3, i3) => {
  const n3 = typeof i3 == "number" ? new m2.exports.Complex(i3) : i3;
  return n3.div(n3.abs());
}, evalDecimal: (e3, i3) => typeof i3 == "number" ? i3 === 0 ? f2 : i3 < 0 ? p2 : h2 : i3.isZero() ? f2 : i3.isNeg() ? p2 : h2}, SignGamma: {domain: "Function", range: "Number", numeric: true}, Sqrt: {domain: "Function", wikidata: "Q134237", range: "Number", numeric: true, evalNumber: (e3, i3) => Math.sqrt(i3), evalComplex: (e3, i3) => typeof i3 == "number" ? new m2.exports.Complex(i3).sqrt() : i3.sqrt(), evalDecimal: (e3, i3) => c2.exports.Decimal.sqrt(i3)}, Square: {domain: "Function", wikidata: "Q3075175", range: "Number", numeric: true, evalNumber: (e3, i3) => i3 * i3, evalComplex: (e3, i3) => typeof i3 == "number" ? new m2.exports.Complex(i3).multiply(i3) : i3.mul(i3), evalDecimal: (e3, i3) => c2.exports.Decimal.mul(i3, i3)}, Root: {domain: "Function", commutative: false, range: "Number", numeric: true, evalNumber: (e3, i3, n3) => Math.pow(i3, 1 / n3), evalComplex: (e3, i3, n3) => {
  const t3 = typeof i3 == "number" ? new m2.exports.Complex(i3) : i3, r3 = typeof n3 == "number" ? new m2.exports.Complex(1 / n3) : new m2.exports.Complex(m2.exports.Complex.ONE.div(n3));
  return m2.exports.Complex.pow(t3, r3);
}, evalDecimal: (e3, i3, n3) => c2.exports.Decimal.pow(i3, h2.div(n3))}, Subtract: {domain: "Function", wikidata: "Q32043", range: "Number", numeric: true, evalNumber: (e3, i3, n3) => i3 - n3, evalComplex: (e3, i3, n3) => typeof i3 == "number" ? new m2.exports.Complex(i3).sub(n3) : i3.sub(n3), evalDecimal: (e3, i3, n3) => c2.exports.Decimal.sub(i3, n3)}};
function De(e3) {
  var i3, n3, t3, r3;
  if (typeof (e3 = Ae(e3)) == "number")
    return -e3;
  if (e3 && H2(e3))
    return e3.num[0] === "-" ? {num: e3.num.slice(1)} : e3.num[0] === "+" ? {num: "-" + e3.num.slice(1)} : {num: "-" + e3.num};
  if (e3 instanceof c2.exports.Decimal)
    return e3.mul(-1);
  if (e3 instanceof m2.exports.Complex)
    return e3.mul(-1);
  const o3 = te2(e3), s3 = ue(e3);
  if (o3 === _2 && s3 === 1)
    return (i3 = le(e3, 1)) !== null && i3 !== void 0 ? i3 : P2;
  if (o3 === L2) {
    const i4 = De((n3 = le(e3, 1)) !== null && n3 !== void 0 ? n3 : P2);
    return [L2, i4, ...oe2(e3).slice(1)];
  }
  return o3 === O2 ? [O2, ...ae2(e3, De)] : o3 === "Subtract" ? ["Subtract", (t3 = le(e3, 2)) !== null && t3 !== void 0 ? t3 : P2, (r3 = le(e3, 1)) !== null && r3 !== void 0 ? r3 : P2] : o3 === "Parentheses" && s3 === 1 ? De(le(le(e3, 1), 1)) : [_2, e3 != null ? e3 : P2];
}
function Ae(e3) {
  return e3 === null ? T3 : ne2(e3) ? e3 : ie2(e3) === "Parentheses" && ue(e3) === 1 ? Ae(le(e3, 1)) : se2(e3, Ae);
}
function Ce(e3, i3) {
  var n3, t3;
  if (ue(i3 = Ae(i3)) !== 2)
    return i3;
  const r3 = le(i3, 1), o3 = (n3 = G2(r3)) !== null && n3 !== void 0 ? n3 : NaN, s3 = le(i3, 2);
  if (re2(s3) === "ComplexInfinity")
    return NaN;
  const a3 = (t3 = G2(s3)) !== null && t3 !== void 0 ? t3 : NaN;
  if (xe(e3, s3))
    return 1;
  if (a3 === 1)
    return r3;
  if (a3 === 2)
    return ["Square", r3];
  if (a3 === -1)
    return o3 === -1 || o3 === 1 ? -1 : Number.isFinite(o3) ? ["Divide", 1, r3] : 0;
  if (!Number.isFinite(a3)) {
    if (o3 === 0 && a3 < 0)
      return "ComplexInfinity";
    if (o3 === 1 || o3 === -1)
      return NaN;
    if (o3 === 1 / 0) {
      if (a3 > 0)
        return 1 / 0;
      if (a3 < 0)
        return 0;
    }
    if (o3 === -1 / 0 && !Number.isFinite(a3))
      return NaN;
  }
  return i3;
}
function Fe(e3, i3, n3, t3) {
  return n3 === null ? "\\sqrt{}" : (t3 = t3 != null ? t3 : 2, i3 === "solidus" ? e3.wrapShort(n3) + "^{1\\/" + e3.serialize(t3) + "}" : i3 === "quotient" ? e3.wrapShort(n3) + "^{\\frac{1}{" + e3.serialize(t3) + "}}" : G2(t3) === 2 ? "\\sqrt{" + e3.serialize(n3) + "}" : "\\sqrt[" + e3.serialize(t3) + "]{" + e3.serialize(n3) + "}");
}
function Ie(e3, i3, n3) {
  if (!i3.match("\\sqrt"))
    return [e3, null];
  const t3 = i3.matchOptionalLatexArgument(), r3 = i3.matchRequiredLatexArgument();
  return r3 === null ? t3 !== null ? [e3, [Z2, T3, t3]] : [e3, [Q2]] : t3 !== null ? [e3, [Z2, r3, t3]] : [e3, [Q2, r3]];
}
function ke(e3, i3, n3) {
  if (276 < n3)
    return [e3, null];
  const t3 = i3.index;
  if (!i3.match("-"))
    return [e3, null];
  const r3 = i3.matchExpression(e3 === null ? 400 : 277);
  return r3 === null ? (i3.index = t3, [e3, null]) : e3 === null ? [null, [_2, r3]] : [null, ["Subtract", e3, r3]];
}
function Pe(e3, i3) {
  var n3;
  if (i3 === null)
    return "";
  e3.level -= 1;
  let t3 = "";
  const [r3, o3] = function(e4) {
    var i4, n4, t4, r4, o4, s3;
    if (te2(e4) !== L2)
      return [[], []];
    const a4 = [], l4 = [], u4 = oe2(e4);
    for (const e5 of u4)
      if (te2(e5) === R2)
        if (te2(le(e5, 2)) === _2) {
          const t5 = (i4 = le(e5, 1)) !== null && i4 !== void 0 ? i4 : T3, r5 = (n4 = le(le(e5, 2), 1)) !== null && n4 !== void 0 ? n4 : T3;
          l4.push([R2, t5, r5]);
        } else {
          const i5 = (t4 = G2(le(e5, 2))) !== null && t4 !== void 0 ? t4 : NaN;
          i5 === -1 ? l4.push((r4 = le(e5, 1)) !== null && r4 !== void 0 ? r4 : T3) : i5 < 0 ? l4.push([R2, (o4 = le(e5, 1)) !== null && o4 !== void 0 ? o4 : T3, (s3 = De(le(e5, 2))) !== null && s3 !== void 0 ? s3 : T3]) : a4.push(e5);
        }
      else
        a4.push(e5);
    return [a4, l4];
  }(i3);
  if (o3.length > 0 && (t3 = o3.length === 1 && o3[0] === 1 ? r3.length === 0 ? "1" : r3.length === 1 ? e3.serialize(r3[0]) : Pe(e3, [L2, ...r3]) : e3.serialize([z2, r3.length === 1 ? r3[0] : [L2, ...r3], o3.length === 1 ? o3[0] : [L2, ...o3]])), t3)
    return e3.level += 1, t3;
  let a3 = false, l3 = null;
  const u3 = ue(i3) + 1;
  let c3 = false;
  for (let r4 = 1; r4 < u3; r4++)
    if (l3 = le(i3, r4), l3 !== null) {
      let i4;
      typeof l3 == "number" || H2(l3) ? (i4 = e3.serialize(l3), i4 !== "-1" || t3 ? (i4[0] === "-" && (i4 = i4.slice(1), a3 = !a3), t3 = t3 ? s2([t3, e3.options.multiply, i4]) : i4) : t3 = "-", c3 = true) : te2(l3) !== R2 || isNaN((n3 = G2(le(l3, 1))) !== null && n3 !== void 0 ? n3 : NaN) ? (te2(l3) === _2 && (l3 = le(l3, 1), a3 = !a3), i4 = e3.wrap(l3, 390), t3 = t3 ? c3 && te2(l3) === z2 ? s2([t3, "\\times", i4]) : e3.options.invisibleMultiply ? s2([t3, e3.options.invisibleMultiply, i4]) : s2([t3, i4]) : i4, c3 = false) : (t3 = t3 ? s2([t3, e3.options.multiply, e3.serialize(l3)]) : e3.serialize(l3), c3 = true);
    }
  return e3.level += 1, a3 ? "-" + t3 : t3;
}
function Te(e3, i3) {
  if (i3 === null)
    return "";
  if (ue(i3) === 1)
    return e3.serialize(le(i3, 1));
  const n3 = e3.level > 3 ? "inline-solidus" : "quotient";
  if (n3 === "inline-solidus" || n3 === "nice-solidus") {
    const t3 = e3.wrapShort(le(i3, 1)), r3 = e3.wrapShort(le(i3, 2));
    return n3 === "nice-solidus" ? `^{${t3}}\\!\\!/\\!_{${r3}}` : `${t3}\\/${r3}`;
  }
  return n3 === "reciprocal" ? e3.wrap(le(i3, 1)) + e3.wrap(le(i3, 2)) + "^{-1}" : n3 === "factor" ? "\\frac{1}{" + e3.serialize(le(i3, 2)) + "}" + e3.wrap(le(i3, 1)) : "\\frac{" + e3.serialize(le(i3, 1)) + "}{" + e3.serialize(le(i3, 2)) + "}";
}
function Oe(e3, i3) {
  var n3;
  const t3 = le(i3, 1), r3 = le(i3, 2);
  if (r3 === null)
    return e3.serialize(t3);
  if (t3 === null)
    return "";
  const o3 = te2(i3);
  if (o3 === Q2 || o3 === Z2)
    return Fe(e3, he(0, e3.level), le(i3, 1), le(i3, 2));
  const s3 = (n3 = G2(r3)) !== null && n3 !== void 0 ? n3 : 1;
  if (s3 === -1)
    return e3.serialize([z2, "1", t3]);
  if (s3 < 0)
    return e3.serialize([z2, "1", [R2, t3, -s3]]);
  if (te2(r3) === z2) {
    if (G2(le(r3, 1)) === 1)
      return Fe(e3, he(0, e3.level), t3, le(r3, 2));
  } else if (te2(r3) === R2 && G2(le(r3, 2)) === -1)
    return Fe(e3, he(0, e3.level), t3, le(r3, 1));
  return e3.wrapShort(t3) + "^{" + e3.serialize(r3) + "}";
}
function ze(e3, i3, n3) {
  var t3;
  const r3 = i3.next();
  let o3 = false, s3 = 0;
  if (i3.skipSpace(), i3.match("^")) {
    if (i3.skipSpace(), i3.match("<{>")) {
      i3.skipSpace(), i3.match("-") && i3.match("1") && (o3 = true);
      do {
        i3.match("\\doubleprime") && (s3 += 2), i3.match("\\prime") && (s3 += 1), i3.match("'") && (s3 += 1);
      } while (!i3.match("<}>") && !i3.atEnd);
    }
    let e4 = false;
    for (; !e4; )
      i3.skipSpace(), i3.match("\\doubleprime") ? s3 += 2 : i3.match("\\prime") || i3.match("'") ? s3 += 1 : e4 = true;
  }
  let a3 = (t3 = {"\\arcsin": "Arcsin", "\\arccos": "Arccos", "\\arctan": "Arctan", "\\arctg": "Arctan", "\\arcctg": "Arctan", "\\arcsec": "Arcsec", "\\arccsc": " Arccsc", "\\arsinh": "Arsinh", "\\arcosh": "Arcosh", "\\artanh": "Artanh", "\\arcsech": "Arcsech", "\\arccsch": "Arcsch", "\\ch": "Cosh", "\\cos": "Cos", "\\cosec": "Csc", "\\cosh": "Csch", "\\cot": "Cot", "\\cotg": "Cot", "\\coth": "Coth", "\\csc": "Csc", "\\ctg": "Cot", "\\cth": "Coth", "\\sec": "Sec", "\\sin": "Sin", "\\sinh": "Sinh", "\\sh": "Sinh", "\\tan": "Tan", "\\tanh": "Tanh", "\\tg": "Tan", "\\th": "Tanh"}[r3]) !== null && t3 !== void 0 ? t3 : r3;
  o3 && (a3 = ["InverseFunction", a3]), s3 >= 1 && (a3 = ["Derivative", s3, a3]);
  const l3 = i3.matchArguments("implicit");
  return l3 === null ? [null, a3] : [null, [a3, ...l3]];
}
function Le(e3) {
  return a2(e3);
}
var _e = {algebra: [{name: "To", trigger: {infix: "\\to"}, precedence: 270}], arithmetic: [{name: "ThreeQuarter", serialize: "\\frac{3}{4}"}, {name: "TwoThird", serialize: "\\frac{2}{3}"}, {name: "Half", serialize: "\\frac{1}{2}"}, {name: "Third", serialize: "\\frac{1}{3}"}, {name: "Quarter", serialize: "\\frac{1}{4}"}, {name: "CatalanConstant", serialize: "G"}, {name: "GoldenRatio", serialize: "\\varphi"}, {name: "EulerGamma", serialize: "\\gamma"}, {name: "Degrees", serialize: "\\frac{\\pi}{180}"}, {name: "MinusDoublePi", serialize: "-2\\pi"}, {name: "MinusPi", serialize: "-\\pi"}, {name: "MinusHalfPi", serialize: "-\\frac{\\pi}{2}"}, {name: "QuarterPi", serialize: "\\frac{\\pi}{4}"}, {name: "ThirdPi", serialize: "\\frac{\\pi}{3}"}, {name: "HalfPi", serialize: "\\frac{\\pi}{2}"}, {name: "TwoThirdPi", serialize: "\\frac{2\\pi}{3}"}, {name: "ThreeQuarterPi", serialize: "\\frac{3\\pi}{4}"}, {name: "DoublePi", serialize: "2\\pi"}, {name: "Complex", precedence: 275, serialize: (e3, i3) => {
  const n3 = G2(le(i3, 1)), t3 = G2(le(i3, 2));
  if (t3 === 0)
    return e3.serialize(le(i3, 1));
  const r3 = t3 === 1 ? "\\imaginaryI" : t3 === -1 ? "-\\imaginaryI" : s2([e3.serialize(le(i3, 2)), "\\imaginaryI"]);
  return n3 === 0 ? r3 : s2([e3.serialize(le(i3, 1)), "+", r3]);
}}, {name: "Exp", serialize: (e3, i3) => {
  var n3;
  return s2(["\\exponentialE^{", e3.serialize((n3 = le(i3, 1)) !== null && n3 !== void 0 ? n3 : T3), "}"]);
}}, {name: "Square", serialize: (e3, i3) => e3.wrapShort(le(i3, 1)) + "^2"}, {trigger: {symbol: "\\infty"}, parse: {num: "+Infinity"}}, {name: "ComplexInfinity", trigger: {symbol: ["\\tilde", "\\infty"]}, serialize: "\\tilde\\infty"}, {name: "ComplexInfinity", trigger: {symbol: ["\\tilde", "<{>", "\\infty", "<}>"]}, serialize: "\\tilde\\infty"}, {name: "Pi", trigger: {symbol: "\\pi"}}, {name: "Pi", trigger: {symbol: "\u03C0"}, serialize: "\\pi"}, {name: "ExponentialE", trigger: {symbol: "e"}, serialize: "e"}, {name: "ImaginaryUnit", trigger: {symbol: "i"}, serialize: "\\imaginaryI"}, {name: "ImaginaryUnit", trigger: {symbol: "\\imaginaryI"}}, {name: O2, trigger: {prefix: "+", infix: "+"}, parse: function(e3, i3, n3) {
  if (275 < n3)
    return [e3, null];
  const t3 = i3.index;
  if (!i3.match("+"))
    return [e3, null];
  const r3 = i3.matchExpression(e3 === null ? 400 : 275);
  return r3 === null ? (i3.index = t3, [e3, null]) : e3 === null ? [null, r3] : i3.applyOperator(O2, e3, r3);
}, serialize: function(e3, i3) {
  var n3, t3;
  e3.level -= 1;
  const r3 = te2(i3);
  let o3 = "", s3 = le(i3, 1), a3 = !Number.isNaN((n3 = G2(s3)) !== null && n3 !== void 0 ? n3 : NaN);
  if (r3 === _2)
    o3 = "-" + e3.wrap(s3, 276);
  else if (r3 === O2) {
    o3 = e3.serialize(s3);
    const n4 = ue(i3) + 1;
    for (let r4 = 2; r4 < n4; r4++) {
      s3 = le(i3, r4);
      const n5 = (t3 = G2(s3)) !== null && t3 !== void 0 ? t3 : NaN, l3 = !Number.isNaN(n5);
      let u3 = false;
      if (s3 !== null && a3) {
        const [i4, n6] = X2(s3);
        i4 !== null && n6 !== null && isFinite(i4) && isFinite(n6) && n6 !== 1 && (o3 += e3.options.invisiblePlus + e3.serialize(s3), u3 = true);
      }
      if (!u3)
        if (n5 < 0)
          o3 += e3.serialize(s3);
        else if (te2(s3) === _2)
          o3 += e3.wrap(s3, 275);
        else {
          const i4 = e3.wrap(s3, 275);
          i4[0] === "-" || i4[0] === "+" ? o3 += i4 : o3 = o3 + "+" + i4;
        }
      a3 = l3;
    }
  } else if (r3 === "Subtract") {
    const n4 = le(i3, 2);
    o3 = n4 !== null ? e3.wrap(s3, 275) + "-" + e3.wrap(n4, 275) : e3.wrap(s3, 275);
  }
  return e3.level += 1, o3;
}, associativity: "both", precedence: 275}, {name: _2, trigger: {prefix: "-"}, parse: ke, associativity: "left", precedence: 275}, {name: "Subtract", trigger: {infix: "-"}, parse: ke, associativity: "both", precedence: 275}, {name: "PlusMinus", trigger: {infix: "\\pm"}, associativity: "both", precedence: 270}, {name: "MinusPlus", trigger: {infix: "\\mp"}, associativity: "both", precedence: 270}, {name: L2, trigger: {infix: "\\times"}, serialize: Pe, associativity: "both", precedence: 390}, {name: L2, trigger: {infix: "\\cdot"}, serialize: Pe, associativity: "both", precedence: 390}, {name: L2, trigger: {infix: "*"}, serialize: Pe, associativity: "both", precedence: 390}, {name: z2, trigger: "\\frac", parse: function(e3, i3, n3) {
  var t3, r3, o3, s3;
  if (!i3.match("\\frac"))
    return [e3, null];
  const a3 = (t3 = i3.matchRequiredLatexArgument()) !== null && t3 !== void 0 ? t3 : P2, l3 = (r3 = i3.matchRequiredLatexArgument()) !== null && r3 !== void 0 ? r3 : P2;
  if (te2(a3) === "PartialDerivative" && (te2(l3) === "PartialDerivative" || te2(l3) === L2 && te2(le(l3, 1)) === "PartialDerivative")) {
    const n4 = (o3 = le(a3, 3)) !== null && o3 !== void 0 ? o3 : T3;
    let t4 = le(a3, 1);
    t4 !== null && t4 !== T3 || (t4 = (s3 = i3.matchExpression()) !== null && s3 !== void 0 ? s3 : T3);
    let r4 = [];
    if (te2(l3) === L2) {
      for (const e4 of oe2(l3))
        if (ie2(e4) === "PartialDerivative") {
          const i4 = le(e4, 2);
          i4 && r4.push(i4);
        }
    } else {
      const e4 = le(l3, 2);
      e4 && r4.push(e4);
    }
    return r4.length > 1 && (r4 = [k2, ...r4]), [e3, ["PartialDerivative", t4, r4, n4 === T3 ? 1 : n4]];
  }
  return [e3, [z2, a3, l3]];
}, serialize: Te, requiredLatexArg: 2}, {name: z2, trigger: {infix: "\\/"}, serialize: Te, associativity: "non", precedence: 660}, {name: z2, trigger: {infix: "/"}, serialize: Te, associativity: "non", precedence: 660}, {name: z2, trigger: {infix: "\\div"}, serialize: Te, associativity: "non", precedence: 660}, {name: R2, trigger: {infix: "^"}, associativity: "non", precedence: 720, serialize: Oe}, {name: R2, trigger: {infix: ["*", "*"]}, associativity: "non", precedence: 720, serialize: Oe}, {name: Q2, trigger: "\\sqrt", optionalLatexArg: 1, requiredLatexArg: 1, parse: Ie, serialize: Oe}, {name: Z2, trigger: "\\sqrt", optionalLatexArg: 1, requiredLatexArg: 1, parse: Ie}, {name: "Norm", trigger: {matchfix: "\\lVert"}, closeFence: "\\rVert"}, {name: "Norm", trigger: {matchfix: "\\|"}, closeFence: "\\|"}, {name: "Norm", trigger: {matchfix: ["|", "|"]}, closeFence: ["|", "|"]}, {name: "Abs", trigger: {matchfix: "|"}, closeFence: "|"}, {name: "Abs", trigger: {matchfix: "\\lvert"}, closeFence: "\\rvert"}, {name: "Factorial", trigger: {postfix: "!"}, precedence: 810}, {name: "Factorial2", trigger: {postfix: ["!", "!"]}, precedence: 810}, {name: "Lcm", trigger: {symbol: ["\\operatorname", "<{>", "l", "c", "m", "<}>"]}}, {name: "Gcd", trigger: {symbol: ["\\operatorname", "<{>", "g", "c", "d", "<}>"]}}, {name: "Ceil", trigger: {symbol: ["\\operatorname", "<{>", "c", "e", "i", "l", "<}>"]}}, {name: "Floor", trigger: {symbol: ["\\operatorname", "<{>", "f", "l", "o", "o", "r", "<}>"]}}, {name: "Round", trigger: {symbol: ["\\operatorname", "<{>", "r", "o", "u", "n", "d", "<}>"]}}, {name: "Sign", trigger: {symbol: ["\\operatorname", "<{>", "s", "g", "n", "<}>"]}}], calculus: [{trigger: {symbol: "\\int"}, parse: function(e3, i3, n3) {
  if (!i3.match("\\int"))
    return [e3, null];
  let t3 = T3, r3 = T3, o3 = false;
  for (; !o3; )
    i3.skipSpace(), i3.match("_") ? r3 = i3.matchRequiredLatexArgument() : i3.match("^") ? t3 = i3.matchRequiredLatexArgument() : o3 = true;
  const s3 = i3.matchBalancedExpression("<{>", "<}>");
  return [e3, ["Integral", s3 != null ? s3 : "", t3 != null ? t3 : T3, r3 != null ? r3 : T3]];
}, serialize: function(e3, i3) {
  return "";
}}], core: ve, inequalities: [{name: "NotLess", trigger: {infix: ["!", "<"]}, associativity: "right", precedence: 246}, {name: "NotLess", trigger: {infix: "\\nless"}, associativity: "right", precedence: 246}, {name: "Less", trigger: {infix: "<"}, associativity: "right", precedence: 245}, {name: "Less", trigger: {infix: "\\lt"}, associativity: "right", precedence: 245}, {name: "LessEqual", trigger: {infix: ["<", "="]}, associativity: "right", precedence: 241}, {name: "LessEqual", trigger: {infix: "\\le"}, associativity: "right", precedence: 241}, {name: "LessEqual", trigger: {infix: "\\leq"}, associativity: "right", precedence: 241}, {name: "LessEqual", trigger: {infix: "\\leqslant"}, associativity: "right", precedence: 265}, {name: "LessNotEqual", trigger: {infix: "\\lneqq"}, associativity: "right", precedence: 260}, {name: "NotLessNotEqual", trigger: {infix: "\\nleqq"}, associativity: "right", precedence: 260}, {name: "LessOverEqual", trigger: {infix: "\\leqq"}, associativity: "right", precedence: 265}, {name: "GreaterOverEqual", trigger: {infix: "\\geqq"}, associativity: "right", precedence: 265}, {name: "Equal", trigger: {infix: "="}, associativity: "right", precedence: 260}, {name: "StarEqual", trigger: {infix: ["*", "="]}, associativity: "right", precedence: 260}, {name: "StarEqual", trigger: {infix: ["\\star", "="]}, associativity: "right", precedence: 260}, {name: "PlusEqual", trigger: {infix: ["+", "="]}, associativity: "right", precedence: 260}, {name: "MinusEqual", trigger: {infix: ["-", "="]}, associativity: "right", precedence: 260}, {name: "SlashEqual", trigger: {infix: ["/", "="]}, associativity: "right", precedence: 260}, {name: "EqualEqual", trigger: {infix: ["=", "="]}, associativity: "right", precedence: 260}, {name: "EqualEqualEqual", trigger: {infix: ["=", "=", "="]}, associativity: "right", precedence: 265}, {name: "TildeFullEqual", trigger: {infix: "\\cong"}, associativity: "right", precedence: 260}, {name: "NotTildeFullEqual", trigger: {infix: "\\ncong"}, associativity: "right", precedence: 260}, {name: "Assign", trigger: {infix: [":", "="]}, associativity: "right", precedence: 260}, {name: "Assign", trigger: {infix: "\\coloneq"}, associativity: "right", precedence: 260}, {name: "Approx", trigger: {infix: "\\approx"}, associativity: "right", precedence: 247}, {name: "NotApprox", trigger: {infix: "\\approx"}, associativity: "right", precedence: 247}, {name: "ApproxEqual", trigger: {infix: "\\approxeq"}, associativity: "right", precedence: 260}, {name: "NotApproxEqual", trigger: {infix: ["!", "\\approxeq"]}, associativity: "right", precedence: 250}, {name: "NotEqual", trigger: {infix: "\\ne"}, associativity: "right", precedence: 255}, {name: "Unequal", trigger: {infix: ["!", "="]}, associativity: "right", precedence: 260}, {name: "GreaterEqual", trigger: {infix: "\\ge"}, associativity: "right", precedence: 242}, {name: "GreaterEqual", trigger: {infix: "\\geq"}, associativity: "right", precedence: 242}, {name: "GreaterEqual", trigger: {infix: [">", "="]}, associativity: "right", precedence: 243}, {name: "GreaterEqual", trigger: {infix: "\\geqslant"}, associativity: "right", precedence: 265}, {name: "GreaterNotEqual", trigger: {infix: "\\gneqq"}, associativity: "right", precedence: 260}, {name: "NotGreaterNotEqual", trigger: {infix: "\\ngeqq"}, associativity: "right", precedence: 260}, {name: "Greater", trigger: {infix: ">"}, associativity: "right", precedence: 245}, {name: "Greater", trigger: {infix: "\\gt"}, associativity: "right", precedence: 245}, {name: "NotGreater", trigger: {infix: "\\ngtr"}, associativity: "right", precedence: 244}, {name: "NotGreater", trigger: {infix: ["!", ">"]}, associativity: "right", precedence: 244}, {name: "RingEqual", trigger: {infix: "\\circeq"}, associativity: "right", precedence: 260}, {name: "TriangleEqual", trigger: {infix: "\\triangleq"}, associativity: "right", precedence: 260}, {name: "DotEqual", trigger: {infix: "\\doteq"}, associativity: "right", precedence: 265}, {name: "DotEqualDot", trigger: {infix: "\\doteqdot"}, associativity: "right", precedence: 265}, {name: "FallingDotEqual", trigger: {infix: "\\fallingdotseq"}, associativity: "right", precedence: 265}, {name: "RisingDotEqual", trigger: {infix: "\\fallingdotseq"}, associativity: "right", precedence: 265}, {name: "QuestionEqual", trigger: {infix: "\\questeq"}, associativity: "right", precedence: 260}, {name: "Equivalent", trigger: {infix: "\\equiv"}, associativity: "right", precedence: 260}, {name: "MuchLess", trigger: {infix: "\\ll"}, associativity: "right", precedence: 260}, {name: "MuchGreater", trigger: {infix: "\\gg"}, associativity: "right", precedence: 260}, {name: "Precedes", trigger: {infix: "\\prec"}, associativity: "right", precedence: 260}, {name: "Succeeds", trigger: {infix: "\\succ"}, associativity: "right", precedence: 260}, {name: "PrecedesEqual", trigger: {infix: "\\preccurlyeq"}, associativity: "right", precedence: 260}, {name: "SucceedsEqual", trigger: {infix: "\\curlyeqprec"}, associativity: "right", precedence: 260}, {name: "NotPrecedes", trigger: {infix: "\\nprec"}, associativity: "right", precedence: 260}, {name: "NotSucceeds", trigger: {infix: "\\nsucc"}, associativity: "right", precedence: 260}, {name: "Between", trigger: {infix: "\\between"}, associativity: "right", precedence: 265}], other: fe, physics: [{name: "mu-0", trigger: {symbol: ["\\mu", "_", "0"]}}], sets: [{trigger: {symbol: "\\N"}, parse: "NaturalNumber"}, {trigger: {symbol: "\\Z"}, parse: "Integer"}, {trigger: {symbol: "\\Q"}, parse: "RationalNumber"}, {trigger: {symbol: ["\\mathbb", "<{>", "A", "<}>"]}, parse: "AlgebraicNumber"}, {trigger: {symbol: "\\R"}, parse: "RealNumber"}, {trigger: {symbol: "\\C"}, parse: "ComplexNumber"}, {trigger: {symbol: "\\varnothing"}, parse: "EmptySet"}, {trigger: {symbol: "\\emptyset"}, parse: "EmptySet"}, {name: "Complement", trigger: {infix: "\\complement"}, precedence: 240}, {name: "Element", trigger: {infix: "\\in"}, precedence: 240}, {name: "Intersection", trigger: {infix: "\\Cap"}, precedence: 350}, {name: "NotElement", trigger: {infix: "\\notin"}, precedence: 240}, {name: "SetMinus", trigger: {infix: "\\setminus"}, precedence: 650}, {name: "SubsetEqual", trigger: {infix: "\\subseteq"}, precedence: 240}, {name: "SymmetricDifference", trigger: {infix: "\\triangle"}, precedence: 260}, {name: "Union", trigger: {infix: "\\cup"}, precedence: 350}, {name: "Contains", trigger: {infix: "\\ni"}, associativity: "right", precedence: 160}, {name: "Subset", trigger: {infix: "\\subset"}, associativity: "right", precedence: 240}, {name: "SquareSubset", trigger: {infix: "\\sqsubset"}, associativity: "right", precedence: 265}, {name: "SquareSubsetEqual", trigger: {infix: "\\sqsubseteq"}, associativity: "right", precedence: 265}, {name: "Superset", trigger: {infix: "\\supset"}, associativity: "right", precedence: 240}, {name: "SquareSuperset", trigger: {infix: "\\sqsupset"}, associativity: "right", precedence: 265}, {name: "SquareSupersetEqual", trigger: {infix: "\\sqsupseteq"}, associativity: "right", precedence: 265}, {name: "NotSubset", trigger: {infix: "\\nsubset"}, associativity: "right", precedence: 240}, {name: "NotSuperset", trigger: {infix: "\\nsupset"}, associativity: "right", precedence: 240}, {name: "SupersetEqual", trigger: {infix: "\\supseteq"}, associativity: "right", precedence: 240}, {name: "NotSubsetNotEqual", trigger: {infix: "\\nsubseteq"}, associativity: "right", precedence: 240}, {name: "NotSupersetNotEqual", trigger: {infix: "\\nsupseteq"}, associativity: "right", precedence: 240}, {name: "SubsetNotEqual", trigger: {infix: "\\subsetneq"}, associativity: "right", precedence: 240}, {name: "SubsetNotEqual", trigger: {infix: "\\varsupsetneqq"}, associativity: "right", precedence: 240}, {name: "SupersetNotEqual", trigger: {infix: "\\supsetneq"}, associativity: "right", precedence: 240}, {name: "SupersetNotEqual", trigger: {infix: "\\varsupsetneq"}, associativity: "right", precedence: 240}], symbols: [{trigger: {symbol: "\\alpha"}, parse: "\u03B1"}, {trigger: {symbol: "\\beta"}, parse: "\u03B2"}, {trigger: {symbol: "\\gamma"}, parse: "\u03B3"}, {trigger: {symbol: "\\delta"}, parse: "\u03B4"}, {trigger: {symbol: "\\epsilon"}, parse: "\u03F5"}, {trigger: {symbol: "\\varepsilon"}, parse: "\u03B5"}, {trigger: {symbol: "\\zeta"}, parse: "\u03B6"}, {trigger: {symbol: "\\eta"}, parse: "\u03B7"}, {trigger: {symbol: "\\theta"}, parse: "\u03B8"}, {trigger: {symbol: "\\vartheta"}, parse: "\u03D1"}, {trigger: {symbol: "\\iota"}, parse: "\u03B9"}, {trigger: {symbol: "\\kappa"}, parse: "\u03BA"}, {trigger: {symbol: "\\varkappa"}, parse: "\u03F0"}, {trigger: {symbol: "\\lambda"}, parse: "\u03BB"}, {trigger: {symbol: "\\mu"}, parse: "\u03BC"}, {trigger: {symbol: "\\nu"}, parse: "\u03BD"}, {trigger: {symbol: "\\xi"}, parse: "\u03BE"}, {trigger: {symbol: "\\omicron"}, parse: "\u03BF"}, {trigger: {symbol: "\\varpi"}, parse: "\u03D6"}, {trigger: {symbol: "\\rho"}, parse: "\u03C1"}, {trigger: {symbol: "\\varrho"}, parse: "\u03F1"}, {trigger: {symbol: "\\sigma"}, parse: "\u03C3"}, {trigger: {symbol: "\\varsigma"}, parse: "\u03C2"}, {trigger: {symbol: "\\tau"}, parse: "\u03C4"}, {trigger: {symbol: "\\phi"}, parse: "\u03D5"}, {trigger: {symbol: "\\varphi"}, parse: "\u03C6"}, {trigger: {symbol: "\\upsilon"}, parse: "\u03C5"}, {trigger: {symbol: "\\chi"}, parse: "\u03C7"}, {trigger: {symbol: "\\psi"}, parse: "\u03C8"}, {trigger: {symbol: "\\omega"}, parse: "\u03C9"}, {trigger: {symbol: "\\Gamma"}, parse: "\u0393"}, {trigger: {symbol: "\\Delta"}, parse: "\u0394"}, {trigger: {symbol: "\\Theta"}, parse: "\u0398"}, {trigger: {symbol: "\\Lambda"}, parse: "\u039B"}, {trigger: {symbol: "\\Xi"}, parse: "\u039E"}, {trigger: {symbol: "\\Pi"}, parse: "\u03A0"}, {trigger: {symbol: "\\Sigma"}, parse: "\u03A3"}, {trigger: {symbol: "\\Upsilon"}, parse: "\u03A5"}, {trigger: {symbol: "\\Phi"}, parse: "\u03A6"}, {trigger: {symbol: "\\Psi"}, parse: "\u03A8"}, {trigger: {symbol: "\\Omega"}, parse: "\u03A9"}, {trigger: {symbol: "\\digamma"}, parse: "\u03DD"}, {trigger: {symbol: "\\aleph"}, parse: "\u2135"}, {trigger: {symbol: "\\beth"}, parse: "\u2136"}, {trigger: {symbol: "\\daleth"}, parse: "\u2138"}, {trigger: {symbol: "\\gimel"}, parse: "\u2137"}, {trigger: {symbol: "\\Finv"}, parse: "\u2132"}, {trigger: {symbol: "\\Game"}, parse: "\u2141"}, {trigger: {symbol: "\\wp"}, parse: "\u2118"}, {trigger: {symbol: "\\eth"}, parse: "\xF0"}, {trigger: {symbol: "\\mho"}, parse: "\u2127"}, {trigger: {symbol: "\\clubsuit"}, parse: "\u2663"}, {trigger: {symbol: "\\heartsuit"}, parse: "\u2661"}, {trigger: {symbol: "\\spadesuit"}, parse: "\u2660"}, {trigger: {symbol: "\\diamondsuit"}, parse: "\u2662"}, {trigger: {symbol: "\\sharp"}, parse: "\u266F"}, {trigger: {symbol: "\\flat"}, parse: "\u266D"}, {trigger: {symbol: "\\natural"}, parse: "\u266E"}], trigonometry: [{name: "Arcsin", trigger: "\\arcsin", arguments: "implicit", parse: ze}, {name: "Arccos", trigger: "\\arccos", arguments: "implicit", parse: ze}, {name: "Arctan", trigger: "\\arctan", arguments: "implicit", parse: ze}, {name: "Arctan", trigger: "\\arctg", arguments: "implicit", parse: ze}, {name: "Arccot", trigger: "\\arcctg", arguments: "implicit", parse: ze}, {name: "Arcsec", trigger: "\\arcsec", arguments: "implicit", parse: ze}, {name: "Arccsc", trigger: "\\arccsc", arguments: "implicit", parse: ze}, {name: "Arsinh", trigger: "\\arsinh", arguments: "implicit", parse: ze}, {name: "Arcosh", trigger: "\\arcosh", arguments: "implicit", parse: ze}, {name: "Artanh", trigger: "\\artanh", arguments: "implicit", parse: ze}, {name: "Arsech", trigger: "\\arsech", arguments: "implicit", parse: ze}, {name: "Arcsch", trigger: "\\arcsch", arguments: "implicit", parse: ze}, {name: "Cosh", trigger: "\\ch", arguments: "implicit", parse: ze}, {name: "Cosec", trigger: "\\cosec", arguments: "implicit", parse: ze}, {name: "Cosh", trigger: "\\cosh", arguments: "implicit", parse: ze}, {name: "Cot", trigger: "\\cot", arguments: "implicit", parse: ze}, {name: "Cot", trigger: "\\cotg", arguments: "implicit", parse: ze}, {name: "Coth", trigger: "\\coth", arguments: "implicit", parse: ze}, {name: "Csc", trigger: "\\csc", arguments: "implicit", parse: ze}, {name: "Cot", trigger: "\\ctg", arguments: "implicit", parse: ze}, {name: "Coth", trigger: "\\cth", arguments: "implicit", parse: ze}, {name: "Sec", trigger: "\\sec", arguments: "implicit", parse: ze}, {name: "Sinh", trigger: "\\sinh", arguments: "implicit", parse: ze}, {name: "Sinh", trigger: "\\sh", arguments: "implicit", parse: ze}, {name: "Tan", trigger: "\\tan", arguments: "implicit", parse: ze}, {name: "Tan", trigger: "\\tg", arguments: "implicit", parse: ze}, {name: "Tanh", trigger: "\\tanh", arguments: "implicit", parse: ze}, {name: "Tanh", trigger: "\\th", arguments: "implicit", parse: ze}, {name: "Cos", trigger: "\\cos", arguments: "implicit", parse: ze}, {name: "Sin", trigger: "\\sin", arguments: "implicit", parse: ze}]};
var Re = {precision: 15, positiveInfinity: "\\infty", negativeInfinity: "-\\infty", notANumber: "\\operatorname{NaN}", decimalMarker: ".", groupSeparator: ",", exponentProduct: "\\cdot", beginExponentMarker: "10^{", endExponentMarker: "}", notation: "auto", truncationMarker: "\\ldots", beginRepeatingDigits: "\\overline{", endRepeatingDigits: "}", imaginaryNumber: "\\imaginaryI"};
var Ze = {invisibleOperator: L2, skipSpace: true, parseArgumentsOfUnknownLatexCommands: true, parseNumbers: true, promoteUnknownSymbols: /^[a-zA-Z]$/, promoteUnknownFunctions: /^[fg]$/, ignoreCommands: ["\\displaystyle", "\\!", "\\:", "\\enskip", "\\quad", "\\,", "\\;", "\\enspace", "\\qquad", "\\selectfont", "\\tiny", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"], idempotentCommands: ["\\left", "\\right", "\\mleft", "\\mright", "\\middle", "\\bigl", "\\bigm", "\\bigr", "\\Bigl", "\\Bigm", "\\Bigr", "\\biggl", "\\biggm", "\\biggr", "\\Biggl", "\\Biggm", "\\Biggr"], invisiblePlusOperator: O2, preserveLatex: false};
var Qe = {invisibleMultiply: "", invisiblePlus: "", multiply: "\\times"};
function He(e3, i3) {
  var n3;
  let t3 = e3;
  for (let e4 = 0; e4 < i3.length; e4++) {
    let r3 = (n3 = i3[e4]) !== null && n3 !== void 0 ? n3 : "";
    if (/[a-zA-Z*]/.test(r3[0])) {
      const i4 = t3.match(new RegExp("(.*)#" + Number(e4 + 1).toString()));
      i4 && /\\[a-zA-Z*]+/.test(i4[1]) && (r3 = " " + r3);
    }
    t3 = t3.replace("#" + Number(e4 + 1).toString(), r3);
  }
  return t3;
}
var $e = class {
  constructor(e3, i3, n3, t3) {
    let r3;
    this.index = 0, this.options = {...Re, ...Ze, ...i3}, this.tokens = e3, this.onError = (e4) => t3({...e4, before: this.latexBefore(), after: this.latexAfter()}), this.dictionary = n3, this.invisibleOperatorPrecedence = 0, this.options.invisibleOperator && (r3 = this.dictionary.name.get(this.options.invisibleOperator), r3 === void 0 ? t3({code: "unknown-operator", arg: "invisible operator " + this.options.invisibleOperator}) : r3.precedence === void 0 ? t3({code: "expected-operator", arg: "invisible operator " + this.options.invisibleOperator}) : this.invisibleOperatorPrecedence = r3.precedence);
  }
  clone(e3, i3) {
    return new $e(this.tokens.slice(e3, i3), this.options, this.dictionary, this.onError);
  }
  balancedClone(e3, i3, n3 = true) {
    if (!this.matchAll(e3))
      return n3 || this.onError({code: "syntax-error", arg: "Expected " + a2(e3)}), null;
    const t3 = this.index;
    let r3 = t3, o3 = 1;
    for (; !this.atEnd && o3 !== 0; )
      this.skipSpace(), r3 = this.index, this.matchAll(i3) ? o3 -= 1 : this.matchAll(e3) ? o3 += 1 : this.next();
    return o3 !== 0 ? (n3 || this.onError({code: "unbalanced-symbols", arg: a2(e3) + a2(i3)}), this.index = t3, null) : this.clone(t3, r3);
  }
  get atEnd() {
    return this.index >= this.tokens.length;
  }
  get peek() {
    return this.tokens[this.index];
  }
  latex(e3, i3) {
    return a2(this.tokens.slice(e3, i3));
  }
  latexAhead(e3) {
    return a2(this.tokens.slice(this.index, this.index + e3));
  }
  latexBefore() {
    return this.latex(0, this.index);
  }
  latexAfter() {
    return this.latex(this.index);
  }
  lookAhead() {
    let e3 = Math.min(this.dictionary.lookahead, this.tokens.length - this.index);
    const i3 = [];
    for (; e3 > 0; )
      i3[e3] = this.latexAhead(e3--);
    return i3;
  }
  peekDefinition(e3) {
    let i3;
    i3 = e3 === "operator" ? this.lookAhead().map((e4, i4) => {
      var n3, t3, r3, o3, s3;
      return (o3 = (t3 = (n3 = this.dictionary.infix[i4]) === null || n3 === void 0 ? void 0 : n3.get(e4)) !== null && t3 !== void 0 ? t3 : (r3 = this.dictionary.postfix[i4]) === null || r3 === void 0 ? void 0 : r3.get(e4)) !== null && o3 !== void 0 ? o3 : (s3 = this.dictionary.prefix[i4]) === null || s3 === void 0 ? void 0 : s3.get(e4);
    }) : this.lookAhead().map((i4, n3) => {
      var t3;
      return (t3 = this.dictionary[e3][n3]) === null || t3 === void 0 ? void 0 : t3.get(i4);
    });
    for (let e4 = i3.length; e4 > 0; e4--)
      if (i3[e4] !== void 0)
        return [i3[e4], e4];
    return [null, 0];
  }
  next() {
    return this.tokens[this.index++];
  }
  skipSpace() {
    if (!this.atEnd && this.peek === "<{>" && this.tokens[this.index + 1] === "<}>")
      return this.index += 2, this.skipSpace(), true;
    let e3 = false;
    for (; !this.atEnd && (this.options.ignoreCommands.includes(this.peek) || this.options.idempotentCommands.includes(this.peek)); )
      this.index += 1, this.skipSpace(), e3 = true;
    if (!this.options.skipSpace)
      return false;
    for (; this.match("<space>"); )
      e3 = true;
    return e3 && this.skipSpace(), e3;
  }
  match(e3) {
    return this.tokens[this.index] === e3 && (this.index++, true);
  }
  matchAll(e3) {
    let i3 = true;
    typeof e3 == "string" && (e3 = [e3]);
    let n3 = 0;
    do {
      i3 = this.tokens[this.index + n3] === e3[n3++];
    } while (i3 && n3 < e3.length);
    return i3 && (this.index += n3), i3;
  }
  matchAny(e3) {
    return e3.includes(this.tokens[this.index]) ? this.tokens[this.index++] : "";
  }
  matchWhile(e3) {
    const i3 = [];
    for (; e3.includes(this.tokens[this.index]); )
      i3.push(this.tokens[this.index++]);
    return i3;
  }
  matchSign() {
    let e3 = false, i3 = false;
    for (; !i3; )
      this.skipSpace() ? i3 = false : this.match("-") ? (e3 = !e3, i3 = false) : i3 = !this.match("+");
    return e3 ? "-" : "+";
  }
  matchDecimalDigits() {
    let e3 = "", i3 = false;
    for (; !i3; )
      if (e3 += this.matchWhile(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]).join(""), i3 = true, this.options.groupSeparator) {
        const e4 = this.index;
        this.match(this.options.groupSeparator) && (/[0-9]/.test(this.peek) ? i3 = false : this.index = e4);
      }
    return e3;
  }
  matchSignedInteger() {
    const e3 = this.index, i3 = this.matchSign(), n3 = this.matchDecimalDigits();
    return n3 ? (i3 === "-" ? "-" : "") + n3 : (this.index = e3, "");
  }
  matchExponent() {
    const e3 = this.index;
    let i3 = "";
    if (this.matchAny(["e", "E", "d", "D"])) {
      const e4 = this.matchSignedInteger();
      e4 && (i3 = "e" + e4);
    }
    if (i3)
      return i3;
    if (this.match("\\times") && (this.skipSpace(), this.match("1") && this.match("0") && this.match("^"))) {
      if (/[0-9]/.test(this.peek))
        return "e" + this.next();
      if (this.match("<{>")) {
        this.skipSpace();
        const e4 = this.matchSignedInteger();
        if (this.skipSpace(), this.match("<}>") && e4)
          return "e" + e4;
      }
    }
    return this.index = e3, "";
  }
  matchNumber() {
    var e3, i3;
    if (!this.options.parseNumbers)
      return "";
    const n3 = this.index, t3 = this.matchSign();
    let r3 = this.matchDecimalDigits();
    if (!r3)
      return this.index = n3, "";
    r3 = (t3 === "-" ? "-" : "") + r3;
    let o3 = false, s3 = false;
    this.match((e3 = this.options.decimalMarker) !== null && e3 !== void 0 ? e3 : "") && (o3 = true, r3 += "." + ((i3 = this.matchDecimalDigits()) !== null && i3 !== void 0 ? i3 : "0"));
    const a3 = this.matchExponent();
    return a3 && (s3 = true), r3 ? r3.length + a3.length > 12 ? o3 || s3 ? r3 + a3 + "d" : r3 + "n" : r3 + a3 : (this.index = n3, "");
  }
  matchOperator(e3, i3 = null, n3 = 0) {
    const [t3, r3] = this.peekDefinition(e3);
    if (t3 === null)
      return null;
    if (typeof t3.parse == "function") {
      let e4 = null;
      return [i3, e4] = t3.parse(i3, this, n3), e4 === null ? null : this.applyInvisibleOperator(i3, e4);
    }
    let o3 = t3.precedence;
    if (o3 === void 0 || o3 < n3)
      return null;
    o3 += t3.associativity === "left" ? 1 : 0, this.index += r3;
    const s3 = this.matchExpression(o3);
    return this.applyInvisibleOperator(...this.applyOperator(t3.parse, i3, s3));
  }
  matchArguments(e3) {
    if (!e3)
      return null;
    const i3 = this.index;
    let n3 = null;
    const t3 = this.matchMatchfixOperator();
    if (e3 === "group" && te2(t3) === "Parentheses")
      n3 = oe2(t3);
    else if (e3 === "implicit")
      if (te2(t3) === "Parentheses")
        n3 = oe2(t3);
      else if (t3 !== null)
        n3 = [t3];
      else {
        const e4 = this.matchPrimary();
        e4 !== null && (n3 = [e4]);
      }
    else
      this.index = i3;
    return n3;
  }
  matchMatchfixOperator() {
    const [e3] = this.peekDefinition("matchfix");
    if (e3 === null)
      return null;
    if (typeof e3.parse == "function")
      return this.applyInvisibleOperator(...e3.parse(null, this, 0));
    const i3 = typeof e3.trigger == "object" ? e3.trigger.matchfix : e3.trigger;
    if (!i3 || !e3.closeFence || !e3.parse)
      return null;
    const n3 = this.matchBalancedExpression(i3, e3.closeFence, this.onError);
    return n3 ? [e3.parse, n3] : [e3.parse];
  }
  matchDefinition(e3) {
    const [i3, n3] = this.peekDefinition(e3);
    if (typeof (i3 == null ? void 0 : i3.parse) == "function") {
      const [, e4] = i3.parse(null, this, 0);
      return [i3, e4];
    }
    return this.index += n3, [i3, null];
  }
  matchSymbol() {
    var e3, i3, n3, t3;
    const [r3, o3] = this.matchDefinition("symbol");
    if (o3 !== null)
      return o3;
    if (r3 === null) {
      if ((e3 = this.options.promoteUnknownFunctions) === null || e3 === void 0 ? void 0 : e3.test(this.peek)) {
        const e4 = this.next(), i4 = this.matchMatchfixOperator();
        return i4 === null ? e4 : te2(i4) !== "Parentheses" ? null : [e4, ...oe2(i4)];
      }
      return ((i3 = this.options.promoteUnknownSymbols) === null || i3 === void 0 ? void 0 : i3.test(this.peek)) ? this.next() : this.matchUnknownLatexCommand();
    }
    const s3 = [], a3 = [];
    let l3, u3 = (n3 = r3.optionalLatexArg) !== null && n3 !== void 0 ? n3 : 0;
    for (; u3 > 0; )
      l3 = this.matchOptionalLatexArgument(), l3 !== null && a3.push(l3), u3--;
    for (u3 = (t3 = r3.requiredLatexArg) !== null && t3 !== void 0 ? t3 : 0; u3 > 0; )
      l3 = this.matchRequiredLatexArgument(), l3 === null && this.onError({code: "expected-argument"}), l3 !== null && s3.push(l3), u3--;
    const c3 = this.matchArguments(r3.arguments);
    return c3 === null ? s3.length === 0 && a3.length === 0 ? r3.parse : [r3.parse, ...s3, ...a3] : [r3.parse, ...s3, ...c3, ...a3];
  }
  matchOptionalLatexArgument() {
    return this.skipSpace(), this.matchBalancedExpression("[", "]");
  }
  matchRequiredLatexArgument() {
    return this.skipSpace(), this.matchBalancedExpression("<{>", "<}>") || (/^[0-9]$/.test(this.peek) ? parseFloat(this.next()) : /^[^\\#]$/.test(this.peek) ? this.next() : this.matchSymbol());
  }
  matchSupsub(e3) {
    if (e3 === null)
      return null;
    let i3 = null;
    return this.skipSpace(), [["^", "superfix"], ["_", "subfix"]].forEach((n3) => {
      var t3, r3, o3;
      if (i3 !== null)
        return;
      const [s3, a3] = n3, l3 = this.index;
      if (!this.match(s3))
        return;
      const u3 = this.index;
      let c3, m3 = 0;
      if (this.match("<{>") ? ([c3, m3] = this.peekDefinition(a3), c3 ? typeof c3.parse == "function" ? i3 = c3.parse(e3, this, 0)[1] : (this.index += m3, this.match("<}>") ? i3 = [(t3 = c3.parse) !== null && t3 !== void 0 ? t3 : c3.name, e3] : this.index = u3) : this.index = u3) : ([c3, m3] = this.peekDefinition(a3), c3 ? typeof c3.parse == "function" ? i3 = c3.parse(e3, this, 0)[1] : (this.index += m3, i3 = [(r3 = c3.parse) !== null && r3 !== void 0 ? r3 : c3.name, e3]) : this.index = u3), i3 === null && (c3 = (o3 = this.dictionary.infix[1]) === null || o3 === void 0 ? void 0 : o3.get(s3), typeof (c3 == null ? void 0 : c3.parse) == "function" ? (this.index = l3, i3 = c3.parse(e3, this, 0)[1]) : typeof (c3 == null ? void 0 : c3.parse) == "string" ? ([e3, i3] = this.applyOperator(c3.parse, e3, this.matchRequiredLatexArgument()), i3 = this.applyInvisibleOperator(e3, i3)) : i3 = this.applyInvisibleOperator(e3, s3)), i3 !== null) {
        const e4 = this.matchArguments(c3 == null ? void 0 : c3.arguments);
        e4 !== null && (i3 = [i3, ...e4]);
      }
    }), i3;
  }
  matchPostfix(e3) {
    if (e3 === null)
      return null;
    const [i3, n3] = this.peekDefinition("postfix");
    return i3 == null ? null : typeof i3.parse == "function" ? ([, e3] = i3.parse(e3, this, 0), e3 === null ? null : e3) : (this.index += n3, [i3.parse, e3]);
  }
  matchString() {
    let e3 = "", i3 = this.atEnd;
    for (; !i3; ) {
      if (this.match("<space>"))
        e3 += " ";
      else {
        const n3 = this.peek;
        n3 === "]" ? i3 = true : /^<({|}|\$|\$\$|space)>$/.test(n3) ? n3[0] === "\\" ? (this.onError({code: "unexpected-command"}), e3 += this.next()) : i3 = true : e3 += this.next();
      }
      i3 = i3 || this.atEnd;
    }
    return e3;
  }
  matchEnvironmentName(e3, i3) {
    if (this.match(e3)) {
      const e4 = this.index;
      if (this.match("<{>")) {
        const e5 = this.matchString();
        if (this.match("<}>") && e5 === i3)
          return true;
      }
      this.index = e4;
    }
    return false;
  }
  matchTabular() {
    const e3 = ["list"];
    let i3 = ["list"], n3 = null, t3 = false;
    for (; !this.atEnd && !t3; )
      if (this.match("&"))
        i3.push(n3 != null ? n3 : T3), n3 = null;
      else if (this.match("\\\\") || this.match("\\cr"))
        this.skipSpace(), this.matchOptionalLatexArgument(), n3 !== null && i3.push(n3), e3.push(i3), i3 = ["list"], n3 = null;
      else {
        const e4 = this.matchExpression();
        e4 === null && (t3 = true), n3 = n3 !== null ? this.applyInvisibleOperator(n3, e4) : e4;
      }
    return i3.length > 1 && e3.push(i3), e3;
  }
  matchEnvironment() {
    var e3;
    if (this.match("\\begin") && this.match("<{>")) {
      const i3 = this.matchString();
      if (this.match("<}>")) {
        const n3 = this.index;
        let t3 = this.index, r3 = 1;
        for (; !this.atEnd && r3 !== 0; )
          t3 = this.index, this.matchEnvironmentName("\\begin", i3) ? r3 += 1 : this.matchEnvironmentName("\\end", i3) ? r3 -= 1 : this.next();
        const o3 = this.dictionary.environment.get(i3);
        return typeof (o3 == null ? void 0 : o3.parse) == "function" ? o3.parse(null, this.clone(n3, t3), 0)[1] : (e3 = o3 == null ? void 0 : o3.parse) !== null && e3 !== void 0 ? e3 : null;
      }
    }
    return null;
  }
  applyOperator(e3, i3, n3) {
    var t3, r3, o3, s3;
    const a3 = this.dictionary.name.get(e3);
    if (a3 === void 0)
      return this.onError({code: "unknown-operator"}), [i3, n3];
    if (((t3 = a3.trigger) === null || t3 === void 0 ? void 0 : t3.prefix) !== void 0 && i3 === null && n3 !== null)
      return [null, [a3.name, n3]];
    if (((r3 = a3.trigger) === null || r3 === void 0 ? void 0 : r3.postfix) !== void 0 && i3 !== null)
      return [null, [a3.name, i3]];
    if (((o3 = a3.trigger) === null || o3 === void 0 ? void 0 : o3.matchfix) !== void 0 || ((s3 = a3.trigger) === null || s3 === void 0 ? void 0 : s3.infix) !== void 0) {
      if (a3.associativity === "non")
        return [null, [e3, i3 != null ? i3 : "Missing", n3 != null ? n3 : "Missing"]];
      if (te2(i3) === e3) {
        if (a3.associativity === "both") {
          if (te2(n3) === e3) {
            if (Array.isArray(i3))
              return [null, i3.concat(oe2(n3))];
            if (B2(i3))
              return [null, i3.fn.concat(oe2(n3))];
          } else
            n3 && (Array.isArray(i3) && i3.push(n3), B2(i3) && i3.fn.push(n3));
          return [null, i3];
        }
        return a3.associativity === "left" ? [null, [e3, i3 != null ? i3 : P2, n3 != null ? n3 : P2]] : Array.isArray(i3) ? [null, [e3, i3[1], [e3, i3[2], n3 != null ? n3 : P2]]] : (B2(i3) && (i3.fn[2] = [e3, i3.fn[2], n3 != null ? n3 : P2]), [null, i3]);
      }
      return te2(n3) === e3 ? a3.associativity === "both" ? (Array.isArray(n3) && i3 && n3.splice(1, 0, i3), B2(n3) && i3 && n3.fn.splice(1, 0, i3), [null, n3]) : a3.associativity === "right" ? [null, [e3, i3 != null ? i3 : P2, n3 != null ? n3 : P2]] : Array.isArray(n3) ? [null, [e3, n3[1], [e3, n3[2], i3 != null ? i3 : P2]]] : (B2(n3) && (n3.fn[2] = [e3, n3.fn[2], i3 != null ? i3 : P2]), [null, n3]) : [null, [e3, i3 != null ? i3 : "Missing", n3 != null ? n3 : "Missing"]];
    }
    return [i3, null];
  }
  applyInvisibleOperator(e3, i3) {
    if (e3 === null)
      return i3;
    if (i3 === null)
      return e3;
    if (this.options.invisiblePlusOperator && (typeof e3 == "number" || H2(e3)) && function(e4) {
      var i4, n4;
      const t3 = re2(e4);
      if (t3 !== null && ["ThreeQuarter", "TwoThird", "Half", "Third", "Quarter"].includes(t3))
        return true;
      if (te2(e4) !== z2)
        return false;
      const r3 = (i4 = G2(le(e4, 1))) !== null && i4 !== void 0 ? i4 : NaN, o3 = (n4 = G2(le(e4, 2))) !== null && n4 !== void 0 ? n4 : NaN;
      return Number.isInteger(r3) && Number.isInteger(o3);
    }(i3))
      return [e3, i3] = this.applyOperator(this.options.invisiblePlusOperator, e3, i3), e3 === null ? i3 : null;
    if (this.options.invisibleOperator)
      return [e3, i3] = this.applyOperator(this.options.invisibleOperator, e3, i3), e3 === null ? i3 : null;
    let n3 = ["LatexTokens"];
    return te2(e3) === "LatexTokens" ? n3 = n3.concat(oe2(e3)) : n3.push(e3), i3 !== null && (te2(i3) === "LatexTokens" ? n3 = n3.concat(oe2(i3)) : n3.push(i3)), this.options.invisibleOperator && this.onError({code: "unexpected-sequence"}), n3;
  }
  matchUnknownLatexCommand() {
    var e3;
    const i3 = this.peek;
    if (!i3 || i3[0] !== "\\")
      return null;
    if (this.next(), i3 === "\\operatorname") {
      if (this.skipSpace(), this.peek === "<{>") {
        let e4 = "";
        for (this.next(); !this.atEnd && this.tokens[this.index] !== "<}>"; )
          e4 += this.next();
        return e4;
      }
      return (e3 = this.next()) !== null && e3 !== void 0 ? e3 : P2;
    }
    const n3 = [], t3 = [];
    let r3 = false;
    do {
      r3 = true;
      let e4 = this.matchOptionalLatexArgument();
      e4 !== null && (n3.push(e4), r3 = false), this.skipSpace(), this.peek === "<{>" && (e4 = this.matchRequiredLatexArgument(), e4 !== null && (t3.push(e4), r3 = false));
    } while (!r3);
    return n3.length > 0 || t3.length > 0 ? [i3, ...t3, ...n3] : i3;
  }
  matchPrimary(e3) {
    let i3 = null;
    const n3 = this.index, t3 = this.matchNumber();
    t3 && (i3 = {num: t3}), i3 === null && (i3 = this.matchMatchfixOperator()), i3 === null && (i3 = this.matchEnvironment()), i3 === null && (i3 = this.matchSymbol());
    let r3 = null;
    do {
      r3 = this.matchSupsub(i3), i3 = r3 != null ? r3 : i3;
    } while (r3 !== null);
    let o3 = null;
    do {
      o3 = this.matchPostfix(i3), i3 = o3 != null ? o3 : i3;
    } while (o3 !== null);
    return this.decorate(i3, n3);
  }
  matchBalancedExpression(e3, i3, n3) {
    const t3 = this.balancedClone(e3, i3);
    if (!t3)
      return n3 == null || n3({code: "unbalanced-symbols", arg: a2(e3) + a2(i3)}), null;
    const r3 = t3.matchExpression();
    return t3.atEnd || n3 == null || n3({code: "unbalanced-symbols", arg: a2(e3) + a2(i3)}), r3;
  }
  matchExpression(e3 = 0) {
    let i3 = null;
    const n3 = this.index;
    this.skipSpace(), i3 = this.matchPrimary(e3), i3 === null && (i3 = this.matchOperator("prefix"));
    let t3 = false;
    for (; !this.atEnd && !t3; ) {
      this.skipSpace();
      let n4 = this.matchOperator("infix", i3, e3);
      if (n4 === null && i3 !== null) {
        const [e4] = this.peekDefinition("operator");
        if (e4 === null) {
          const e5 = this.matchExpression(this.invisibleOperatorPrecedence);
          e5 !== null && (n4 = this.applyInvisibleOperator(i3, e5));
        }
      }
      n4 !== null ? i3 = n4 : t3 = true;
    }
    return this.decorate(i3, n3);
  }
  decorate(e3, i3) {
    if (e3 === null)
      return null;
    if (this.options.preserveLatex) {
      const n3 = this.latex(i3, this.index);
      Array.isArray(e3) ? e3 = {latex: n3, fn: e3} : typeof e3 == "number" ? e3 = {latex: n3, num: Number(e3).toString()} : typeof e3 == "string" ? e3 = {latex: n3, sym: e3} : typeof e3 == "object" && e3 !== null && (e3.latex = n3);
    }
    return e3;
  }
};
function je(e3, i3) {
  const n3 = e3.length, t3 = e3;
  e3 = e3.slice(0, -1);
  for (let n4 = 0; n4 < e3.length - 16; n4++) {
    const t4 = e3.substr(0, n4);
    for (let r4 = 0; r4 < 17; r4++) {
      const o3 = e3.substr(n4, r4 + 1), s3 = Math.floor((e3.length - t4.length) / o3.length);
      if (s3 > 1 && (t4 + o3.repeat(s3 + 1)).startsWith(e3))
        return o3 === "0" ? t4.replace(/(\d{3})/g, "$1" + i3.groupSeparator) : t4.replace(/(\d{3})/g, "$1" + i3.groupSeparator) + i3.beginRepeatingDigits + o3 + i3.endRepeatingDigits;
    }
  }
  const r3 = n3 > i3.precision - 1;
  return e3 = t3, r3 && (e3 = e3.substr(0, i3.precision - 1)), i3.groupSeparator && (e3 = e3.replace(/(\d{3})/g, "$1" + i3.groupSeparator)).endsWith(i3.groupSeparator) && (e3 = e3.slice(0, -i3.groupSeparator.length)), r3 ? e3 + i3.truncationMarker : e3;
}
function Be(e3, i3) {
  var n3;
  return e3 ? i3.beginExponentMarker ? i3.beginExponentMarker + e3 + ((n3 = i3.endExponentMarker) !== null && n3 !== void 0 ? n3 : "") : "10^{" + e3 + "}" : "";
}
var Ue = class {
  constructor(e3, i3, n3) {
    this.level = -1, this.options = e3, e3.invisibleMultiply && (/#1/.test(e3.invisibleMultiply) && /#2/.test(e3.invisibleMultiply) || n3({code: "expected-argument", arg: "invisibleMultiply"})), this.onError = n3, this.dictionary = i3;
  }
  wrap(e3, i3) {
    if (e3 === null)
      return "";
    if (i3 === void 0)
      return "(" + this.serialize(e3) + ")";
    if (typeof e3 == "number" || H2(e3) || typeof e3 == "string" || $2(e3))
      return this.serialize(e3);
    const n3 = te2(e3);
    if (n3 && n3 !== "Parentheses") {
      const t3 = this.dictionary.name.get(n3);
      if (t3 && t3.precedence !== void 0 && t3.precedence < i3)
        return this.wrapString(this.serialize(e3), (this.level, "paren"));
    }
    return this.serialize(e3);
  }
  wrapShort(e3) {
    if (e3 === null)
      return "";
    const i3 = this.serialize(e3);
    return te2(e3) === "Parentheses" || typeof e3 == "number" || H2(e3) || /(^(.|\\[a-zA-Z*]+))$/.test(i3) ? i3 : this.wrapString(i3, (this.level, "paren"));
  }
  wrapString(e3, i3) {
    return i3 === "none" ? e3 : "(" + e3 + ")";
  }
  serializeSymbol(e3, i3) {
    const n3 = ie2(e3);
    if (!n3) {
      if (typeof (i3 == null ? void 0 : i3.serialize) == "string")
        return i3.serialize;
      const n4 = re2(e3);
      if (n4 === null)
        return "";
      switch (function(e4, i4) {
        const n5 = re2(e4);
        return n5 === null ? "asis" : n5.length > 1 ? "upright" : "asis";
      }(e3, this.level)) {
        case "upright":
          return "\\operatorname{" + n4 + "}";
        default:
          return n4;
      }
    }
    const t3 = oe2(e3);
    if (!i3) {
      if (typeof n3 == "string" && n3.length > 0 && n3[0] === "\\") {
        let e4 = n3;
        for (const i4 of t3)
          e4 += "{" + this.serialize(i4) + "}";
        return e4;
      }
      return `${this.serialize(n3)}(${t3.map((e4) => this.serialize(e4)).join(", ")})`;
    }
    if (i3.requiredLatexArg > 0) {
      let e4 = "", n4 = "", r3 = 0;
      for (; r3 < i3.requiredLatexArg; )
        n4 += "{" + this.serialize(t3[r3++]) + "}";
      for (; r3 < Math.min(t3.length, i3.optionalLatexArg + i3.requiredLatexArg); ) {
        const i4 = this.serialize(t3[1 + r3++]);
        i4 && (e4 += "[" + i4 + "]");
      }
      return i3.serialize + (e4 + n4);
    }
    return this.level, i3.serialize + this.serialize(["Parentheses", ...t3]);
  }
  serializeDictionary(e3) {
    return `\\left[\\begin{array}{lll}${Object.keys(e3).map((i3) => `\\textbf{${i3}} & \\rightarrow & ${this.serialize(e3[i3])}`).join("\\\\")}\\end{array}\\right]`;
  }
  serialize(e3) {
    if (e3 === null)
      return "";
    this.level += 1;
    const i3 = (() => {
      var i4, n3, t3, r3;
      const o3 = function(e4, i5) {
        var n4, t4;
        let r4;
        if (typeof e4 == "number")
          r4 = e4;
        else {
          if (!H2(e4))
            return "";
          r4 = e4.num;
        }
        if (r4 === 1 / 0 || r4 === "Infinity" || r4 === "+Infinity")
          return i5.positiveInfinity;
        if (r4 === -1 / 0 || r4 === "-Infinity")
          return i5.negativeInfinity;
        if (r4 === "NaN" || typeof r4 == "number" && Number.isNaN(r4))
          return i5.notANumber;
        if (typeof r4 == "number")
          return i5.notation === "engineering" ? function(e5, i6) {
            if (e5 === 0)
              return "0";
            const n5 = Math.abs(e5);
            let t5 = Math.round(Math.log10(n5));
            t5 -= t5 % 3, n5 < 1e3 && (t5 = 0);
            const r5 = n5 / Math.pow(10, t5);
            let o5 = "";
            const s4 = r5.toString().match(/^(.*)\.(.*)$/);
            (s4 == null ? void 0 : s4[1]) && s4[2] && (o5 = s4[1] + i6.decimalMarker + s4[2]), i6.groupSeparator && (o5 = je(r5.toExponential(), i6));
            let a4 = "";
            return t5 !== 0 && (a4 = Be(t5.toString(), i6)), (e5 < 0 ? "-" : "") + o5 + a4;
          }(r4, i5) : function(e5, i6) {
            let n5, t5 = e5.match(/^(.*)[e|E]([-+]?[0-9]+)$/i);
            (t5 == null ? void 0 : t5[1]) && t5[2] && (n5 = Be(t5[2], i6), n5 && (n5 = i6.exponentProduct + n5));
            let r5 = e5, o5 = "";
            return t5 = (n5 ? t5[1] : e5).match(/^(.*)\.(.*)$/), (t5 == null ? void 0 : t5[1]) && t5[2] && (r5 = t5[1], o5 = t5[2]), i6.groupSeparator && (r5 = r5.replace(/\B(?=(\d{3})+(?!\d))/g, i6.groupSeparator), o5 = je(o5, i6)), o5 && (o5 = i6.decimalMarker + o5), r5 + o5 + (n5 != null ? n5 : "");
          }(r4.toString(), i5);
        /[a-zA-Z]$/.test(r4) && (r4 = r4.slice(0, -1));
        let o4 = "";
        for (r4[0] === "-" ? (o4 = "-", r4 = r4.substr(1)) : r4[0] === "+" && (r4 = r4.substr(1)); r4[0] === "0"; )
          r4 = r4.substr(1);
        if (r4.length === 0)
          return o4 + "0";
        r4[0] === "." && (r4 = "0" + r4);
        let s3 = "";
        if (r4.indexOf(".") >= 0) {
          const e5 = r4.match(/(\d*)\.(\d*)([e|E]([-+]?[0-9]*))?/);
          if (!e5)
            return "";
          const t5 = e5[1], a4 = e5[2];
          if (s3 = (n4 = e5[4]) !== null && n4 !== void 0 ? n4 : "", t5 === "0") {
            let e6 = 0;
            for (; a4[e6] === "0" && e6 < a4.length; )
              e6 += 1;
            let n5 = "";
            if (e6 <= 4)
              n5 = "0" + i5.decimalMarker, n5 += a4.substr(0, e6), n5 += je(r4.substr(n5.length), i5);
            else if (e6 + 1 >= i5.precision)
              n5 = "0", o4 = "";
            else {
              n5 = r4[e6];
              const t6 = je(r4.substr(e6 + 1), i5);
              t6 && (n5 += i5.decimalMarker + t6);
            }
            n5 !== "0" && (!(r4.length - 1 > i5.precision) || i5.endRepeatingDigits && n5.endsWith(i5.endRepeatingDigits) || !i5.truncationMarker || n5.endsWith(i5.truncationMarker) || (n5 += i5.truncationMarker), e6 > 4 && (n5 += i5.exponentProduct + Be((1 - e6).toString(), i5))), r4 = n5;
          } else {
            r4 = t5.replace(/\B(?=(\d{3})+(?!\d))/g, i5.groupSeparator);
            const e6 = je(a4, i5);
            e6 && (r4 += i5.decimalMarker + e6);
          }
        } else if (r4.length > i5.precision) {
          const e5 = r4.length;
          let n5 = r4[0];
          const t5 = je(r4.substr(1), i5);
          t5 && (n5 += i5.decimalMarker + t5, i5.truncationMarker && !n5.endsWith(i5.truncationMarker) && i5.endRepeatingDigits && !n5.endsWith(i5.endRepeatingDigits) && (n5 += i5.truncationMarker)), n5 !== "1" ? n5 += i5.exponentProduct : n5 = "", r4 = n5 + Be((e5 - 1).toString(), i5);
        } else {
          const e5 = r4.match(/([0-9]*)\.?([0-9]*)([e|E]([-+]?[0-9]+))?/);
          e5 && (r4 = e5[1], e5[2] && (r4 += i5.decimalMarker + e5[2]), s3 = (t4 = e5[4]) !== null && t4 !== void 0 ? t4 : ""), r4 = r4.replace(/\B(?=(\d{3})+(?!\d))/g, i5.groupSeparator);
        }
        const a3 = Be(s3, i5);
        return o4 + r4 + (a3 ? i5.exponentProduct + a3 : "");
      }(e3, this.options);
      if (o3)
        return o3;
      const l3 = J2(e3);
      if (l3 !== null)
        return `\\text{${l3}}`;
      const u3 = re2(e3);
      if (u3 !== null)
        return this.serializeSymbol(e3, this.dictionary.name.get(u3));
      const c3 = ce(e3);
      if (c3 !== null)
        return this.serializeDictionary(c3);
      const m3 = te2(e3);
      if (m3) {
        if (m3[0] === "\\") {
          const i5 = oe2(e3);
          return i5.length === 0 ? m3 : m3 + "{" + i5.map((e4) => this.serialize(e4)).filter((e4) => Boolean(e4)).join("}{") + "}";
        }
        const o4 = this.dictionary.name.get(m3);
        if (o4) {
          let l4 = "";
          return typeof o4.serialize == "function" && (l4 = o4.serialize(this, e3)), l4 || o4.precedence === void 0 && !((i4 = o4.trigger) === null || i4 === void 0 ? void 0 : i4.superfix) && !((n3 = o4.trigger) === null || n3 === void 0 ? void 0 : n3.subfix) || (l4 = function(e4, i5, n4) {
            var t4, r4, o5, s3, a3;
            let l5 = "";
            const u4 = ue(i5), c4 = te2(i5);
            if (((t4 = n4.trigger) === null || t4 === void 0 ? void 0 : t4.superfix) || ((r4 = n4.trigger) === null || r4 === void 0 ? void 0 : r4.subfix))
              return u4 !== 1 && e4.onError({code: "operator-requires-one-operand", arg: e4.serializeSymbol(c4)}), He(n4.serialize, [e4.serialize(le(i5, 1))]);
            if ((o5 = n4.trigger) === null || o5 === void 0 ? void 0 : o5.postfix)
              return u4 !== 1 && e4.onError({code: "postfix-operator-requires-one-operand", arg: e4.serializeSymbol(c4)}), He(n4.serialize, [e4.wrap(le(i5, 1), n4.precedence)]);
            if ((s3 = n4.trigger) === null || s3 === void 0 ? void 0 : s3.prefix)
              return u4 !== 1 && e4.onError({code: "prefix-operator-requires-one-operand", arg: e4.serializeSymbol(c4)}), He(n4.serialize, [e4.wrap(le(i5, 1), n4.precedence + 1)]);
            if ((a3 = n4.trigger) === null || a3 === void 0 ? void 0 : a3.infix) {
              l5 = e4.wrap(le(i5, 1), n4.precedence);
              for (let t5 = 2; t5 < u4 + 1; t5++) {
                const r5 = le(i5, t5);
                r5 !== null && (l5 = He(n4.serialize, [l5, e4.wrap(r5, n4.precedence)]));
              }
            }
            return l5;
          }(this, e3, o4)), !l4 && ((t3 = o4.trigger) === null || t3 === void 0 ? void 0 : t3.matchfix) && (l4 = function(e4, i5, n4) {
            var t4, r4;
            let o5 = [];
            if (typeof ((t4 = n4.trigger) === null || t4 === void 0 ? void 0 : t4.matchfix) == "string" ? o5.push((r4 = n4.trigger) === null || r4 === void 0 ? void 0 : r4.matchfix) : n4.trigger && Array.isArray(n4.trigger.matchfix) && (o5 = [...n4.trigger.matchfix]), ue(i5) >= 1) {
              let t5 = "";
              for (const r5 of oe2(i5))
                r5 && (o5.push(t5), o5.push(e4.serialize(r5)), t5 = n4.separator);
            }
            return o5.push(a2(n4.closeFence)), s2(o5);
          }(this, e3, o4)), !l4 && ((r3 = o4.trigger) === null || r3 === void 0 ? void 0 : r3.symbol) && (l4 = this.serializeSymbol(e3, o4)), l4;
        }
      }
      if (Array.isArray(e3) || B2(e3))
        return this.serializeSymbol(e3);
      this.onError({code: "syntax-error", arg: JSON.stringify(e3)});
    })();
    return this.level -= 1, i3 != null ? i3 : "";
  }
};
var Ge = class {
  constructor(e3) {
    var i3, n3;
    this.onError = (i3 = e3 == null ? void 0 : e3.onError) !== null && i3 !== void 0 ? i3 : (e4) => {
      typeof window != "undefined" && (!e4.before || e4.after);
    };
    const t3 = {...e3 != null ? e3 : {}};
    delete t3.dictionary, delete t3.onError, this.options = {...Re, ...Qe, ...Ze, ...t3}, this.dictionary = function(e4, i4) {
      var n4, t4, r3, o3, s3, a3, l3, u3, c3, m3, f3, h3, p3, g3, d3;
      const v3 = {lookahead: 1, name: new Map(), prefix: [], infix: [], postfix: [], matchfix: [], superfix: [], subfix: [], symbol: [], environment: new Map()};
      for (const x3 of e4)
        x3.parse === void 0 && (x3.parse = x3.name), typeof x3.trigger == "string" && (x3.trigger = {symbol: x3.trigger}), typeof x3.serialize == "string" && ((n4 = x3.trigger) === null || n4 === void 0 ? void 0 : n4.symbol) !== void 0 && /#[0-9]/.test(x3.serialize) && i4({code: "unexpected-argument", arg: x3.name}), x3.serialize === void 0 && (((t4 = x3.trigger) === null || t4 === void 0 ? void 0 : t4.postfix) !== void 0 ? x3.serialize = "#1" + Le(x3.trigger.postfix) : ((r3 = x3.trigger) === null || r3 === void 0 ? void 0 : r3.prefix) !== void 0 ? x3.serialize = Le(x3.trigger.prefix) + "#1" : ((o3 = x3.trigger) === null || o3 === void 0 ? void 0 : o3.infix) !== void 0 ? x3.serialize = "#1" + Le(x3.trigger.infix) + "#2" : ((s3 = x3.trigger) === null || s3 === void 0 ? void 0 : s3.symbol) !== void 0 ? x3.serialize = Le(x3.trigger.symbol) : ((a3 = x3.trigger) === null || a3 === void 0 ? void 0 : a3.superfix) !== void 0 ? x3.serialize = "#1^{" + Le((l3 = x3.trigger) === null || l3 === void 0 ? void 0 : l3.superfix) + "}" : ((u3 = x3.trigger) === null || u3 === void 0 ? void 0 : u3.subfix) !== void 0 ? x3.serialize = "#1_{" + Le((c3 = x3.trigger) === null || c3 === void 0 ? void 0 : c3.subfix) + "}" : x3.serialize = ""), ((m3 = x3.trigger) === null || m3 === void 0 ? void 0 : m3.infix) !== void 0 && (x3.precedence === void 0 && i4({code: "syntax-error", arg: "Infix operators require a precedence"}), x3.associativity || (x3.associativity = "non")), ((f3 = x3.trigger) === null || f3 === void 0 ? void 0 : f3.symbol) !== void 0 && (x3.arguments = (h3 = x3.arguments) !== null && h3 !== void 0 ? h3 : "", x3.optionalLatexArg = (p3 = x3.optionalLatexArg) !== null && p3 !== void 0 ? p3 : 0, x3.requiredLatexArg = (g3 = x3.requiredLatexArg) !== null && g3 !== void 0 ? g3 : 0), ((d3 = x3.trigger) === null || d3 === void 0 ? void 0 : d3.matchfix) !== void 0 && (x3.parse === "function" || x3.closeFence || i4({code: "syntax-error", arg: "Matchfix operators require a close fence or a custom parse function"})), x3.trigger !== void 0 && (["infix", "prefix", "postfix", "symbol", "matchfix", "superfix", "subfix"].forEach((e5) => {
          if (x3.trigger[e5]) {
            const n5 = (i5 = x3.trigger[e5], Array.isArray(i5) ? i5.length : 1);
            v3.lookahead = Math.max(v3.lookahead, n5), v3[e5][n5] === void 0 && (v3[e5][n5] = new Map()), v3[e5][n5].set(Le(x3.trigger[e5]), x3);
          }
          var i5;
        }), x3.trigger.environment !== void 0 && v3.environment.set(x3.trigger.environment, x3)), x3.name !== void 0 ? v3.name.set(Le(x3.name), x3) : typeof x3.parse == "string" && v3.name.set(x3.parse, x3), x3.trigger !== void 0 || x3.name || i4({code: "syntax-error", arg: "Need at least a trigger or a name"});
      return v3;
    }((n3 = e3 == null ? void 0 : e3.dictionary) !== null && n3 !== void 0 ? n3 : Ge.getDictionary(), this.onError);
  }
  static getDictionary(e3 = "all") {
    if (e3 === "all") {
      let e4 = [];
      for (const i3 of Object.keys(_e))
        e4 = [...e4, ..._e[i3]];
      return e4;
    }
    return _e[e3] ? [..._e[e3]] : [];
  }
  parse(e3) {
    var i3;
    const n3 = new $e(o2(e3, []), this.options, this.dictionary, this.onError), t3 = n3.matchExpression();
    return n3.atEnd || (i3 = this.onError) === null || i3 === void 0 || i3.call(this, {code: "syntax-error"}), t3 != null ? t3 : "";
  }
  serialize(e3) {
    return new Ue(this.options, this.dictionary, this.onError).serialize(e3);
  }
};
function We(e3, i3) {
  return new Ge(i3).parse(e3);
}
function Ve(e3, i3) {
  return new Ge(i3).serialize(e3);
}
var ii = {Anything: [], Expression: "Anything", Domain: ["Set", "Symbol"], ParametricDomain: ["Domain", "Function"], MaybeBoolean: "Expression", Boolean: "MaybeBoolean", Collection: "Expression", Dictionary: "Collection", List: "Collection", Sequence: "Collection", Tuple: "Collection", Set: "Collection", FiniteSet: "Set", InfiniteSet: "Set", EmptySet: "FiniteSet", String: "Expression", Symbol: "String", Function: "Expression", Predicate: "Function", LogicalFunction: "Predicate", TranscendentalFunction: "Function", AlgebraicFunction: "Function", PeriodicFunction: "Function", TrigonometricFunction: ["PeriodicFunction", "TranscendentalFunction"], HyperbolicFunction: "TranscendentalFunction", MonotonicFunction: "Function", StrictMonotonicFunction: "MonotonicFunction", ContinuousFunction: "Function", DifferentiableFunction: "ContinuousFunction", InfinitelyDifferentiableFunction: "DifferentiableFunction", RationalFunction: ["AlgebraicFunction", "ContinuousFunction"], PolynomialFunction: ["AlgebraicFunction", "InfinitelyDifferentiableFunction"], QuadraticFunction: "PolynomialFunction", LinearFunction: ["QuadraticFunction", "MonotonicFunction"], ConstantFunction: "LinearFunction", Number: "Set", ImaginaryNumber: ["ComplexNumber", "InfiniteSet"], ComplexNumber: "ExtendedComplexNumber", ExtendedComplexNumber: "Number", ComplexInfinity: "ExtendedComplexNumber", NumberZero: ["CompositeNumber", "ImaginaryNumber", "FiniteSet"], NaturalNumber: "Integer", CompositeNumber: "NaturalNumber", PrimeNumber: "NaturalNumber", Integer: ["RationalNumber", "ExtendedInteger"], ExtendedInteger: "ExtendedRationalNumber", RationalNumber: ["AlgebraicNumber", "ExtendedRationalNumber"], IrrationalNumber: "RealNumber", TranscendentalNumber: ["IrrationalNumber", "ImaginaryNumber"], AlgebraicNumber: "IrrationalNumber", RealNumber: ["ComplexNumber", "ExtendedRealNumber"], ExtendedRealNumber: "ExtendedComplexNumber", ExtendedNaturalNumber: "ExtendedInteger", ExtendedRationalNumber: "ExtendedRealNumber", SignedInfinity: "ExtendedNaturalNumber", Tensor: "Expression", Scalar: "Tensor", Vector: "Matrix", Row: "Vector", Column: "Vector", Matrix: "Tensor", ComplexTensor: "Tensor", RealTensor: "ComplexTensor", IntegerTensor: "RealTensor", LogicalTensor: "IntegerTensor", SquareMatrix: "Matrix", MonomialMatrix: "SquareMatrix", TriangularMatrix: "SquareMatrix", UpperTriangularMatrix: "TriangularMatrix", LowerTriangularMatrix: "TriangularMatrix", PermutationMatrix: ["MonomialMatrix", "LogicalTensor", "OrthogonalMatrix"], OrthogonalMatrix: ["SquareMatrix", "RealTensor"], DiagonalMatrix: ["UpperTriangularMatrix", "LowerTriangularMatrix"], IdentityMatrix: ["DiagonalMatrix", "SymmetricMatrix", "PermutationMatrix"], ZeroMatrix: ["DiagonalMatrix", "SymmetricMatrix", "PermutationMatrix"], SymmetricMatrix: ["HermitianMatrix", "SquareMatrix", "RealTensor"], HermitianMatrix: "ComplexTensor", Quaternion: ["SquareMatrix", "ComplexTensor"]};
var ni = {Function: "Q11348", ComplexNumber: "Q26851286", Integer: "Q47007735", ImaginaryNumber: "Q47310259", NaturalNumber: "Q28920052"};
var ti = {MaybeBoolean: ["Union", "Boolean", ["Set", "Maybe"]], NaturalNumber: ["Union", "CompositeNumber", "PrimeNumber"], Scalar: ["Intersection", "Row", "Column"], TriangularMatrix: ["Union", "UpperTriangularMatrix", "LowerTriangularMatrix"], Vector: ["Union", "Row", "Column"]};
var ri = {Boolean: 2, MaybeBoolean: 3, EmptySet: 0, IdentityMatrix: 1, ZeroMatrix: 1, NumberZero: 1};
var oi = {Range: {range: "ParametricDomain", evaluate: (e3, i3, n3) => (i3 = Math.round(i3), n3 = Math.round(n3), Number.isNaN(i3) || Number.isNaN(n3) || i3 > n3 ? "EmptySet" : i3 === -1 / 0 && n3 === 1 / 0 ? "Integer" : i3 === 0 && n3 === 1 / 0 ? "NaturalNumber" : i3 === 0 && n3 === 0 ? "NumberZero" : ["Range", i3, n3])}, Interval: {range: "ParametricDomain", evaluate: (e3, i3, n3) => Number.isNaN(i3) || Number.isNaN(n3) || i3 > n3 ? "EmptySet" : i3 === -1 / 0 && n3 === 1 / 0 ? "RealNumber" : i3 === 0 && n3 === 0 ? "NumberZero" : ["Interval", i3, n3]}};
function si(e3, i3, n3) {
  if (i3 === null)
    return null;
  const t3 = ci(e3);
  return t3 === "" ? n3 : n3[t3] ? li(i3, n3[t3]) === null ? null : n3 : (n3[t3] = i3, n3);
}
function ai(e3, i3, n3, t3) {
  var r3;
  const o3 = G2(i3);
  if (o3 !== null)
    return Math.abs(o3 - ((r3 = G2(e3)) !== null && r3 !== void 0 ? r3 : NaN)) <= t3.numericalTolerance ? n3 : null;
  const s3 = J2(i3);
  if (s3 !== null)
    return J2(e3) === s3 ? n3 : null;
  const a3 = ce(i3);
  if (a3 !== null) {
    const i4 = Object.keys(a3), r4 = ce(e3);
    if (r4 === null)
      return null;
    if (Object.keys(r4).length !== i4.length)
      return null;
    for (const e4 of i4) {
      const i5 = ai(r4[e4], a3[e4], n3, t3);
      if (i5 === null)
        return null;
      n3 = i5;
    }
    return n3;
  }
  const l3 = re2(i3);
  if (l3 !== null)
    return l3.startsWith("_") ? si(l3, e3, n3) : l3 === re2(e3) ? typeof i3 == "object" && typeof e3 == "object" && "wikidata" in i3 && "wikidata" in e3 && i3.wikidata !== e3.wikidata ? null : n3 : typeof i3 == "object" && typeof e3 == "object" && "wikidata" in i3 && "wikidata" in e3 && i3.wikidata === e3.wikidata ? n3 : null;
  const u3 = ie2(i3);
  if (u3 === null)
    return null;
  if (typeof u3 == "string" && u3.startsWith("_"))
    return si(u3, ie2(e3), n3);
  {
    const i4 = ie2(e3);
    if (i4 === null)
      return null;
    if (li(u3, i4, t3) === null)
      return null;
  }
  const c3 = oe2(i3), m3 = oe2(e3), f3 = c3.length;
  if (f3 !== m3.length)
    return null;
  let h3 = {...n3}, p3 = 0;
  for (; p3 < f3; ) {
    const e4 = c3[p3], i4 = re2(e4);
    if (i4 !== null)
      if (i4.startsWith("__")) {
        let e5 = 0;
        if (c3[p3 + 1] === void 0)
          e5 = m3.length + 1;
        else {
          let i5 = false;
          for (; !i5 && e5 < m3.length; )
            i5 = li(c3[p3 + 1], m3[e5], t3) !== null, e5 += 1;
          if (!i5)
            return null;
        }
        if (!i4.startsWith("___") && e5 <= 1)
          return null;
        h3 = si(i4, ["Sequence", ...m3.splice(0, e5 - 1)], h3);
      } else if (i4.startsWith("_"))
        h3 = si(i4, m3.shift(), h3);
      else {
        const i5 = li(e4, m3.shift(), t3);
        if (i5 === null)
          return null;
        h3 = {...h3, ...i5};
      }
    else {
      const i5 = li(e4, m3.shift(), t3);
      if (i5 === null)
        return null;
      h3 = {...h3, ...i5};
    }
    if (h3 === null)
      return null;
    p3 += 1;
  }
  return h3;
}
function li(e3, i3, n3) {
  return ai(i3, e3, {}, n3 != null ? n3 : {numericalTolerance: E2});
}
function ci(e3) {
  const i3 = e3.match(/^__?_?([a-zA-Z0-9]+)/);
  return i3 === null ? "" : i3[1];
}
var mi = class {
  constructor(e3) {
    this._items = e3 ? new Map(e3 instanceof mi ? e3._items : e3) : new Map();
  }
  has(e3) {
    for (const i3 of this._items.keys())
      if (li(e3, i3))
        return true;
    return false;
  }
  get(e3) {
    for (const [i3, n3] of this._items)
      if (li(e3, i3))
        return n3;
  }
  set(e3, i3) {
    for (const n3 of this._items.keys())
      if (li(e3, n3))
        return void this._items.set(n3, i3);
    this._items.set(e3, i3);
  }
  delete(e3) {
    this._items.delete(e3);
  }
  [Symbol.iterator]() {
    return this._items.entries();
  }
  entries() {
    return this._items.entries();
  }
};
var fi = ["Sqrt", 2];
var hi = ["Sqrt", 3];
var pi = ["Sqrt", 5];
var gi = ["Sqrt", 6];
var di = new mi([[["Divide", "Pi", 12], {Sin: ["Divide", ["Subtract", gi, fi], 4], Cos: ["Divide", ["Add", gi, fi], 4], Tan: ["Subtract", [2, hi]], Cot: ["Add", [2, hi]], Sec: ["Subtract", [gi, fi]], Csc: ["Add", [gi, fi]]}], [["Divide", "Pi", 10], {Sin: ["Divide", ["Subtract", pi, 1], 4], Cos: ["Divide", ["Sqrt", ["Add", 10, ["Multiply", 2, pi]]], 4], Tan: ["Divide", ["Sqrt", ["Subtract", 25, ["Multiply", 10, pi]]], 4], Cot: ["Sqrt", ["Add", 5, ["Multiply", 2, pi]]], Sec: ["Divide", ["Sqrt", ["Subtract", 50, ["Multiply", 10, pi]]], 5], Csc: ["Add", 1, pi]}], [["Divide", "Pi", 4], {Sin: ["Divide", fi, 2], Cos: ["Divide", fi, 2], Tan: 1, Cot: 1, Sec: fi, Csc: fi}], [["Divide", "Pi", 3], {Sin: ["Divide", hi, 2], Cos: "Half", Tan: hi, Cot: ["Divide", hi, 3], Sec: 2, Csc: ["Divide", ["Multiply", 2, hi], 3]}], [["Divide", "Pi", 2], {Sin: 1, Cos: 0, Tan: 1 / 0, Cot: 0, Sec: 1 / 0, Csc: 1}]]);
var vi = {Degrees: {domain: "Real", constant: true, value: 0.017453292519943295}, MinusDoublePi: {domain: "TranscendentalNumber", constant: true, hold: false, value: [L2, -2, "Pi"]}, MinusPi: {domain: "TranscendentalNumber", constant: true, hold: false, value: [_2, "Pi"]}, MinusHalfPi: {domain: "TranscendentalNumber", constant: true, hold: false, value: [z2, [_2, "Pi"], 2]}, QuarterPi: {domain: "TranscendentalNumber", constant: true, hold: false, value: [z2, "Pi", 4]}, ThirdPi: {domain: "TranscendentalNumber", constant: true, hold: false, value: [z2, "Pi", 3]}, HalfPi: {domain: "TranscendentalNumber", constant: true, hold: false, value: [z2, "Pi", 2]}, TwoThirdPi: {domain: "TranscendentalNumber", constant: true, hold: false, value: [L2, 2, [z2, "Pi", 3]]}, ThreeQuarterPi: {domain: "TranscendentalNumber", constant: true, hold: false, value: [L2, 3, [z2, "Pi", 4]]}, Pi: {domain: "TranscendentalNumber", constant: true, wikidata: "Q167", value: (e3) => e3.numericFormat === "decimal" ? c2.exports.Decimal.acos(-1) : e3.numericFormat === "complex" ? m2.exports.Complex.PI : Math.PI}, DoublePi: {domain: "TranscendentalNumber", constant: true, hold: false, value: [L2, 2, "Pi"]}, Arccos: {domain: "TrigonometricFunction", range: ["Interval", 0, "Pi"], numeric: true, value: ["Subtract", "HalfPi", ["Arcsin", "_"]], simplify: (e3, i3) => {
  var n3, t3;
  return (t3 = (n3 = di.get(i3)) === null || n3 === void 0 ? void 0 : n3.Arccos) !== null && t3 !== void 0 ? t3 : ["Subtract", "HalfPi", ["Arcsin", i3]];
}, evalNumber: (e3, i3) => Math.acos(i3), evalDecimal: (e3, i3) => c2.exports.Decimal.acos(i3), evalComplex: (e3, i3) => m2.exports.Complex.acos(i3)}, Arcosh: {domain: "HyperbolicFunction", range: ["Interval", 0, 1 / 0], numeric: true, value: ["Ln", ["Add", "_", ["Sqrt", ["Subtract", ["Square", "_"], 1]]]], simplify: (e3, i3) => {
  var n3, t3;
  return (t3 = (n3 = di.get(i3)) === null || n3 === void 0 ? void 0 : n3.Arccosh) !== null && t3 !== void 0 ? t3 : ["Ln", ["Add", i3, ["Sqrt", ["Subtract", ["Square", i3], 1]]]];
}, evalNumber: (e3, i3) => Math.acosh(i3), evalDecimal: (e3, i3) => c2.exports.Decimal.acosh(i3), evalComplex: (e3, i3) => m2.exports.Complex.acosh(i3)}, Arcsin: {domain: "TrigonometricFunction", range: ["Interval", "MinusHalfPi", "HalfPi"], numeric: true, simplify: (e3, i3) => {
  var n3, t3;
  return (t3 = (n3 = di.get(i3)) === null || n3 === void 0 ? void 0 : n3.Arcsin) !== null && t3 !== void 0 ? t3 : ["Multiply", 2, ["Arctan2", i3, ["Add", 1, ["Sqrt", ["Subtract", 1, ["Square", i3]]]]]];
}, value: ["Multiply", 2, ["Arctan2", "_", ["Add", 1, ["Sqrt", ["Subtract", 1, ["Square", "_"]]]]]], evalNumber: (e3, i3) => Math.asin(i3), evalDecimal: (e3, i3) => c2.exports.Decimal.asin(i3), evalComplex: (e3, i3) => m2.exports.Complex.asin(i3)}, Arsinh: {domain: "HyperbolicFunction", range: ["Interval", -1 / 0, 1 / 0], numeric: true, simplify: (e3, i3) => {
  var n3, t3;
  return (t3 = (n3 = di.get(i3)) === null || n3 === void 0 ? void 0 : n3.Arsinh) !== null && t3 !== void 0 ? t3 : ["Ln", ["Add", i3, ["Sqrt", ["Add", ["Square", i3], 1]]]];
}, value: ["Ln", ["Add", "_", ["Sqrt", ["Add", ["Square", "_"], 1]]]], evalNumber: (e3, i3) => Math.asinh(i3), evalDecimal: (e3, i3) => c2.exports.Decimal.asinh(i3), evalComplex: (e3, i3) => m2.exports.Complex.asinh(i3)}, Arctan: {wikidata: "Q2257242", domain: "TrigonometricFunction", range: ["Interval", "MinusHalfPi", "HalfPi"], numeric: true, simplify: (e3, i3) => {
  var n3, t3;
  return (t3 = (n3 = di.get(i3)) === null || n3 === void 0 ? void 0 : n3.Arctan) !== null && t3 !== void 0 ? t3 : i3;
}, evalNumber: (e3, i3) => Math.atan(i3), evalDecimal: (e3, i3) => c2.exports.Decimal.atan(i3), evalComplex: (e3, i3) => m2.exports.Complex.atan(i3)}, Arctan2: {wikidata: "Q776598", range: ["Interval", "MinusPi", "Pi"], domain: "TrigonometricFunction", numeric: true, evalNumber: (e3, i3, n3) => Math.atan2(i3, n3), evalDecimal: (e3, i3, n3) => c2.exports.Decimal.atan2(i3, n3), evalComplex: (e3, i3, n3) => m2.exports.Complex.atan2(i3, n3)}, Artanh: {domain: "HyperbolicFunction", range: ["Interval", -1 / 0, 1 / 0], numeric: true, simplify: (e3, i3) => {
  var n3, t3;
  return (t3 = (n3 = di.get(i3)) === null || n3 === void 0 ? void 0 : n3.Artanh) !== null && t3 !== void 0 ? t3 : ["Multiply", "Half", ["Ln", ["Divide", ["Add", 1, i3], ["Subtract", 1, i3]]]];
}, value: ["Multiply", "Half", ["Ln", ["Divide", ["Add", 1, "_"], ["Subtract", 1, "_"]]]], evalNumber: (e3, i3) => Math.atanh(i3), evalDecimal: (e3, i3) => c2.exports.Decimal.atanh(i3), evalComplex: (e3, i3) => m2.exports.Complex.atanh(i3)}, Cosh: {domain: "HyperbolicFunction", range: ["Interval", 1, 1 / 0], numeric: true, simplify: (e3, i3) => {
  var n3, t3;
  return (t3 = (n3 = di.get(i3)) === null || n3 === void 0 ? void 0 : n3.Cosh) !== null && t3 !== void 0 ? t3 : i3;
}, value: ["Multiply", "Half", ["Add", ["Exp", "_"], ["Exp", ["Negate", "_"]]]], evalNumber: (e3, i3) => Math.cosh(i3), evalDecimal: (e3, i3) => c2.exports.Decimal.cosh(i3), evalComplex: (e3, i3) => m2.exports.Complex.cosh(i3)}, Cos: {domain: "TrigonometricFunction", range: ["Interval", -1, 1], numeric: true, simplify: (e3, i3) => {
  var n3, t3;
  return (t3 = (n3 = di.get(i3)) === null || n3 === void 0 ? void 0 : n3.Cos) !== null && t3 !== void 0 ? t3 : ["Sin", ["Add", i3, "HalfPi"]];
}, value: ["Sin", ["Add", "_", "HalfPi"]], evalNumber: (e3, i3) => Math.cos(i3), evalDecimal: (e3, i3) => c2.exports.Decimal.cos(i3), evalComplex: (e3, i3) => m2.exports.Complex.cos(i3)}, Cot: {domain: "TrigonometricFunction", range: "ComplexNumber", numeric: true, simplify: (e3, i3) => {
  var n3, t3;
  return (t3 = (n3 = di.get(i3)) === null || n3 === void 0 ? void 0 : n3.Cot) !== null && t3 !== void 0 ? t3 : ["Divide", ["Cos", i3], ["Sin", i3]];
}, value: ["Divide", ["Cos", "_"], ["Sin", "_"]], evalNumber: (e3, i3) => 1 / Math.tan(i3), evalDecimal: (e3, i3) => h2.div(c2.exports.Decimal.tan(i3)), evalComplex: (e3, i3) => m2.exports.Complex.ONE.div(m2.exports.Complex.tan(i3))}, Coth: {domain: "HyperbolicFunction", range: "ComplexNumber", numeric: true, simplify: (e3, i3) => {
  var n3, t3;
  return (t3 = (n3 = di.get(i3)) === null || n3 === void 0 ? void 0 : n3.Coth) !== null && t3 !== void 0 ? t3 : ["Divide", 1, ["Tanh", i3]];
}, value: ["Divide", 1, ["Tanh", "_"]], evalNumber: (e3, i3) => 1 / Math.tanh(i3), evalDecimal: (e3, i3) => h2.div(c2.exports.Decimal.tanh(i3)), evalComplex: (e3, i3) => m2.exports.Complex.ONE.div(m2.exports.Complex.tanh(i3))}, Csc: {domain: "TrigonometricFunction", range: ["Interval", -1, 1], numeric: true, simplify: (e3, i3) => {
  var n3, t3;
  return (t3 = (n3 = di.get(i3)) === null || n3 === void 0 ? void 0 : n3.Csc) !== null && t3 !== void 0 ? t3 : ["Divide", 1, ["Sin", i3]];
}, value: ["Divide", 1, ["Sin", "_"]], evalNumber: (e3, i3) => 1 / Math.tanh(i3), evalDecimal: (e3, i3) => h2.div(c2.exports.Decimal.tanh(i3)), evalComplex: (e3, i3) => m2.exports.Complex.ONE.div(m2.exports.Complex.tanh(i3))}, Csch: {domain: "HyperbolicFunction", range: ["Interval", -1, 1], numeric: true, simplify: (e3, i3) => {
  var n3, t3;
  return (t3 = (n3 = di.get(i3)) === null || n3 === void 0 ? void 0 : n3.Csch) !== null && t3 !== void 0 ? t3 : ["Divide", 1, ["Sinh", i3]];
}, value: ["Divide", 1, ["Sinh", "_"]], evalNumber: (e3, i3) => 1 / Math.sinh(i3), evalDecimal: (e3, i3) => h2.div(c2.exports.Decimal.sinh(i3)), evalComplex: (e3, i3) => m2.exports.Complex.ONE.div(m2.exports.Complex.sinh(i3))}, FromPolarCoordinates: {domain: "Function", range: ["TupleOf", "RealNumber", "RealNumber"]}, Haversine: {wikidata: "Q2528380", domain: "TrigonometricFunction", range: ["Interval", 0, 1], value: ["Divide", ["Subtract", 1, ["Cos", "_"]], 2], numeric: true}, Hypot: {domain: "Function", range: ["Interval", 0, 1 / 0], value: ["Sqrt", ["Square", "_"], ["Square", "_2"]], evalNumber: (e3, i3, n3) => Math.sqrt(i3 * i3 * +n3 * n3), evalDecimal: (e3, i3, n3) => c2.exports.Decimal.sqrt(i3.mul(i3).add(n3.mul(n3))), evalComplex: (e3, i3, n3) => m2.exports.Complex.sqrt(i3.mul(i3).add(n3.mul(n3)))}, InverseFunction: {domain: "Function", range: "Function", simplify: (e3, i3) => {
  var n3, t3;
  const r3 = (n3 = le(i3, 1)) !== null && n3 !== void 0 ? n3 : P2;
  return typeof r3 != "string" ? i3 : (t3 = {Sin: "Arcsin", Cos: "Arccos", Tan: "Arctan", Sec: "Arcsec", Csc: " Arccsc", Sinh: "Arsinh", Cosh: "Arcosh", Tanh: "Artanh", Sech: "Arcsech", Csch: "Arcsch", Arcosh: "Cosh", Arcos: "Cos", Arccsc: "Csc", Arcsch: "Csch", Arcsec: "Sec", Arcsin: "Sin", Arsinh: "Sinh", Arctan: "Tan", Artanh: "Tanh"}[r3]) !== null && t3 !== void 0 ? t3 : i3;
}}, InverseHaversine: {domain: "TrigonometricFunction", range: ["Interval", ["MinusPi"], "Pi"], numeric: true, value: ["Multiply", 2, ["Arcsin", ["Sqrt", "_"]]]}, Sec: {domain: "TrigonometricFunction", range: ["Interval", -1, 1], numeric: true, simplify: (e3, i3) => {
  var n3, t3;
  return (t3 = (n3 = di.get(i3)) === null || n3 === void 0 ? void 0 : n3.Sec) !== null && t3 !== void 0 ? t3 : ["Divide", 1, ["Cos", i3]];
}, value: ["Divide", 1, ["Cos", "_"]], evalNumber: (e3, i3) => 1 / Math.cos(i3), evalDecimal: (e3, i3) => h2.div(c2.exports.Decimal.cos(i3)), evalComplex: (e3, i3) => m2.exports.Complex.ONE.div(m2.exports.Complex.cos(i3))}, Sech: {domain: "HyperbolicFunction", range: ["Interval", -1, 1], numeric: true, simplify: (e3, i3) => {
  var n3, t3;
  return (t3 = (n3 = di.get(i3)) === null || n3 === void 0 ? void 0 : n3.Sech) !== null && t3 !== void 0 ? t3 : ["Divide", 1, ["Cosh", i3]];
}, value: ["Divide", 1, ["Cosh", "_"]], evalNumber: (e3, i3) => 1 / Math.cosh(i3), evalDecimal: (e3, i3) => h2.div(c2.exports.Decimal.cosh(i3)), evalComplex: (e3, i3) => m2.exports.Complex.ONE.div(m2.exports.Complex.cosh(i3))}, Sinh: {domain: "HyperbolicFunction", range: ["Interval", -1 / 0, 1 / 0], numeric: true, simplify: (e3, i3) => {
  var n3, t3;
  return (t3 = (n3 = di.get(i3)) === null || n3 === void 0 ? void 0 : n3.Sinh) !== null && t3 !== void 0 ? t3 : ["Multiply", "Half", ["Subtract", ["Exp", i3], ["Exp", ["Negate", i3]]]];
}, value: ["Multiply", "Half", ["Subtract", ["Exp", "_"], ["Exp", ["Negate", "_"]]]]}, Sin: {domain: "TrigonometricFunction", range: ["Interval", -1, 1], numeric: true, simplify: (e3, i3) => {
  var n3, t3;
  return (t3 = (n3 = di.get(i3)) === null || n3 === void 0 ? void 0 : n3.Sin) !== null && t3 !== void 0 ? t3 : i3;
}, value: ["Divide", ["Subtract", ["Exp", ["Multiply", "ImaginaryUnit", "_"]], ["Exp", ["Multiply", "ImaginaryUnit", ["Negate", "_"]]]], ["Multiply", 2, "ImaginaryUnit"]], evalNumber: (e3, i3) => Math.sin(i3), evalDecimal: (e3, i3) => i3.sin(), evalComplex: (e3, i3) => i3.sin()}, Tanh: {domain: "HyperbolicFunction", range: ["Interval", -1 / 0, 1 / 0], numeric: true, simplify: (e3, i3) => {
  var n3, t3;
  return (t3 = (n3 = di.get(i3)) === null || n3 === void 0 ? void 0 : n3.Tanh) !== null && t3 !== void 0 ? t3 : ["Divide", ["Sinh", i3], ["Cosh", i3]];
}, value: ["Divide", ["Sinh", "_"], ["Cosh", "_"]], evalNumber: (e3, i3) => Math.tanh(i3), evalDecimal: (e3, i3) => i3.tanh(), evalComplex: (e3, i3) => i3.tanh()}, Tan: {domain: "TrigonometricFunction", range: "RealNumber", numeric: true, simplify: (e3, i3) => {
  var n3, t3;
  return (t3 = (n3 = di.get(i3)) === null || n3 === void 0 ? void 0 : n3.Tan) !== null && t3 !== void 0 ? t3 : ["Divide", ["Sin", i3], ["Cos", i3]];
}, value: ["Divide", ["Sin", "_"], ["Cos", "_"]], evalNumber: (e3, i3) => Math.tan(i3), evalDecimal: (e3, i3) => i3.tan(), evalComplex: (e3, i3) => i3.tan()}, ToPolarCoordinates: {domain: "Function", range: ["TupleOf", "RealNumber", "RealNumber"]}};
var Ei = {arithmetic: Ee, algebra: {}, calculus: {}, combinatorics: {}, complex: {}, core: {Apply: {domain: "Function", range: "Anything"}, About: {domain: "Function", range: "Dictionary"}, BaseForm: {domain: "Function", range: "Integer"}, Block: {domain: "Function", range: "Anything"}, Domain: {domain: "ParametricDomain", range: "Domain"}, Evaluate: {domain: "Function", range: "Anything"}, Parentheses: {domain: "Function", threadable: true, pure: false, range: "Anything"}, Head: {domain: "Function", range: "Anything"}, Lambda: {domain: "Function", wikidata: "Q567612", hold: "all", range: "Anything"}, Latex: {domain: "Function", range: "String"}, String: {domain: "Function", threadable: true, range: "String"}, Symbol: {domain: "Function", threadable: true, range: "Symbol"}, Tail: {domain: "Function", range: "List"}}, collections: {EmptySet: {domain: "EmptySet", constant: true, wikidata: "Q226183"}, CartesianProduct: {domain: "Function", wikidata: "Q173740", range: "Set", evaluate: function(e3, i3, n3) {
  return "EmptySet";
}}, Intersection: {domain: "Function", wikidata: "Q185837", threadable: true, associative: true, commutative: true, idempotent: true, involution: true, range: "Set", evaluate: function(e3, ...i3) {
  return "EmptySet";
}}, Complement: {domain: "Function", wikidata: "Q242767", range: "Set"}, Union: {domain: "Function", wikidata: "Q185359", threadable: true, associative: true, commutative: true, idempotent: true, involution: true, range: "Set", evaluate: function(e3, ...i3) {
  return "EmptySet";
}}, SymmetricDifference: {domain: "Function", wikidata: "Q1147242", range: "Set"}, Subset: {domain: "Predicate", range: "MaybeBoolean", evaluate: function(e3, i3, n3) {
  return "False";
}}, SubsetEqual: {domain: "Predicate", range: "MaybeBoolean", evaluate: function(e3, i3, n3) {
  return "False";
}}, SetMinus: {domain: "Function", wikidata: "Q18192442", range: "MaybeBoolean", evaluate: function(e3, i3, n3) {
  return "EmptySet";
}}}, domains: function() {
  var e3;
  const i3 = {Nothing: {countable: true, supersets: [], domain: "Domain"}};
  for (const n4 of Object.keys(ii)) {
    const t3 = Array.isArray(ii[n4]) ? ii[n4] : [ii[n4]];
    i3[n4] = (e3 = oi[n4]) !== null && e3 !== void 0 ? e3 : {}, i3[n4] = {domain: oi[n4] ? "ParametricDomain" : "Domain", wikidata: ni[n4], supersets: t3, value: ti, countable: ri[n4] !== void 0, size: () => ri[n4], ...i3[n4]};
    for (const e4 of t3)
      if (e4 !== "Anything" && !ii[e4])
        throw new Error(`Unknown parent of domain "${n4}": "${e4}"`);
  }
  const n3 = new Set();
  for (const e4 of Object.keys(i3))
    n3.add(e4);
  for (const e4 of Object.keys(i3))
    for (const t3 of i3[e4].supersets)
      n3.delete(t3);
  n3.delete("Nothing"), i3.Nothing.supersets = [...n3.values()];
  for (const e4 of Object.keys(i3)) {
    let n4 = false, t3 = 0, r3 = [e4];
    for (; t3 < 512 && !n4; ) {
      const e5 = r3.pop();
      n4 = e5 === "Anything", n4 || (r3 = [...e5, ...i3[e5].supersets]), t3++;
    }
    if (!n4)
      throw new Error(`The "${e4}" domain cannot reach "Anything"`);
  }
  return i3;
}(), dimensions: {}, logic: {True: {domain: "Boolean", constant: true}, False: {domain: "Boolean", constant: true}, Maybe: {domain: "MaybeBoolean", constant: true}, And: {domain: "LogicalFunction", threadable: true, associative: true, commutative: true, idempotent: true, range: "MaybeBoolean"}, Or: {domain: "LogicalFunction", threadable: true, associative: true, commutative: true, idempotent: true, range: "MaybeBoolean"}, Not: {domain: "LogicalFunction", involution: true, range: "MaybeBoolean"}, Equivalent: {domain: "LogicalFunction", range: "MaybeBoolean"}, Implies: {domain: "LogicalFunction", range: "MaybeBoolean"}, Exists: {domain: "LogicalFunction", range: "MaybeBoolean"}, Equal: {domain: "LogicalFunction", range: "MaybeBoolean"}, NotEqual: {domain: "Function", wikidata: "Q28113351", commutative: true, range: "MaybeBoolean"}}, inequalities: {}, intervals: {}, "linear-algebra": {}, numeric: {}, other: {}, polynomials: {}, physics: {"Mu-0": {constant: true, wikidata: "Q1515261", domain: "RealNumber", value: 125663706212e-17, unit: [L2, "H", [R2, "m", -1]]}}, relations: {}, rounding: {}, statistics: {}, transcendentals: {}, trigonometry: vi, units: {}};
var qi = {"simplify-arithmetic": [["x - x", 0], [["Subtract", "_x", 0], "x"], [["Subtract", 0, "_x"], "-x"], [["Add", "_x", ["Negate", "_x"]], 0], ["x \\times x ", "x^2"], [["Divide", "_x", 1], {sym: "_x"}], [["Divide", "_x", "_x"], 1, (e3, i3) => {
  var n3;
  return (n3 = ye(e3, i3.x)) !== null && n3 !== void 0 && n3;
}], [["Divide", "_x", 0], 1 / 0, (e3, i3) => {
  var n3;
  return (n3 = Ne(e3, i3.x)) !== null && n3 !== void 0 && n3;
}], [["Divide", "_x", 0], -1 / 0, (e3, i3) => {
  var n3;
  return (n3 = we(e3, i3.x)) !== null && n3 !== void 0 && n3;
}], [["Divide", 0, 0], NaN], [["Power", "_x", "Half"], ["\\sqrt{x}"]], [["Power", "_x", ["Divide", 1, 2]], ["\\sqrt{x}"]], [["Power", "_x", 2], ["Square", "_x"]], [["Divide", ["Complex", "_re", "_im"], "_x"], ["Add", ["Divide", ["Complex", 0, "_im"], "_x"], ["Divide", "_re", "_x"]], (e3, i3) => {
  var n3, t3, r3;
  return (n3 = e3.isNotZero(i3.re)) !== null && n3 !== void 0 && n3 && (t3 = e3.isInteger(i3.re)) !== null && t3 !== void 0 && t3 && (r3 = e3.isInteger(i3.im)) !== null && r3 !== void 0 && r3;
}], [["Abs", "_x"], {sym: "_x"}, (e3, i3) => {
  var n3, t3;
  return (n3 = xe(e3, i3.x)) !== null && n3 !== void 0 && n3 || (t3 = Ne(e3, i3.x)) !== null && t3 !== void 0 && t3;
}], [["Abs", "_x"], ["Negate", "_x"], (e3, i3) => {
  var n3;
  return (n3 = we(e3, i3.x)) !== null && n3 !== void 0 && n3;
}]]};
var Mn = "0.4.2";

// src/mathlive.ts
function makeSharedVirtualKeyboard(options) {
  new RemoteVirtualKeyboard(options);
}
function convertLatexToMarkup(text, options) {
  options = options ?? {};
  options.mathstyle = options.mathstyle ?? "displaystyle";
  let letterShapeStyle = options.letterShapeStyle ?? "auto";
  if (letterShapeStyle === "auto") {
    letterShapeStyle = l10n.locale.startsWith("fr") ? "french" : "tex";
  }
  options.macros = getMacros(options?.macros);
  const root = new Atom("root", {mode: "math"});
  root.body = typeset(parseLatex(text, {
    parseMode: "math",
    macros: options.macros,
    registers: options.registers,
    mathstyle: options.mathstyle,
    onError: options.onError,
    colorMap: options.colorMap,
    backgroundColorMap: options.backgroundColorMap
  }), {registers: options.registers});
  const box = root.render(new Context({
    macros: options.macros,
    registers: getDefaultRegisters(),
    smartFence: false,
    renderPlaceholder: () => new Box(160, {maxFontSize: 1})
  }, {
    fontSize: DEFAULT_FONT_SIZE,
    letterShapeStyle
  }, options.mathstyle));
  if (!box)
    return "";
  adjustInterAtomSpacing(box);
  coalesce(box);
  const wrapper = makeStruts(box, {classes: "ML__mathlive"});
  return wrapper.toMarkup();
}
function convertLatexToMathMl(latex, options = {}) {
  options.macros = getMacros(options?.macros);
  return atomsToMathML(parseLatex(latex, {
    parseMode: "math",
    args: () => "",
    macros: options.macros,
    registers: options.registers,
    mathstyle: "displaystyle",
    onError: options.onError,
    colorMap: options.colorMap,
    backgroundColorMap: options.backgroundColorMap
  }), options);
}
function convertLatexToSpeakableText(latex, options = {}) {
  options.macros = getMacros(options?.macros);
  const atoms = parseLatex(latex, {
    parseMode: "math",
    macros: options.macros,
    registers: options.registers,
    mathstyle: "displaystyle",
    onError: options.onError,
    colorMap: options.colorMap,
    backgroundColorMap: options.backgroundColorMap
  });
  return atomToSpeakableText(atoms, options);
}
function renderMathInDocument(options) {
  throwIfNotInBrowser();
  renderMathInElement(document.body, options);
}
function getElement(element) {
  if (typeof element === "string" && isBrowser()) {
    const result = document.getElementById(element);
    if (result === null) {
      throw new Error(`The element with ID "${element}" could not be found.`);
    }
    return result;
  }
  return typeof element === "string" ? null : element;
}
function renderMathInElement(element, options) {
  const el = getElement(element);
  if (!el)
    return;
  options = options ?? {};
  options.renderToMarkup = options.renderToMarkup ?? convertLatexToMarkup;
  options.renderToMathML = options.renderToMathML ?? convertLatexToMathMl;
  options.renderToSpeakableText = options.renderToSpeakableText ?? convertLatexToSpeakableText;
  autoRenderMathInElement(el, options);
}
var version = {
  mathlive: "{{SDK_VERSION}}",
  computeEngine: Mn
};
var debug = {
  latexToAsciiMath,
  asciiMathToLatex,
  FUNCTIONS: debug_default.FUNCTIONS,
  MATH_SYMBOLS: debug_default.MATH_SYMBOLS,
  TEXT_SYMBOLS: debug_default.TEXT_SYMBOLS,
  ENVIRONMENTS: debug_default.ENVIRONMENTS,
  DEFAULT_KEYBINDINGS: debug_default.DEFAULT_KEYBINDINGS,
  getKeybindingMarkup: debug_default.getKeybindingMarkup
};
export {
  MathfieldElement,
  convertLatexToMarkup,
  convertLatexToMathMl,
  convertLatexToSpeakableText,
  debug,
  makeSharedVirtualKeyboard,
  We as parseMathJson,
  renderMathInDocument,
  renderMathInElement,
  Ve as serializeMathJson,
  version
};
/**
 * @license Complex.js v2.0.13 12/05/2020
 *
 * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/
//# sourceMappingURL=mathlive.mjs.map
